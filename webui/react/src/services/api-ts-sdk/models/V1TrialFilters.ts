/* tslint:disable */
/* eslint-disable */
/**
 * Determined API (Beta)
 * Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.  You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.
 *
 * The version of the OpenAPI document: 0.1
 * Contact: community@determined.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { Determinedtrialv1State } from './Determinedtrialv1State';
import {
    Determinedtrialv1StateFromJSON,
    Determinedtrialv1StateFromJSONTyped,
    Determinedtrialv1StateToJSON,
} from './Determinedtrialv1State';
import type { TrialFiltersRankWithinExp } from './TrialFiltersRankWithinExp';
import {
    TrialFiltersRankWithinExpFromJSON,
    TrialFiltersRankWithinExpFromJSONTyped,
    TrialFiltersRankWithinExpToJSON,
} from './TrialFiltersRankWithinExp';
import type { V1ColumnFilter } from './V1ColumnFilter';
import {
    V1ColumnFilterFromJSON,
    V1ColumnFilterFromJSONTyped,
    V1ColumnFilterToJSON,
} from './V1ColumnFilter';
import type { V1DoubleFieldFilter } from './V1DoubleFieldFilter';
import {
    V1DoubleFieldFilterFromJSON,
    V1DoubleFieldFilterFromJSONTyped,
    V1DoubleFieldFilterToJSON,
} from './V1DoubleFieldFilter';
import type { V1TimestampFieldFilter } from './V1TimestampFieldFilter';
import {
    V1TimestampFieldFilterFromJSON,
    V1TimestampFieldFilterFromJSONTyped,
    V1TimestampFieldFilterToJSON,
} from './V1TimestampFieldFilter';
import type { V1TrialTag } from './V1TrialTag';
import {
    V1TrialTagFromJSON,
    V1TrialTagFromJSONTyped,
    V1TrialTagToJSON,
} from './V1TrialTag';

/**
 * Filters to be applied to trials. Can be used to query, patch, and create
 * dynamic collections of trials.
 * @export
 * @interface V1TrialFilters
 */
export interface V1TrialFilters {
    /**
     * Filter trials by their corresponding experiment ids.
     * @type {Array<number>}
     * @memberof V1TrialFilters
     */
    experimentIds?: Array<number>;
    /**
     * Filter trials by their corresponding project ids.
     * @type {Array<number>}
     * @memberof V1TrialFilters
     */
    projectIds?: Array<number>;
    /**
     * Filter trials by their corresponding workspace ids.
     * @type {Array<number>}
     * @memberof V1TrialFilters
     */
    workspaceIds?: Array<number>;
    /**
     * Filter trials to those containing ALL validation_metrics
     * within the indicated ranges.
     * @type {Array<V1ColumnFilter>}
     * @memberof V1TrialFilters
     */
    validationMetrics?: Array<V1ColumnFilter>;
    /**
     * Filter trials to those containing ALL training_metrics
     * within the indicated ranges.
     * @type {Array<V1ColumnFilter>}
     * @memberof V1TrialFilters
     */
    trainingMetrics?: Array<V1ColumnFilter>;
    /**
     * Filter trials to those containing ALL hyperparameters
     * within the indicated ranges. Nested hparams are specified
     * with dots.
     * @type {Array<V1ColumnFilter>}
     * @memberof V1TrialFilters
     */
    hparams?: Array<V1ColumnFilter>;
    /**
     * Filter trials according to the creators user id.
     * @type {Array<number>}
     * @memberof V1TrialFilters
     */
    userIds?: Array<number>;
    /**
     * Filter trials according to the name of the searcher used.
     * @type {string}
     * @memberof V1TrialFilters
     */
    searcher?: string;
    /**
     * Filter trials to those containing ANY of the provided tags.
     * @type {Array<V1TrialTag>}
     * @memberof V1TrialFilters
     */
    tags?: Array<V1TrialTag>;
    /**
     * 
     * @type {TrialFiltersRankWithinExp}
     * @memberof V1TrialFilters
     */
    rankWithinExp?: TrialFiltersRankWithinExp;
    /**
     * 
     * @type {V1TimestampFieldFilter}
     * @memberof V1TrialFilters
     */
    startTime?: V1TimestampFieldFilter;
    /**
     * 
     * @type {V1TimestampFieldFilter}
     * @memberof V1TrialFilters
     */
    endTime?: V1TimestampFieldFilter;
    /**
     * Filter trials to those with any of the given states.
     * @type {Array<Determinedtrialv1State>}
     * @memberof V1TrialFilters
     */
    states?: Array<Determinedtrialv1State>;
    /**
     * Filter trials to those with the given searcher metric.
     * @type {string}
     * @memberof V1TrialFilters
     */
    searcherMetric?: string;
    /**
     * 
     * @type {V1DoubleFieldFilter}
     * @memberof V1TrialFilters
     */
    searcherMetricValue?: V1DoubleFieldFilter;
    /**
     * 
     * @type {Array<number>}
     * @memberof V1TrialFilters
     */
    trialIds?: Array<number>;
}

/**
 * Check if a given object implements the V1TrialFilters interface.
 */
export function instanceOfV1TrialFilters(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function V1TrialFiltersFromJSON(json: any): V1TrialFilters {
    return V1TrialFiltersFromJSONTyped(json, false);
}

export function V1TrialFiltersFromJSONTyped(json: any, ignoreDiscriminator: boolean): V1TrialFilters {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'experimentIds': !exists(json, 'experimentIds') ? undefined : json['experimentIds'],
        'projectIds': !exists(json, 'projectIds') ? undefined : json['projectIds'],
        'workspaceIds': !exists(json, 'workspaceIds') ? undefined : json['workspaceIds'],
        'validationMetrics': !exists(json, 'validationMetrics') ? undefined : ((json['validationMetrics'] as Array<any>).map(V1ColumnFilterFromJSON)),
        'trainingMetrics': !exists(json, 'trainingMetrics') ? undefined : ((json['trainingMetrics'] as Array<any>).map(V1ColumnFilterFromJSON)),
        'hparams': !exists(json, 'hparams') ? undefined : ((json['hparams'] as Array<any>).map(V1ColumnFilterFromJSON)),
        'userIds': !exists(json, 'userIds') ? undefined : json['userIds'],
        'searcher': !exists(json, 'searcher') ? undefined : json['searcher'],
        'tags': !exists(json, 'tags') ? undefined : ((json['tags'] as Array<any>).map(V1TrialTagFromJSON)),
        'rankWithinExp': !exists(json, 'rankWithinExp') ? undefined : TrialFiltersRankWithinExpFromJSON(json['rankWithinExp']),
        'startTime': !exists(json, 'startTime') ? undefined : V1TimestampFieldFilterFromJSON(json['startTime']),
        'endTime': !exists(json, 'endTime') ? undefined : V1TimestampFieldFilterFromJSON(json['endTime']),
        'states': !exists(json, 'states') ? undefined : ((json['states'] as Array<any>).map(Determinedtrialv1StateFromJSON)),
        'searcherMetric': !exists(json, 'searcherMetric') ? undefined : json['searcherMetric'],
        'searcherMetricValue': !exists(json, 'searcherMetricValue') ? undefined : V1DoubleFieldFilterFromJSON(json['searcherMetricValue']),
        'trialIds': !exists(json, 'trialIds') ? undefined : json['trialIds'],
    };
}

export function V1TrialFiltersToJSON(value?: V1TrialFilters | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'experimentIds': value.experimentIds,
        'projectIds': value.projectIds,
        'workspaceIds': value.workspaceIds,
        'validationMetrics': value.validationMetrics === undefined ? undefined : ((value.validationMetrics as Array<any>).map(V1ColumnFilterToJSON)),
        'trainingMetrics': value.trainingMetrics === undefined ? undefined : ((value.trainingMetrics as Array<any>).map(V1ColumnFilterToJSON)),
        'hparams': value.hparams === undefined ? undefined : ((value.hparams as Array<any>).map(V1ColumnFilterToJSON)),
        'userIds': value.userIds,
        'searcher': value.searcher,
        'tags': value.tags === undefined ? undefined : ((value.tags as Array<any>).map(V1TrialTagToJSON)),
        'rankWithinExp': TrialFiltersRankWithinExpToJSON(value.rankWithinExp),
        'startTime': V1TimestampFieldFilterToJSON(value.startTime),
        'endTime': V1TimestampFieldFilterToJSON(value.endTime),
        'states': value.states === undefined ? undefined : ((value.states as Array<any>).map(Determinedtrialv1StateToJSON)),
        'searcherMetric': value.searcherMetric,
        'searcherMetricValue': V1DoubleFieldFilterToJSON(value.searcherMetricValue),
        'trialIds': value.trialIds,
    };
}

