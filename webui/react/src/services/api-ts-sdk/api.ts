/**
 * Determined API (Beta)
 * Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.  You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.
 *
 * OpenAPI spec version: 0.1
 * Contact: community@determined.ai
 *
 * NOTE: Do not edit the class manually.
 */


import { Configuration } from "./configuration";

type ValueOf<T> = T[keyof T];
const BASE_PATH = "http://localhost".replace(/\/+$/, "");

const convert = (v: unknown): string => {
    switch (typeof v) {
        case 'string':
        case 'boolean': {
            return v.toString();
        }
        case 'bigint': {
            return '' + v
        }
        case 'number': {
            if (Number.isFinite(v))  {
                return encodeURIComponent(v);
            }
            return '';
        }
        default: {
            return '';
        }
    }
}

const objToSearchParams = (obj: {}, searchParams: URLSearchParams) => {
    Object.entries(obj).forEach(([key, value]) => {
        if (Array.isArray(value) && value.length > 0) {
            searchParams.set(key, convert(value[0]))
            value.slice(1).forEach((subValue) => searchParams.append(key, convert(subValue)))
        } else if (!Array.isArray(value)) {
            searchParams.set(key, convert(value))
        }
    });
};

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = window.fetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}


/**
 * The current state of the checkpoint.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.  - STATE_PARTIALLY_DELETED: The checkpoint has been partially deleted.
 * @export
 * @enum {string}
 */
export const Checkpointv1State = {
    UNSPECIFIED: 'STATE_UNSPECIFIED',
    ACTIVE: 'STATE_ACTIVE',
    COMPLETED: 'STATE_COMPLETED',
    ERROR: 'STATE_ERROR',
    DELETED: 'STATE_DELETED',
    PARTIALLYDELETED: 'STATE_PARTIALLY_DELETED',
} as const
export type Checkpointv1State = ValueOf<typeof Checkpointv1State>
/**
 * The current state of the container.   - STATE_UNSPECIFIED: The container state is unknown.  - STATE_ASSIGNED: The container has been assigned to an agent but has not started yet.  - STATE_PULLING: The container's base image is being pulled from the Docker registry.  - STATE_STARTING: The image has been built and the container is being started, but the service in the container is not ready yet.  - STATE_RUNNING: The service in the container is able to accept requests.  - STATE_TERMINATED: The container has completely exited or the container has been aborted prior to getting assigned.
 * @export
 * @enum {string}
 */
export const Containerv1State = {
    UNSPECIFIED: 'STATE_UNSPECIFIED',
    ASSIGNED: 'STATE_ASSIGNED',
    PULLING: 'STATE_PULLING',
    STARTING: 'STATE_STARTING',
    RUNNING: 'STATE_RUNNING',
    TERMINATED: 'STATE_TERMINATED',
} as const
export type Containerv1State = ValueOf<typeof Containerv1State>
/**
 * The type of the Device.   - TYPE_UNSPECIFIED: An unspecified device type.  - TYPE_CPU: A CPU device.  - TYPE_CUDA: CUDA device.  - TYPE_ROCM: ROCM.
 * @export
 * @enum {string}
 */
export const Devicev1Type = {
    UNSPECIFIED: 'TYPE_UNSPECIFIED',
    CPU: 'TYPE_CPU',
    CUDA: 'TYPE_CUDA',
    ROCM: 'TYPE_ROCM',
} as const
export type Devicev1Type = ValueOf<typeof Devicev1Type>
/**
 * The current state of the experiment.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.  - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.  - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The experiment is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The experiment has an allocation actively running. Running is a substate of the Active state.
 * @export
 * @enum {string}
 */
export const Experimentv1State = {
    UNSPECIFIED: 'STATE_UNSPECIFIED',
    ACTIVE: 'STATE_ACTIVE',
    PAUSED: 'STATE_PAUSED',
    STOPPINGCOMPLETED: 'STATE_STOPPING_COMPLETED',
    STOPPINGCANCELED: 'STATE_STOPPING_CANCELED',
    STOPPINGERROR: 'STATE_STOPPING_ERROR',
    COMPLETED: 'STATE_COMPLETED',
    CANCELED: 'STATE_CANCELED',
    ERROR: 'STATE_ERROR',
    DELETED: 'STATE_DELETED',
    DELETING: 'STATE_DELETING',
    DELETEFAILED: 'STATE_DELETE_FAILED',
    STOPPINGKILLED: 'STATE_STOPPING_KILLED',
    QUEUED: 'STATE_QUEUED',
    PULLING: 'STATE_PULLING',
    STARTING: 'STATE_STARTING',
    RUNNING: 'STATE_RUNNING',
} as const
export type Experimentv1State = ValueOf<typeof Experimentv1State>
/**
 * - PRODUCT_UNSPECIFIED: Not a Cloud Community offering  - PRODUCT_COMMUNITY: Determined Cloud, Community Edition
 * @export
 * @enum {string}
 */
export const GetMasterResponseProduct = {
    UNSPECIFIED: 'PRODUCT_UNSPECIFIED',
    COMMUNITY: 'PRODUCT_COMMUNITY',
} as const
export type GetMasterResponseProduct = ValueOf<typeof GetMasterResponseProduct>
/**
 * Filter workloads with training, validation, and checkpoint information.   - FILTER_OPTION_UNSPECIFIED: Any workload.  - FILTER_OPTION_CHECKPOINT: Only workloads with an associated checkpoint.  - FILTER_OPTION_VALIDATION: Only validation workloads.  - FILTER_OPTION_CHECKPOINT_OR_VALIDATION: Only validation workloads or ones with an associated checkpoint.
 * @export
 * @enum {string}
 */
export const GetTrialWorkloadsRequestFilterOption = {
    UNSPECIFIED: 'FILTER_OPTION_UNSPECIFIED',
    CHECKPOINT: 'FILTER_OPTION_CHECKPOINT',
    VALIDATION: 'FILTER_OPTION_VALIDATION',
    CHECKPOINTORVALIDATION: 'FILTER_OPTION_CHECKPOINT_OR_VALIDATION',
} as const
export type GetTrialWorkloadsRequestFilterOption = ValueOf<typeof GetTrialWorkloadsRequestFilterOption>
/**
 * Job state.   - STATE_UNSPECIFIED: Unspecified state.  - STATE_QUEUED: Job is queued and waiting to be schedlued.  - STATE_SCHEDULED: Job is scheduled.  - STATE_SCHEDULED_BACKFILLED: Job is scheduled as a backfill.
 * @export
 * @enum {string}
 */
export const Jobv1State = {
    UNSPECIFIED: 'STATE_UNSPECIFIED',
    QUEUED: 'STATE_QUEUED',
    SCHEDULED: 'STATE_SCHEDULED',
    SCHEDULEDBACKFILLED: 'STATE_SCHEDULED_BACKFILLED',
} as const
export type Jobv1State = ValueOf<typeof Jobv1State>
/**
 * Job type.   - TYPE_UNSPECIFIED: Unspecified state.  - TYPE_EXPERIMENT: Experiement Job.  - TYPE_NOTEBOOK: Jupyter Notebook Job.  - TYPE_TENSORBOARD: TensorBoard Job.  - TYPE_SHELL: Shell Job.  - TYPE_COMMAND: Command Job.  - TYPE_CHECKPOINT_GC: CheckpointGC Job.  - TYPE_EXTERNAL: External Job.
 * @export
 * @enum {string}
 */
export const Jobv1Type = {
    UNSPECIFIED: 'TYPE_UNSPECIFIED',
    EXPERIMENT: 'TYPE_EXPERIMENT',
    NOTEBOOK: 'TYPE_NOTEBOOK',
    TENSORBOARD: 'TYPE_TENSORBOARD',
    SHELL: 'TYPE_SHELL',
    COMMAND: 'TYPE_COMMAND',
    CHECKPOINTGC: 'TYPE_CHECKPOINT_GC',
    EXTERNAL: 'TYPE_EXTERNAL',
} as const
export type Jobv1Type = ValueOf<typeof Jobv1Type>
/**
 * Gets around not being able to do "Optional map<string, int64>". Not ideal but this API is marked internal for now.
 * @export
 * @interface PatchCheckpointOptionalResources
 */
export interface PatchCheckpointOptionalResources {
    /**
     * Resources.
     * @type {{ [key: string]: string; }}
     * @memberof PatchCheckpointOptionalResources
     */
    resources?: { [key: string]: string; };
}
/**
 * Nested object for checkpoint_storage field patch.
 * @export
 * @interface PatchExperimentPatchCheckpointStorage
 */
export interface PatchExperimentPatchCheckpointStorage {
    /**
     * Experiment config checkpoint_storage.save_experiment_best.
     * @type {number}
     * @memberof PatchExperimentPatchCheckpointStorage
     */
    saveExperimentBest?: number;
    /**
     * Experiment config checkpoint_storage.save_trial_best.
     * @type {number}
     * @memberof PatchExperimentPatchCheckpointStorage
     */
    saveTrialBest?: number;
    /**
     * Experiment config checkpoint_storage.save_trial_latest.
     * @type {number}
     * @memberof PatchExperimentPatchCheckpointStorage
     */
    saveTrialLatest?: number;
}
/**
 * Nested object for resources field patch.
 * @export
 * @interface PatchExperimentPatchResources
 */
export interface PatchExperimentPatchResources {
    /**
     * Experiment config resources.max_slots.
     * @type {number}
     * @memberof PatchExperimentPatchResources
     */
    maxSlots?: number;
    /**
     * Experiment config resources.weight.
     * @type {number}
     * @memberof PatchExperimentPatchResources
     */
    weight?: number;
    /**
     * Experiment config resources.priority.
     * @type {number}
     * @memberof PatchExperimentPatchResources
     */
    priority?: number;
}
/**
 * https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Any
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    /**
     * https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Any
     * @type {string}
     * @memberof ProtobufAny
     */
    typeUrl?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ProtobufAny
     */
    value?: string;
}
/**
 * paths: "f.a"     paths: "f.b.d"  Here `f` represents a field in some root message, `a` and `b` fields in the message found in `f`, and `d` a field found in the message in `f.b`.  Field masks are used to specify a subset of fields that should be returned by a get operation or modified by an update operation. Field masks also have a custom JSON encoding (see below).  # Field Masks in Projections  When used in the context of a projection, a response message or sub-message is filtered by the API to only contain those fields as specified in the mask. For example, if the mask in the previous example is applied to a response message as follows:      f {       a : 22       b {         d : 1         x : 2       }       y : 13     }     z: 8  The result will not contain specific values for fields x,y and z (their value will be set to the default, and omitted in proto text output):       f {       a : 22       b {         d : 1       }     }  A repeated field is not allowed except at the last position of a paths string.  If a FieldMask object is not present in a get operation, the operation applies to all fields (as if a FieldMask of all fields had been specified).  Note that a field mask does not necessarily apply to the top-level response message. In case of a REST get operation, the field mask applies directly to the response, but in case of a REST list operation, the mask instead applies to each individual message in the returned resource list. In case of a REST custom method, other definitions may be used. Where the mask applies will be clearly documented together with its declaration in the API.  In any case, the effect on the returned resource/resources is required behavior for APIs.  # Field Masks in Update Operations  A field mask in update operations specifies which fields of the targeted resource are going to be updated. The API is required to only change the values of the fields as specified in the mask and leave the others untouched. If a resource is passed in to describe the updated values, the API ignores the values of all fields not covered by the mask.  If a repeated field is specified for an update operation, new values will be appended to the existing repeated field in the target resource. Note that a repeated field is only allowed in the last position of a `paths` string.  If a sub-message is specified in the last position of the field mask for an update operation, then new value will be merged into the existing sub-message in the target resource.  For example, given the target message:      f {       b {         d: 1         x: 2       }       c: [1]     }  And an update message:      f {       b {         d: 10       }       c: [2]     }  then if the field mask is:   paths: ["f.b", "f.c"]  then the result will be:      f {       b {         d: 10         x: 2       }       c: [1, 2]     }  An implementation may provide options to override this default behavior for repeated and message fields.  In order to reset a field's value to the default, the field must be in the mask and set to the default value in the provided resource. Hence, in order to reset all fields of a resource, provide a default instance of the resource and set all fields in the mask, or do not provide a mask as described below.  If a field mask is not present on update, the operation applies to all fields (as if a field mask of all fields has been specified). Note that in the presence of schema evolution, this may mean that fields the client does not know and has therefore not filled into the request will be reset to their default. If this is unwanted behavior, a specific service may require a client to always specify a field mask, producing an error if not.  As with get operations, the location of the resource which describes the updated values in the request message depends on the operation kind. In any case, the effect of the field mask is required to be honored by the API.  ## Considerations for HTTP REST  The HTTP kind of an update operation which uses a field mask must be set to PATCH instead of PUT in order to satisfy HTTP semantics (PUT must only be used for full updates).  # JSON Encoding of Field Masks  In JSON, a field mask is encoded as a single string where paths are separated by a comma. Fields name in each path are converted to/from lower-camel naming conventions.  As an example, consider the following message declarations:      message Profile {       User user = 1;       Photo photo = 2;     }     message User {       string display_name = 1;       string address = 2;     }  In proto a field mask for `Profile` may look as such:      mask {       paths: "user.display_name"       paths: "photo"     }  In JSON, the same mask is represented as below:      {       mask: "user.displayName,photo"     }  # Field Masks and Oneof Fields  Field masks treat fields in oneofs just as regular fields. Consider the following message:      message SampleMessage {       oneof test_oneof {         string name = 4;         SubMessage sub_message = 9;       }     }  The field mask can be:      mask {       paths: "name"     }  Or:      mask {       paths: "sub_message"     }  Note that oneof type names ("test_oneof" in this case) cannot be used in paths.  ## Field Mask Verification  The implementation of any API method which has a FieldMask type field in the request should verify the included field paths, and return an `INVALID_ARGUMENT` error if any path is unmappable.
 * @export
 * @interface ProtobufFieldMask
 */
export interface ProtobufFieldMask {
    /**
     * The set of field mask paths.
     * @type {Array<string>}
     * @memberof ProtobufFieldMask
     */
    paths?: Array<string>;
}
/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */
export const ProtobufNullValue = {
    NULLVALUE: 'NULL_VALUE',
} as const
export type ProtobufNullValue = ValueOf<typeof ProtobufNullValue>
/**
 * A wrapper message of a list of devices.
 * @export
 * @interface ResourcesSummaryDevices
 */
export interface ResourcesSummaryDevices {
    /**
     * The devices on an agent.
     * @type {Array<V1Device>}
     * @memberof ResourcesSummaryDevices
     */
    devices?: Array<V1Device>;
}
/**
 * 
 * @export
 * @interface RuntimeError
 */
export interface RuntimeError {
    /**
     * 
     * @type {string}
     * @memberof RuntimeError
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof RuntimeError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof RuntimeError
     */
    message?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RuntimeError
     */
    details?: Array<ProtobufAny>;
}
/**
 * 
 * @export
 * @interface RuntimeStreamError
 */
export interface RuntimeStreamError {
    /**
     * 
     * @type {number}
     * @memberof RuntimeStreamError
     */
    grpcCode?: number;
    /**
     * 
     * @type {number}
     * @memberof RuntimeStreamError
     */
    httpCode?: number;
    /**
     * 
     * @type {string}
     * @memberof RuntimeStreamError
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof RuntimeStreamError
     */
    httpStatus?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RuntimeStreamError
     */
    details?: Array<ProtobufAny>;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1ExpMetricNamesResponse
 */
export interface StreamResultOfV1ExpMetricNamesResponse {
    /**
     * 
     * @type {V1ExpMetricNamesResponse}
     * @memberof StreamResultOfV1ExpMetricNamesResponse
     */
    result?: V1ExpMetricNamesResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1ExpMetricNamesResponse
     */
    error?: RuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1GetMetricsResponse
 */
export interface StreamResultOfV1GetMetricsResponse {
    /**
     * 
     * @type {V1GetMetricsResponse}
     * @memberof StreamResultOfV1GetMetricsResponse
     */
    result?: V1GetMetricsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1GetMetricsResponse
     */
    error?: RuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1GetTrainingMetricsResponse
 */
export interface StreamResultOfV1GetTrainingMetricsResponse {
    /**
     * 
     * @type {V1GetTrainingMetricsResponse}
     * @memberof StreamResultOfV1GetTrainingMetricsResponse
     */
    result?: V1GetTrainingMetricsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1GetTrainingMetricsResponse
     */
    error?: RuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1GetTrialProfilerAvailableSeriesResponse
 */
export interface StreamResultOfV1GetTrialProfilerAvailableSeriesResponse {
    /**
     * 
     * @type {V1GetTrialProfilerAvailableSeriesResponse}
     * @memberof StreamResultOfV1GetTrialProfilerAvailableSeriesResponse
     */
    result?: V1GetTrialProfilerAvailableSeriesResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1GetTrialProfilerAvailableSeriesResponse
     */
    error?: RuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1GetTrialProfilerMetricsResponse
 */
export interface StreamResultOfV1GetTrialProfilerMetricsResponse {
    /**
     * 
     * @type {V1GetTrialProfilerMetricsResponse}
     * @memberof StreamResultOfV1GetTrialProfilerMetricsResponse
     */
    result?: V1GetTrialProfilerMetricsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1GetTrialProfilerMetricsResponse
     */
    error?: RuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1GetValidationMetricsResponse
 */
export interface StreamResultOfV1GetValidationMetricsResponse {
    /**
     * 
     * @type {V1GetValidationMetricsResponse}
     * @memberof StreamResultOfV1GetValidationMetricsResponse
     */
    result?: V1GetValidationMetricsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1GetValidationMetricsResponse
     */
    error?: RuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1MasterLogsResponse
 */
export interface StreamResultOfV1MasterLogsResponse {
    /**
     * 
     * @type {V1MasterLogsResponse}
     * @memberof StreamResultOfV1MasterLogsResponse
     */
    result?: V1MasterLogsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1MasterLogsResponse
     */
    error?: RuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1MetricBatchesResponse
 */
export interface StreamResultOfV1MetricBatchesResponse {
    /**
     * 
     * @type {V1MetricBatchesResponse}
     * @memberof StreamResultOfV1MetricBatchesResponse
     */
    result?: V1MetricBatchesResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1MetricBatchesResponse
     */
    error?: RuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1TaskLogsFieldsResponse
 */
export interface StreamResultOfV1TaskLogsFieldsResponse {
    /**
     * 
     * @type {V1TaskLogsFieldsResponse}
     * @memberof StreamResultOfV1TaskLogsFieldsResponse
     */
    result?: V1TaskLogsFieldsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1TaskLogsFieldsResponse
     */
    error?: RuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1TaskLogsResponse
 */
export interface StreamResultOfV1TaskLogsResponse {
    /**
     * 
     * @type {V1TaskLogsResponse}
     * @memberof StreamResultOfV1TaskLogsResponse
     */
    result?: V1TaskLogsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1TaskLogsResponse
     */
    error?: RuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1TrialLogsFieldsResponse
 */
export interface StreamResultOfV1TrialLogsFieldsResponse {
    /**
     * 
     * @type {V1TrialLogsFieldsResponse}
     * @memberof StreamResultOfV1TrialLogsFieldsResponse
     */
    result?: V1TrialLogsFieldsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1TrialLogsFieldsResponse
     */
    error?: RuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1TrialLogsResponse
 */
export interface StreamResultOfV1TrialLogsResponse {
    /**
     * 
     * @type {V1TrialLogsResponse}
     * @memberof StreamResultOfV1TrialLogsResponse
     */
    result?: V1TrialLogsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1TrialLogsResponse
     */
    error?: RuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1TrialsSampleResponse
 */
export interface StreamResultOfV1TrialsSampleResponse {
    /**
     * 
     * @type {V1TrialsSampleResponse}
     * @memberof StreamResultOfV1TrialsSampleResponse
     */
    result?: V1TrialsSampleResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1TrialsSampleResponse
     */
    error?: RuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1TrialsSnapshotResponse
 */
export interface StreamResultOfV1TrialsSnapshotResponse {
    /**
     * 
     * @type {V1TrialsSnapshotResponse}
     * @memberof StreamResultOfV1TrialsSnapshotResponse
     */
    result?: V1TrialsSnapshotResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1TrialsSnapshotResponse
     */
    error?: RuntimeStreamError;
}
/**
 * The current state of the task.   - STATE_UNSPECIFIED: The task state is unknown.  - STATE_PULLING: The task's base image is being pulled from the Docker registry.  - STATE_STARTING: The image has been pulled and the task is being started, but the task is not ready yet.  - STATE_RUNNING: The service in the task is running.  - STATE_TERMINATED: The task has exited or has been aborted.  - STATE_TERMINATING: The task has begun to exit.  - STATE_WAITING: The task is waiting on something to complete.  - STATE_QUEUED: Additional state to cover queueing operations.
 * @export
 * @enum {string}
 */
export const Taskv1State = {
    UNSPECIFIED: 'STATE_UNSPECIFIED',
    PULLING: 'STATE_PULLING',
    STARTING: 'STATE_STARTING',
    RUNNING: 'STATE_RUNNING',
    TERMINATED: 'STATE_TERMINATED',
    TERMINATING: 'STATE_TERMINATING',
    WAITING: 'STATE_WAITING',
    QUEUED: 'STATE_QUEUED',
} as const
export type Taskv1State = ValueOf<typeof Taskv1State>
/**
 * To distinguish the 2 different categories of metrics.   - PROFILER_METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - PROFILER_METRIC_TYPE_SYSTEM: For systems metrics, like GPU utilization or memory.  - PROFILER_METRIC_TYPE_TIMING: For timing metrics, like how long a backwards pass or getting a batch from the dataloader took.  - PROFILER_METRIC_TYPE_MISC: For other miscellaneous metrics.
 * @export
 * @enum {string}
 */
export const TrialProfilerMetricLabelsProfilerMetricType = {
    UNSPECIFIED: 'PROFILER_METRIC_TYPE_UNSPECIFIED',
    SYSTEM: 'PROFILER_METRIC_TYPE_SYSTEM',
    TIMING: 'PROFILER_METRIC_TYPE_TIMING',
    MISC: 'PROFILER_METRIC_TYPE_MISC',
} as const
export type TrialProfilerMetricLabelsProfilerMetricType = ValueOf<typeof TrialProfilerMetricLabelsProfilerMetricType>
/**
 * - STATE_UNSPECIFIED: The trial is in an unspecified state.  - STATE_ACTIVE: The trial is in an active state.  - STATE_PAUSED: The trial is in a paused state  - STATE_STOPPING_CANCELED: The trial is canceled and is shutting down.  - STATE_STOPPING_KILLED: The trial is killed and is shutting down.  - STATE_STOPPING_COMPLETED: The trial is completed and is shutting down.  - STATE_STOPPING_ERROR: The trial is errored and is shutting down.  - STATE_CANCELED: The trial is canceled and is shut down.  - STATE_COMPLETED: The trial is completed and is shut down.  - STATE_ERROR: The trial is errored and is shut down.  - STATE_QUEUED: The trial is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The trial is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The trial is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The trial's allocation is actively running. Running is a substate of the Active state.
 * @export
 * @enum {string}
 */
export const Trialv1State = {
    UNSPECIFIED: 'STATE_UNSPECIFIED',
    ACTIVE: 'STATE_ACTIVE',
    PAUSED: 'STATE_PAUSED',
    STOPPINGCANCELED: 'STATE_STOPPING_CANCELED',
    STOPPINGKILLED: 'STATE_STOPPING_KILLED',
    STOPPINGCOMPLETED: 'STATE_STOPPING_COMPLETED',
    STOPPINGERROR: 'STATE_STOPPING_ERROR',
    CANCELED: 'STATE_CANCELED',
    COMPLETED: 'STATE_COMPLETED',
    ERROR: 'STATE_ERROR',
    QUEUED: 'STATE_QUEUED',
    PULLING: 'STATE_PULLING',
    STARTING: 'STATE_STARTING',
    RUNNING: 'STATE_RUNNING',
} as const
export type Trialv1State = ValueOf<typeof Trialv1State>
/**
 * Trial is a set of workloads and are exploring a determined set of hyperparameters.
 * @export
 * @interface Trialv1Trial
 */
export interface Trialv1Trial {
    /**
     * The id of the trial.
     * @type {number}
     * @memberof Trialv1Trial
     */
    id: number;
    /**
     * The id of the parent experiment.
     * @type {number}
     * @memberof Trialv1Trial
     */
    experimentId: number;
    /**
     * The time the trial was started.
     * @type {Date}
     * @memberof Trialv1Trial
     */
    startTime: Date;
    /**
     * The time the trial ended if the trial is stopped.
     * @type {Date}
     * @memberof Trialv1Trial
     */
    endTime?: Date;
    /**
     * The current state of the trial.
     * @type {Trialv1State}
     * @memberof Trialv1Trial
     */
    state: Trialv1State;
    /**
     * Number times the trial restarted.
     * @type {number}
     * @memberof Trialv1Trial
     */
    restarts: number;
    /**
     * Trial hyperparameters.
     * @type {any}
     * @memberof Trialv1Trial
     */
    hparams: any;
    /**
     * The current processed batches.
     * @type {number}
     * @memberof Trialv1Trial
     */
    totalBatchesProcessed: number;
    /**
     * Best validation.
     * @type {V1MetricsWorkload}
     * @memberof Trialv1Trial
     */
    bestValidation?: V1MetricsWorkload;
    /**
     * Latest validation.
     * @type {V1MetricsWorkload}
     * @memberof Trialv1Trial
     */
    latestValidation?: V1MetricsWorkload;
    /**
     * Best checkpoint.
     * @type {V1CheckpointWorkload}
     * @memberof Trialv1Trial
     */
    bestCheckpoint?: V1CheckpointWorkload;
    /**
     * The last reported state of the trial runner (harness code).
     * @type {string}
     * @memberof Trialv1Trial
     */
    runnerState?: string;
    /**
     * The wall clock time is all active time of the cluster for the trial, inclusive of everything (restarts, initiailization, etc), in seconds.
     * @type {number}
     * @memberof Trialv1Trial
     */
    wallClockTime?: number;
    /**
     * UUID of checkpoint that this trial started from.
     * @type {string}
     * @memberof Trialv1Trial
     */
    warmStartCheckpointUuid?: string;
    /**
     * Id of the first task associated with this trial. This field is deprecated since trials can have multiple tasks.
     * @type {string}
     * @memberof Trialv1Trial
     */
    taskId?: string;
    /**
     * The sum of sizes of all resources in all checkpoints for the trial.
     * @type {string}
     * @memberof Trialv1Trial
     */
    totalCheckpointSize?: string;
    /**
     * The count of checkpoints.
     * @type {number}
     * @memberof Trialv1Trial
     */
    checkpointCount?: number;
    /**
     * summary metrics
     * @type {any}
     * @memberof Trialv1Trial
     */
    summaryMetrics?: any;
    /**
     * Task IDs of tasks associated with this trial. Length of task_ids will always be greater or equal to one when TaskID is sent. For example CompareTrial we will send a reduced Trial object, without TaskID or TaskIDs fileld in. The first element of task_ids will be the same as task_id. task_ids is sorted ascending by task_run_id.
     * @type {Array<string>}
     * @memberof Trialv1Trial
     */
    taskIds?: Array<string>;
    /**
     * Signed searcher metrics value.
     * @type {number}
     * @memberof Trialv1Trial
     */
    searcherMetricValue?: number;
}
/**
 * Acknowledge the receipt of some stop signal.
 * @export
 * @interface V1AckAllocationPreemptionSignalRequest
 */
export interface V1AckAllocationPreemptionSignalRequest {
    /**
     * The allocation that is acknowledging the request.
     * @type {string}
     * @memberof V1AckAllocationPreemptionSignalRequest
     */
    allocationId: string;
}
/**
 * Response to AckAllocationPreemptionSignalRequest.
 * @export
 * @interface V1AckAllocationPreemptionSignalResponse
 */
export interface V1AckAllocationPreemptionSignalResponse {
}
/**
 * Response to ActivateExperimentRequest.
 * @export
 * @interface V1ActivateExperimentResponse
 */
export interface V1ActivateExperimentResponse {
}
/**
 * Activate multiple experiments.
 * @export
 * @interface V1ActivateExperimentsRequest
 */
export interface V1ActivateExperimentsRequest {
    /**
     * Select experiments by id.
     * @type {Array<number>}
     * @memberof V1ActivateExperimentsRequest
     */
    experimentIds: Array<number>;
    /**
     * Targets all experiments matching filters.
     * @type {V1BulkExperimentFilters}
     * @memberof V1ActivateExperimentsRequest
     */
    filters?: V1BulkExperimentFilters;
}
/**
 * Response to ActivateExperimentsRequest.
 * @export
 * @interface V1ActivateExperimentsResponse
 */
export interface V1ActivateExperimentsResponse {
    /**
     * Details on success or error for each experiment.
     * @type {Array<V1ExperimentActionResult>}
     * @memberof V1ActivateExperimentsResponse
     */
    results: Array<V1ExperimentActionResult>;
}
/**
 * - ACTIVITY_TYPE_UNSPECIFIED: Default activity type.  - ACTIVITY_TYPE_GET: Represents a get request.
 * @export
 * @enum {string}
 */
export const V1ActivityType = {
    UNSPECIFIED: 'ACTIVITY_TYPE_UNSPECIFIED',
    GET: 'ACTIVITY_TYPE_GET',
} as const
export type V1ActivityType = ValueOf<typeof V1ActivityType>
/**
 * Response to AddProjectNoteRequest.
 * @export
 * @interface V1AddProjectNoteResponse
 */
export interface V1AddProjectNoteResponse {
    /**
     * The complete list of notes on a project.
     * @type {Array<V1Note>}
     * @memberof V1AddProjectNoteResponse
     */
    notes: Array<V1Note>;
}
/**
 * Address represents an exposed port on a container.
 * @export
 * @interface V1Address
 */
export interface V1Address {
    /**
     * ContainerIP is the IP address from inside the container.
     * @type {string}
     * @memberof V1Address
     */
    containerIp?: string;
    /**
     * ContainerPort is the port from inside the container.
     * @type {number}
     * @memberof V1Address
     */
    containerPort?: number;
    /**
     * HostIP is the IP address from outside the container. This can be different than the ContainerIP because of network forwarding on the host machine.
     * @type {string}
     * @memberof V1Address
     */
    hostIp?: string;
    /**
     * HostPort is the IP port from outside the container. This can be different than the ContainerPort because of network forwarding on the host machine.
     * @type {number}
     * @memberof V1Address
     */
    hostPort?: number;
}
/**
 * Agent is a pool of resources where containers are run.
 * @export
 * @interface V1Agent
 */
export interface V1Agent {
    /**
     * The unique id of the agent.
     * @type {string}
     * @memberof V1Agent
     */
    id: string;
    /**
     * The time when the agent registered with the master.
     * @type {Date}
     * @memberof V1Agent
     */
    registeredTime?: Date;
    /**
     * A map of slot id to each slot of this agent.
     * @type {{ [key: string]: V1Slot; }}
     * @memberof V1Agent
     */
    slots?: { [key: string]: V1Slot; };
    /**
     * A map of container id to all containers assigned to this agent.
     * @type {{ [key: string]: V1Container; }}
     * @memberof V1Agent
     */
    containers?: { [key: string]: V1Container; };
    /**
     * This field has been deprecated and will be empty.
     * @type {string}
     * @memberof V1Agent
     */
    label?: string;
    /**
     * The addresses of the agent.
     * @type {Array<string>}
     * @memberof V1Agent
     */
    addresses?: Array<string>;
    /**
     * Flag notifying if containers can be scheduled on this agent.
     * @type {boolean}
     * @memberof V1Agent
     */
    enabled?: boolean;
    /**
     * Flag notifying if this agent is in the draining mode: current containers will be allowed to finish but no new ones will be scheduled.
     * @type {boolean}
     * @memberof V1Agent
     */
    draining?: boolean;
    /**
     * The Determined version that this agent was built from.
     * @type {string}
     * @memberof V1Agent
     */
    version?: string;
    /**
     * The name of the resource pools the agent is in. Only slurm can contain multiples.
     * @type {Array<string>}
     * @memberof V1Agent
     */
    resourcePools?: Array<string>;
}
/**
 * AgentUserGroup represents a username and primary group for a user on an agent host machine.
 * @export
 * @interface V1AgentUserGroup
 */
export interface V1AgentUserGroup {
    /**
     * The user id on the agent.
     * @type {number}
     * @memberof V1AgentUserGroup
     */
    agentUid?: number;
    /**
     * The group id on the agent.
     * @type {number}
     * @memberof V1AgentUserGroup
     */
    agentGid?: number;
    /**
     * User name.
     * @type {string}
     * @memberof V1AgentUserGroup
     */
    agentUser?: string;
    /**
     * Group name.
     * @type {string}
     * @memberof V1AgentUserGroup
     */
    agentGroup?: string;
}
/**
 * Aggregate statistics for a queue.
 * @export
 * @interface V1AggregateQueueStats
 */
export interface V1AggregateQueueStats {
    /**
     * The date of this entry.
     * @type {string}
     * @memberof V1AggregateQueueStats
     */
    periodStart: string;
    /**
     * The total number of seconds queued.
     * @type {number}
     * @memberof V1AggregateQueueStats
     */
    seconds: number;
}
/**
 * Allocation tracks a specific instance of a Task.
 * @export
 * @interface V1Allocation
 */
export interface V1Allocation {
    /**
     * Unique ID of task associated with the allocation.
     * @type {string}
     * @memberof V1Allocation
     */
    taskId: string;
    /**
     * The current state of the allocation.
     * @type {Taskv1State}
     * @memberof V1Allocation
     */
    state: Taskv1State;
    /**
     * Whether the allocation is ready to access.
     * @type {boolean}
     * @memberof V1Allocation
     */
    isReady: boolean;
    /**
     * Start timestamp.
     * @type {string}
     * @memberof V1Allocation
     */
    startTime?: string;
    /**
     * End timestamp if completed.
     * @type {string}
     * @memberof V1Allocation
     */
    endTime?: string;
    /**
     * Unique ID of the allocation.
     * @type {string}
     * @memberof V1Allocation
     */
    allocationId: string;
}
/**
 * Arguments to an all gather.
 * @export
 * @interface V1AllocationAllGatherRequest
 */
export interface V1AllocationAllGatherRequest {
    /**
     * The ID of the allocation.
     * @type {string}
     * @memberof V1AllocationAllGatherRequest
     */
    allocationId: string;
    /**
     * The UUID of the participant in an all gather.
     * @type {string}
     * @memberof V1AllocationAllGatherRequest
     */
    requestUuid?: string;
    /**
     * The number of process to wait for.
     * @type {number}
     * @memberof V1AllocationAllGatherRequest
     */
    numPeers?: number;
    /**
     * The data from this process.
     * @type {any}
     * @memberof V1AllocationAllGatherRequest
     */
    data: any;
}
/**
 * 
 * @export
 * @interface V1AllocationAllGatherResponse
 */
export interface V1AllocationAllGatherResponse {
    /**
     * The data for all the processes.
     * @type {Array<any>}
     * @memberof V1AllocationAllGatherResponse
     */
    data: Array<any>;
}
/**
 * 
 * @export
 * @interface V1AllocationPendingPreemptionSignalRequest
 */
export interface V1AllocationPendingPreemptionSignalRequest {
    /**
     * The id of the allocation.
     * @type {string}
     * @memberof V1AllocationPendingPreemptionSignalRequest
     */
    allocationId: string;
}
/**
 * 
 * @export
 * @interface V1AllocationPendingPreemptionSignalResponse
 */
export interface V1AllocationPendingPreemptionSignalResponse {
}
/**
 * Response to AllocationPreemptionSignalRequest.
 * @export
 * @interface V1AllocationPreemptionSignalResponse
 */
export interface V1AllocationPreemptionSignalResponse {
    /**
     * True if signaling preempt, otherwise just a synchronization marker.
     * @type {boolean}
     * @memberof V1AllocationPreemptionSignalResponse
     */
    preempt?: boolean;
}
/**
 * Mark the given task as ready.
 * @export
 * @interface V1AllocationReadyRequest
 */
export interface V1AllocationReadyRequest {
    /**
     * The id of the allocation.
     * @type {string}
     * @memberof V1AllocationReadyRequest
     */
    allocationId?: string;
}
/**
 * Response to AllocationReadyRequest.
 * @export
 * @interface V1AllocationReadyResponse
 */
export interface V1AllocationReadyResponse {
}
/**
 * 
 * @export
 * @interface V1AllocationRendezvousInfoResponse
 */
export interface V1AllocationRendezvousInfoResponse {
    /**
     * The rendezvous information.
     * @type {V1RendezvousInfo}
     * @memberof V1AllocationRendezvousInfoResponse
     */
    rendezvousInfo: V1RendezvousInfo;
}
/**
 * AllocationSummary contains information about a task for external display.
 * @export
 * @interface V1AllocationSummary
 */
export interface V1AllocationSummary {
    /**
     * TaskID is the unique ID of a task among all tasks.
     * @type {string}
     * @memberof V1AllocationSummary
     */
    taskId?: string;
    /**
     * AllocationID is the ID of an allocation of a task. It is usually of the form TaskID.allocation_number, maybe with some other metadata if different types of allocations run.
     * @type {string}
     * @memberof V1AllocationSummary
     */
    allocationId?: string;
    /**
     * The name of the task.
     * @type {string}
     * @memberof V1AllocationSummary
     */
    name?: string;
    /**
     * The registered time of the task.
     * @type {Date}
     * @memberof V1AllocationSummary
     */
    registeredTime?: Date;
    /**
     * The name of the resource pool.
     * @type {string}
     * @memberof V1AllocationSummary
     */
    resourcePool?: string;
    /**
     * The number of slots that are needed.
     * @type {number}
     * @memberof V1AllocationSummary
     */
    slotsNeeded?: number;
    /**
     * ResourcesSummary provides a summary of the resources comprising what we know at the time the allocation is granted.
     * @type {Array<V1ResourcesSummary>}
     * @memberof V1AllocationSummary
     */
    resources?: Array<V1ResourcesSummary>;
    /**
     * The type of the scheduler. Either 'FAIR_SHARE', 'PRIORITY', or 'ROUND_ROBIN'.
     * @type {string}
     * @memberof V1AllocationSummary
     */
    schedulerType?: string;
    /**
     * THe priority of the task.
     * @type {number}
     * @memberof V1AllocationSummary
     */
    priority?: number;
    /**
     * ProxyPortConfig configures a proxy the allocation should start.
     * @type {Array<V1ProxyPortConfig>}
     * @memberof V1AllocationSummary
     */
    proxyPorts?: Array<V1ProxyPortConfig>;
}
/**
 * Mark the given task as waiting.
 * @export
 * @interface V1AllocationWaitingRequest
 */
export interface V1AllocationWaitingRequest {
    /**
     * The id of the allocation.
     * @type {string}
     * @memberof V1AllocationWaitingRequest
     */
    allocationId?: string;
}
/**
 * Response to AllocationWaitingRequest.
 * @export
 * @interface V1AllocationWaitingResponse
 */
export interface V1AllocationWaitingResponse {
}
/**
 * Response to ArchiveExperimentRequest.
 * @export
 * @interface V1ArchiveExperimentResponse
 */
export interface V1ArchiveExperimentResponse {
}
/**
 * Archive multiple experiments.
 * @export
 * @interface V1ArchiveExperimentsRequest
 */
export interface V1ArchiveExperimentsRequest {
    /**
     * Selecting experiments by id.
     * @type {Array<number>}
     * @memberof V1ArchiveExperimentsRequest
     */
    experimentIds: Array<number>;
    /**
     * Targets all experiments matching filters.
     * @type {V1BulkExperimentFilters}
     * @memberof V1ArchiveExperimentsRequest
     */
    filters?: V1BulkExperimentFilters;
}
/**
 * Response to ArchiveExperimentsRequest.
 * @export
 * @interface V1ArchiveExperimentsResponse
 */
export interface V1ArchiveExperimentsResponse {
    /**
     * Details on success or error for each experiment.
     * @type {Array<V1ExperimentActionResult>}
     * @memberof V1ArchiveExperimentsResponse
     */
    results: Array<V1ExperimentActionResult>;
}
/**
 * 
 * @export
 * @interface V1ArchiveModelResponse
 */
export interface V1ArchiveModelResponse {
}
/**
 * Response to ArchiveProjectRequest.
 * @export
 * @interface V1ArchiveProjectResponse
 */
export interface V1ArchiveProjectResponse {
}
/**
 * Response to ArchiveWorkspaceRequest.
 * @export
 * @interface V1ArchiveWorkspaceResponse
 */
export interface V1ArchiveWorkspaceResponse {
}
/**
 * AssignRolesRequest is the body of the request for the call to grant a user or group a role. It requires group_id, role_id, and either scope_workspace_id or scope_project_id.
 * @export
 * @interface V1AssignRolesRequest
 */
export interface V1AssignRolesRequest {
    /**
     * the set of groups being assigned to a role.
     * @type {Array<V1GroupRoleAssignment>}
     * @memberof V1AssignRolesRequest
     */
    groupRoleAssignments?: Array<V1GroupRoleAssignment>;
    /**
     * the set of users being assigned to a role.
     * @type {Array<V1UserRoleAssignment>}
     * @memberof V1AssignRolesRequest
     */
    userRoleAssignments?: Array<V1UserRoleAssignment>;
}
/**
 * AssignRolesResponse is the body of the request for the call to grant a user or group a role.
 * @export
 * @interface V1AssignRolesResponse
 */
export interface V1AssignRolesResponse {
}
/**
 * 
 * @export
 * @interface V1AwsCustomTag
 */
export interface V1AwsCustomTag {
    /**
     * The key of the custom tag
     * @type {string}
     * @memberof V1AwsCustomTag
     */
    key: string;
    /**
     * The value of the custom tag
     * @type {string}
     * @memberof V1AwsCustomTag
     */
    value: string;
}
/**
 * 
 * @export
 * @interface V1BindRPToWorkspaceRequest
 */
export interface V1BindRPToWorkspaceRequest {
    /**
     * The resource pool name.
     * @type {string}
     * @memberof V1BindRPToWorkspaceRequest
     */
    resourcePoolName: string;
    /**
     * The workspace IDs to be bound to the resource pool.
     * @type {Array<number>}
     * @memberof V1BindRPToWorkspaceRequest
     */
    workspaceIds?: Array<number>;
    /**
     * The workspace names to be bound to the resource pool.
     * @type {Array<string>}
     * @memberof V1BindRPToWorkspaceRequest
     */
    workspaceNames?: Array<string>;
}
/**
 * Bind a resource pool to workspaces response.
 * @export
 * @interface V1BindRPToWorkspaceResponse
 */
export interface V1BindRPToWorkspaceResponse {
}
/**
 * Filters to apply actions to multiple experiments.
 * @export
 * @interface V1BulkExperimentFilters
 */
export interface V1BulkExperimentFilters {
    /**
     * Limit experiments to those that match the description.
     * @type {string}
     * @memberof V1BulkExperimentFilters
     */
    description?: string;
    /**
     * Limit experiments to those that match the name.
     * @type {string}
     * @memberof V1BulkExperimentFilters
     */
    name?: string;
    /**
     * Limit experiments to those that match the provided labels.
     * @type {Array<string>}
     * @memberof V1BulkExperimentFilters
     */
    labels?: Array<string>;
    /**
     * Limit experiments to those that are archived.
     * @type {boolean}
     * @memberof V1BulkExperimentFilters
     */
    archived?: boolean;
    /**
     * Limit experiments to those that match the provided state.
     * @type {Array<Experimentv1State>}
     * @memberof V1BulkExperimentFilters
     */
    states?: Array<Experimentv1State>;
    /**
     * Limit experiments to those that are owned by users with the specified userIds.
     * @type {Array<number>}
     * @memberof V1BulkExperimentFilters
     */
    userIds?: Array<number>;
    /**
     * Limit experiments to those within a specified project, or 0 for all projects.
     * @type {number}
     * @memberof V1BulkExperimentFilters
     */
    projectId?: number;
    /**
     * Experiment ids to exclude when filters are used.
     * @type {Array<number>}
     * @memberof V1BulkExperimentFilters
     */
    excludedExperimentIds?: Array<number>;
}
/**
 * Response to CancelExperimentRequest.
 * @export
 * @interface V1CancelExperimentResponse
 */
export interface V1CancelExperimentResponse {
}
/**
 * Cancel multiple experiments.
 * @export
 * @interface V1CancelExperimentsRequest
 */
export interface V1CancelExperimentsRequest {
    /**
     * Selecting experiments by id.
     * @type {Array<number>}
     * @memberof V1CancelExperimentsRequest
     */
    experimentIds: Array<number>;
    /**
     * Targets all experiments matching filters.
     * @type {V1BulkExperimentFilters}
     * @memberof V1CancelExperimentsRequest
     */
    filters?: V1BulkExperimentFilters;
}
/**
 * Response to CancelExperimentsRequest.
 * @export
 * @interface V1CancelExperimentsResponse
 */
export interface V1CancelExperimentsResponse {
    /**
     * Details on success or error for each experiment.
     * @type {Array<V1ExperimentActionResult>}
     * @memberof V1CancelExperimentsResponse
     */
    results: Array<V1ExperimentActionResult>;
}
/**
 * Checkpoint a collection of files saved by a task.
 * @export
 * @interface V1Checkpoint
 */
export interface V1Checkpoint {
    /**
     * ID of the task which generated this checkpoint.
     * @type {string}
     * @memberof V1Checkpoint
     */
    taskId?: string;
    /**
     * ID of the allocation which generated this checkpoint.
     * @type {string}
     * @memberof V1Checkpoint
     */
    allocationId?: string;
    /**
     * UUID of the checkpoint.
     * @type {string}
     * @memberof V1Checkpoint
     */
    uuid: string;
    /**
     * Timestamp when the checkpoint was reported.
     * @type {Date}
     * @memberof V1Checkpoint
     */
    reportTime?: Date;
    /**
     * Dictionary of file paths to file sizes in bytes of all files in the checkpoint.
     * @type {{ [key: string]: string; }}
     * @memberof V1Checkpoint
     */
    resources: { [key: string]: string; };
    /**
     * User defined metadata associated with the checkpoint.
     * @type {any}
     * @memberof V1Checkpoint
     */
    metadata: any;
    /**
     * The state of the underlying checkpoint.
     * @type {Checkpointv1State}
     * @memberof V1Checkpoint
     */
    state: Checkpointv1State;
    /**
     * Training-related data for this checkpoint.
     * @type {V1CheckpointTrainingMetadata}
     * @memberof V1Checkpoint
     */
    training: V1CheckpointTrainingMetadata;
}
/**
 * Request to delete files matching globs in checkpoints.
 * @export
 * @interface V1CheckpointsRemoveFilesRequest
 */
export interface V1CheckpointsRemoveFilesRequest {
    /**
     * The list of checkpoint_uuids for the requested checkpoints.
     * @type {Array<string>}
     * @memberof V1CheckpointsRemoveFilesRequest
     */
    checkpointUuids: Array<string>;
    /**
     * The list of checkpoint_globs for the requested checkpoints. If a value is set to the empty string the checkpoint will only have its metadata refreshed.
     * @type {Array<string>}
     * @memberof V1CheckpointsRemoveFilesRequest
     */
    checkpointGlobs: Array<string>;
}
/**
 * Response to CheckpointRemoveFilesRequest.
 * @export
 * @interface V1CheckpointsRemoveFilesResponse
 */
export interface V1CheckpointsRemoveFilesResponse {
}
/**
 * CheckpointTrainingMetadata is specifically metadata about training.
 * @export
 * @interface V1CheckpointTrainingMetadata
 */
export interface V1CheckpointTrainingMetadata {
    /**
     * The ID of the trial that created this checkpoint.
     * @type {number}
     * @memberof V1CheckpointTrainingMetadata
     */
    trialId?: number;
    /**
     * The ID of the experiment that created this checkpoint.
     * @type {number}
     * @memberof V1CheckpointTrainingMetadata
     */
    experimentId?: number;
    /**
     * The configuration of the experiment that created this checkpoint.
     * @type {any}
     * @memberof V1CheckpointTrainingMetadata
     */
    experimentConfig?: any;
    /**
     * Hyperparameter values for the trial that created this checkpoint.
     * @type {any}
     * @memberof V1CheckpointTrainingMetadata
     */
    hparams?: any;
    /**
     * Training metrics reported at the same steps_completed as the checkpoint.
     * @type {V1Metrics}
     * @memberof V1CheckpointTrainingMetadata
     */
    trainingMetrics?: V1Metrics;
    /**
     * Validation metrics reported at the same steps_completed as the checkpoint.
     * @type {V1Metrics}
     * @memberof V1CheckpointTrainingMetadata
     */
    validationMetrics?: V1Metrics;
    /**
     * Searcher metric (as specified by the expconf) at the same steps_completed of the checkpoint.
     * @type {number}
     * @memberof V1CheckpointTrainingMetadata
     */
    searcherMetric?: number;
}
/**
 * CheckpointWorkload is an artifact created by a trial during training.
 * @export
 * @interface V1CheckpointWorkload
 */
export interface V1CheckpointWorkload {
    /**
     * UUID of the checkpoint.
     * @type {string}
     * @memberof V1CheckpointWorkload
     */
    uuid?: string;
    /**
     * The time the workload finished or was stopped.
     * @type {Date}
     * @memberof V1CheckpointWorkload
     */
    endTime?: Date;
    /**
     * The state of the checkpoint.
     * @type {Checkpointv1State}
     * @memberof V1CheckpointWorkload
     */
    state: Checkpointv1State;
    /**
     * Dictionary of file paths to file sizes in bytes of all files in the checkpoint.
     * @type {{ [key: string]: string; }}
     * @memberof V1CheckpointWorkload
     */
    resources?: { [key: string]: string; };
    /**
     * Total number of batches as of this workload's completion.
     * @type {number}
     * @memberof V1CheckpointWorkload
     */
    totalBatches: number;
    /**
     * User defined metadata associated with the checkpoint.
     * @type {any}
     * @memberof V1CheckpointWorkload
     */
    metadata?: any;
}
/**
 * Close a trial with given ID.
 * @export
 * @interface V1CloseTrialOperation
 */
export interface V1CloseTrialOperation {
    /**
     * The ID of the trial to close.
     * @type {string}
     * @memberof V1CloseTrialOperation
     */
    requestId?: string;
}
/**
 * - COLUMN_TYPE_UNSPECIFIED: data type is unknown/mixed  - COLUMN_TYPE_TEXT: data type is textual  - COLUMN_TYPE_NUMBER: data type is numeric  - COLUMN_TYPE_DATE: data type is a date
 * @export
 * @enum {string}
 */
export const V1ColumnType = {
    UNSPECIFIED: 'COLUMN_TYPE_UNSPECIFIED',
    TEXT: 'COLUMN_TYPE_TEXT',
    NUMBER: 'COLUMN_TYPE_NUMBER',
    DATE: 'COLUMN_TYPE_DATE',
} as const
export type V1ColumnType = ValueOf<typeof V1ColumnType>
/**
 * Command is a single container running the configured command.
 * @export
 * @interface V1Command
 */
export interface V1Command {
    /**
     * The id of the command.
     * @type {string}
     * @memberof V1Command
     */
    id: string;
    /**
     * The description of the command.
     * @type {string}
     * @memberof V1Command
     */
    description: string;
    /**
     * The state of the command.
     * @type {Taskv1State}
     * @memberof V1Command
     */
    state: Taskv1State;
    /**
     * The time the command was started.
     * @type {Date}
     * @memberof V1Command
     */
    startTime: Date;
    /**
     * The container running the command.
     * @type {V1Container}
     * @memberof V1Command
     */
    container?: V1Container;
    /**
     * The display name of the user that created the command.
     * @type {string}
     * @memberof V1Command
     */
    displayName?: string;
    /**
     * The id of the user that created the command.
     * @type {number}
     * @memberof V1Command
     */
    userId?: number;
    /**
     * The username of the user that created the command.
     * @type {string}
     * @memberof V1Command
     */
    username: string;
    /**
     * The name of the resource pool the command was created in
     * @type {string}
     * @memberof V1Command
     */
    resourcePool: string;
    /**
     * The exit status;
     * @type {string}
     * @memberof V1Command
     */
    exitStatus?: string;
    /**
     * The associated job id.
     * @type {string}
     * @memberof V1Command
     */
    jobId: string;
    /**
     * The workspace id.
     * @type {number}
     * @memberof V1Command
     */
    workspaceId: number;
}
/**
 * Container for a requested trial and its metrics.
 * @export
 * @interface V1ComparableTrial
 */
export interface V1ComparableTrial {
    /**
     * The requested trial.
     * @type {Trialv1Trial}
     * @memberof V1ComparableTrial
     */
    trial: Trialv1Trial;
    /**
     * The downsampled datapoints.
     * @type {Array<V1DownsampledMetrics>}
     * @memberof V1ComparableTrial
     */
    metrics: Array<V1DownsampledMetrics>;
}
/**
 * Response to CompareTrialsRequest.
 * @export
 * @interface V1CompareTrialsResponse
 */
export interface V1CompareTrialsResponse {
    /**
     * A list of objects containing trial and metrics information.
     * @type {Array<V1ComparableTrial>}
     * @memberof V1CompareTrialsResponse
     */
    trials: Array<V1ComparableTrial>;
}
/**
 * 
 * @export
 * @interface V1CompleteTrialSearcherValidationResponse
 */
export interface V1CompleteTrialSearcherValidationResponse {
}
/**
 * Used to complete a ValidateAfterOperation.
 * @export
 * @interface V1CompleteValidateAfterOperation
 */
export interface V1CompleteValidateAfterOperation {
    /**
     * The ValidateAfterOperation being completed.
     * @type {V1ValidateAfterOperation}
     * @memberof V1CompleteValidateAfterOperation
     */
    op?: V1ValidateAfterOperation;
    /**
     * The value of searcher metric associated with this completed operation. The metric provided should be the metric used to guide HP search.
     * @type {any}
     * @memberof V1CompleteValidateAfterOperation
     */
    searcherMetric?: any;
}
/**
 * The config to be patched into Master Config.
 * @export
 * @interface V1Config
 */
export interface V1Config {
    /**
     * The log config to be patched into Master Config.
     * @type {V1LogConfig}
     * @memberof V1Config
     */
    log?: V1LogConfig;
}
/**
 * Container is a Docker container that is either scheduled to run or is currently running on a set of slots.
 * @export
 * @interface V1Container
 */
export interface V1Container {
    /**
     * The id of the task that is currently managing this container.
     * @type {string}
     * @memberof V1Container
     */
    parent?: string;
    /**
     * The unique id of this instance of a container.
     * @type {string}
     * @memberof V1Container
     */
    id: string;
    /**
     * The current state that the container is currently in.
     * @type {Containerv1State}
     * @memberof V1Container
     */
    state: Containerv1State;
    /**
     * A list of devices that is being used by this container.
     * @type {Array<V1Device>}
     * @memberof V1Container
     */
    devices?: Array<V1Device>;
}
/**
 * Request to create a new experiment.
 * @export
 * @interface V1CreateExperimentRequest
 */
export interface V1CreateExperimentRequest {
    /**
     * Experiment context.
     * @type {Array<V1File>}
     * @memberof V1CreateExperimentRequest
     */
    modelDefinition?: Array<V1File>;
    /**
     * Experiment config (YAML).
     * @type {string}
     * @memberof V1CreateExperimentRequest
     */
    config?: string;
    /**
     * Only validate instead of creating the experiment. A dry run.
     * @type {boolean}
     * @memberof V1CreateExperimentRequest
     */
    validateOnly?: boolean;
    /**
     * Parent experiment id.
     * @type {number}
     * @memberof V1CreateExperimentRequest
     */
    parentId?: number;
    /**
     * Request to auto-activate the experiment.
     * @type {boolean}
     * @memberof V1CreateExperimentRequest
     */
    activate?: boolean;
    /**
     * Project id to contain the experiment.
     * @type {number}
     * @memberof V1CreateExperimentRequest
     */
    projectId?: number;
    /**
     * Template to use for the experiment.
     * @type {string}
     * @memberof V1CreateExperimentRequest
     */
    template?: string;
    /**
     * Git remote at submission time.
     * @type {string}
     * @memberof V1CreateExperimentRequest
     */
    gitRemote?: string;
    /**
     * Git commit at submission time.
     * @type {string}
     * @memberof V1CreateExperimentRequest
     */
    gitCommit?: string;
    /**
     * Git committer at submission time.
     * @type {string}
     * @memberof V1CreateExperimentRequest
     */
    gitCommitter?: string;
    /**
     * Git commit date at submission time.
     * @type {Date}
     * @memberof V1CreateExperimentRequest
     */
    gitCommitDate?: Date;
    /**
     * Unmanaged experiments are detached.
     * @type {boolean}
     * @memberof V1CreateExperimentRequest
     */
    unmanaged?: boolean;
}
/**
 * Response to CreateExperimentRequest.
 * @export
 * @interface V1CreateExperimentResponse
 */
export interface V1CreateExperimentResponse {
    /**
     * The created experiment.
     * @type {V1Experiment}
     * @memberof V1CreateExperimentResponse
     */
    experiment: V1Experiment;
    /**
     * The created experiment config.
     * @type {any}
     * @memberof V1CreateExperimentResponse
     */
    config: any;
    /**
     * List of any related warnings.
     * @type {Array<V1LaunchWarning>}
     * @memberof V1CreateExperimentResponse
     */
    warnings?: Array<V1LaunchWarning>;
}
/**
 * CreateGroupRequest is the body of the request for the call to create a group.
 * @export
 * @interface V1CreateGroupRequest
 */
export interface V1CreateGroupRequest {
    /**
     * The name the new group should have
     * @type {string}
     * @memberof V1CreateGroupRequest
     */
    name: string;
    /**
     * The ids of users that should be added to the new group
     * @type {Array<number>}
     * @memberof V1CreateGroupRequest
     */
    addUsers?: Array<number>;
}
/**
 * CreateGroupResponse is the body of the response for the call to update a group and its members.
 * @export
 * @interface V1CreateGroupResponse
 */
export interface V1CreateGroupResponse {
    /**
     * Info about the group after the update succeeded.
     * @type {V1GroupDetails}
     * @memberof V1CreateGroupResponse
     */
    group: V1GroupDetails;
}
/**
 * Create a trial with given hyperparameters.
 * @export
 * @interface V1CreateTrialOperation
 */
export interface V1CreateTrialOperation {
    /**
     * The ID of the trial to create.
     * @type {string}
     * @memberof V1CreateTrialOperation
     */
    requestId?: string;
    /**
     * A JSON object representing the hyperparameters.
     * @type {string}
     * @memberof V1CreateTrialOperation
     */
    hyperparams?: string;
}
/**
 * Create a trial.
 * @export
 * @interface V1CreateTrialRequest
 */
export interface V1CreateTrialRequest {
    /**
     * The id of the parent experiment.
     * @type {number}
     * @memberof V1CreateTrialRequest
     */
    experimentId?: number;
    /**
     * Trial hyperparameters.
     * @type {any}
     * @memberof V1CreateTrialRequest
     */
    hparams?: any;
    /**
     * Currently only unmanaged trials are supported, must be true.
     * @type {boolean}
     * @memberof V1CreateTrialRequest
     */
    unmanaged?: boolean;
}
/**
 * Response to CreateTrialRequest.
 * @export
 * @interface V1CreateTrialResponse
 */
export interface V1CreateTrialResponse {
    /**
     * The requested trial.
     * @type {Trialv1Trial}
     * @memberof V1CreateTrialResponse
     */
    trial: Trialv1Trial;
}
/**
 * Response to CurrentUserRequest.
 * @export
 * @interface V1CurrentUserResponse
 */
export interface V1CurrentUserResponse {
    /**
     * The currently logged in user.
     * @type {V1User}
     * @memberof V1CurrentUserResponse
     */
    user: V1User;
}
/**
 * One datapoint in a series of metrics from a trial in batch.
 * @export
 * @interface V1DataPoint
 */
export interface V1DataPoint {
    /**
     * Total batches processed by the time this measurement is taken.
     * @type {number}
     * @memberof V1DataPoint
     */
    batches: number;
    /**
     * Values of the requested metrics at this point in the trial.
     * @type {any}
     * @memberof V1DataPoint
     */
    values?: any;
    /**
     * The time the measurement is taken.
     * @type {Date}
     * @memberof V1DataPoint
     */
    time: Date;
    /**
     * The epoch this measurement is taken.
     * @type {number}
     * @memberof V1DataPoint
     */
    epoch?: number;
}
/**
 * 
 * @export
 * @interface V1DeleteCheckpointsRequest
 */
export interface V1DeleteCheckpointsRequest {
    /**
     * The list of checkpoint_uuids for the requested checkpoint.
     * @type {Array<string>}
     * @memberof V1DeleteCheckpointsRequest
     */
    checkpointUuids: Array<string>;
}
/**
 * 
 * @export
 * @interface V1DeleteCheckpointsResponse
 */
export interface V1DeleteCheckpointsResponse {
}
/**
 * Response to DeleteExperimentRequest.
 * @export
 * @interface V1DeleteExperimentResponse
 */
export interface V1DeleteExperimentResponse {
}
/**
 * Delete multiple experiments.
 * @export
 * @interface V1DeleteExperimentsRequest
 */
export interface V1DeleteExperimentsRequest {
    /**
     * Selecting experiments by id.
     * @type {Array<number>}
     * @memberof V1DeleteExperimentsRequest
     */
    experimentIds: Array<number>;
    /**
     * Targets all experiments matching filters.
     * @type {V1BulkExperimentFilters}
     * @memberof V1DeleteExperimentsRequest
     */
    filters?: V1BulkExperimentFilters;
}
/**
 * Response to DeleteExperimentsRequest.
 * @export
 * @interface V1DeleteExperimentsResponse
 */
export interface V1DeleteExperimentsResponse {
    /**
     * Details on success or error for each experiment.
     * @type {Array<V1ExperimentActionResult>}
     * @memberof V1DeleteExperimentsResponse
     */
    results: Array<V1ExperimentActionResult>;
}
/**
 * DeleteGroupResponse is the body of the response for the call to delete a group.
 * @export
 * @interface V1DeleteGroupResponse
 */
export interface V1DeleteGroupResponse {
}
/**
 * 
 * @export
 * @interface V1DeleteModelResponse
 */
export interface V1DeleteModelResponse {
}
/**
 * 
 * @export
 * @interface V1DeleteModelVersionResponse
 */
export interface V1DeleteModelVersionResponse {
}
/**
 * Response to DeleteProjectRequest.
 * @export
 * @interface V1DeleteProjectResponse
 */
export interface V1DeleteProjectResponse {
    /**
     * Status of deletion.
     * @type {boolean}
     * @memberof V1DeleteProjectResponse
     */
    completed: boolean;
}
/**
 * Response to DeleteTemplateRequest.
 * @export
 * @interface V1DeleteTemplateResponse
 */
export interface V1DeleteTemplateResponse {
}
/**
 * Response to DeleteWebhookRequest.
 * @export
 * @interface V1DeleteWebhookResponse
 */
export interface V1DeleteWebhookResponse {
}
/**
 * Response to DeleteWorkspaceRequest.
 * @export
 * @interface V1DeleteWorkspaceResponse
 */
export interface V1DeleteWorkspaceResponse {
    /**
     * Status of deletion.
     * @type {boolean}
     * @memberof V1DeleteWorkspaceResponse
     */
    completed: boolean;
}
/**
 * Device represents a single computational device on an agent.
 * @export
 * @interface V1Device
 */
export interface V1Device {
    /**
     * The index of the device.
     * @type {number}
     * @memberof V1Device
     */
    id?: number;
    /**
     * The brand name of the device.
     * @type {string}
     * @memberof V1Device
     */
    brand?: string;
    /**
     * The unique UUID of the device.
     * @type {string}
     * @memberof V1Device
     */
    uuid?: string;
    /**
     * The type of the Device.
     * @type {Devicev1Type}
     * @memberof V1Device
     */
    type?: Devicev1Type;
}
/**
 * Disable the agent.
 * @export
 * @interface V1DisableAgentRequest
 */
export interface V1DisableAgentRequest {
    /**
     * The id of the agent.
     * @type {string}
     * @memberof V1DisableAgentRequest
     */
    agentId?: string;
    /**
     * If true, wait for running tasks to finish.
     * @type {boolean}
     * @memberof V1DisableAgentRequest
     */
    drain?: boolean;
}
/**
 * Response to DisableAgentRequest.
 * @export
 * @interface V1DisableAgentResponse
 */
export interface V1DisableAgentResponse {
    /**
     * The disabled agent.
     * @type {V1Agent}
     * @memberof V1DisableAgentResponse
     */
    agent?: V1Agent;
}
/**
 * Disable the slot.
 * @export
 * @interface V1DisableSlotRequest
 */
export interface V1DisableSlotRequest {
    /**
     * The id of the agent.
     * @type {string}
     * @memberof V1DisableSlotRequest
     */
    agentId?: string;
    /**
     * The id of the slot.
     * @type {string}
     * @memberof V1DisableSlotRequest
     */
    slotId?: string;
    /**
     * If true, wait for running task to finish.
     * @type {boolean}
     * @memberof V1DisableSlotRequest
     */
    drain?: boolean;
}
/**
 * Response to DisableSlotRequest.
 * @export
 * @interface V1DisableSlotResponse
 */
export interface V1DisableSlotResponse {
    /**
     * The disabled slot.
     * @type {V1Slot}
     * @memberof V1DisableSlotResponse
     */
    slot?: V1Slot;
}
/**
 * Double filters.
 * @export
 * @interface V1DoubleFieldFilter
 */
export interface V1DoubleFieldFilter {
    /**
     * Less than.
     * @type {number}
     * @memberof V1DoubleFieldFilter
     */
    lt?: number;
    /**
     * Less than or equal.
     * @type {number}
     * @memberof V1DoubleFieldFilter
     */
    lte?: number;
    /**
     * Greater than.
     * @type {number}
     * @memberof V1DoubleFieldFilter
     */
    gt?: number;
    /**
     * Greater than or equal.
     * @type {number}
     * @memberof V1DoubleFieldFilter
     */
    gte?: number;
}
/**
 * DownsampledMetrics captures a metric's name and downsampled data points.
 * @export
 * @interface V1DownsampledMetrics
 */
export interface V1DownsampledMetrics {
    /**
     * A possibly down-sampled series of metrics' readings through the progress of the trial.
     * @type {Array<V1DataPoint>}
     * @memberof V1DownsampledMetrics
     */
    data: Array<V1DataPoint>;
    /**
     * Metric group (training, validation, or unset).
     * @type {V1MetricType}
     * @memberof V1DownsampledMetrics
     */
    type: V1MetricType;
    /**
     * Metric group (training, validation, etc).
     * @type {string}
     * @memberof V1DownsampledMetrics
     */
    group: string;
}
/**
 * Response to EnableAgentRequest.
 * @export
 * @interface V1EnableAgentResponse
 */
export interface V1EnableAgentResponse {
    /**
     * The enabled agent.
     * @type {V1Agent}
     * @memberof V1EnableAgentResponse
     */
    agent?: V1Agent;
}
/**
 * Response to EnableSlotRequest.
 * @export
 * @interface V1EnableSlotResponse
 */
export interface V1EnableSlotResponse {
    /**
     * The enabled slot.
     * @type {V1Slot}
     * @memberof V1EnableSlotResponse
     */
    slot?: V1Slot;
}
/**
 * - ENTITY_TYPE_UNSPECIFIED: Default entity type.  - ENTITY_TYPE_PROJECT: Represents a project.
 * @export
 * @enum {string}
 */
export const V1EntityType = {
    UNSPECIFIED: 'ENTITY_TYPE_UNSPECIFIED',
    PROJECT: 'ENTITY_TYPE_PROJECT',
} as const
export type V1EntityType = ValueOf<typeof V1EntityType>
/**
 * Experiment is a collection of one or more trials that are exploring a user-defined hyperparameter space.
 * @export
 * @interface V1Experiment
 */
export interface V1Experiment {
    /**
     * The id of the experiment.
     * @type {number}
     * @memberof V1Experiment
     */
    id: number;
    /**
     * The description of the experiment.
     * @type {string}
     * @memberof V1Experiment
     */
    description?: string;
    /**
     * Labels attached to the experiment.
     * @type {Array<string>}
     * @memberof V1Experiment
     */
    labels?: Array<string>;
    /**
     * The time the experiment was started.
     * @type {Date}
     * @memberof V1Experiment
     */
    startTime: Date;
    /**
     * The time the experiment ended if the experiment is stopped.
     * @type {Date}
     * @memberof V1Experiment
     */
    endTime?: Date;
    /**
     * The current state of the experiment.
     * @type {Experimentv1State}
     * @memberof V1Experiment
     */
    state: Experimentv1State;
    /**
     * Boolean denoting whether the experiment was archived.
     * @type {boolean}
     * @memberof V1Experiment
     */
    archived: boolean;
    /**
     * The number of trials linked to the experiment.
     * @type {number}
     * @memberof V1Experiment
     */
    numTrials: number;
    /**
     * The ids of trials linked to the experiment.
     * @type {Array<number>}
     * @memberof V1Experiment
     */
    trialIds?: Array<number>;
    /**
     * The display name of the user that created the experiment.
     * @type {string}
     * @memberof V1Experiment
     */
    displayName?: string;
    /**
     * The id of the user that created the experiment.
     * @type {number}
     * @memberof V1Experiment
     */
    userId?: number;
    /**
     * The username of the user that created the experiment.
     * @type {string}
     * @memberof V1Experiment
     */
    username: string;
    /**
     * The resource pool the experiment was created in
     * @type {string}
     * @memberof V1Experiment
     */
    resourcePool?: string;
    /**
     * The type of searcher for the experiment
     * @type {string}
     * @memberof V1Experiment
     */
    searcherType: string;
    /**
     * The searcher metric name for the experiment
     * @type {string}
     * @memberof V1Experiment
     */
    searcherMetric?: string;
    /**
     * The experiment name.
     * @type {string}
     * @memberof V1Experiment
     */
    name: string;
    /**
     * The experiment notes.
     * @type {string}
     * @memberof V1Experiment
     */
    notes?: string;
    /**
     * Associated job's id.
     * @type {string}
     * @memberof V1Experiment
     */
    jobId: string;
    /**
     * Original id of a forked or continued experiment.
     * @type {number}
     * @memberof V1Experiment
     */
    forkedFrom?: number;
    /**
     * The current progress of a running experiment.
     * @type {number}
     * @memberof V1Experiment
     */
    progress?: number;
    /**
     * The id of the project associated with this experiment.
     * @type {number}
     * @memberof V1Experiment
     */
    projectId: number;
    /**
     * The name of the project associated with this experiment.
     * @type {string}
     * @memberof V1Experiment
     */
    projectName?: string;
    /**
     * The id of the workspace associated with this experiment.
     * @type {number}
     * @memberof V1Experiment
     */
    workspaceId?: number;
    /**
     * The name of the workspace associated with this experiment.
     * @type {string}
     * @memberof V1Experiment
     */
    workspaceName?: string;
    /**
     * The archived status of the parent project (can be inherited from workspace).
     * @type {boolean}
     * @memberof V1Experiment
     */
    parentArchived?: boolean;
    /**
     * The configuration of the experiment.
     * @type {any}
     * @memberof V1Experiment
     */
    config: any;
    /**
     * The original configuration that the user submitted.
     * @type {string}
     * @memberof V1Experiment
     */
    originalConfig: string;
    /**
     * The id of the user who created the parent project.
     * @type {number}
     * @memberof V1Experiment
     */
    projectOwnerId: number;
    /**
     * The total size of checkpoints.
     * @type {string}
     * @memberof V1Experiment
     */
    checkpointSize?: string;
    /**
     * The count of checkpoints.
     * @type {number}
     * @memberof V1Experiment
     */
    checkpointCount?: number;
    /**
     * The metrics and hyperparameters associated with the best trial by searcher metric.
     * @type {number}
     * @memberof V1Experiment
     */
    bestTrialSearcherMetric?: number;
    /**
     * Id of experiment's best trial, calculated by the best searcher metrics value of trial's best validation.
     * @type {number}
     * @memberof V1Experiment
     */
    bestTrialId?: number;
    /**
     * Unmanaged experiments are detached.
     * @type {boolean}
     * @memberof V1Experiment
     */
    unmanaged?: boolean;
    /**
     * Time in seconds which experiment ran or has been running.
     * @type {number}
     * @memberof V1Experiment
     */
    duration?: number;
}
/**
 * Message for results of individual experiments in a multi-experiment action.
 * @export
 * @interface V1ExperimentActionResult
 */
export interface V1ExperimentActionResult {
    /**
     * Optional error message.
     * @type {string}
     * @memberof V1ExperimentActionResult
     */
    error: string;
    /**
     * Experiment ID.
     * @type {number}
     * @memberof V1ExperimentActionResult
     */
    id: number;
}
/**
 * ExperimentInactive is a searcher event triggered when an experiment is no longer active.
 * @export
 * @interface V1ExperimentInactive
 */
export interface V1ExperimentInactive {
    /**
     * Current state of the experiment.
     * @type {Experimentv1State}
     * @memberof V1ExperimentInactive
     */
    experimentState: Experimentv1State;
}
/**
 * ExperimentSimulation holds the configuration and results of simulated run of a searcher.
 * @export
 * @interface V1ExperimentSimulation
 */
export interface V1ExperimentSimulation {
    /**
     * The simulated experiment config.
     * @type {any}
     * @memberof V1ExperimentSimulation
     */
    config?: any;
    /**
     * The searcher simulation seed.
     * @type {number}
     * @memberof V1ExperimentSimulation
     */
    seed?: number;
    /**
     * The list of trials in the simulation.
     * @type {Array<V1TrialSimulation>}
     * @memberof V1ExperimentSimulation
     */
    trials?: Array<V1TrialSimulation>;
}
/**
 * Response to ExpMetricNamesRequest.
 * @export
 * @interface V1ExpMetricNamesResponse
 */
export interface V1ExpMetricNamesResponse {
    /**
     * The names of the searcher metrics.
     * @type {Array<string>}
     * @memberof V1ExpMetricNamesResponse
     */
    searcherMetrics?: Array<string>;
    /**
     * List of training metric names.
     * @type {Array<string>}
     * @memberof V1ExpMetricNamesResponse
     */
    trainingMetrics?: Array<string>;
    /**
     * List of validation metric names.
     * @type {Array<string>}
     * @memberof V1ExpMetricNamesResponse
     */
    validationMetrics?: Array<string>;
    /**
     * List of metric group-name pairs.
     * @type {Array<V1MetricIdentifier>}
     * @memberof V1ExpMetricNamesResponse
     */
    metricNames?: Array<V1MetricIdentifier>;
}
/**
 * The failure type of a resource.   - FAILURE_TYPE_UNSPECIFIED: UNSPECIFIED denotes an error that is not defined below.  - FAILURE_TYPE_RESOURCES_FAILED: ResourcesFailed denotes that the container ran but failed with a non-zero exit code.  - FAILURE_TYPE_RESOURCES_ABORTED: ResourcesAborted denotes the container was canceled before it was started.  - FAILURE_TYPE_RESOURCES_MISSING: ResourcesMissing denotes the resources were missing when the master asked about it.  - FAILURE_TYPE_TASK_ABORTED: TaskAborted denotes that the task was canceled before it was started.  - FAILURE_TYPE_TASK_ERROR: TaskError denotes that the task failed without an associated exit code.  - FAILURE_TYPE_AGENT_FAILED: AgentFailed denotes that the agent failed while the container was running.  - FAILURE_TYPE_AGENT_ERROR: AgentError denotes that the agent failed to launch the container.  - FAILURE_TYPE_RESTORE_ERROR: RestoreError denotes a failure to restore a running allocation on master blip.  - FAILURE_TYPE_UNKNOWN_ERROR: UnknownError denotes an internal error that did not map to a know failure type.
 * @export
 * @enum {string}
 */
export const V1FailureType = {
    UNSPECIFIED: 'FAILURE_TYPE_UNSPECIFIED',
    RESOURCESFAILED: 'FAILURE_TYPE_RESOURCES_FAILED',
    RESOURCESABORTED: 'FAILURE_TYPE_RESOURCES_ABORTED',
    RESOURCESMISSING: 'FAILURE_TYPE_RESOURCES_MISSING',
    TASKABORTED: 'FAILURE_TYPE_TASK_ABORTED',
    TASKERROR: 'FAILURE_TYPE_TASK_ERROR',
    AGENTFAILED: 'FAILURE_TYPE_AGENT_FAILED',
    AGENTERROR: 'FAILURE_TYPE_AGENT_ERROR',
    RESTOREERROR: 'FAILURE_TYPE_RESTORE_ERROR',
    UNKNOWNERROR: 'FAILURE_TYPE_UNKNOWN_ERROR',
} as const
export type V1FailureType = ValueOf<typeof V1FailureType>
/**
 * File is a Unix file.
 * @export
 * @interface V1File
 */
export interface V1File {
    /**
     * Path to the file.
     * @type {string}
     * @memberof V1File
     */
    path: string;
    /**
     * File type.
     * @type {number}
     * @memberof V1File
     */
    type: number;
    /**
     * base64 encoded contents of the file.
     * @type {string}
     * @memberof V1File
     */
    content: string;
    /**
     * Modified time (Unix timestamp).
     * @type {string}
     * @memberof V1File
     */
    mtime: string;
    /**
     * File mode.
     * @type {number}
     * @memberof V1File
     */
    mode: number;
    /**
     * User ID.
     * @type {number}
     * @memberof V1File
     */
    uid: number;
    /**
     * Group ID.
     * @type {number}
     * @memberof V1File
     */
    gid: number;
}
/**
 * File node is one node of file in experiment model definition file tree.
 * @export
 * @interface V1FileNode
 */
export interface V1FileNode {
    /**
     * Path of file.
     * @type {string}
     * @memberof V1FileNode
     */
    path?: string;
    /**
     * Name of file.
     * @type {string}
     * @memberof V1FileNode
     */
    name?: string;
    /**
     * Modification time of file.
     * @type {Date}
     * @memberof V1FileNode
     */
    modifiedTime?: Date;
    /**
     * Number of bytes in file content.
     * @type {number}
     * @memberof V1FileNode
     */
    contentLength?: number;
    /**
     * Is this a directory.
     * @type {boolean}
     * @memberof V1FileNode
     */
    isDir?: boolean;
    /**
     * MIME type of file.
     * @type {string}
     * @memberof V1FileNode
     */
    contentType?: string;
    /**
     * Subdirectory files.
     * @type {Array<V1FileNode>}
     * @memberof V1FileNode
     */
    files?: Array<V1FileNode>;
}
/**
 * The fitting policy of the scheduler.   - FITTING_POLICY_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - FITTING_POLICY_BEST: Best fit. Tasks are preferentially packed together on the smallest number of agents  - FITTING_POLICY_WORST: Worst fit. Tasks are placed on under-utilized agents, spreading out the tasks.  - FITTING_POLICY_KUBERNETES: A kubernetes placeholder. In k8s, the task placement is delegated to the k8s scheduler so the fitting policy is not relevant.  - FITTING_POLICY_SLURM: A slurm placeholder. When running on slurm, task placement is delegated.  - FITTING_POLICY_PBS: A PBS placeholder. When running on PBS, task placement is delegated.
 * @export
 * @enum {string}
 */
export const V1FittingPolicy = {
    UNSPECIFIED: 'FITTING_POLICY_UNSPECIFIED',
    BEST: 'FITTING_POLICY_BEST',
    WORST: 'FITTING_POLICY_WORST',
    KUBERNETES: 'FITTING_POLICY_KUBERNETES',
    SLURM: 'FITTING_POLICY_SLURM',
    PBS: 'FITTING_POLICY_PBS',
} as const
export type V1FittingPolicy = ValueOf<typeof V1FittingPolicy>
/**
 * Response to GetActiveTasksCountRequest.
 * @export
 * @interface V1GetActiveTasksCountResponse
 */
export interface V1GetActiveTasksCountResponse {
    /**
     * The count of commands.
     * @type {number}
     * @memberof V1GetActiveTasksCountResponse
     */
    commands: number;
    /**
     * The count of notebooks.
     * @type {number}
     * @memberof V1GetActiveTasksCountResponse
     */
    notebooks: number;
    /**
     * The count of shells.
     * @type {number}
     * @memberof V1GetActiveTasksCountResponse
     */
    shells: number;
    /**
     * The count of TensorBoards.
     * @type {number}
     * @memberof V1GetActiveTasksCountResponse
     */
    tensorboards: number;
}
/**
 * Response to GetAgentRequest.
 * @export
 * @interface V1GetAgentResponse
 */
export interface V1GetAgentResponse {
    /**
     * The requested agent.
     * @type {V1Agent}
     * @memberof V1GetAgentResponse
     */
    agent: V1Agent;
}
/**
 * Sorts agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
 * @export
 * @enum {string}
 */
export const V1GetAgentsRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    ID: 'SORT_BY_ID',
    TIME: 'SORT_BY_TIME',
} as const
export type V1GetAgentsRequestSortBy = ValueOf<typeof V1GetAgentsRequestSortBy>
/**
 * Response to GetAgentsRequest.
 * @export
 * @interface V1GetAgentsResponse
 */
export interface V1GetAgentsResponse {
    /**
     * The list of returned agents.
     * @type {Array<V1Agent>}
     * @memberof V1GetAgentsResponse
     */
    agents: Array<V1Agent>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetAgentsResponse
     */
    pagination?: V1Pagination;
}
/**
 * Response to GetBestSearcherValidationMetricRequest.
 * @export
 * @interface V1GetBestSearcherValidationMetricResponse
 */
export interface V1GetBestSearcherValidationMetricResponse {
    /**
     * The value of the metric.
     * @type {number}
     * @memberof V1GetBestSearcherValidationMetricResponse
     */
    metric?: number;
}
/**
 * Response to GetCheckpointRequest.
 * @export
 * @interface V1GetCheckpointResponse
 */
export interface V1GetCheckpointResponse {
    /**
     * The requested checkpoint.
     * @type {V1Checkpoint}
     * @memberof V1GetCheckpointResponse
     */
    checkpoint: V1Checkpoint;
}
/**
 * Response to GetCommandRequest.
 * @export
 * @interface V1GetCommandResponse
 */
export interface V1GetCommandResponse {
    /**
     * The requested command.
     * @type {V1Command}
     * @memberof V1GetCommandResponse
     */
    command: V1Command;
    /**
     * The command config.
     * @type {any}
     * @memberof V1GetCommandResponse
     */
    config: any;
}
/**
 * Sorts commands by the given field.   - SORT_BY_UNSPECIFIED: Returns commands in an unsorted list.  - SORT_BY_ID: Returns commands sorted by id.  - SORT_BY_DESCRIPTION: Returns commands sorted by description.  - SORT_BY_START_TIME: Return commands sorted by start time.  - SORT_BY_WORKSPACE_ID: Return commands sorted by workspace_id.
 * @export
 * @enum {string}
 */
export const V1GetCommandsRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    ID: 'SORT_BY_ID',
    DESCRIPTION: 'SORT_BY_DESCRIPTION',
    STARTTIME: 'SORT_BY_START_TIME',
    WORKSPACEID: 'SORT_BY_WORKSPACE_ID',
} as const
export type V1GetCommandsRequestSortBy = ValueOf<typeof V1GetCommandsRequestSortBy>
/**
 * Response to GetCommandsRequest.
 * @export
 * @interface V1GetCommandsResponse
 */
export interface V1GetCommandsResponse {
    /**
     * The list of returned commands.
     * @type {Array<V1Command>}
     * @memberof V1GetCommandsResponse
     */
    commands: Array<V1Command>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetCommandsResponse
     */
    pagination?: V1Pagination;
}
/**
 * 
 * @export
 * @interface V1GetCurrentTrialSearcherOperationResponse
 */
export interface V1GetCurrentTrialSearcherOperationResponse {
    /**
     * The current searcher operation.
     * @type {V1TrialOperation}
     * @memberof V1GetCurrentTrialSearcherOperationResponse
     */
    op?: V1TrialOperation;
    /**
     * The status of the searcher operation.
     * @type {boolean}
     * @memberof V1GetCurrentTrialSearcherOperationResponse
     */
    completed?: boolean;
}
/**
 * Sorts checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_TRIAL_ID: Returns checkpoints sorted by trial id.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_STATE: Returns checkpoints sorted by state.  - SORT_BY_SEARCHER_METRIC: Returns checkpoints sorted by the experiment's `searcher.metric` configuration setting.
 * @export
 * @enum {string}
 */
export const V1GetExperimentCheckpointsRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    UUID: 'SORT_BY_UUID',
    TRIALID: 'SORT_BY_TRIAL_ID',
    BATCHNUMBER: 'SORT_BY_BATCH_NUMBER',
    ENDTIME: 'SORT_BY_END_TIME',
    STATE: 'SORT_BY_STATE',
    SEARCHERMETRIC: 'SORT_BY_SEARCHER_METRIC',
} as const
export type V1GetExperimentCheckpointsRequestSortBy = ValueOf<typeof V1GetExperimentCheckpointsRequestSortBy>
/**
 * Response to GetExperimentCheckpointsRequest.
 * @export
 * @interface V1GetExperimentCheckpointsResponse
 */
export interface V1GetExperimentCheckpointsResponse {
    /**
     * The list of returned checkpoints.
     * @type {Array<V1Checkpoint>}
     * @memberof V1GetExperimentCheckpointsResponse
     */
    checkpoints: Array<V1Checkpoint>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetExperimentCheckpointsResponse
     */
    pagination: V1Pagination;
}
/**
 * Response to GetExperimentsLabelsRequest.
 * @export
 * @interface V1GetExperimentLabelsResponse
 */
export interface V1GetExperimentLabelsResponse {
    /**
     * The list of labels used across all experiments.
     * @type {Array<string>}
     * @memberof V1GetExperimentLabelsResponse
     */
    labels?: Array<string>;
}
/**
 * Response to GetExperimentRequest.
 * @export
 * @interface V1GetExperimentResponse
 */
export interface V1GetExperimentResponse {
    /**
     * The requested experiment.
     * @type {V1Experiment}
     * @memberof V1GetExperimentResponse
     */
    experiment: V1Experiment;
    /**
     * Associated job summary.
     * @type {V1JobSummary}
     * @memberof V1GetExperimentResponse
     */
    jobSummary?: V1JobSummary;
}
/**
 * Sorts experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end_time are returned after the ones with end_time.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.  - SORT_BY_NAME: Returns experiments sorted by name.  - SORT_BY_FORKED_FROM: Returns experiments sorted by originating model.  - SORT_BY_RESOURCE_POOL: Returns experiments sorted by resource pool.  - SORT_BY_PROJECT_ID: Returns experiments sorted by project.  - SORT_BY_CHECKPOINT_SIZE: Returns experiments sorted by checkpoint size.  - SORT_BY_CHECKPOINT_COUNT: Returns experiments sorted by checkpoint count.  - SORT_BY_SEARCHER_METRIC_VAL: Returns experiments sorted by searcher metric value..
 * @export
 * @enum {string}
 */
export const V1GetExperimentsRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    ID: 'SORT_BY_ID',
    DESCRIPTION: 'SORT_BY_DESCRIPTION',
    STARTTIME: 'SORT_BY_START_TIME',
    ENDTIME: 'SORT_BY_END_TIME',
    STATE: 'SORT_BY_STATE',
    NUMTRIALS: 'SORT_BY_NUM_TRIALS',
    PROGRESS: 'SORT_BY_PROGRESS',
    USER: 'SORT_BY_USER',
    NAME: 'SORT_BY_NAME',
    FORKEDFROM: 'SORT_BY_FORKED_FROM',
    RESOURCEPOOL: 'SORT_BY_RESOURCE_POOL',
    PROJECTID: 'SORT_BY_PROJECT_ID',
    CHECKPOINTSIZE: 'SORT_BY_CHECKPOINT_SIZE',
    CHECKPOINTCOUNT: 'SORT_BY_CHECKPOINT_COUNT',
    SEARCHERMETRICVAL: 'SORT_BY_SEARCHER_METRIC_VAL',
} as const
export type V1GetExperimentsRequestSortBy = ValueOf<typeof V1GetExperimentsRequestSortBy>
/**
 * Response to GetExperimentsRequest.
 * @export
 * @interface V1GetExperimentsResponse
 */
export interface V1GetExperimentsResponse {
    /**
     * The list of returned experiments.
     * @type {Array<V1Experiment>}
     * @memberof V1GetExperimentsResponse
     */
    experiments: Array<V1Experiment>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetExperimentsResponse
     */
    pagination: V1Pagination;
}
/**
 * Sorts trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.  - SORT_BY_RESTARTS: Return the trials sorted by the number of restarts.  - SORT_BY_CHECKPOINT_SIZE: Return the trials sorted by checkpoint size.
 * @export
 * @enum {string}
 */
export const V1GetExperimentTrialsRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    ID: 'SORT_BY_ID',
    STARTTIME: 'SORT_BY_START_TIME',
    ENDTIME: 'SORT_BY_END_TIME',
    STATE: 'SORT_BY_STATE',
    BESTVALIDATIONMETRIC: 'SORT_BY_BEST_VALIDATION_METRIC',
    LATESTVALIDATIONMETRIC: 'SORT_BY_LATEST_VALIDATION_METRIC',
    BATCHESPROCESSED: 'SORT_BY_BATCHES_PROCESSED',
    DURATION: 'SORT_BY_DURATION',
    RESTARTS: 'SORT_BY_RESTARTS',
    CHECKPOINTSIZE: 'SORT_BY_CHECKPOINT_SIZE',
} as const
export type V1GetExperimentTrialsRequestSortBy = ValueOf<typeof V1GetExperimentTrialsRequestSortBy>
/**
 * Response to GetExperimentTrialsRequest.
 * @export
 * @interface V1GetExperimentTrialsResponse
 */
export interface V1GetExperimentTrialsResponse {
    /**
     * The list of returned trials.
     * @type {Array<Trialv1Trial>}
     * @memberof V1GetExperimentTrialsResponse
     */
    trials: Array<Trialv1Trial>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetExperimentTrialsResponse
     */
    pagination: V1Pagination;
}
/**
 * Response to GetExperimentValidationHistoryRequest.
 * @export
 * @interface V1GetExperimentValidationHistoryResponse
 */
export interface V1GetExperimentValidationHistoryResponse {
    /**
     * validation_history is a collection of zero or more validation metrics for an experiment, describing the best metrics as they were reported through the lifetime of an experiment. The historical list of best validations.
     * @type {Array<V1ValidationHistoryEntry>}
     * @memberof V1GetExperimentValidationHistoryResponse
     */
    validationHistory?: Array<V1ValidationHistoryEntry>;
}
/**
 * GetGroupResponse is the body of the response for the call to get a group by id.
 * @export
 * @interface V1GetGroupResponse
 */
export interface V1GetGroupResponse {
    /**
     * The group info
     * @type {V1GroupDetails}
     * @memberof V1GetGroupResponse
     */
    group: V1GroupDetails;
}
/**
 * Response object for GetGroupsAndUsersAssignedToWorkspace.
 * @export
 * @interface V1GetGroupsAndUsersAssignedToWorkspaceResponse
 */
export interface V1GetGroupsAndUsersAssignedToWorkspaceResponse {
    /**
     * Groups with a role assigned to the given workspace scope. Contains user membership of each group.
     * @type {Array<V1GroupDetails>}
     * @memberof V1GetGroupsAndUsersAssignedToWorkspaceResponse
     */
    groups: Array<V1GroupDetails>;
    /**
     * Only contains users assigned directly to roles on the workspace scope.
     * @type {Array<V1User>}
     * @memberof V1GetGroupsAndUsersAssignedToWorkspaceResponse
     */
    usersAssignedDirectly: Array<V1User>;
    /**
     * Roles assigned to workspace with associations between groups and users_assigned_directly with roles.
     * @type {Array<V1RoleWithAssignments>}
     * @memberof V1GetGroupsAndUsersAssignedToWorkspaceResponse
     */
    assignments: Array<V1RoleWithAssignments>;
}
/**
 * GetGroupsRequest is the body of the request for the call to search for groups.
 * @export
 * @interface V1GetGroupsRequest
 */
export interface V1GetGroupsRequest {
    /**
     * The id of the user to use to find groups to which the user belongs.
     * @type {number}
     * @memberof V1GetGroupsRequest
     */
    userId?: number;
    /**
     * The group name to use when searching.
     * @type {string}
     * @memberof V1GetGroupsRequest
     */
    name?: string;
    /**
     * Skip the number of groups before returning results. Negative values denote number of groups to skip from the end before returning results.
     * @type {number}
     * @memberof V1GetGroupsRequest
     */
    offset?: number;
    /**
     * Limit the number of groups. Required and must be must be <= 500.
     * @type {number}
     * @memberof V1GetGroupsRequest
     */
    limit: number;
}
/**
 * GetGroupsResponse is the body of the response for the call to search for groups.
 * @export
 * @interface V1GetGroupsResponse
 */
export interface V1GetGroupsResponse {
    /**
     * The found groups
     * @type {Array<V1GroupSearchResult>}
     * @memberof V1GetGroupsResponse
     */
    groups?: Array<V1GroupSearchResult>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetGroupsResponse
     */
    pagination?: V1Pagination;
}
/**
 * Response to GetJobQueueStatsRequest.
 * @export
 * @interface V1GetJobQueueStatsResponse
 */
export interface V1GetJobQueueStatsResponse {
    /**
     * List of queue stats per resource pool.
     * @type {Array<V1RPQueueStat>}
     * @memberof V1GetJobQueueStatsResponse
     */
    results: Array<V1RPQueueStat>;
}
/**
 * Response to GetJobsRequest.
 * @export
 * @interface V1GetJobsResponse
 */
export interface V1GetJobsResponse {
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetJobsResponse
     */
    pagination: V1Pagination;
    /**
     * List of the request jobs.
     * @type {Array<V1Job>}
     * @memberof V1GetJobsResponse
     */
    jobs: Array<V1Job>;
}
/**
 * Response to GetJobsV2Request.
 * @export
 * @interface V1GetJobsV2Response
 */
export interface V1GetJobsV2Response {
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetJobsV2Response
     */
    pagination: V1Pagination;
    /**
     * List of the requested jobs.
     * @type {Array<V1RBACJob>}
     * @memberof V1GetJobsV2Response
     */
    jobs: Array<V1RBACJob>;
}
/**
 * Response to GetMasterRequest.
 * @export
 * @interface V1GetMasterConfigResponse
 */
export interface V1GetMasterConfigResponse {
    /**
     * The config file loaded by the master.
     * @type {any}
     * @memberof V1GetMasterConfigResponse
     */
    config: any;
}
/**
 * Response to GetMasterRequest.
 * @export
 * @interface V1GetMasterResponse
 */
export interface V1GetMasterResponse {
    /**
     * The current version of the master.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    version: string;
    /**
     * The current instance id of the master.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    masterId: string;
    /**
     * The global cluster id of the master.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    clusterId: string;
    /**
     * The cluster name.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    clusterName: string;
    /**
     * Telemetry status.
     * @type {boolean}
     * @memberof V1GetMasterResponse
     */
    telemetryEnabled?: boolean;
    /**
     * SSO providers.
     * @type {Array<V1SSOProvider>}
     * @memberof V1GetMasterResponse
     */
    ssoProviders?: Array<V1SSOProvider>;
    /**
     * Redirect for starting internal sessions..
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    externalLoginUri?: string;
    /**
     * Redirect for ending external sessions.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    externalLogoutUri?: string;
    /**
     * Branding style to use on front-end.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    branding?: string;
    /**
     * Feature flag for RBAC and user groups.
     * @type {boolean}
     * @memberof V1GetMasterResponse
     */
    rbacEnabled?: boolean;
    /**
     * What kind of product offering the cluster is part of, if any
     * @type {GetMasterResponseProduct}
     * @memberof V1GetMasterResponse
     */
    product?: GetMasterResponseProduct;
    /**
     * List of features that is on.
     * @type {Array<string>}
     * @memberof V1GetMasterResponse
     */
    featureSwitches?: Array<string>;
    /**
     * Feature flag for user management.
     * @type {boolean}
     * @memberof V1GetMasterResponse
     */
    userManagementEnabled?: boolean;
    /**
     * Feature flag for strict job queue control.
     * @type {boolean}
     * @memberof V1GetMasterResponse
     */
    strictJobQueueControl: boolean;
}
/**
 * Response to GetMeRequest.
 * @export
 * @interface V1GetMeResponse
 */
export interface V1GetMeResponse {
    /**
     * The requested user.
     * @type {V1User}
     * @memberof V1GetMeResponse
     */
    user: V1User;
}
/**
 * Response to GetMetricsRequest.
 * @export
 * @interface V1GetMetricsResponse
 */
export interface V1GetMetricsResponse {
    /**
     * Metric response.
     * @type {Array<V1MetricsReport>}
     * @memberof V1GetMetricsResponse
     */
    metrics: Array<V1MetricsReport>;
}
/**
 * Request to get a file of model definition.
 * @export
 * @interface V1GetModelDefFileRequest
 */
export interface V1GetModelDefFileRequest {
    /**
     * The id of the experiment.
     * @type {number}
     * @memberof V1GetModelDefFileRequest
     */
    experimentId?: number;
    /**
     * The path of file.
     * @type {string}
     * @memberof V1GetModelDefFileRequest
     */
    path?: string;
}
/**
 * Response to GetModelDefFileRequest.
 * @export
 * @interface V1GetModelDefFileResponse
 */
export interface V1GetModelDefFileResponse {
    /**
     * Content of file.
     * @type {string}
     * @memberof V1GetModelDefFileResponse
     */
    file?: string;
}
/**
 * Response to GetModelDefRequest.
 * @export
 * @interface V1GetModelDefResponse
 */
export interface V1GetModelDefResponse {
    /**
     * The base64-encoded, gzipped, tarball.
     * @type {string}
     * @memberof V1GetModelDefResponse
     */
    b64Tgz: string;
}
/**
 * Response to GetModelDefTreeRequest.
 * @export
 * @interface V1GetModelDefTreeResponse
 */
export interface V1GetModelDefTreeResponse {
    /**
     * File tree of an experiment.
     * @type {Array<V1FileNode>}
     * @memberof V1GetModelDefTreeResponse
     */
    files?: Array<V1FileNode>;
}
/**
 * Response to GetModelLabelsRequest.
 * @export
 * @interface V1GetModelLabelsResponse
 */
export interface V1GetModelLabelsResponse {
    /**
     * List of labels used across all models.
     * @type {Array<string>}
     * @memberof V1GetModelLabelsResponse
     */
    labels: Array<string>;
}
/**
 * Response to GetModelRequest.
 * @export
 * @interface V1GetModelResponse
 */
export interface V1GetModelResponse {
    /**
     * The model requested.
     * @type {V1Model}
     * @memberof V1GetModelResponse
     */
    model: V1Model;
}
/**
 * Sort models by the given field.   - SORT_BY_UNSPECIFIED: Returns models in an unsorted list.  - SORT_BY_NAME: Returns models sorted by name.  - SORT_BY_DESCRIPTION: Returns models sorted by description.  - SORT_BY_CREATION_TIME: Returns models sorted by creation time.  - SORT_BY_LAST_UPDATED_TIME: Returns models sorted by last updated time.  - SORT_BY_NUM_VERSIONS: Returns models sorted by number of version.  - SORT_BY_WORKSPACE: Returns models sorted by workspace name.
 * @export
 * @enum {string}
 */
export const V1GetModelsRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    NAME: 'SORT_BY_NAME',
    DESCRIPTION: 'SORT_BY_DESCRIPTION',
    CREATIONTIME: 'SORT_BY_CREATION_TIME',
    LASTUPDATEDTIME: 'SORT_BY_LAST_UPDATED_TIME',
    NUMVERSIONS: 'SORT_BY_NUM_VERSIONS',
    WORKSPACE: 'SORT_BY_WORKSPACE',
} as const
export type V1GetModelsRequestSortBy = ValueOf<typeof V1GetModelsRequestSortBy>
/**
 * Response to GetModelsRequest.
 * @export
 * @interface V1GetModelsResponse
 */
export interface V1GetModelsResponse {
    /**
     * The list of returned models.
     * @type {Array<V1Model>}
     * @memberof V1GetModelsResponse
     */
    models: Array<V1Model>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetModelsResponse
     */
    pagination: V1Pagination;
}
/**
 * Response for GetModelVersionRequest.
 * @export
 * @interface V1GetModelVersionResponse
 */
export interface V1GetModelVersionResponse {
    /**
     * The model version requested.
     * @type {V1ModelVersion}
     * @memberof V1GetModelVersionResponse
     */
    modelVersion: V1ModelVersion;
}
/**
 * Sort models by the given field.   - SORT_BY_UNSPECIFIED: Returns model versions in an unsorted list.  - SORT_BY_VERSION: Returns model versions sorted by version number.  - SORT_BY_CREATION_TIME: Returns model versions sorted by creation_time.
 * @export
 * @enum {string}
 */
export const V1GetModelVersionsRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    VERSION: 'SORT_BY_VERSION',
    CREATIONTIME: 'SORT_BY_CREATION_TIME',
} as const
export type V1GetModelVersionsRequestSortBy = ValueOf<typeof V1GetModelVersionsRequestSortBy>
/**
 * Response for GetModelVersionRequest.
 * @export
 * @interface V1GetModelVersionsResponse
 */
export interface V1GetModelVersionsResponse {
    /**
     * The model requested.
     * @type {V1Model}
     * @memberof V1GetModelVersionsResponse
     */
    model: V1Model;
    /**
     * The list of returned model versions.
     * @type {Array<V1ModelVersion>}
     * @memberof V1GetModelVersionsResponse
     */
    modelVersions: Array<V1ModelVersion>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetModelVersionsResponse
     */
    pagination: V1Pagination;
}
/**
 * Response to GetNotebookRequest.
 * @export
 * @interface V1GetNotebookResponse
 */
export interface V1GetNotebookResponse {
    /**
     * The requested notebook.
     * @type {V1Notebook}
     * @memberof V1GetNotebookResponse
     */
    notebook: V1Notebook;
    /**
     * The notebook config.
     * @type {any}
     * @memberof V1GetNotebookResponse
     */
    config: any;
}
/**
 * Sorts notebooks by the given field.   - SORT_BY_UNSPECIFIED: Returns notebooks in an unsorted list.  - SORT_BY_ID: Returns notebooks sorted by id.  - SORT_BY_DESCRIPTION: Returns notebooks sorted by description.  - SORT_BY_START_TIME: Return notebooks sorted by start time.  - SORT_BY_WORKSPACE_ID: Return notebooks sorted by workspace_id
 * @export
 * @enum {string}
 */
export const V1GetNotebooksRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    ID: 'SORT_BY_ID',
    DESCRIPTION: 'SORT_BY_DESCRIPTION',
    STARTTIME: 'SORT_BY_START_TIME',
    WORKSPACEID: 'SORT_BY_WORKSPACE_ID',
} as const
export type V1GetNotebooksRequestSortBy = ValueOf<typeof V1GetNotebooksRequestSortBy>
/**
 * Response to GetNotebooksRequest.
 * @export
 * @interface V1GetNotebooksResponse
 */
export interface V1GetNotebooksResponse {
    /**
     * The list of returned notebooks.
     * @type {Array<V1Notebook>}
     * @memberof V1GetNotebooksResponse
     */
    notebooks: Array<V1Notebook>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetNotebooksResponse
     */
    pagination?: V1Pagination;
}
/**
 * Response to GetPermissionsSummaryRequest.
 * @export
 * @interface V1GetPermissionsSummaryResponse
 */
export interface V1GetPermissionsSummaryResponse {
    /**
     * A group of roles in cluster and other scopes.
     * @type {Array<V1Role>}
     * @memberof V1GetPermissionsSummaryResponse
     */
    roles: Array<V1Role>;
    /**
     * Lists of assignments for the cluster and other scopes.
     * @type {Array<V1RoleAssignmentSummary>}
     * @memberof V1GetPermissionsSummaryResponse
     */
    assignments: Array<V1RoleAssignmentSummary>;
}
/**
 * 
 * @export
 * @interface V1GetProjectColumnsResponse
 */
export interface V1GetProjectColumnsResponse {
    /**
     * List of columns.
     * @type {Array<V1ProjectColumn>}
     * @memberof V1GetProjectColumnsResponse
     */
    columns: Array<V1ProjectColumn>;
}
/**
 * 
 * @export
 * @interface V1GetProjectNumericMetricsRangeResponse
 */
export interface V1GetProjectNumericMetricsRangeResponse {
    /**
     * List of ranges.
     * @type {Array<V1MetricsRange>}
     * @memberof V1GetProjectNumericMetricsRangeResponse
     */
    ranges?: Array<V1MetricsRange>;
}
/**
 * Response to GetProjectRequest.
 * @export
 * @interface V1GetProjectResponse
 */
export interface V1GetProjectResponse {
    /**
     * The project requested.
     * @type {V1Project}
     * @memberof V1GetProjectResponse
     */
    project: V1Project;
}
/**
 * Response to GetProjectsByUserActivityRequest.
 * @export
 * @interface V1GetProjectsByUserActivityResponse
 */
export interface V1GetProjectsByUserActivityResponse {
    /**
     * A list of projects
     * @type {Array<V1Project>}
     * @memberof V1GetProjectsByUserActivityResponse
     */
    projects?: Array<V1Project>;
}
/**
 * Response to GetResourcePoolsRequest.
 * @export
 * @interface V1GetResourcePoolsResponse
 */
export interface V1GetResourcePoolsResponse {
    /**
     * The list of returned resource pools.
     * @type {Array<V1ResourcePool>}
     * @memberof V1GetResourcePoolsResponse
     */
    resourcePools?: Array<V1ResourcePool>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetResourcePoolsResponse
     */
    pagination?: V1Pagination;
}
/**
 * 
 * @export
 * @interface V1GetRolesAssignedToGroupResponse
 */
export interface V1GetRolesAssignedToGroupResponse {
    /**
     * The roles assigned to the requested groups.
     * @type {Array<V1Role>}
     * @memberof V1GetRolesAssignedToGroupResponse
     */
    roles: Array<V1Role>;
    /**
     * What scope each role is assigned to.
     * @type {Array<V1RoleAssignmentSummary>}
     * @memberof V1GetRolesAssignedToGroupResponse
     */
    assignments: Array<V1RoleAssignmentSummary>;
}
/**
 * 
 * @export
 * @interface V1GetRolesAssignedToUserResponse
 */
export interface V1GetRolesAssignedToUserResponse {
    /**
     * The roles assigned to the requested user with assignment information.
     * @type {Array<V1RoleWithAssignments>}
     * @memberof V1GetRolesAssignedToUserResponse
     */
    roles: Array<V1RoleWithAssignments>;
}
/**
 * 
 * @export
 * @interface V1GetRolesByIDRequest
 */
export interface V1GetRolesByIDRequest {
    /**
     * The ids of the roles to be returned
     * @type {Array<number>}
     * @memberof V1GetRolesByIDRequest
     */
    roleIds?: Array<number>;
}
/**
 * 
 * @export
 * @interface V1GetRolesByIDResponse
 */
export interface V1GetRolesByIDResponse {
    /**
     * The roles requested
     * @type {Array<V1RoleWithAssignments>}
     * @memberof V1GetRolesByIDResponse
     */
    roles?: Array<V1RoleWithAssignments>;
}
/**
 * Response to GetSearcherEventsRequest.
 * @export
 * @interface V1GetSearcherEventsResponse
 */
export interface V1GetSearcherEventsResponse {
    /**
     * The list of events in the queue.
     * @type {Array<V1SearcherEvent>}
     * @memberof V1GetSearcherEventsResponse
     */
    searcherEvents?: Array<V1SearcherEvent>;
}
/**
 * Response to GetShellRequest.
 * @export
 * @interface V1GetShellResponse
 */
export interface V1GetShellResponse {
    /**
     * The requested shell.
     * @type {V1Shell}
     * @memberof V1GetShellResponse
     */
    shell: V1Shell;
    /**
     * The shell config.
     * @type {any}
     * @memberof V1GetShellResponse
     */
    config: any;
}
/**
 * Sorts shells by the given field.   - SORT_BY_UNSPECIFIED: Returns shells in an unsorted list.  - SORT_BY_ID: Returns shells sorted by id.  - SORT_BY_DESCRIPTION: Returns shells sorted by description.  - SORT_BY_START_TIME: Return shells sorted by start time.  - SORT_BY_WORKSPACE_ID: Return shells sorted by workspace_id.
 * @export
 * @enum {string}
 */
export const V1GetShellsRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    ID: 'SORT_BY_ID',
    DESCRIPTION: 'SORT_BY_DESCRIPTION',
    STARTTIME: 'SORT_BY_START_TIME',
    WORKSPACEID: 'SORT_BY_WORKSPACE_ID',
} as const
export type V1GetShellsRequestSortBy = ValueOf<typeof V1GetShellsRequestSortBy>
/**
 * Response to GetShellsRequest.
 * @export
 * @interface V1GetShellsResponse
 */
export interface V1GetShellsResponse {
    /**
     * The list of returned shells.
     * @type {Array<V1Shell>}
     * @memberof V1GetShellsResponse
     */
    shells: Array<V1Shell>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetShellsResponse
     */
    pagination?: V1Pagination;
}
/**
 * Response to GetSlotRequest.
 * @export
 * @interface V1GetSlotResponse
 */
export interface V1GetSlotResponse {
    /**
     * The requested slot.
     * @type {V1Slot}
     * @memberof V1GetSlotResponse
     */
    slot?: V1Slot;
}
/**
 * Response to GetSlotsRequest.
 * @export
 * @interface V1GetSlotsResponse
 */
export interface V1GetSlotsResponse {
    /**
     * The requested slots.
     * @type {Array<V1Slot>}
     * @memberof V1GetSlotsResponse
     */
    slots?: Array<V1Slot>;
}
/**
 * Response to GetTaskRequest.
 * @export
 * @interface V1GetTaskResponse
 */
export interface V1GetTaskResponse {
    /**
     * The requested task.
     * @type {V1Task}
     * @memberof V1GetTaskResponse
     */
    task: V1Task;
}
/**
 * Response to GetTasksRequest.
 * @export
 * @interface V1GetTasksResponse
 */
export interface V1GetTasksResponse {
    /**
     * Information about a task for external display.
     * @type {{ [key: string]: V1AllocationSummary; }}
     * @memberof V1GetTasksResponse
     */
    allocationIdToSummary?: { [key: string]: V1AllocationSummary; };
}
/**
 * Response to GetTelemetryRequest.
 * @export
 * @interface V1GetTelemetryResponse
 */
export interface V1GetTelemetryResponse {
    /**
     * Whether telemetry is enabled or not.
     * @type {boolean}
     * @memberof V1GetTelemetryResponse
     */
    enabled: boolean;
    /**
     * The key used for analytics in the UI.
     * @type {string}
     * @memberof V1GetTelemetryResponse
     */
    segmentKey?: string;
}
/**
 * Response to GetTemplateRequest.
 * @export
 * @interface V1GetTemplateResponse
 */
export interface V1GetTemplateResponse {
    /**
     * The requested template.
     * @type {V1Template}
     * @memberof V1GetTemplateResponse
     */
    template: V1Template;
}
/**
 * Sorts templates by the given field.   - SORT_BY_UNSPECIFIED: Returns templates in an unsorted list.  - SORT_BY_NAME: Returns templates sorted by name.
 * @export
 * @enum {string}
 */
export const V1GetTemplatesRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    NAME: 'SORT_BY_NAME',
} as const
export type V1GetTemplatesRequestSortBy = ValueOf<typeof V1GetTemplatesRequestSortBy>
/**
 * Response to GetTemplatesRequest.
 * @export
 * @interface V1GetTemplatesResponse
 */
export interface V1GetTemplatesResponse {
    /**
     * the list of requested templates.
     * @type {Array<V1Template>}
     * @memberof V1GetTemplatesResponse
     */
    templates: Array<V1Template>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetTemplatesResponse
     */
    pagination: V1Pagination;
}
/**
 * Response to GetTensorboardRequest.
 * @export
 * @interface V1GetTensorboardResponse
 */
export interface V1GetTensorboardResponse {
    /**
     * The requested tensorboard.
     * @type {V1Tensorboard}
     * @memberof V1GetTensorboardResponse
     */
    tensorboard: V1Tensorboard;
    /**
     * The config;
     * @type {any}
     * @memberof V1GetTensorboardResponse
     */
    config: any;
}
/**
 * Sorts tensorboards by the given field.   - SORT_BY_UNSPECIFIED: Returns tensorboards in an unsorted list.  - SORT_BY_ID: Returns tensorboards sorted by id.  - SORT_BY_DESCRIPTION: Returns tensorboards sorted by description.  - SORT_BY_START_TIME: Return tensorboards sorted by start time.  - SORT_BY_WORKSPACE_ID: Return tensorboards sorted by workspace_id.
 * @export
 * @enum {string}
 */
export const V1GetTensorboardsRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    ID: 'SORT_BY_ID',
    DESCRIPTION: 'SORT_BY_DESCRIPTION',
    STARTTIME: 'SORT_BY_START_TIME',
    WORKSPACEID: 'SORT_BY_WORKSPACE_ID',
} as const
export type V1GetTensorboardsRequestSortBy = ValueOf<typeof V1GetTensorboardsRequestSortBy>
/**
 * Response to GetTensorboardsRequest.
 * @export
 * @interface V1GetTensorboardsResponse
 */
export interface V1GetTensorboardsResponse {
    /**
     * The list of returned tensorboards.
     * @type {Array<V1Tensorboard>}
     * @memberof V1GetTensorboardsResponse
     */
    tensorboards: Array<V1Tensorboard>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetTensorboardsResponse
     */
    pagination?: V1Pagination;
}
/**
 * Response to GetTrainingMetricsRequest.
 * @export
 * @interface V1GetTrainingMetricsResponse
 */
export interface V1GetTrainingMetricsResponse {
    /**
     * Metric response.
     * @type {Array<V1MetricsReport>}
     * @memberof V1GetTrainingMetricsResponse
     */
    metrics: Array<V1MetricsReport>;
}
/**
 * Sorts checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_STATE: Returns checkpoints sorted by state.
 * @export
 * @enum {string}
 */
export const V1GetTrialCheckpointsRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    UUID: 'SORT_BY_UUID',
    BATCHNUMBER: 'SORT_BY_BATCH_NUMBER',
    ENDTIME: 'SORT_BY_END_TIME',
    STATE: 'SORT_BY_STATE',
} as const
export type V1GetTrialCheckpointsRequestSortBy = ValueOf<typeof V1GetTrialCheckpointsRequestSortBy>
/**
 * Response to GetTrialCheckpointsRequest.
 * @export
 * @interface V1GetTrialCheckpointsResponse
 */
export interface V1GetTrialCheckpointsResponse {
    /**
     * The list of returned checkpoints.
     * @type {Array<V1Checkpoint>}
     * @memberof V1GetTrialCheckpointsResponse
     */
    checkpoints: Array<V1Checkpoint>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetTrialCheckpointsResponse
     */
    pagination: V1Pagination;
}
/**
 * 
 * @export
 * @interface V1GetTrialMetricsByCheckpointResponse
 */
export interface V1GetTrialMetricsByCheckpointResponse {
    /**
     * All the related trials and their metrics
     * @type {Array<V1MetricsReport>}
     * @memberof V1GetTrialMetricsByCheckpointResponse
     */
    metrics: Array<V1MetricsReport>;
}
/**
 * 
 * @export
 * @interface V1GetTrialMetricsByModelVersionResponse
 */
export interface V1GetTrialMetricsByModelVersionResponse {
    /**
     * All the related trials and their metrics
     * @type {Array<V1MetricsReport>}
     * @memberof V1GetTrialMetricsByModelVersionResponse
     */
    metrics: Array<V1MetricsReport>;
}
/**
 * Response to TrialProfilerAvailableSeriesRequest.
 * @export
 * @interface V1GetTrialProfilerAvailableSeriesResponse
 */
export interface V1GetTrialProfilerAvailableSeriesResponse {
    /**
     * The labels for the series.
     * @type {Array<V1TrialProfilerMetricLabels>}
     * @memberof V1GetTrialProfilerAvailableSeriesResponse
     */
    labels: Array<V1TrialProfilerMetricLabels>;
}
/**
 * 
 * @export
 * @interface V1GetTrialProfilerMetricsResponse
 */
export interface V1GetTrialProfilerMetricsResponse {
    /**
     * A batch matching the series requested.
     * @type {V1TrialProfilerMetricsBatch}
     * @memberof V1GetTrialProfilerMetricsResponse
     */
    batch: V1TrialProfilerMetricsBatch;
}
/**
 * Response to GetTrialRequest.
 * @export
 * @interface V1GetTrialResponse
 */
export interface V1GetTrialResponse {
    /**
     * The requested trial.
     * @type {Trialv1Trial}
     * @memberof V1GetTrialResponse
     */
    trial: Trialv1Trial;
}
/**
 * Response to GetTrialWorkloadsRequest.
 * @export
 * @interface V1GetTrialWorkloadsResponse
 */
export interface V1GetTrialWorkloadsResponse {
    /**
     * The list of returned workloads.
     * @type {Array<V1WorkloadContainer>}
     * @memberof V1GetTrialWorkloadsResponse
     */
    workloads: Array<V1WorkloadContainer>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetTrialWorkloadsResponse
     */
    pagination: V1Pagination;
}
/**
 * Response to GetUserByUsernameRequest.
 * @export
 * @interface V1GetUserByUsernameResponse
 */
export interface V1GetUserByUsernameResponse {
    /**
     * The requested user.
     * @type {V1User}
     * @memberof V1GetUserByUsernameResponse
     */
    user: V1User;
}
/**
 * Response to GetUserRequest.
 * @export
 * @interface V1GetUserResponse
 */
export interface V1GetUserResponse {
    /**
     * The requested user.
     * @type {V1User}
     * @memberof V1GetUserResponse
     */
    user: V1User;
}
/**
 * Response to GetUserSettingRequest.
 * @export
 * @interface V1GetUserSettingResponse
 */
export interface V1GetUserSettingResponse {
    /**
     * List of user settings.
     * @type {Array<V1UserWebSetting>}
     * @memberof V1GetUserSettingResponse
     */
    settings: Array<V1UserWebSetting>;
}
/**
 * Sort users by the given field.   - SORT_BY_UNSPECIFIED: Returns users in an unsorted list.  - SORT_BY_DISPLAY_NAME: Returns users sorted by display name.  - SORT_BY_USER_NAME: Returns users sorted by user name.  - SORT_BY_ADMIN: Returns users sorted by if they are admin.  - SORT_BY_ACTIVE: Returns users sorted by if they are active.  - SORT_BY_MODIFIED_TIME: Returns users sorted by modified time.  - SORT_BY_NAME: Returns users sorted by username unless display name exist.
 * @export
 * @enum {string}
 */
export const V1GetUsersRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    DISPLAYNAME: 'SORT_BY_DISPLAY_NAME',
    USERNAME: 'SORT_BY_USER_NAME',
    ADMIN: 'SORT_BY_ADMIN',
    ACTIVE: 'SORT_BY_ACTIVE',
    MODIFIEDTIME: 'SORT_BY_MODIFIED_TIME',
    NAME: 'SORT_BY_NAME',
} as const
export type V1GetUsersRequestSortBy = ValueOf<typeof V1GetUsersRequestSortBy>
/**
 * Response to GetUsersRequest.
 * @export
 * @interface V1GetUsersResponse
 */
export interface V1GetUsersResponse {
    /**
     * The list of requested users.
     * @type {Array<V1User>}
     * @memberof V1GetUsersResponse
     */
    users?: Array<V1User>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetUsersResponse
     */
    pagination?: V1Pagination;
}
/**
 * Response to GetTrainingMetricsRequest.
 * @export
 * @interface V1GetValidationMetricsResponse
 */
export interface V1GetValidationMetricsResponse {
    /**
     * Metric response.
     * @type {Array<V1MetricsReport>}
     * @memberof V1GetValidationMetricsResponse
     */
    metrics: Array<V1MetricsReport>;
}
/**
 * Response to GetWebhooksRequest.
 * @export
 * @interface V1GetWebhooksResponse
 */
export interface V1GetWebhooksResponse {
    /**
     * The list of returned webhooks.
     * @type {Array<V1Webhook>}
     * @memberof V1GetWebhooksResponse
     */
    webhooks: Array<V1Webhook>;
}
/**
 * Sort associated projects by the given field.   - SORT_BY_UNSPECIFIED: Returns projects in an unsorted list.  - SORT_BY_CREATION_TIME: Returns projects sorted by time that they were created.  - SORT_BY_LAST_EXPERIMENT_START_TIME: Returns projects sorted by most recent start of an experiment.  - SORT_BY_NAME: Returns projects sorted by name.  - SORT_BY_DESCRIPTION: Returns projects sorted by description.  - SORT_BY_ID: Returns projects sorted by ID.
 * @export
 * @enum {string}
 */
export const V1GetWorkspaceProjectsRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    CREATIONTIME: 'SORT_BY_CREATION_TIME',
    LASTEXPERIMENTSTARTTIME: 'SORT_BY_LAST_EXPERIMENT_START_TIME',
    NAME: 'SORT_BY_NAME',
    DESCRIPTION: 'SORT_BY_DESCRIPTION',
    ID: 'SORT_BY_ID',
} as const
export type V1GetWorkspaceProjectsRequestSortBy = ValueOf<typeof V1GetWorkspaceProjectsRequestSortBy>
/**
 * Response to GetWorkspaceProjectsRequest.
 * @export
 * @interface V1GetWorkspaceProjectsResponse
 */
export interface V1GetWorkspaceProjectsResponse {
    /**
     * The projects associated with the workspace.
     * @type {Array<V1Project>}
     * @memberof V1GetWorkspaceProjectsResponse
     */
    projects: Array<V1Project>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetWorkspaceProjectsResponse
     */
    pagination: V1Pagination;
}
/**
 * Response to GetWorkspaceRequest.
 * @export
 * @interface V1GetWorkspaceResponse
 */
export interface V1GetWorkspaceResponse {
    /**
     * The workspace requested.
     * @type {V1Workspace}
     * @memberof V1GetWorkspaceResponse
     */
    workspace: V1Workspace;
}
/**
 * Sort workspaces by the given field.   - SORT_BY_UNSPECIFIED: Returns workspaces in an unsorted list.  - SORT_BY_ID: Returns workspaces sorted by id.  - SORT_BY_NAME: Returns workspaces sorted by name.
 * @export
 * @enum {string}
 */
export const V1GetWorkspacesRequestSortBy = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    ID: 'SORT_BY_ID',
    NAME: 'SORT_BY_NAME',
} as const
export type V1GetWorkspacesRequestSortBy = ValueOf<typeof V1GetWorkspacesRequestSortBy>
/**
 * Response to GetWorkspacesRequest.
 * @export
 * @interface V1GetWorkspacesResponse
 */
export interface V1GetWorkspacesResponse {
    /**
     * The list of returned workspaces.
     * @type {Array<V1Workspace>}
     * @memberof V1GetWorkspacesResponse
     */
    workspaces: Array<V1Workspace>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetWorkspacesResponse
     */
    pagination: V1Pagination;
}
/**
 * 
 * @export
 * @interface V1Group
 */
export interface V1Group {
    /**
     * The id of the group being detailed
     * @type {number}
     * @memberof V1Group
     */
    groupId?: number;
    /**
     * The name of the group
     * @type {string}
     * @memberof V1Group
     */
    name?: string;
}
/**
 * GroupDetails contains detailed information about a specific Group including which users belong to the group.
 * @export
 * @interface V1GroupDetails
 */
export interface V1GroupDetails {
    /**
     * The id of the group being detailed
     * @type {number}
     * @memberof V1GroupDetails
     */
    groupId?: number;
    /**
     * The name of the group
     * @type {string}
     * @memberof V1GroupDetails
     */
    name?: string;
    /**
     * The members of the group
     * @type {Array<V1User>}
     * @memberof V1GroupDetails
     */
    users?: Array<V1User>;
}
/**
 * GroupRoleAssignment contains information about the groups belonging to a role.
 * @export
 * @interface V1GroupRoleAssignment
 */
export interface V1GroupRoleAssignment {
    /**
     * The group id of the role assignment
     * @type {number}
     * @memberof V1GroupRoleAssignment
     */
    groupId: number;
    /**
     * The role and scope of the assignment.
     * @type {V1RoleAssignment}
     * @memberof V1GroupRoleAssignment
     */
    roleAssignment: V1RoleAssignment;
}
/**
 * GroupSearchResult is the representation of groups as they're returned by the search endpoint.
 * @export
 * @interface V1GroupSearchResult
 */
export interface V1GroupSearchResult {
    /**
     * A group matching the search criteria
     * @type {V1Group}
     * @memberof V1GroupSearchResult
     */
    group: V1Group;
    /**
     * The number of users that are in this group
     * @type {number}
     * @memberof V1GroupSearchResult
     */
    numMembers: number;
}
/**
 * Kill the requested notebook if idle.
 * @export
 * @interface V1IdleNotebookRequest
 */
export interface V1IdleNotebookRequest {
    /**
     * The id of the notebook.
     * @type {string}
     * @memberof V1IdleNotebookRequest
     */
    notebookId?: string;
    /**
     * The value of idle timeout
     * @type {boolean}
     * @memberof V1IdleNotebookRequest
     */
    idle?: boolean;
}
/**
 * Response to IdleNotebookRequest.
 * @export
 * @interface V1IdleNotebookResponse
 */
export interface V1IdleNotebookResponse {
}
/**
 * InitialOperations is a searcher event signaling the creation of an experiment.
 * @export
 * @interface V1InitialOperations
 */
export interface V1InitialOperations {
    /**
     * Cannot have an empty message type.
     * @type {number}
     * @memberof V1InitialOperations
     */
    placeholder?: number;
}
/**
 * Int32 filters.
 * @export
 * @interface V1Int32FieldFilter
 */
export interface V1Int32FieldFilter {
    /**
     * Less than.
     * @type {number}
     * @memberof V1Int32FieldFilter
     */
    lt?: number;
    /**
     * Less than or equal.
     * @type {number}
     * @memberof V1Int32FieldFilter
     */
    lte?: number;
    /**
     * Greater than.
     * @type {number}
     * @memberof V1Int32FieldFilter
     */
    gt?: number;
    /**
     * Greater than or equal.
     * @type {number}
     * @memberof V1Int32FieldFilter
     */
    gte?: number;
    /**
     * In a set. `in` is a reserved word in python.
     * @type {Array<number>}
     * @memberof V1Int32FieldFilter
     */
    incl?: Array<number>;
    /**
     * Not in a set.
     * @type {Array<number>}
     * @memberof V1Int32FieldFilter
     */
    notIn?: Array<number>;
}
/**
 * Job represents a user submitted work that is not in a terminal state.
 * @export
 * @interface V1Job
 */
export interface V1Job {
    /**
     * Job summary.
     * @type {V1JobSummary}
     * @memberof V1Job
     */
    summary?: V1JobSummary;
    /**
     * Job type.
     * @type {Jobv1Type}
     * @memberof V1Job
     */
    type: Jobv1Type;
    /**
     * The time when the job was submitted by the user.
     * @type {Date}
     * @memberof V1Job
     */
    submissionTime: Date;
    /**
     * The username of the user who submitted the job.
     * @type {string}
     * @memberof V1Job
     */
    username: string;
    /**
     * The id of the user who submitted the job.
     * @type {number}
     * @memberof V1Job
     */
    userId?: number;
    /**
     * Associated resource pool.
     * @type {string}
     * @memberof V1Job
     */
    resourcePool: string;
    /**
     * Whether the job is preemptible.
     * @type {boolean}
     * @memberof V1Job
     */
    isPreemptible: boolean;
    /**
     * The job priority in priority scheduler.
     * @type {number}
     * @memberof V1Job
     */
    priority?: number;
    /**
     * The job weight in fairshare scheduler.
     * @type {number}
     * @memberof V1Job
     */
    weight?: number;
    /**
     * Entity ID.
     * @type {string}
     * @memberof V1Job
     */
    entityId: string;
    /**
     * Job type.
     * @type {string}
     * @memberof V1Job
     */
    jobId: string;
    /**
     * Number of requested slots.
     * @type {number}
     * @memberof V1Job
     */
    requestedSlots: number;
    /**
     * Number of allocated slots.
     * @type {number}
     * @memberof V1Job
     */
    allocatedSlots: number;
    /**
     * Job name.
     * @type {string}
     * @memberof V1Job
     */
    name: string;
    /**
     * Job's progress from 0 to 1.
     * @type {number}
     * @memberof V1Job
     */
    progress?: number;
    /**
     * Job's workspace id.
     * @type {number}
     * @memberof V1Job
     */
    workspaceId: number;
}
/**
 * Job summary.
 * @export
 * @interface V1JobSummary
 */
export interface V1JobSummary {
    /**
     * The scheduling state of the job.
     * @type {Jobv1State}
     * @memberof V1JobSummary
     */
    state: Jobv1State;
    /**
     * The number of jobs ahead of this one in the queue.
     * @type {number}
     * @memberof V1JobSummary
     */
    jobsAhead: number;
}
/**
 * 
 * @export
 * @interface V1K8PriorityClass
 */
export interface V1K8PriorityClass {
    /**
     * Priority class name.
     * @type {string}
     * @memberof V1K8PriorityClass
     */
    priorityClass?: string;
    /**
     * Priority class value.
     * @type {number}
     * @memberof V1K8PriorityClass
     */
    priorityValue?: number;
}
/**
 * Response to KillCommandRequest.
 * @export
 * @interface V1KillCommandResponse
 */
export interface V1KillCommandResponse {
    /**
     * The requested command.
     * @type {V1Command}
     * @memberof V1KillCommandResponse
     */
    command?: V1Command;
}
/**
 * Response to KillExperimentRequest.
 * @export
 * @interface V1KillExperimentResponse
 */
export interface V1KillExperimentResponse {
}
/**
 * Kill multiple experiments.
 * @export
 * @interface V1KillExperimentsRequest
 */
export interface V1KillExperimentsRequest {
    /**
     * Selecting experiments by id.
     * @type {Array<number>}
     * @memberof V1KillExperimentsRequest
     */
    experimentIds: Array<number>;
    /**
     * Targets all experiments matching filters.
     * @type {V1BulkExperimentFilters}
     * @memberof V1KillExperimentsRequest
     */
    filters?: V1BulkExperimentFilters;
}
/**
 * Response to KillExperimentsRequest.
 * @export
 * @interface V1KillExperimentsResponse
 */
export interface V1KillExperimentsResponse {
    /**
     * Details on success or error for each experiment.
     * @type {Array<V1ExperimentActionResult>}
     * @memberof V1KillExperimentsResponse
     */
    results: Array<V1ExperimentActionResult>;
}
/**
 * Response to KillNotebookRequest.
 * @export
 * @interface V1KillNotebookResponse
 */
export interface V1KillNotebookResponse {
    /**
     * The requested notebook.
     * @type {V1Notebook}
     * @memberof V1KillNotebookResponse
     */
    notebook?: V1Notebook;
}
/**
 * Response to KillShellRequest.
 * @export
 * @interface V1KillShellResponse
 */
export interface V1KillShellResponse {
    /**
     * The requested shell.
     * @type {V1Shell}
     * @memberof V1KillShellResponse
     */
    shell?: V1Shell;
}
/**
 * Response to KillTensorboardRequest.
 * @export
 * @interface V1KillTensorboardResponse
 */
export interface V1KillTensorboardResponse {
    /**
     * The requested tensorboard.
     * @type {V1Tensorboard}
     * @memberof V1KillTensorboardResponse
     */
    tensorboard?: V1Tensorboard;
}
/**
 * Response to KillTrialRequest.
 * @export
 * @interface V1KillTrialResponse
 */
export interface V1KillTrialResponse {
}
/**
 * Request to launch a command.
 * @export
 * @interface V1LaunchCommandRequest
 */
export interface V1LaunchCommandRequest {
    /**
     * Command config (JSON).
     * @type {any}
     * @memberof V1LaunchCommandRequest
     */
    config?: any;
    /**
     * Template name.
     * @type {string}
     * @memberof V1LaunchCommandRequest
     */
    templateName?: string;
    /**
     * The files to run with the command.
     * @type {Array<V1File>}
     * @memberof V1LaunchCommandRequest
     */
    files?: Array<V1File>;
    /**
     * Additional data.
     * @type {string}
     * @memberof V1LaunchCommandRequest
     */
    data?: string;
    /**
     * Workspace ID. Defaults to the 'Uncategorized' workspace if not specified.
     * @type {number}
     * @memberof V1LaunchCommandRequest
     */
    workspaceId?: number;
}
/**
 * Response to LaunchCommandRequest.
 * @export
 * @interface V1LaunchCommandResponse
 */
export interface V1LaunchCommandResponse {
    /**
     * The requested command.
     * @type {V1Command}
     * @memberof V1LaunchCommandResponse
     */
    command: V1Command;
    /**
     * The config;
     * @type {any}
     * @memberof V1LaunchCommandResponse
     */
    config: any;
    /**
     * If the requested slots exceeded the current max available.
     * @type {Array<V1LaunchWarning>}
     * @memberof V1LaunchCommandResponse
     */
    warnings?: Array<V1LaunchWarning>;
}
/**
 * Request to launch a notebook.
 * @export
 * @interface V1LaunchNotebookRequest
 */
export interface V1LaunchNotebookRequest {
    /**
     * Notebook config (JSON).
     * @type {any}
     * @memberof V1LaunchNotebookRequest
     */
    config?: any;
    /**
     * Template name.
     * @type {string}
     * @memberof V1LaunchNotebookRequest
     */
    templateName?: string;
    /**
     * The files to run with the command.
     * @type {Array<V1File>}
     * @memberof V1LaunchNotebookRequest
     */
    files?: Array<V1File>;
    /**
     * Preview a launching request without actually creating a Notebook.
     * @type {boolean}
     * @memberof V1LaunchNotebookRequest
     */
    preview?: boolean;
    /**
     * Workspace ID. Defaults to 'Uncategorized' workspace if not specified.
     * @type {number}
     * @memberof V1LaunchNotebookRequest
     */
    workspaceId?: number;
}
/**
 * Response to LaunchNotebookRequest.
 * @export
 * @interface V1LaunchNotebookResponse
 */
export interface V1LaunchNotebookResponse {
    /**
     * The requested notebook.
     * @type {V1Notebook}
     * @memberof V1LaunchNotebookResponse
     */
    notebook: V1Notebook;
    /**
     * The config;
     * @type {any}
     * @memberof V1LaunchNotebookResponse
     */
    config: any;
    /**
     * List of any related warnings.
     * @type {Array<V1LaunchWarning>}
     * @memberof V1LaunchNotebookResponse
     */
    warnings?: Array<V1LaunchWarning>;
}
/**
 * Request to launch a shell.
 * @export
 * @interface V1LaunchShellRequest
 */
export interface V1LaunchShellRequest {
    /**
     * Shell config (JSON).
     * @type {any}
     * @memberof V1LaunchShellRequest
     */
    config?: any;
    /**
     * Template name.
     * @type {string}
     * @memberof V1LaunchShellRequest
     */
    templateName?: string;
    /**
     * The files to run with the command.
     * @type {Array<V1File>}
     * @memberof V1LaunchShellRequest
     */
    files?: Array<V1File>;
    /**
     * Additional data.
     * @type {string}
     * @memberof V1LaunchShellRequest
     */
    data?: string;
    /**
     * Workspace ID. Defaults to 'Uncategorized' workspace if not specified.
     * @type {number}
     * @memberof V1LaunchShellRequest
     */
    workspaceId?: number;
}
/**
 * Response to LaunchShellRequest.
 * @export
 * @interface V1LaunchShellResponse
 */
export interface V1LaunchShellResponse {
    /**
     * The requested shell.
     * @type {V1Shell}
     * @memberof V1LaunchShellResponse
     */
    shell: V1Shell;
    /**
     * The config;
     * @type {any}
     * @memberof V1LaunchShellResponse
     */
    config: any;
    /**
     * List of any related warnings.
     * @type {Array<V1LaunchWarning>}
     * @memberof V1LaunchShellResponse
     */
    warnings?: Array<V1LaunchWarning>;
}
/**
 * Request to launch a tensorboard.
 * @export
 * @interface V1LaunchTensorboardRequest
 */
export interface V1LaunchTensorboardRequest {
    /**
     * List of source experiment ids.
     * @type {Array<number>}
     * @memberof V1LaunchTensorboardRequest
     */
    experimentIds?: Array<number>;
    /**
     * List of source trial ids.
     * @type {Array<number>}
     * @memberof V1LaunchTensorboardRequest
     */
    trialIds?: Array<number>;
    /**
     * Tensorboard config (JSON).
     * @type {any}
     * @memberof V1LaunchTensorboardRequest
     */
    config?: any;
    /**
     * Tensorboard template name.
     * @type {string}
     * @memberof V1LaunchTensorboardRequest
     */
    templateName?: string;
    /**
     * The files to run with the command.
     * @type {Array<V1File>}
     * @memberof V1LaunchTensorboardRequest
     */
    files?: Array<V1File>;
    /**
     * Workspace in which to launch tensorboard. Defaults to 'Uncategorized'.
     * @type {number}
     * @memberof V1LaunchTensorboardRequest
     */
    workspaceId?: number;
    /**
     * Targets all experiments matching filters.
     * @type {V1BulkExperimentFilters}
     * @memberof V1LaunchTensorboardRequest
     */
    filters?: V1BulkExperimentFilters;
}
/**
 * Response to LaunchTensorboardRequest.
 * @export
 * @interface V1LaunchTensorboardResponse
 */
export interface V1LaunchTensorboardResponse {
    /**
     * The requested tensorboard.
     * @type {V1Tensorboard}
     * @memberof V1LaunchTensorboardResponse
     */
    tensorboard: V1Tensorboard;
    /**
     * The config;
     * @type {any}
     * @memberof V1LaunchTensorboardResponse
     */
    config: any;
    /**
     * List of any related warnings.
     * @type {Array<V1LaunchWarning>}
     * @memberof V1LaunchTensorboardResponse
     */
    warnings?: Array<V1LaunchWarning>;
}
/**
 * Enum values for warnings when launching commands.   - LAUNCH_WARNING_UNSPECIFIED: Default value  - LAUNCH_WARNING_CURRENT_SLOTS_EXCEEDED: For a default webhook
 * @export
 * @enum {string}
 */
export const V1LaunchWarning = {
    UNSPECIFIED: 'LAUNCH_WARNING_UNSPECIFIED',
    CURRENTSLOTSEXCEEDED: 'LAUNCH_WARNING_CURRENT_SLOTS_EXCEEDED',
} as const
export type V1LaunchWarning = ValueOf<typeof V1LaunchWarning>
/**
 * LimitedJob is a Job with omitted fields.
 * @export
 * @interface V1LimitedJob
 */
export interface V1LimitedJob {
    /**
     * Job summary.
     * @type {V1JobSummary}
     * @memberof V1LimitedJob
     */
    summary?: V1JobSummary;
    /**
     * Job type.
     * @type {Jobv1Type}
     * @memberof V1LimitedJob
     */
    type: Jobv1Type;
    /**
     * Associated resource pool.
     * @type {string}
     * @memberof V1LimitedJob
     */
    resourcePool: string;
    /**
     * Whether the job is preemptible.
     * @type {boolean}
     * @memberof V1LimitedJob
     */
    isPreemptible: boolean;
    /**
     * The job priority in priority scheduler.
     * @type {number}
     * @memberof V1LimitedJob
     */
    priority?: number;
    /**
     * The job weight in fairshare scheduler.
     * @type {number}
     * @memberof V1LimitedJob
     */
    weight?: number;
    /**
     * Job type.
     * @type {string}
     * @memberof V1LimitedJob
     */
    jobId: string;
    /**
     * Number of requested slots.
     * @type {number}
     * @memberof V1LimitedJob
     */
    requestedSlots: number;
    /**
     * Number of allocated slots.
     * @type {number}
     * @memberof V1LimitedJob
     */
    allocatedSlots: number;
    /**
     * Job's progress from 0 to 1.
     * @type {number}
     * @memberof V1LimitedJob
     */
    progress?: number;
    /**
     * Job's workspace id.
     * @type {number}
     * @memberof V1LimitedJob
     */
    workspaceId: number;
}
/**
 * ListRolesRequest is the body of the request for the call to search for a role.
 * @export
 * @interface V1ListRolesRequest
 */
export interface V1ListRolesRequest {
    /**
     * the offset for pagination.
     * @type {number}
     * @memberof V1ListRolesRequest
     */
    offset?: number;
    /**
     * the limit for pagination.
     * @type {number}
     * @memberof V1ListRolesRequest
     */
    limit: number;
}
/**
 * ListRolesResponse is the body of the response for the call to search for a role.
 * @export
 * @interface V1ListRolesResponse
 */
export interface V1ListRolesResponse {
    /**
     * a set of roles and all assignments belonging to it.
     * @type {Array<V1Role>}
     * @memberof V1ListRolesResponse
     */
    roles: Array<V1Role>;
    /**
     * pagination information.
     * @type {V1Pagination}
     * @memberof V1ListRolesResponse
     */
    pagination: V1Pagination;
}
/**
 * Response to ListWorkspaceRPsRequest.
 * @export
 * @interface V1ListRPsBoundToWorkspaceResponse
 */
export interface V1ListRPsBoundToWorkspaceResponse {
    /**
     * List of resource pools bound to the workspace.
     * @type {Array<string>}
     * @memberof V1ListRPsBoundToWorkspaceResponse
     */
    resourcePools?: Array<string>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1ListRPsBoundToWorkspaceResponse
     */
    pagination?: V1Pagination;
}
/**
 * Response to ListWorkspacesBoundToRPRequest.
 * @export
 * @interface V1ListWorkspacesBoundToRPResponse
 */
export interface V1ListWorkspacesBoundToRPResponse {
    /**
     * List of workspace IDs.
     * @type {Array<number>}
     * @memberof V1ListWorkspacesBoundToRPResponse
     */
    workspaceIds?: Array<number>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1ListWorkspacesBoundToRPResponse
     */
    pagination?: V1Pagination;
}
/**
 * - LOCATION_TYPE_UNSPECIFIED: Location unknown  - LOCATION_TYPE_EXPERIMENT: Column is located on the experiment  - LOCATION_TYPE_HYPERPARAMETERS: Column is located in the hyperparameter config of the experiment  - LOCATION_TYPE_VALIDATIONS: Column is located on the experiment's validation metrics  - LOCATION_TYPE_TRAINING: Column is located on the experiment's training steps  - LOCATION_TYPE_CUSTOM_METRIC: Column is located on the experiment's custom metric
 * @export
 * @enum {string}
 */
export const V1LocationType = {
    UNSPECIFIED: 'LOCATION_TYPE_UNSPECIFIED',
    EXPERIMENT: 'LOCATION_TYPE_EXPERIMENT',
    HYPERPARAMETERS: 'LOCATION_TYPE_HYPERPARAMETERS',
    VALIDATIONS: 'LOCATION_TYPE_VALIDATIONS',
    TRAINING: 'LOCATION_TYPE_TRAINING',
    CUSTOMMETRIC: 'LOCATION_TYPE_CUSTOM_METRIC',
} as const
export type V1LocationType = ValueOf<typeof V1LocationType>
/**
 * 
 * @export
 * @interface V1LogConfig
 */
export interface V1LogConfig {
    /**
     * The log level for Master Config.
     * @type {string}
     * @memberof V1LogConfig
     */
    level?: string;
    /**
     * The color setting for log in Master Config.
     * @type {boolean}
     * @memberof V1LogConfig
     */
    color?: boolean;
}
/**
 * LogEntry is a log event.
 * @export
 * @interface V1LogEntry
 */
export interface V1LogEntry {
    /**
     * The id.
     * @type {number}
     * @memberof V1LogEntry
     */
    id: number;
    /**
     * The message.
     * @type {string}
     * @memberof V1LogEntry
     */
    message: string;
    /**
     * The timestamp.
     * @type {Date}
     * @memberof V1LogEntry
     */
    timestamp: Date;
    /**
     * The log level.
     * @type {V1LogLevel}
     * @memberof V1LogEntry
     */
    level: V1LogLevel;
}
/**
 * Login the user.
 * @export
 * @interface V1LoginRequest
 */
export interface V1LoginRequest {
    /**
     * The username of the user.
     * @type {string}
     * @memberof V1LoginRequest
     */
    username: string;
    /**
     * The password of the user.
     * @type {string}
     * @memberof V1LoginRequest
     */
    password: string;
    /**
     * Indicate whether the provided password is pre-salted & hashed or not.
     * @type {boolean}
     * @memberof V1LoginRequest
     */
    isHashed?: boolean;
}
/**
 * Response to LoginRequest.
 * @export
 * @interface V1LoginResponse
 */
export interface V1LoginResponse {
    /**
     * The token to be used when sending results.
     * @type {string}
     * @memberof V1LoginResponse
     */
    token: string;
    /**
     * The logged in user.
     * @type {V1User}
     * @memberof V1LoginResponse
     */
    user: V1User;
}
/**
 * LogLevel specifies the level for a log.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
 * @export
 * @enum {string}
 */
export const V1LogLevel = {
    UNSPECIFIED: 'LOG_LEVEL_UNSPECIFIED',
    TRACE: 'LOG_LEVEL_TRACE',
    DEBUG: 'LOG_LEVEL_DEBUG',
    INFO: 'LOG_LEVEL_INFO',
    WARNING: 'LOG_LEVEL_WARNING',
    ERROR: 'LOG_LEVEL_ERROR',
    CRITICAL: 'LOG_LEVEL_CRITICAL',
} as const
export type V1LogLevel = ValueOf<typeof V1LogLevel>
/**
 * Response to LogoutRequest.
 * @export
 * @interface V1LogoutResponse
 */
export interface V1LogoutResponse {
}
/**
 * Mark some reservation as a daemon.
 * @export
 * @interface V1MarkAllocationResourcesDaemonRequest
 */
export interface V1MarkAllocationResourcesDaemonRequest {
    /**
     * The id of the allocation.
     * @type {string}
     * @memberof V1MarkAllocationResourcesDaemonRequest
     */
    allocationId: string;
    /**
     * The id of the clump of resources to mark as daemon.
     * @type {string}
     * @memberof V1MarkAllocationResourcesDaemonRequest
     */
    resourcesId?: string;
}
/**
 * Response to MarkAllocationResourcesDaemonRequest.
 * @export
 * @interface V1MarkAllocationResourcesDaemonResponse
 */
export interface V1MarkAllocationResourcesDaemonResponse {
}
/**
 * Response to MasterLogsRequest.
 * @export
 * @interface V1MasterLogsResponse
 */
export interface V1MasterLogsResponse {
    /**
     * The log entry.
     * @type {V1LogEntry}
     * @memberof V1MasterLogsResponse
     */
    logEntry: V1LogEntry;
}
/**
 * Response to MetricBatchesRequest.
 * @export
 * @interface V1MetricBatchesResponse
 */
export interface V1MetricBatchesResponse {
    /**
     * Milestones (in batches processed) at which the specified metric is recorded.
     * @type {Array<number>}
     * @memberof V1MetricBatchesResponse
     */
    batches?: Array<number>;
}
/**
 * MetricIdentifier packages metric name and group.
 * @export
 * @interface V1MetricIdentifier
 */
export interface V1MetricIdentifier {
    /**
     * The group of the metric.
     * @type {string}
     * @memberof V1MetricIdentifier
     */
    group: string;
    /**
     * The name of the metric.
     * @type {string}
     * @memberof V1MetricIdentifier
     */
    name: string;
}
/**
 * 
 * @export
 * @interface V1Metrics
 */
export interface V1Metrics {
    /**
     * Aggregate user-generated metrics
     * @type {any}
     * @memberof V1Metrics
     */
    avgMetrics: any;
    /**
     * User-generated metrics for each batch
     * @type {Array<any>}
     * @memberof V1Metrics
     */
    batchMetrics?: Array<any>;
}
/**
 * MetricsRange represents the range of a metrics. Range is a in the format of [min, max].
 * @export
 * @interface V1MetricsRange
 */
export interface V1MetricsRange {
    /**
     * The name of metrics formatted as <type>.<name>.
     * @type {string}
     * @memberof V1MetricsRange
     */
    metricsName: string;
    /**
     * The min of metrics values.
     * @type {number}
     * @memberof V1MetricsRange
     */
    min: number;
    /**
     * The max of metrics values.
     * @type {number}
     * @memberof V1MetricsRange
     */
    max: number;
}
/**
 * Metrics report.
 * @export
 * @interface V1MetricsReport
 */
export interface V1MetricsReport {
    /**
     * ID of the trial.
     * @type {number}
     * @memberof V1MetricsReport
     */
    trialId: number;
    /**
     * End time of when metric was reported.
     * @type {Date}
     * @memberof V1MetricsReport
     */
    endTime: Date;
    /**
     * Struct of the reported metrics.
     * @type {any}
     * @memberof V1MetricsReport
     */
    metrics: any;
    /**
     * batches completed in the report.
     * @type {number}
     * @memberof V1MetricsReport
     */
    totalBatches: number;
    /**
     * If metric is archived.
     * @type {boolean}
     * @memberof V1MetricsReport
     */
    archived: boolean;
    /**
     * ID of metric in table.
     * @type {number}
     * @memberof V1MetricsReport
     */
    id: number;
    /**
     * Run ID of trial when metric was reported.
     * @type {number}
     * @memberof V1MetricsReport
     */
    trialRunId: number;
    /**
     * Name of the Metric Group ("training", "validation", anything else)
     * @type {string}
     * @memberof V1MetricsReport
     */
    group: string;
}
/**
 * MetricsWorkload is a workload generating metrics.
 * @export
 * @interface V1MetricsWorkload
 */
export interface V1MetricsWorkload {
    /**
     * The time the workload finished or was stopped.
     * @type {Date}
     * @memberof V1MetricsWorkload
     */
    endTime?: Date;
    /**
     * Metrics.
     * @type {V1Metrics}
     * @memberof V1MetricsWorkload
     */
    metrics: V1Metrics;
    /**
     * Number of inputs processed.
     * @type {number}
     * @memberof V1MetricsWorkload
     */
    numInputs: number;
    /**
     * Total number of batches as of this workload's completion.
     * @type {number}
     * @memberof V1MetricsWorkload
     */
    totalBatches: number;
}
/**
 * To distinguish the different categories of metrics.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
 * @export
 * @enum {string}
 */
export const V1MetricType = {
    UNSPECIFIED: 'METRIC_TYPE_UNSPECIFIED',
    TRAINING: 'METRIC_TYPE_TRAINING',
    VALIDATION: 'METRIC_TYPE_VALIDATION',
} as const
export type V1MetricType = ValueOf<typeof V1MetricType>
/**
 * Model is a named collection of model versions.
 * @export
 * @interface V1Model
 */
export interface V1Model {
    /**
     * The name of the model.
     * @type {string}
     * @memberof V1Model
     */
    name: string;
    /**
     * The description of the model.
     * @type {string}
     * @memberof V1Model
     */
    description?: string;
    /**
     * The user-defined metadata of the model.
     * @type {any}
     * @memberof V1Model
     */
    metadata: any;
    /**
     * The time the model was created.
     * @type {Date}
     * @memberof V1Model
     */
    creationTime: Date;
    /**
     * The time the model was last updated.
     * @type {Date}
     * @memberof V1Model
     */
    lastUpdatedTime: Date;
    /**
     * The id of this model.
     * @type {number}
     * @memberof V1Model
     */
    id: number;
    /**
     * The number of versions associated with this model.
     * @type {number}
     * @memberof V1Model
     */
    numVersions: number;
    /**
     * Labels associated with this model.
     * @type {Array<string>}
     * @memberof V1Model
     */
    labels?: Array<string>;
    /**
     * Username of the user who created this model.
     * @type {string}
     * @memberof V1Model
     */
    username: string;
    /**
     * The id of the workspace associated with this model.
     * @type {number}
     * @memberof V1Model
     */
    workspaceId: number;
    /**
     * Id of the user who created this model.
     * @type {number}
     * @memberof V1Model
     */
    userId: number;
    /**
     * Whether this model is archived or not.
     * @type {boolean}
     * @memberof V1Model
     */
    archived: boolean;
    /**
     * Notes associated with this model.
     * @type {string}
     * @memberof V1Model
     */
    notes?: string;
}
/**
 * A version of a model containing a checkpoint. Users can label checkpoints as a version of a model and use the model name and version to locate a checkpoint.
 * @export
 * @interface V1ModelVersion
 */
export interface V1ModelVersion {
    /**
     * The model the version is related to.
     * @type {V1Model}
     * @memberof V1ModelVersion
     */
    model: V1Model;
    /**
     * The checkpoint of the model version.
     * @type {V1Checkpoint}
     * @memberof V1ModelVersion
     */
    checkpoint: V1Checkpoint;
    /**
     * The version number.
     * @type {number}
     * @memberof V1ModelVersion
     */
    version: number;
    /**
     * The time the model version was created.
     * @type {Date}
     * @memberof V1ModelVersion
     */
    creationTime: Date;
    /**
     * Unique id for each model version.
     * @type {number}
     * @memberof V1ModelVersion
     */
    id: number;
    /**
     * Name for this model version.
     * @type {string}
     * @memberof V1ModelVersion
     */
    name?: string;
    /**
     * Metadata associated with this model version.
     * @type {any}
     * @memberof V1ModelVersion
     */
    metadata?: any;
    /**
     * The time this model version was last updated.
     * @type {Date}
     * @memberof V1ModelVersion
     */
    lastUpdatedTime: Date;
    /**
     * Comment associated with this model version.
     * @type {string}
     * @memberof V1ModelVersion
     */
    comment?: string;
    /**
     * Username of the user who created this model version.
     * @type {string}
     * @memberof V1ModelVersion
     */
    username?: string;
    /**
     * Id of the user who created this model version.
     * @type {number}
     * @memberof V1ModelVersion
     */
    userId?: number;
    /**
     * Labels associated with this model version.
     * @type {Array<string>}
     * @memberof V1ModelVersion
     */
    labels?: Array<string>;
    /**
     * Notes associated with this model version.
     * @type {string}
     * @memberof V1ModelVersion
     */
    notes?: string;
}
/**
 * Request to move an experiment into a project.
 * @export
 * @interface V1MoveExperimentRequest
 */
export interface V1MoveExperimentRequest {
    /**
     * The id of the experiment being moved.
     * @type {number}
     * @memberof V1MoveExperimentRequest
     */
    experimentId: number;
    /**
     * The id of the new parent project.
     * @type {number}
     * @memberof V1MoveExperimentRequest
     */
    destinationProjectId: number;
}
/**
 * Response to MoveExperimentRequest.
 * @export
 * @interface V1MoveExperimentResponse
 */
export interface V1MoveExperimentResponse {
}
/**
 * Request to move an experiment into a project.
 * @export
 * @interface V1MoveExperimentsRequest
 */
export interface V1MoveExperimentsRequest {
    /**
     * The ids of the experiments being moved.
     * @type {Array<number>}
     * @memberof V1MoveExperimentsRequest
     */
    experimentIds: Array<number>;
    /**
     * The id of the new parent project.
     * @type {number}
     * @memberof V1MoveExperimentsRequest
     */
    destinationProjectId: number;
    /**
     * Targets all experiments matching filters.
     * @type {V1BulkExperimentFilters}
     * @memberof V1MoveExperimentsRequest
     */
    filters?: V1BulkExperimentFilters;
}
/**
 * Response to MoveExperimentsRequest.
 * @export
 * @interface V1MoveExperimentsResponse
 */
export interface V1MoveExperimentsResponse {
    /**
     * Details on success or error for each experiment.
     * @type {Array<V1ExperimentActionResult>}
     * @memberof V1MoveExperimentsResponse
     */
    results: Array<V1ExperimentActionResult>;
}
/**
 * Request to move a model to a workspace.
 * @export
 * @interface V1MoveModelRequest
 */
export interface V1MoveModelRequest {
    /**
     * The target model name.
     * @type {string}
     * @memberof V1MoveModelRequest
     */
    modelName: string;
    /**
     * The workspace id that the model will be stored.
     * @type {number}
     * @memberof V1MoveModelRequest
     */
    destinationWorkspaceId: number;
}
/**
 * 
 * @export
 * @interface V1MoveModelResponse
 */
export interface V1MoveModelResponse {
}
/**
 * Request to move a project into a workspace.
 * @export
 * @interface V1MoveProjectRequest
 */
export interface V1MoveProjectRequest {
    /**
     * The id of the project being moved.
     * @type {number}
     * @memberof V1MoveProjectRequest
     */
    projectId: number;
    /**
     * The id of the new parent workspace.
     * @type {number}
     * @memberof V1MoveProjectRequest
     */
    destinationWorkspaceId: number;
}
/**
 * Response to MoveProjectRequest.
 * @export
 * @interface V1MoveProjectResponse
 */
export interface V1MoveProjectResponse {
}
/**
 * Note is a user comment connected to a project.
 * @export
 * @interface V1Note
 */
export interface V1Note {
    /**
     * The name or title of the note.
     * @type {string}
     * @memberof V1Note
     */
    name: string;
    /**
     * The text contents of the note.
     * @type {string}
     * @memberof V1Note
     */
    contents: string;
}
/**
 * Notebook is a Jupyter notebook in a containerized environment.
 * @export
 * @interface V1Notebook
 */
export interface V1Notebook {
    /**
     * The id of the notebook.
     * @type {string}
     * @memberof V1Notebook
     */
    id: string;
    /**
     * The description of the notebook.
     * @type {string}
     * @memberof V1Notebook
     */
    description: string;
    /**
     * The state of the notebook.
     * @type {Taskv1State}
     * @memberof V1Notebook
     */
    state: Taskv1State;
    /**
     * The time the notebook was started.
     * @type {Date}
     * @memberof V1Notebook
     */
    startTime: Date;
    /**
     * The container running the notebook.
     * @type {V1Container}
     * @memberof V1Notebook
     */
    container?: V1Container;
    /**
     * The display name of the user that created the notebook.
     * @type {string}
     * @memberof V1Notebook
     */
    displayName?: string;
    /**
     * The id of the user that created the notebook.
     * @type {number}
     * @memberof V1Notebook
     */
    userId?: number;
    /**
     * The username of the user that created the notebook.
     * @type {string}
     * @memberof V1Notebook
     */
    username: string;
    /**
     * The service address.
     * @type {string}
     * @memberof V1Notebook
     */
    serviceAddress?: string;
    /**
     * The name of the resource pool the Notebook was created in.
     * @type {string}
     * @memberof V1Notebook
     */
    resourcePool: string;
    /**
     * The exit status.
     * @type {string}
     * @memberof V1Notebook
     */
    exitStatus?: string;
    /**
     * The associated job id.
     * @type {string}
     * @memberof V1Notebook
     */
    jobId: string;
    /**
     * Workspace ID.
     * @type {number}
     * @memberof V1Notebook
     */
    workspaceId: number;
}
/**
 * Arguments to a notify container running.
 * @export
 * @interface V1NotifyContainerRunningRequest
 */
export interface V1NotifyContainerRunningRequest {
    /**
     * The ID of the allocation.
     * @type {string}
     * @memberof V1NotifyContainerRunningRequest
     */
    allocationId: string;
    /**
     * The UUID of the participant in a notify container running message.
     * @type {string}
     * @memberof V1NotifyContainerRunningRequest
     */
    requestUuid?: string;
    /**
     * The number of process to wait for.
     * @type {number}
     * @memberof V1NotifyContainerRunningRequest
     */
    numPeers?: number;
    /**
     * The container's rank.
     * @type {number}
     * @memberof V1NotifyContainerRunningRequest
     */
    rank?: number;
    /**
     * The name of the node who sent the request
     * @type {string}
     * @memberof V1NotifyContainerRunningRequest
     */
    nodeName?: string;
    /**
     * The data from this process.
     * @type {any}
     * @memberof V1NotifyContainerRunningRequest
     */
    data: any;
}
/**
 * 
 * @export
 * @interface V1NotifyContainerRunningResponse
 */
export interface V1NotifyContainerRunningResponse {
    /**
     * The data for all the processes.
     * @type {Array<any>}
     * @memberof V1NotifyContainerRunningResponse
     */
    data: Array<any>;
}
/**
 * Order records in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
 * @export
 * @enum {string}
 */
export const V1OrderBy = {
    UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
    ASC: 'ORDER_BY_ASC',
    DESC: 'ORDER_BY_DESC',
} as const
export type V1OrderBy = ValueOf<typeof V1OrderBy>
/**
 * Overwrite and replace the workspaces bound to an RP request.
 * @export
 * @interface V1OverwriteRPWorkspaceBindingsRequest
 */
export interface V1OverwriteRPWorkspaceBindingsRequest {
    /**
     * The resource pool name.
     * @type {string}
     * @memberof V1OverwriteRPWorkspaceBindingsRequest
     */
    resourcePoolName: string;
    /**
     * The new workspace IDs to bind to the resource_pool.
     * @type {Array<number>}
     * @memberof V1OverwriteRPWorkspaceBindingsRequest
     */
    workspaceIds?: Array<number>;
    /**
     * The new workspace names to bind to the resource_pool.
     * @type {Array<string>}
     * @memberof V1OverwriteRPWorkspaceBindingsRequest
     */
    workspaceNames?: Array<string>;
}
/**
 * Overwrite and replace the workspaces bound to an RP response.
 * @export
 * @interface V1OverwriteRPWorkspaceBindingsResponse
 */
export interface V1OverwriteRPWorkspaceBindingsResponse {
}
/**
 * Pagination provides information about the offset, limit, and total number of records returned in the results.
 * @export
 * @interface V1Pagination
 */
export interface V1Pagination {
    /**
     * The number of records skipped before returning results.
     * @type {number}
     * @memberof V1Pagination
     */
    offset?: number;
    /**
     * The amount of records limited in the results.
     * @type {number}
     * @memberof V1Pagination
     */
    limit?: number;
    /**
     * The index of the first record in the dataset.
     * @type {number}
     * @memberof V1Pagination
     */
    startIndex?: number;
    /**
     * The index+1 of the last record in the dataset.
     * @type {number}
     * @memberof V1Pagination
     */
    endIndex?: number;
    /**
     * The total number of values that match the filter.
     * @type {number}
     * @memberof V1Pagination
     */
    total?: number;
}
/**
 * Request to change checkpoint database information.
 * @export
 * @interface V1PatchCheckpoint
 */
export interface V1PatchCheckpoint {
    /**
     * The uuid of the checkpoint.
     * @type {string}
     * @memberof V1PatchCheckpoint
     */
    uuid: string;
    /**
     * Dictionary of file paths to file sizes in bytes of all files in the checkpoint. This won't update actual checkpoint files. If len(resources) == 0 => the checkpoint is considered deleted Otherwise if resources are updated the checkpoint is considered partially deleted.
     * @type {PatchCheckpointOptionalResources}
     * @memberof V1PatchCheckpoint
     */
    resources?: PatchCheckpointOptionalResources;
}
/**
 * Request to patch database info about a checkpoint.
 * @export
 * @interface V1PatchCheckpointsRequest
 */
export interface V1PatchCheckpointsRequest {
    /**
     * List of checkpoints to patch.
     * @type {Array<V1PatchCheckpoint>}
     * @memberof V1PatchCheckpointsRequest
     */
    checkpoints: Array<V1PatchCheckpoint>;
}
/**
 * Intentionally don't send the updated response for performance reasons.
 * @export
 * @interface V1PatchCheckpointsResponse
 */
export interface V1PatchCheckpointsResponse {
}
/**
 * PatchExperiment is a partial update to an experiment with only id required.
 * @export
 * @interface V1PatchExperiment
 */
export interface V1PatchExperiment {
    /**
     * The id of the experiment.
     * @type {number}
     * @memberof V1PatchExperiment
     */
    id: number;
    /**
     * The description of the experiment.
     * @type {string}
     * @memberof V1PatchExperiment
     */
    description?: string;
    /**
     * Labels attached to the experiment.
     * @type {Array<string>}
     * @memberof V1PatchExperiment
     */
    labels?: Array<string>;
    /**
     * The experiment name.
     * @type {string}
     * @memberof V1PatchExperiment
     */
    name?: string;
    /**
     * The experiment notes.
     * @type {string}
     * @memberof V1PatchExperiment
     */
    notes?: string;
    /**
     * Experiment config resources.
     * @type {PatchExperimentPatchResources}
     * @memberof V1PatchExperiment
     */
    resources?: PatchExperimentPatchResources;
    /**
     * Experiment config checkpoint_storage.
     * @type {PatchExperimentPatchCheckpointStorage}
     * @memberof V1PatchExperiment
     */
    checkpointStorage?: PatchExperimentPatchCheckpointStorage;
}
/**
 * Response to PatchExperimentRequest.
 * @export
 * @interface V1PatchExperimentResponse
 */
export interface V1PatchExperimentResponse {
    /**
     * Patched experiment.
     * @type {V1Experiment}
     * @memberof V1PatchExperimentResponse
     */
    experiment?: V1Experiment;
}
/**
 * Patch master config.
 * @export
 * @interface V1PatchMasterConfigRequest
 */
export interface V1PatchMasterConfigRequest {
    /**
     * The new config that the user wants to patch into the master config.
     * @type {V1Config}
     * @memberof V1PatchMasterConfigRequest
     */
    config?: V1Config;
    /**
     * The fields from the master config that the user wants to patch.
     * @type {ProtobufFieldMask}
     * @memberof V1PatchMasterConfigRequest
     */
    fieldMask?: ProtobufFieldMask;
}
/**
 * Response to PatchMasterConfigRequest.
 * @export
 * @interface V1PatchMasterConfigResponse
 */
export interface V1PatchMasterConfigResponse {
    /**
     * The config file loaded by the master.
     * @type {any}
     * @memberof V1PatchMasterConfigResponse
     */
    config: any;
}
/**
 * PatchModel is a partial update to a model with only name required.
 * @export
 * @interface V1PatchModel
 */
export interface V1PatchModel {
    /**
     * An updated name for the model.
     * @type {string}
     * @memberof V1PatchModel
     */
    name?: string;
    /**
     * An updated description for the model.
     * @type {string}
     * @memberof V1PatchModel
     */
    description?: string;
    /**
     * An updated metadata object for the model.
     * @type {any}
     * @memberof V1PatchModel
     */
    metadata?: any;
    /**
     * An updated label list for the model.
     * @type {Array<string>}
     * @memberof V1PatchModel
     */
    labels?: Array<string>;
    /**
     * Updated notes associated with this model.
     * @type {string}
     * @memberof V1PatchModel
     */
    notes?: string;
    /**
     * The name of the workspace associated with this model.
     * @type {string}
     * @memberof V1PatchModel
     */
    workspaceName?: string;
    /**
     * The id of the workspace associated with this model.
     * @type {number}
     * @memberof V1PatchModel
     */
    workspaceId?: number;
}
/**
 * Response to PatchModelRequest.
 * @export
 * @interface V1PatchModelResponse
 */
export interface V1PatchModelResponse {
    /**
     * The model created.
     * @type {V1Model}
     * @memberof V1PatchModelResponse
     */
    model: V1Model;
}
/**
 * 
 * @export
 * @interface V1PatchModelVersion
 */
export interface V1PatchModelVersion {
    /**
     * An updated checkpoint to associate with the model version.
     * @type {V1Checkpoint}
     * @memberof V1PatchModelVersion
     */
    checkpoint?: V1Checkpoint;
    /**
     * An updated name for the model version.
     * @type {string}
     * @memberof V1PatchModelVersion
     */
    name?: string;
    /**
     * An updated metadata object for the model version.
     * @type {any}
     * @memberof V1PatchModelVersion
     */
    metadata?: any;
    /**
     * An updated comment for the model version.
     * @type {string}
     * @memberof V1PatchModelVersion
     */
    comment?: string;
    /**
     * An updated label list for the model version.
     * @type {Array<string>}
     * @memberof V1PatchModelVersion
     */
    labels?: Array<string>;
    /**
     * Updated text notes for the model version.
     * @type {string}
     * @memberof V1PatchModelVersion
     */
    notes?: string;
}
/**
 * Response to PatchModelVersionRequest.
 * @export
 * @interface V1PatchModelVersionResponse
 */
export interface V1PatchModelVersionResponse {
    /**
     * The model version created.
     * @type {V1ModelVersion}
     * @memberof V1PatchModelVersionResponse
     */
    modelVersion: V1ModelVersion;
}
/**
 * PatchProject is a partial update to a project with all optional fields.
 * @export
 * @interface V1PatchProject
 */
export interface V1PatchProject {
    /**
     * The new name for the project.
     * @type {string}
     * @memberof V1PatchProject
     */
    name?: string;
    /**
     * The new description for the project.
     * @type {string}
     * @memberof V1PatchProject
     */
    description?: string;
}
/**
 * Response to PatchProjectRequest.
 * @export
 * @interface V1PatchProjectResponse
 */
export interface V1PatchProjectResponse {
    /**
     * The updated project.
     * @type {V1Project}
     * @memberof V1PatchProjectResponse
     */
    project: V1Project;
}
/**
 * Response to PatchTemplateConfigRequest.
 * @export
 * @interface V1PatchTemplateConfigResponse
 */
export interface V1PatchTemplateConfigResponse {
    /**
     * The updated template.
     * @type {V1Template}
     * @memberof V1PatchTemplateConfigResponse
     */
    template: V1Template;
}
/**
 * Patch a trial.
 * @export
 * @interface V1PatchTrialRequest
 */
export interface V1PatchTrialRequest {
    /**
     * Trial id.
     * @type {number}
     * @memberof V1PatchTrialRequest
     */
    trialId: number;
    /**
     * The state of the trial.
     * @type {Trialv1State}
     * @memberof V1PatchTrialRequest
     */
    state?: Trialv1State;
}
/**
 * Response to PatchTrialRequest.
 * @export
 * @interface V1PatchTrialResponse
 */
export interface V1PatchTrialResponse {
    /**
     * The requested trial.
     * @type {Trialv1Trial}
     * @memberof V1PatchTrialResponse
     */
    trial: Trialv1Trial;
}
/**
 * Request to edit fields for a user.
 * @export
 * @interface V1PatchUser
 */
export interface V1PatchUser {
    /**
     * String denoting the username of the user.
     * @type {string}
     * @memberof V1PatchUser
     */
    username?: string;
    /**
     * String denoting the password of the user.
     * @type {string}
     * @memberof V1PatchUser
     */
    password?: string;
    /**
     * Bool denoting whether the account is an admin account.
     * @type {boolean}
     * @memberof V1PatchUser
     */
    admin?: boolean;
    /**
     * Bool denoting whether the account is active.
     * @type {boolean}
     * @memberof V1PatchUser
     */
    active?: boolean;
    /**
     * Name to display in the web UI.
     * @type {string}
     * @memberof V1PatchUser
     */
    displayName?: string;
    /**
     * The user and group on the agent host machine.
     * @type {V1AgentUserGroup}
     * @memberof V1PatchUser
     */
    agentUserGroup?: V1AgentUserGroup;
    /**
     * Indicate whether the provided password is pre-salted & hashed or not.
     * @type {boolean}
     * @memberof V1PatchUser
     */
    isHashed?: boolean;
    /**
     * Bool denoting whether the user should be able to login with or change a password.
     * @type {boolean}
     * @memberof V1PatchUser
     */
    remote?: boolean;
}
/**
 * Response to PatchUserRequest.
 * @export
 * @interface V1PatchUserResponse
 */
export interface V1PatchUserResponse {
    /**
     * The updated user.
     * @type {V1User}
     * @memberof V1PatchUserResponse
     */
    user: V1User;
}
/**
 * PatchWorkspace is a partial update to a workspace with all optional fields.
 * @export
 * @interface V1PatchWorkspace
 */
export interface V1PatchWorkspace {
    /**
     * The new name for the workspace.
     * @type {string}
     * @memberof V1PatchWorkspace
     */
    name?: string;
    /**
     * Optional agent host uid and gid override.
     * @type {V1AgentUserGroup}
     * @memberof V1PatchWorkspace
     */
    agentUserGroup?: V1AgentUserGroup;
    /**
     * Optional checkpoint storage config. Expects same format as experiment config's checkpoint storage.
     * @type {any}
     * @memberof V1PatchWorkspace
     */
    checkpointStorageConfig?: any;
    /**
     * Name of the default compute pool.
     * @type {string}
     * @memberof V1PatchWorkspace
     */
    defaultComputePool?: string;
    /**
     * Name of the default compute pool can be optional.
     * @type {string}
     * @memberof V1PatchWorkspace
     */
    defaultComputeResourcePool?: string;
    /**
     * Name of the default aux pool.
     * @type {string}
     * @memberof V1PatchWorkspace
     */
    defaultAuxPool?: string;
    /**
     * Name of the default aux pool can be optional.
     * @type {string}
     * @memberof V1PatchWorkspace
     */
    defaultAuxResourcePool?: string;
}
/**
 * Response to PatchWorkspaceRequest.
 * @export
 * @interface V1PatchWorkspaceResponse
 */
export interface V1PatchWorkspaceResponse {
    /**
     * The updated workspace.
     * @type {V1Workspace}
     * @memberof V1PatchWorkspaceResponse
     */
    workspace: V1Workspace;
}
/**
 * Response to PauseExperimentRequest.
 * @export
 * @interface V1PauseExperimentResponse
 */
export interface V1PauseExperimentResponse {
}
/**
 * Pause multiple experiments.
 * @export
 * @interface V1PauseExperimentsRequest
 */
export interface V1PauseExperimentsRequest {
    /**
     * Selecting experiments by id.
     * @type {Array<number>}
     * @memberof V1PauseExperimentsRequest
     */
    experimentIds: Array<number>;
    /**
     * Targets all experiments matching filters.
     * @type {V1BulkExperimentFilters}
     * @memberof V1PauseExperimentsRequest
     */
    filters?: V1BulkExperimentFilters;
}
/**
 * Response to PauseExperimentsRequest.
 * @export
 * @interface V1PauseExperimentsResponse
 */
export interface V1PauseExperimentsResponse {
    /**
     * Details on success or error for each experiment.
     * @type {Array<V1ExperimentActionResult>}
     * @memberof V1PauseExperimentsResponse
     */
    results: Array<V1ExperimentActionResult>;
}
/**
 * 
 * @export
 * @interface V1Permission
 */
export interface V1Permission {
    /**
     * The id of the permission
     * @type {V1PermissionType}
     * @memberof V1Permission
     */
    id: V1PermissionType;
    /**
     * The name of the permission
     * @type {string}
     * @memberof V1Permission
     */
    name?: string;
    /**
     * Allowed scope types.
     * @type {V1ScopeTypeMask}
     * @memberof V1Permission
     */
    scopeTypeMask?: V1ScopeTypeMask;
}
/**
 * List of permissions types. Value of the enum has 9xxxx for global only permissions. Permissions on the same object share the thousands place value like 2001 and 2002.   - PERMISSION_TYPE_UNSPECIFIED: The permission type is unknown.  - PERMISSION_TYPE_ADMINISTRATE_USER: Can create and update other users. Allows updating other users passwords making this permission give all other permissions effectively.  - PERMISSION_TYPE_ADMINISTRATE_OAUTH: Ability to manage OAuth clients and settings.  - PERMISSION_TYPE_CREATE_EXPERIMENT: Ability to create experiments.  - PERMISSION_TYPE_VIEW_EXPERIMENT_ARTIFACTS: Ability to view experiment's model code, checkpoints, trials.  - PERMISSION_TYPE_VIEW_EXPERIMENT_METADATA: Ability to view experiment's metadata such as experiment config, progress.  - PERMISSION_TYPE_UPDATE_EXPERIMENT: Ability to update experiment and experiment's lifecycle.  - PERMISSION_TYPE_UPDATE_EXPERIMENT_METADATA: Ability to update experiment's metadata.  - PERMISSION_TYPE_DELETE_EXPERIMENT: Ability to delete experiment.  - PERMISSION_TYPE_CREATE_NSC: Ability to create Notebooks, Shells, and Commands.  - PERMISSION_TYPE_VIEW_NSC: Ability to view Notebooks, Shells, and Commands.  - PERMISSION_TYPE_UPDATE_NSC: Ability to terminate Notebooks, Shells, and Commands.  - PERMISSION_TYPE_UPDATE_GROUP: Ability to create, update, and add / remove users from groups.  - PERMISSION_TYPE_CREATE_WORKSPACE: Ability to create workspaces.  - PERMISSION_TYPE_VIEW_WORKSPACE: Ability to view workspace.  - PERMISSION_TYPE_UPDATE_WORKSPACE: Ability to update workspace.  - PERMISSION_TYPE_DELETE_WORKSPACE: Ability to delete workspace.  - PERMISSION_TYPE_SET_WORKSPACE_AGENT_USER_GROUP: Ability to set workspace agent user group config.  - PERMISSION_TYPE_SET_WORKSPACE_CHECKPOINT_STORAGE_CONFIG: Ability to set workspace checkpoint storage config.  - PERMISSION_TYPE_SET_WORKSPACE_DEFAULT_RESOURCE_POOL: Ability to set workspace default resource pool.  - PERMISSION_TYPE_CREATE_PROJECT: Ability to create projects.  - PERMISSION_TYPE_VIEW_PROJECT: Ability to view projects.  - PERMISSION_TYPE_UPDATE_PROJECT: Ability to update projects.  - PERMISSION_TYPE_DELETE_PROJECT: Ability to delete projects.  - PERMISSION_TYPE_ASSIGN_ROLES: Ability to assign roles to groups / users. If assigned at a workspace scope, can only assign roles to that workspace scope.  - PERMISSION_TYPE_VIEW_MODEL_REGISTRY: Ability to view model registry.  - PERMISSION_TYPE_EDIT_MODEL_REGISTRY: Ability to edit model registry.  - PERMISSION_TYPE_CREATE_MODEL_REGISTRY: Ability to create model registry.  - PERMISSION_TYPE_DELETE_MODEL_REGISTRY: Ability to delete model registry.  - PERMISSION_TYPE_DELETE_MODEL_VERSION: Ability to delete model version.  - PERMISSION_TYPE_DELETE_OTHER_USER_MODEL_REGISTRY: Ability to delete another user's model registry.  - PERMISSION_TYPE_DELETE_OTHER_USER_MODEL_VERSION: Ability to delete another user's model version.  - PERMISSION_TYPE_VIEW_MASTER_LOGS: Ability to view master logs.  - PERMISSION_TYPE_VIEW_CLUSTER_USAGE: Ability to view detailed cluster usage info.  - PERMISSION_TYPE_UPDATE_AGENTS: Ability to update agents.  - PERMISSION_TYPE_VIEW_SENSITIVE_AGENT_INFO: Ability to view sensitive subset of agent info.  - PERMISSION_TYPE_VIEW_MASTER_CONFIG: Ability to view master configs.  - PERMISSION_TYPE_UPDATE_MASTER_CONFIG: Ability to update master configs.  - PERMISSION_TYPE_VIEW_EXTERNAL_JOBS: Ability to view external jobs.  - PERMISSION_TYPE_CONTROL_STRICT_JOB_QUEUE: Ability to control strict job queue.  - PERMISSION_TYPE_VIEW_TEMPLATES: Ability to view templates.  - PERMISSION_TYPE_UPDATE_TEMPLATES: Ability to update templates.  - PERMISSION_TYPE_CREATE_TEMPLATES: Ability to create templates.  - PERMISSION_TYPE_DELETE_TEMPLATES: Ability to delete templates.  - PERMISSION_TYPE_UPDATE_ROLES: Ability to create and update role definitions.  - PERMISSION_TYPE_EDIT_WEBHOOKS: Ability to create and delete webhooks.  - PERMISSION_TYPE_MODIFY_RP_WORKSPACE_BINDINGS: Ability to bind, unbind or overwrite resource pool workspace bindings.
 * @export
 * @enum {string}
 */
export const V1PermissionType = {
    UNSPECIFIED: 'PERMISSION_TYPE_UNSPECIFIED',
    ADMINISTRATEUSER: 'PERMISSION_TYPE_ADMINISTRATE_USER',
    ADMINISTRATEOAUTH: 'PERMISSION_TYPE_ADMINISTRATE_OAUTH',
    CREATEEXPERIMENT: 'PERMISSION_TYPE_CREATE_EXPERIMENT',
    VIEWEXPERIMENTARTIFACTS: 'PERMISSION_TYPE_VIEW_EXPERIMENT_ARTIFACTS',
    VIEWEXPERIMENTMETADATA: 'PERMISSION_TYPE_VIEW_EXPERIMENT_METADATA',
    UPDATEEXPERIMENT: 'PERMISSION_TYPE_UPDATE_EXPERIMENT',
    UPDATEEXPERIMENTMETADATA: 'PERMISSION_TYPE_UPDATE_EXPERIMENT_METADATA',
    DELETEEXPERIMENT: 'PERMISSION_TYPE_DELETE_EXPERIMENT',
    CREATENSC: 'PERMISSION_TYPE_CREATE_NSC',
    VIEWNSC: 'PERMISSION_TYPE_VIEW_NSC',
    UPDATENSC: 'PERMISSION_TYPE_UPDATE_NSC',
    UPDATEGROUP: 'PERMISSION_TYPE_UPDATE_GROUP',
    CREATEWORKSPACE: 'PERMISSION_TYPE_CREATE_WORKSPACE',
    VIEWWORKSPACE: 'PERMISSION_TYPE_VIEW_WORKSPACE',
    UPDATEWORKSPACE: 'PERMISSION_TYPE_UPDATE_WORKSPACE',
    DELETEWORKSPACE: 'PERMISSION_TYPE_DELETE_WORKSPACE',
    SETWORKSPACEAGENTUSERGROUP: 'PERMISSION_TYPE_SET_WORKSPACE_AGENT_USER_GROUP',
    SETWORKSPACECHECKPOINTSTORAGECONFIG: 'PERMISSION_TYPE_SET_WORKSPACE_CHECKPOINT_STORAGE_CONFIG',
    SETWORKSPACEDEFAULTRESOURCEPOOL: 'PERMISSION_TYPE_SET_WORKSPACE_DEFAULT_RESOURCE_POOL',
    CREATEPROJECT: 'PERMISSION_TYPE_CREATE_PROJECT',
    VIEWPROJECT: 'PERMISSION_TYPE_VIEW_PROJECT',
    UPDATEPROJECT: 'PERMISSION_TYPE_UPDATE_PROJECT',
    DELETEPROJECT: 'PERMISSION_TYPE_DELETE_PROJECT',
    ASSIGNROLES: 'PERMISSION_TYPE_ASSIGN_ROLES',
    VIEWMODELREGISTRY: 'PERMISSION_TYPE_VIEW_MODEL_REGISTRY',
    EDITMODELREGISTRY: 'PERMISSION_TYPE_EDIT_MODEL_REGISTRY',
    CREATEMODELREGISTRY: 'PERMISSION_TYPE_CREATE_MODEL_REGISTRY',
    DELETEMODELREGISTRY: 'PERMISSION_TYPE_DELETE_MODEL_REGISTRY',
    DELETEMODELVERSION: 'PERMISSION_TYPE_DELETE_MODEL_VERSION',
    DELETEOTHERUSERMODELREGISTRY: 'PERMISSION_TYPE_DELETE_OTHER_USER_MODEL_REGISTRY',
    DELETEOTHERUSERMODELVERSION: 'PERMISSION_TYPE_DELETE_OTHER_USER_MODEL_VERSION',
    VIEWMASTERLOGS: 'PERMISSION_TYPE_VIEW_MASTER_LOGS',
    VIEWCLUSTERUSAGE: 'PERMISSION_TYPE_VIEW_CLUSTER_USAGE',
    UPDATEAGENTS: 'PERMISSION_TYPE_UPDATE_AGENTS',
    VIEWSENSITIVEAGENTINFO: 'PERMISSION_TYPE_VIEW_SENSITIVE_AGENT_INFO',
    VIEWMASTERCONFIG: 'PERMISSION_TYPE_VIEW_MASTER_CONFIG',
    UPDATEMASTERCONFIG: 'PERMISSION_TYPE_UPDATE_MASTER_CONFIG',
    VIEWEXTERNALJOBS: 'PERMISSION_TYPE_VIEW_EXTERNAL_JOBS',
    CONTROLSTRICTJOBQUEUE: 'PERMISSION_TYPE_CONTROL_STRICT_JOB_QUEUE',
    VIEWTEMPLATES: 'PERMISSION_TYPE_VIEW_TEMPLATES',
    UPDATETEMPLATES: 'PERMISSION_TYPE_UPDATE_TEMPLATES',
    CREATETEMPLATES: 'PERMISSION_TYPE_CREATE_TEMPLATES',
    DELETETEMPLATES: 'PERMISSION_TYPE_DELETE_TEMPLATES',
    UPDATEROLES: 'PERMISSION_TYPE_UPDATE_ROLES',
    EDITWEBHOOKS: 'PERMISSION_TYPE_EDIT_WEBHOOKS',
    MODIFYRPWORKSPACEBINDINGS: 'PERMISSION_TYPE_MODIFY_RP_WORKSPACE_BINDINGS',
} as const
export type V1PermissionType = ValueOf<typeof V1PermissionType>
/**
 * Response to PinWorkspaceRequest.
 * @export
 * @interface V1PinWorkspaceResponse
 */
export interface V1PinWorkspaceResponse {
}
/**
 * 
 * @export
 * @interface V1PolymorphicFilter
 */
export interface V1PolymorphicFilter {
    /**
     * metric or column name for the filter
     * @type {string}
     * @memberof V1PolymorphicFilter
     */
    name?: string;
    /**
     * double value range for the query
     * @type {V1DoubleFieldFilter}
     * @memberof V1PolymorphicFilter
     */
    doubleRange?: V1DoubleFieldFilter;
    /**
     * integer value range for the query
     * @type {V1Int32FieldFilter}
     * @memberof V1PolymorphicFilter
     */
    integerRange?: V1Int32FieldFilter;
    /**
     * time value range for the query
     * @type {V1TimestampFieldFilter}
     * @memberof V1PolymorphicFilter
     */
    timeRange?: V1TimestampFieldFilter;
}
/**
 * Set the proxy address for some allocation.
 * @export
 * @interface V1PostAllocationProxyAddressRequest
 */
export interface V1PostAllocationProxyAddressRequest {
    /**
     * The id of the allocation.
     * @type {string}
     * @memberof V1PostAllocationProxyAddressRequest
     */
    allocationId?: string;
    /**
     * The address of the host where the service is, w.r.t. the master.
     * @type {string}
     * @memberof V1PostAllocationProxyAddressRequest
     */
    proxyAddress?: string;
}
/**
 * 
 * @export
 * @interface V1PostAllocationProxyAddressResponse
 */
export interface V1PostAllocationProxyAddressResponse {
}
/**
 * Request for updating a checkpoints metadata.
 * @export
 * @interface V1PostCheckpointMetadataRequest
 */
export interface V1PostCheckpointMetadataRequest {
    /**
     * The desired checkpoint fields and values.
     * @type {V1Checkpoint}
     * @memberof V1PostCheckpointMetadataRequest
     */
    checkpoint?: V1Checkpoint;
}
/**
 * Response to PostCheckpointRequest.
 * @export
 * @interface V1PostCheckpointMetadataResponse
 */
export interface V1PostCheckpointMetadataResponse {
    /**
     * The updated checkpoint.
     * @type {V1Checkpoint}
     * @memberof V1PostCheckpointMetadataResponse
     */
    checkpoint?: V1Checkpoint;
}
/**
 * Request for creating a model in the registry.
 * @export
 * @interface V1PostModelRequest
 */
export interface V1PostModelRequest {
    /**
     * The name of the model.
     * @type {string}
     * @memberof V1PostModelRequest
     */
    name: string;
    /**
     * The description of the model.
     * @type {string}
     * @memberof V1PostModelRequest
     */
    description?: string;
    /**
     * The user-defined metadata of the model.
     * @type {any}
     * @memberof V1PostModelRequest
     */
    metadata?: any;
    /**
     * Labels associated with this model.
     * @type {Array<string>}
     * @memberof V1PostModelRequest
     */
    labels?: Array<string>;
    /**
     * The name of the workspace associated with this model.
     * @type {string}
     * @memberof V1PostModelRequest
     */
    workspaceName?: string;
    /**
     * The id of the workspace associated with this model.
     * @type {number}
     * @memberof V1PostModelRequest
     */
    workspaceId?: number;
    /**
     * Notes associated with this model.
     * @type {string}
     * @memberof V1PostModelRequest
     */
    notes?: string;
}
/**
 * Response to PostModelRequest.
 * @export
 * @interface V1PostModelResponse
 */
export interface V1PostModelResponse {
    /**
     * The model created.
     * @type {V1Model}
     * @memberof V1PostModelResponse
     */
    model: V1Model;
}
/**
 * Request for creating a model version.
 * @export
 * @interface V1PostModelVersionRequest
 */
export interface V1PostModelVersionRequest {
    /**
     * The name of the model to add this version to.
     * @type {string}
     * @memberof V1PostModelVersionRequest
     */
    modelName: string;
    /**
     * UUID of the checkpoint.
     * @type {string}
     * @memberof V1PostModelVersionRequest
     */
    checkpointUuid: string;
    /**
     * User-friendly name for the model version.
     * @type {string}
     * @memberof V1PostModelVersionRequest
     */
    name?: string;
    /**
     * User-written comment for the model version.
     * @type {string}
     * @memberof V1PostModelVersionRequest
     */
    comment?: string;
    /**
     * The user-defined metadata of the model version.
     * @type {any}
     * @memberof V1PostModelVersionRequest
     */
    metadata?: any;
    /**
     * Labels associated with this model version.
     * @type {Array<string>}
     * @memberof V1PostModelVersionRequest
     */
    labels?: Array<string>;
    /**
     * Notes associated with this model version.
     * @type {string}
     * @memberof V1PostModelVersionRequest
     */
    notes?: string;
}
/**
 * Response for PostModelVersionRequest.
 * @export
 * @interface V1PostModelVersionResponse
 */
export interface V1PostModelVersionResponse {
    /**
     * The model version requested.
     * @type {V1ModelVersion}
     * @memberof V1PostModelVersionResponse
     */
    modelVersion: V1ModelVersion;
}
/**
 * Request for creating a project.
 * @export
 * @interface V1PostProjectRequest
 */
export interface V1PostProjectRequest {
    /**
     * The name of the project.
     * @type {string}
     * @memberof V1PostProjectRequest
     */
    name: string;
    /**
     * Description of the project.
     * @type {string}
     * @memberof V1PostProjectRequest
     */
    description?: string;
    /**
     * Id of the associated workspace.
     * @type {number}
     * @memberof V1PostProjectRequest
     */
    workspaceId: number;
}
/**
 * Response to PostProjectRequest.
 * @export
 * @interface V1PostProjectResponse
 */
export interface V1PostProjectResponse {
    /**
     * The project created.
     * @type {V1Project}
     * @memberof V1PostProjectResponse
     */
    project: V1Project;
}
/**
 * Request for sending operations from a custom search method.
 * @export
 * @interface V1PostSearcherOperationsRequest
 */
export interface V1PostSearcherOperationsRequest {
    /**
     * The experiment ID.
     * @type {number}
     * @memberof V1PostSearcherOperationsRequest
     */
    experimentId?: number;
    /**
     * List of operations to submit.
     * @type {Array<V1SearcherOperation>}
     * @memberof V1PostSearcherOperationsRequest
     */
    searcherOperations?: Array<V1SearcherOperation>;
    /**
     * The event that triggered the client to send these operations to the master.
     * @type {V1SearcherEvent}
     * @memberof V1PostSearcherOperationsRequest
     */
    triggeredByEvent?: V1SearcherEvent;
}
/**
 * Response to PostSearcherOperationsResponse.
 * @export
 * @interface V1PostSearcherOperationsResponse
 */
export interface V1PostSearcherOperationsResponse {
}
/**
 * Response to PostTemplateRequest.
 * @export
 * @interface V1PostTemplateResponse
 */
export interface V1PostTemplateResponse {
    /**
     * The created template.
     * @type {V1Template}
     * @memberof V1PostTemplateResponse
     */
    template: V1Template;
}
/**
 * Create a batch of trial profiler metrics.
 * @export
 * @interface V1PostTrialProfilerMetricsBatchRequest
 */
export interface V1PostTrialProfilerMetricsBatchRequest {
    /**
     * The batches to create.
     * @type {Array<V1TrialProfilerMetricsBatch>}
     * @memberof V1PostTrialProfilerMetricsBatchRequest
     */
    batches?: Array<V1TrialProfilerMetricsBatch>;
}
/**
 * 
 * @export
 * @interface V1PostTrialProfilerMetricsBatchResponse
 */
export interface V1PostTrialProfilerMetricsBatchResponse {
}
/**
 * 
 * @export
 * @interface V1PostTrialRunnerMetadataResponse
 */
export interface V1PostTrialRunnerMetadataResponse {
}
/**
 * Update user activity.
 * @export
 * @interface V1PostUserActivityRequest
 */
export interface V1PostUserActivityRequest {
    /**
     * The type of the activity.
     * @type {V1ActivityType}
     * @memberof V1PostUserActivityRequest
     */
    activityType: V1ActivityType;
    /**
     * The type of the entity.
     * @type {V1EntityType}
     * @memberof V1PostUserActivityRequest
     */
    entityType: V1EntityType;
    /**
     * The unique id for the entity
     * @type {number}
     * @memberof V1PostUserActivityRequest
     */
    entityId: number;
}
/**
 * Response to PostUserActivityRequest.
 * @export
 * @interface V1PostUserActivityResponse
 */
export interface V1PostUserActivityResponse {
}
/**
 * Create a new user.
 * @export
 * @interface V1PostUserRequest
 */
export interface V1PostUserRequest {
    /**
     * The user to create.
     * @type {V1User}
     * @memberof V1PostUserRequest
     */
    user?: V1User;
    /**
     * The password of the user.
     * @type {string}
     * @memberof V1PostUserRequest
     */
    password?: string;
    /**
     * Indicate whether the provided password is pre-salted & hashed or not.
     * @type {boolean}
     * @memberof V1PostUserRequest
     */
    isHashed?: boolean;
}
/**
 * Response to PostUserRequest.
 * @export
 * @interface V1PostUserResponse
 */
export interface V1PostUserResponse {
    /**
     * The created user.
     * @type {V1User}
     * @memberof V1PostUserResponse
     */
    user?: V1User;
}
/**
 * Update user settings.
 * @export
 * @interface V1PostUserSettingRequest
 */
export interface V1PostUserSettingRequest {
    /**
     * Setting key value pair.
     * @type {Array<V1UserWebSetting>}
     * @memberof V1PostUserSettingRequest
     */
    settings: Array<V1UserWebSetting>;
}
/**
 * Response to PostUserSettingRequest.
 * @export
 * @interface V1PostUserSettingResponse
 */
export interface V1PostUserSettingResponse {
}
/**
 * Response to PostWebhookRequest.
 * @export
 * @interface V1PostWebhookResponse
 */
export interface V1PostWebhookResponse {
    /**
     * The webhook created.
     * @type {V1Webhook}
     * @memberof V1PostWebhookResponse
     */
    webhook: V1Webhook;
}
/**
 * Request for creating a workspace.
 * @export
 * @interface V1PostWorkspaceRequest
 */
export interface V1PostWorkspaceRequest {
    /**
     * The name of the workspace.
     * @type {string}
     * @memberof V1PostWorkspaceRequest
     */
    name: string;
    /**
     * Optional agent host uid and gid override.
     * @type {V1AgentUserGroup}
     * @memberof V1PostWorkspaceRequest
     */
    agentUserGroup?: V1AgentUserGroup;
    /**
     * Optional checkpoint storage config.
     * @type {any}
     * @memberof V1PostWorkspaceRequest
     */
    checkpointStorageConfig?: any;
    /**
     * The name of the default compute pool.
     * @type {string}
     * @memberof V1PostWorkspaceRequest
     */
    defaultComputePool?: string;
    /**
     * The name of the default aux pool.
     * @type {string}
     * @memberof V1PostWorkspaceRequest
     */
    defaultAuxPool?: string;
}
/**
 * Response to PostWorkspaceRequest.
 * @export
 * @interface V1PostWorkspaceResponse
 */
export interface V1PostWorkspaceResponse {
    /**
     * The workspace created.
     * @type {V1Workspace}
     * @memberof V1PostWorkspaceResponse
     */
    workspace: V1Workspace;
}
/**
 * Preview hyperparameter search.
 * @export
 * @interface V1PreviewHPSearchRequest
 */
export interface V1PreviewHPSearchRequest {
    /**
     * The experiment config to simulate.
     * @type {any}
     * @memberof V1PreviewHPSearchRequest
     */
    config?: any;
    /**
     * The searcher simulation seed.
     * @type {number}
     * @memberof V1PreviewHPSearchRequest
     */
    seed?: number;
}
/**
 * Response to PreviewSearchRequest.
 * @export
 * @interface V1PreviewHPSearchResponse
 */
export interface V1PreviewHPSearchResponse {
    /**
     * The resulting simulation.
     * @type {V1ExperimentSimulation}
     * @memberof V1PreviewHPSearchResponse
     */
    simulation?: V1ExperimentSimulation;
}
/**
 * Project is a named collection of experiments.
 * @export
 * @interface V1Project
 */
export interface V1Project {
    /**
     * The unique id of the project.
     * @type {number}
     * @memberof V1Project
     */
    id: number;
    /**
     * The unique name of the project.
     * @type {string}
     * @memberof V1Project
     */
    name: string;
    /**
     * The id of the associated workspace.
     * @type {number}
     * @memberof V1Project
     */
    workspaceId: number;
    /**
     * The description of the project.
     * @type {string}
     * @memberof V1Project
     */
    description?: string;
    /**
     * Time of most recently started experiment within this project.
     * @type {Date}
     * @memberof V1Project
     */
    lastExperimentStartedAt?: Date;
    /**
     * Notes associated with this project.
     * @type {Array<V1Note>}
     * @memberof V1Project
     */
    notes: Array<V1Note>;
    /**
     * Count of experiments associated with this project.
     * @type {number}
     * @memberof V1Project
     */
    numExperiments: number;
    /**
     * Count of active experiments associated with this project.
     * @type {number}
     * @memberof V1Project
     */
    numActiveExperiments: number;
    /**
     * Whether this project is archived or not.
     * @type {boolean}
     * @memberof V1Project
     */
    archived: boolean;
    /**
     * User who created this project.
     * @type {string}
     * @memberof V1Project
     */
    username: string;
    /**
     * Whether this project is immutable (default uncategorized project).
     * @type {boolean}
     * @memberof V1Project
     */
    immutable: boolean;
    /**
     * ID of the user who created this project.
     * @type {number}
     * @memberof V1Project
     */
    userId: number;
    /**
     * The name of the associated workspace.
     * @type {string}
     * @memberof V1Project
     */
    workspaceName?: string;
    /**
     * State of project during deletion.
     * @type {V1WorkspaceState}
     * @memberof V1Project
     */
    state: V1WorkspaceState;
    /**
     * Message stored from errors on async-deleting a project.
     * @type {string}
     * @memberof V1Project
     */
    errorMessage: string;
}
/**
 * Project Column is a description of a column used on experiments in the project.
 * @export
 * @interface V1ProjectColumn
 */
export interface V1ProjectColumn {
    /**
     * Raw column name.
     * @type {string}
     * @memberof V1ProjectColumn
     */
    column: string;
    /**
     * Where the column comes from.
     * @type {V1LocationType}
     * @memberof V1ProjectColumn
     */
    location: V1LocationType;
    /**
     * Type of data in the column.
     * @type {V1ColumnType}
     * @memberof V1ProjectColumn
     */
    type: V1ColumnType;
    /**
     * Human-friendly name.
     * @type {string}
     * @memberof V1ProjectColumn
     */
    displayName?: string;
}
/**
 * ProxyPortConfig configures a proxy the allocation should start.
 * @export
 * @interface V1ProxyPortConfig
 */
export interface V1ProxyPortConfig {
    /**
     * The service ID of the proxy port config.
     * @type {string}
     * @memberof V1ProxyPortConfig
     */
    serviceId?: string;
    /**
     * The port of the proxy port config.
     * @type {number}
     * @memberof V1ProxyPortConfig
     */
    port?: number;
    /**
     * True if proxy uses TCP.
     * @type {boolean}
     * @memberof V1ProxyPortConfig
     */
    proxyTcp?: boolean;
    /**
     * True if the proxy is unauthenticated.
     * @type {boolean}
     * @memberof V1ProxyPortConfig
     */
    unauthenticated?: boolean;
}
/**
 * Response to PutExperimentRequest.
 * @export
 * @interface V1PutExperimentResponse
 */
export interface V1PutExperimentResponse {
    /**
     * The created experiment.
     * @type {V1Experiment}
     * @memberof V1PutExperimentResponse
     */
    experiment: V1Experiment;
    /**
     * The created experiment config.
     * @type {any}
     * @memberof V1PutExperimentResponse
     */
    config: any;
}
/**
 * Request for setting project notes.
 * @export
 * @interface V1PutProjectNotesRequest
 */
export interface V1PutProjectNotesRequest {
    /**
     * The complete list of notes.
     * @type {Array<V1Note>}
     * @memberof V1PutProjectNotesRequest
     */
    notes: Array<V1Note>;
    /**
     * The id of the project.
     * @type {number}
     * @memberof V1PutProjectNotesRequest
     */
    projectId: number;
}
/**
 * Response to PutProjectNotesRequest.
 * @export
 * @interface V1PutProjectNotesResponse
 */
export interface V1PutProjectNotesResponse {
    /**
     * The complete list of notes on a project.
     * @type {Array<V1Note>}
     * @memberof V1PutProjectNotesResponse
     */
    notes: Array<V1Note>;
}
/**
 * Response to PutTemplateRequest.
 * @export
 * @interface V1PutTemplateResponse
 */
export interface V1PutTemplateResponse {
    /**
     * The updated or created template.
     * @type {V1Template}
     * @memberof V1PutTemplateResponse
     */
    template?: V1Template;
}
/**
 * Put a trial.
 * @export
 * @interface V1PutTrialRequest
 */
export interface V1PutTrialRequest {
    /**
     * CreateTrialRequest payload.
     * @type {V1CreateTrialRequest}
     * @memberof V1PutTrialRequest
     */
    createTrialRequest?: V1CreateTrialRequest;
    /**
     * External trial id.
     * @type {string}
     * @memberof V1PutTrialRequest
     */
    externalTrialId?: string;
}
/**
 * Response to PutTrialRequest.
 * @export
 * @interface V1PutTrialResponse
 */
export interface V1PutTrialResponse {
    /**
     * The requested trial.
     * @type {Trialv1Trial}
     * @memberof V1PutTrialResponse
     */
    trial: Trialv1Trial;
}
/**
 * Describes a message to control jobs in a queue.
 * @export
 * @interface V1QueueControl
 */
export interface V1QueueControl {
    /**
     * Job id.
     * @type {string}
     * @memberof V1QueueControl
     */
    jobId: string;
    /**
     * The desired job position in the queue in terms of another job.
     * @type {string}
     * @memberof V1QueueControl
     */
    aheadOf?: string;
    /**
     * The desired job position in the queue in terms of another job.
     * @type {string}
     * @memberof V1QueueControl
     */
    behindOf?: string;
    /**
     * Name of the target resource_pool to move the job to.
     * @type {string}
     * @memberof V1QueueControl
     */
    resourcePool?: string;
    /**
     * The desired job priority in priority scheduler.
     * @type {number}
     * @memberof V1QueueControl
     */
    priority?: number;
    /**
     * The desired job weight in fairshare scheduler.
     * @type {number}
     * @memberof V1QueueControl
     */
    weight?: number;
}
/**
 * Statistics for a queue.
 * @export
 * @interface V1QueueStats
 */
export interface V1QueueStats {
    /**
     * Number of queued jobs in the queue.
     * @type {number}
     * @memberof V1QueueStats
     */
    queuedCount: number;
    /**
     * Number of scheduled jobs in the queue.
     * @type {number}
     * @memberof V1QueueStats
     */
    scheduledCount: number;
}
/**
 * RBACJob is a job that can have either a limited or a full representation of a job.
 * @export
 * @interface V1RBACJob
 */
export interface V1RBACJob {
    /**
     * Full representation.
     * @type {V1Job}
     * @memberof V1RBACJob
     */
    full?: V1Job;
    /**
     * Limited representation for lower access levels.
     * @type {V1LimitedJob}
     * @memberof V1RBACJob
     */
    limited?: V1LimitedJob;
}
/**
 * RemoveAssignmentsRequest is the body of the request for the call to remove a user or group from a role.
 * @export
 * @interface V1RemoveAssignmentsRequest
 */
export interface V1RemoveAssignmentsRequest {
    /**
     * the set of groups being removed from a role.
     * @type {Array<V1GroupRoleAssignment>}
     * @memberof V1RemoveAssignmentsRequest
     */
    groupRoleAssignments?: Array<V1GroupRoleAssignment>;
    /**
     * the set of users being removed from a role.
     * @type {Array<V1UserRoleAssignment>}
     * @memberof V1RemoveAssignmentsRequest
     */
    userRoleAssignments?: Array<V1UserRoleAssignment>;
}
/**
 * RemoveAssignmentsResponse is the body of the response for teh call to remove a user or group from a role.
 * @export
 * @interface V1RemoveAssignmentsResponse
 */
export interface V1RemoveAssignmentsResponse {
}
/**
 * The rendezvous info for the trial to rendezvous with sibling containers.
 * @export
 * @interface V1RendezvousInfo
 */
export interface V1RendezvousInfo {
    /**
     * The rendezvous addresses of the other containers.
     * @type {Array<string>}
     * @memberof V1RendezvousInfo
     */
    addresses: Array<string>;
    /**
     * The container rank.
     * @type {number}
     * @memberof V1RendezvousInfo
     */
    rank: number;
    /**
     * The slots for each address, respectively.
     * @type {Array<number>}
     * @memberof V1RendezvousInfo
     */
    slots: Array<number>;
}
/**
 * Response to ReportCheckpointRequest.
 * @export
 * @interface V1ReportCheckpointResponse
 */
export interface V1ReportCheckpointResponse {
}
/**
 * Persist the given metrics for the trial.
 * @export
 * @interface V1ReportTrialMetricsRequest
 */
export interface V1ReportTrialMetricsRequest {
    /**
     * The metrics to persist.
     * @type {V1TrialMetrics}
     * @memberof V1ReportTrialMetricsRequest
     */
    metrics: V1TrialMetrics;
    /**
     * The type of metrics to persist eg 'training', 'validation', etc.
     * @type {string}
     * @memberof V1ReportTrialMetricsRequest
     */
    group: string;
}
/**
 * 
 * @export
 * @interface V1ReportTrialMetricsResponse
 */
export interface V1ReportTrialMetricsResponse {
}
/**
 * 
 * @export
 * @interface V1ReportTrialProgressResponse
 */
export interface V1ReportTrialProgressResponse {
}
/**
 * 
 * @export
 * @interface V1ReportTrialSearcherEarlyExitResponse
 */
export interface V1ReportTrialSearcherEarlyExitResponse {
}
/**
 * 
 * @export
 * @interface V1ReportTrialSourceInfoRequest
 */
export interface V1ReportTrialSourceInfoRequest {
    /**
     * Type of the TrialSourceInfo
     * @type {V1TrialSourceInfo}
     * @memberof V1ReportTrialSourceInfoRequest
     */
    trialSourceInfo: V1TrialSourceInfo;
}
/**
 * 
 * @export
 * @interface V1ReportTrialSourceInfoResponse
 */
export interface V1ReportTrialSourceInfoResponse {
    /**
     * Trial ID of the created
     * @type {number}
     * @memberof V1ReportTrialSourceInfoResponse
     */
    trialId: number;
    /**
     * UUID of the checkpoint.
     * @type {string}
     * @memberof V1ReportTrialSourceInfoResponse
     */
    checkpointUuid: string;
}
/**
 * 
 * @export
 * @interface V1ReportTrialTrainingMetricsResponse
 */
export interface V1ReportTrialTrainingMetricsResponse {
}
/**
 * 
 * @export
 * @interface V1ReportTrialValidationMetricsResponse
 */
export interface V1ReportTrialValidationMetricsResponse {
}
/**
 * Response to ResetUserSettingRequest.
 * @export
 * @interface V1ResetUserSettingResponse
 */
export interface V1ResetUserSettingResponse {
}
/**
 * One instance of slots in the cluster being allocated to a task during a period (aggregated).
 * @export
 * @interface V1ResourceAllocationAggregatedEntry
 */
export interface V1ResourceAllocationAggregatedEntry {
    /**
     * The date of this entry.
     * @type {string}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    periodStart: string;
    /**
     * The period over which aggregation occurred.
     * @type {V1ResourceAllocationAggregationPeriod}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    period: V1ResourceAllocationAggregationPeriod;
    /**
     * The total number of seconds included in this allocation entry.
     * @type {number}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    seconds: number;
    /**
     * The seconds in the cluster used by experiments belonging to each user.
     * @type {{ [key: string]: number; }}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    byUsername: { [key: string]: number; };
    /**
     * The seconds in the cluster used by experiments labeled with each label.
     * @type {{ [key: string]: number; }}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    byExperimentLabel: { [key: string]: number; };
    /**
     * The seconds in the cluster used by experiments assigned to each resource pool.
     * @type {{ [key: string]: number; }}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    byResourcePool: { [key: string]: number; };
    /**
     * This field has been deprecated and will be empty.
     * @type {{ [key: string]: number; }}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    byAgentLabel: { [key: string]: number; };
}
/**
 * Response to ResourceAllocationAggregatedRequest.
 * @export
 * @interface V1ResourceAllocationAggregatedResponse
 */
export interface V1ResourceAllocationAggregatedResponse {
    /**
     * An entry summarizing one workload.
     * @type {Array<V1ResourceAllocationAggregatedEntry>}
     * @memberof V1ResourceAllocationAggregatedResponse
     */
    resourceEntries: Array<V1ResourceAllocationAggregatedEntry>;
}
/**
 * The period over which to perform aggregation.   - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
 * @export
 * @enum {string}
 */
export const V1ResourceAllocationAggregationPeriod = {
    UNSPECIFIED: 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED',
    DAILY: 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY',
    MONTHLY: 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY',
} as const
export type V1ResourceAllocationAggregationPeriod = ValueOf<typeof V1ResourceAllocationAggregationPeriod>
/**
 * One instance of slots in the cluster being allocated to a task.
 * @export
 * @interface V1ResourceAllocationRawEntry
 */
export interface V1ResourceAllocationRawEntry {
    /**
     * The kind of workload being run during this allocation (training, checkpoint, or validation).
     * @type {string}
     * @memberof V1ResourceAllocationRawEntry
     */
    kind?: string;
    /**
     * The time at which the allocation began.
     * @type {Date}
     * @memberof V1ResourceAllocationRawEntry
     */
    startTime?: Date;
    /**
     * The time at which the allocation ended.
     * @type {Date}
     * @memberof V1ResourceAllocationRawEntry
     */
    endTime?: Date;
    /**
     * The ID of the experiment the allocation is a part of.
     * @type {number}
     * @memberof V1ResourceAllocationRawEntry
     */
    experimentId?: number;
    /**
     * The username of the user who ran the experiment.
     * @type {string}
     * @memberof V1ResourceAllocationRawEntry
     */
    username?: string;
    /**
     * The username of the user who ran the experiment.
     * @type {number}
     * @memberof V1ResourceAllocationRawEntry
     */
    userId?: number;
    /**
     * The labels assigned to the experiment.
     * @type {Array<string>}
     * @memberof V1ResourceAllocationRawEntry
     */
    labels?: Array<string>;
    /**
     * The number of seconds for which the allocation was active during the requested period.
     * @type {number}
     * @memberof V1ResourceAllocationRawEntry
     */
    seconds?: number;
    /**
     * The number of slots used by the allocation.
     * @type {number}
     * @memberof V1ResourceAllocationRawEntry
     */
    slots?: number;
}
/**
 * Response to ResourceAllocationRawRequest.
 * @export
 * @interface V1ResourceAllocationRawResponse
 */
export interface V1ResourceAllocationRawResponse {
    /**
     * An entry summarizing one workload.
     * @type {Array<V1ResourceAllocationRawEntry>}
     * @memberof V1ResourceAllocationRawResponse
     */
    resourceEntries?: Array<V1ResourceAllocationRawEntry>;
}
/**
 * A Resource Pool is a pool of resources where containers are run.
 * @export
 * @interface V1ResourcePool
 */
export interface V1ResourcePool {
    /**
     * The unique name of the resource pool.
     * @type {string}
     * @memberof V1ResourcePool
     */
    name: string;
    /**
     * The description of the resource pool
     * @type {string}
     * @memberof V1ResourcePool
     */
    description: string;
    /**
     * The type of the resource pool (AWS/GCP/STATIC)
     * @type {V1ResourcePoolType}
     * @memberof V1ResourcePool
     */
    type: V1ResourcePoolType;
    /**
     * The number of agents running in the resource pool
     * @type {number}
     * @memberof V1ResourcePool
     */
    numAgents: number;
    /**
     * The total number of slots that exist in the resource pool
     * @type {number}
     * @memberof V1ResourcePool
     */
    slotsAvailable: number;
    /**
     * The number of slots that are actively running workloads
     * @type {number}
     * @memberof V1ResourcePool
     */
    slotsUsed: number;
    /**
     * Slot device type: cpu, gpu, ...
     * @type {Devicev1Type}
     * @memberof V1ResourcePool
     */
    slotType: Devicev1Type;
    /**
     * The max number of aux containers that can run in this resource pool
     * @type {number}
     * @memberof V1ResourcePool
     */
    auxContainerCapacity: number;
    /**
     * The current number of aux containers running in this resource pool
     * @type {number}
     * @memberof V1ResourcePool
     */
    auxContainersRunning: number;
    /**
     * Is this resource pool the default compute pool?
     * @type {boolean}
     * @memberof V1ResourcePool
     */
    defaultComputePool: boolean;
    /**
     * Is this resource pool the default auxiliary pool?
     * @type {boolean}
     * @memberof V1ResourcePool
     */
    defaultAuxPool: boolean;
    /**
     * Is this resource pool using preemptible/spot instances? Only meaningful in an AWS or GCP resource pool.
     * @type {boolean}
     * @memberof V1ResourcePool
     */
    preemptible: boolean;
    /**
     * When using dynamic agents, the minimum number of agents that can exist in the resource pool.
     * @type {number}
     * @memberof V1ResourcePool
     */
    minAgents: number;
    /**
     * When using dynamic agents, the maximum number of agents that can exist in the resource pool.
     * @type {number}
     * @memberof V1ResourcePool
     */
    maxAgents: number;
    /**
     * The number of slots that exists on an dynamic agent.
     * @type {number}
     * @memberof V1ResourcePool
     */
    slotsPerAgent?: number;
    /**
     * The maximum number of auxiliary containers that can run on an individual agent
     * @type {number}
     * @memberof V1ResourcePool
     */
    auxContainerCapacityPerAgent: number;
    /**
     * The type of the scheduler. Either 'FAIR_SHARE', 'PRIORITY', or 'ROUND_ROBIN'
     * @type {V1SchedulerType}
     * @memberof V1ResourcePool
     */
    schedulerType: V1SchedulerType;
    /**
     * The fitting policy of the scheduler.
     * @type {V1FittingPolicy}
     * @memberof V1ResourcePool
     */
    schedulerFittingPolicy: V1FittingPolicy;
    /**
     * The location of the resource pool. For AWS this returns the region and for GCP this return the zone.
     * @type {string}
     * @memberof V1ResourcePool
     */
    location: string;
    /**
     * The VM image used for the agents when using dynamic agents.
     * @type {string}
     * @memberof V1ResourcePool
     */
    imageId: string;
    /**
     * The instance type of the agents when using dynamic agents. For AWS this is the Instance Type. For GCP this is the machine type combined with the number and types of GPUs. To work with this data programattically, we recommend working with the ResourcePool.details.aws.instanceType and ResourcePool.details.gcp.machineType/gpuType/gpuNum.
     * @type {string}
     * @memberof V1ResourcePool
     */
    instanceType: string;
    /**
     * The url of the Determined master
     * @type {string}
     * @memberof V1ResourcePool
     */
    masterUrl: string;
    /**
     * A hostname for which the masters TLS certificate is valid, if the host specified by the master_url option is an IP address or is not contained in the certificate
     * @type {string}
     * @memberof V1ResourcePool
     */
    masterCertName: string;
    /**
     * The startup script for the agent. This runs on the node the agent runs on.
     * @type {string}
     * @memberof V1ResourcePool
     */
    startupScript: string;
    /**
     * The startup script for the agent's container. This runs in the container determined-agent runs in.
     * @type {string}
     * @memberof V1ResourcePool
     */
    containerStartupScript: string;
    /**
     * The Docker network to use for the agent when using dynamic agents.
     * @type {string}
     * @memberof V1ResourcePool
     */
    agentDockerNetwork: string;
    /**
     * The docker runtime to use for the agent when using dynamic agents
     * @type {string}
     * @memberof V1ResourcePool
     */
    agentDockerRuntime: string;
    /**
     * The docker image to use for the agent when using dynamic agents
     * @type {string}
     * @memberof V1ResourcePool
     */
    agentDockerImage: string;
    /**
     * The Fluent docker image to use
     * @type {string}
     * @memberof V1ResourcePool
     */
    agentFluentImage: string;
    /**
     * The maximum idle period of agents in seconds. The master waits for this period of time before shutting down idle agents.
     * @type {number}
     * @memberof V1ResourcePool
     */
    maxIdleAgentPeriod: number;
    /**
     * The maximum starting period of agents in seconds. The master waits for this period of time for starting agents before retrying.
     * @type {number}
     * @memberof V1ResourcePool
     */
    maxAgentStartingPeriod: number;
    /**
     * GCP, AWS and Priority Scheduler details
     * @type {V1ResourcePoolDetail}
     * @memberof V1ResourcePool
     */
    details: V1ResourcePoolDetail;
    /**
     * GCP, AWS accelerator information
     * @type {string}
     * @memberof V1ResourcePool
     */
    accelerator?: string;
    /**
     * Job queue stats
     * @type {V1QueueStats}
     * @memberof V1ResourcePool
     */
    stats?: V1QueueStats;
}
/**
 * 
 * @export
 * @interface V1ResourcePoolAwsDetail
 */
export interface V1ResourcePoolAwsDetail {
    /**
     * The region the resource pool exists in
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    region: string;
    /**
     * Size of the root volume of the Determined agent in GB
     * @type {number}
     * @memberof V1ResourcePoolAwsDetail
     */
    rootVolumeSize: number;
    /**
     * The AMI ID of the Determined agent
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    imageId: string;
    /**
     * Key for tagging the Determined agent instances
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    tagKey: string;
    /**
     * Value for tagging the Determined agent instances
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    tagValue: string;
    /**
     * Name to set for the Determined agent instances
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    instanceName: string;
    /**
     * The name of the SSH key registered with AWS for SSH key access to the agent instances
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    sshKeyName: string;
    /**
     * Whether to use public IP addresses for the Determined agent
     * @type {boolean}
     * @memberof V1ResourcePoolAwsDetail
     */
    publicIp: boolean;
    /**
     * The ID of the subnet to run the Determined agents in
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    subnetId?: string;
    /**
     * The ID of the security group to run the Determined agents as
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    securityGroupId: string;
    /**
     * The Amazon Resource Name (ARN) of the IAM instance profile to attach to the agent instances.
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    iamInstanceProfileArn: string;
    /**
     * AWS instance type to use for dynamic agents
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    instanceType?: string;
    /**
     * The log group
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    logGroup?: string;
    /**
     * The log stream
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    logStream?: string;
    /**
     * Whether to use spot instances
     * @type {boolean}
     * @memberof V1ResourcePoolAwsDetail
     */
    spotEnabled: boolean;
    /**
     * The maximum price per hour to pay for a spot instance
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    spotMaxPrice?: string;
    /**
     * List of arbitrary user-defined tags that are added to the Determined agent instances
     * @type {Array<V1AwsCustomTag>}
     * @memberof V1ResourcePoolAwsDetail
     */
    customTags?: Array<V1AwsCustomTag>;
}
/**
 * 
 * @export
 * @interface V1ResourcePoolDetail
 */
export interface V1ResourcePoolDetail {
    /**
     * AWS-specific details
     * @type {V1ResourcePoolAwsDetail}
     * @memberof V1ResourcePoolDetail
     */
    aws?: V1ResourcePoolAwsDetail;
    /**
     * GCP-specific details
     * @type {V1ResourcePoolGcpDetail}
     * @memberof V1ResourcePoolDetail
     */
    gcp?: V1ResourcePoolGcpDetail;
    /**
     * Priority scheduler-specific details
     * @type {V1ResourcePoolPrioritySchedulerDetail}
     * @memberof V1ResourcePoolDetail
     */
    priorityScheduler?: V1ResourcePoolPrioritySchedulerDetail;
}
/**
 * 
 * @export
 * @interface V1ResourcePoolGcpDetail
 */
export interface V1ResourcePoolGcpDetail {
    /**
     * The project ID of the GCP resources used by Determined
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    project: string;
    /**
     * The zone of the GCP resources used by Determined
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    zone: string;
    /**
     * Size of the root volume of the Determined agent in GB
     * @type {number}
     * @memberof V1ResourcePoolGcpDetail
     */
    bootDiskSize: number;
    /**
     * The boot disk source image of the Determined agent
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    bootDiskSourceImage: string;
    /**
     * Key for labeling the Determined agent instances.
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    labelKey: string;
    /**
     * Value for labeling the Determined agent instances
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    labelValue: string;
    /**
     * Name prefix to set for the Determined agent instances
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    namePrefix: string;
    /**
     * Network resource for the Determined agent instances
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    network: string;
    /**
     * Subnetwork resource for the Determined agent instances
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    subnetwork?: string;
    /**
     * Whether to use external IP addresses for the Determined agent instances
     * @type {boolean}
     * @memberof V1ResourcePoolGcpDetail
     */
    externalIp: boolean;
    /**
     * The network tags to set firewalls for the Determined agent instances
     * @type {Array<string>}
     * @memberof V1ResourcePoolGcpDetail
     */
    networkTags?: Array<string>;
    /**
     * Email of the service account for the Determined agent instances.
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    serviceAccountEmail: string;
    /**
     * List of scopes authorized for the Determined agent instances
     * @type {Array<string>}
     * @memberof V1ResourcePoolGcpDetail
     */
    serviceAccountScopes: Array<string>;
    /**
     * Type of machine for the Determined agents
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    machineType: string;
    /**
     * Type of GPU for the Determined agents
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    gpuType: string;
    /**
     * Number of GPUs for the Determined agents
     * @type {number}
     * @memberof V1ResourcePoolGcpDetail
     */
    gpuNum: number;
    /**
     * Whether to use preemptible instances
     * @type {boolean}
     * @memberof V1ResourcePoolGcpDetail
     */
    preemptible: boolean;
    /**
     * The timeout period for tracking a GCP operation in seconds
     * @type {number}
     * @memberof V1ResourcePoolGcpDetail
     */
    operationTimeoutPeriod: number;
}
/**
 * 
 * @export
 * @interface V1ResourcePoolPrioritySchedulerDetail
 */
export interface V1ResourcePoolPrioritySchedulerDetail {
    /**
     * Whether lower priority tasks should be preempted to schedule higher priority tasks
     * @type {boolean}
     * @memberof V1ResourcePoolPrioritySchedulerDetail
     */
    preemption: boolean;
    /**
     * The priority that is assigned to tasks that do not explicitly specify a priority.
     * @type {number}
     * @memberof V1ResourcePoolPrioritySchedulerDetail
     */
    defaultPriority: number;
    /**
     * List of available priorities for K8 (if applicable).
     * @type {Array<V1K8PriorityClass>}
     * @memberof V1ResourcePoolPrioritySchedulerDetail
     */
    k8Priorities?: Array<V1K8PriorityClass>;
}
/**
 * The type of the ResourcePool.   - RESOURCE_POOL_TYPE_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_POOL_TYPE_AWS: An AWS resource pool.  - RESOURCE_POOL_TYPE_GCP: A GCP resource pool.  - RESOURCE_POOL_TYPE_STATIC: A static resource pool.  - RESOURCE_POOL_TYPE_K8S: The kubernetes resource pool.
 * @export
 * @enum {string}
 */
export const V1ResourcePoolType = {
    UNSPECIFIED: 'RESOURCE_POOL_TYPE_UNSPECIFIED',
    AWS: 'RESOURCE_POOL_TYPE_AWS',
    GCP: 'RESOURCE_POOL_TYPE_GCP',
    STATIC: 'RESOURCE_POOL_TYPE_STATIC',
    K8S: 'RESOURCE_POOL_TYPE_K8S',
} as const
export type V1ResourcePoolType = ValueOf<typeof V1ResourcePoolType>
/**
 * ResourcesFailure contains information about restored resources' failure.
 * @export
 * @interface V1ResourcesFailure
 */
export interface V1ResourcesFailure {
    /**
     * FailureType denotes the type of failure that resulted in the container stopping.
     * @type {V1FailureType}
     * @memberof V1ResourcesFailure
     */
    failureType?: V1FailureType;
    /**
     * The error message of the failure.
     * @type {string}
     * @memberof V1ResourcesFailure
     */
    errMsg?: string;
    /**
     * The exit code of the failure.
     * @type {number}
     * @memberof V1ResourcesFailure
     */
    exitCode?: number;
}
/**
 * ResourcesStarted contains the information needed by tasks from container started.
 * @export
 * @interface V1ResourcesStarted
 */
export interface V1ResourcesStarted {
    /**
     * Addresses represents the exposed ports on a container.
     * @type {Array<V1Address>}
     * @memberof V1ResourcesStarted
     */
    addresses?: Array<V1Address>;
    /**
     * NativeResourcesID is the native Docker hex container ID of the Determined container.
     * @type {string}
     * @memberof V1ResourcesStarted
     */
    nativeResourcesId?: string;
}
/**
 * ResourcesStopped contains the information needed by tasks from container stopped.
 * @export
 * @interface V1ResourcesStopped
 */
export interface V1ResourcesStopped {
    /**
     * ResourcesFailure contains information about restored resources' failure.
     * @type {V1ResourcesFailure}
     * @memberof V1ResourcesStopped
     */
    failure?: V1ResourcesFailure;
}
/**
 * ResourcesSummary provides a summary of the resources comprising what we know at the time the allocation is granted, but for k8s it is granted before being scheduled so it isn't really much and `agent_devices` are missing for k8s.
 * @export
 * @interface V1ResourcesSummary
 */
export interface V1ResourcesSummary {
    /**
     * ResourcesID is the ID of some set of resources.
     * @type {string}
     * @memberof V1ResourcesSummary
     */
    resourcesId?: string;
    /**
     * ResourcesType is the type of some set of resources. This should be purely informational.
     * @type {string}
     * @memberof V1ResourcesSummary
     */
    resourcesType?: string;
    /**
     * AllocationID is the ID of an allocation of a task.
     * @type {string}
     * @memberof V1ResourcesSummary
     */
    allocationId?: string;
    /**
     * ID, an identifier for an agent, maps to the associated devices.
     * @type {{ [key: string]: ResourcesSummaryDevices; }}
     * @memberof V1ResourcesSummary
     */
    agentDevices?: { [key: string]: ResourcesSummaryDevices; };
    /**
     * Available if the RM can give information on the container level.
     * @type {string}
     * @memberof V1ResourcesSummary
     */
    containerId?: string;
    /**
     * Available if the RM knows the resource is already started / exited.
     * @type {V1ResourcesStarted}
     * @memberof V1ResourcesSummary
     */
    started?: V1ResourcesStarted;
    /**
     * ResourcesStopped contains the information needed by tasks from container stopped.
     * @type {V1ResourcesStopped}
     * @memberof V1ResourcesSummary
     */
    exited?: V1ResourcesStopped;
}
/**
 * 
 * @export
 * @interface V1Role
 */
export interface V1Role {
    /**
     * The id of the role being detailed
     * @type {number}
     * @memberof V1Role
     */
    roleId: number;
    /**
     * The string of the role being detailed
     * @type {string}
     * @memberof V1Role
     */
    name?: string;
    /**
     * The permissions granted to the role
     * @type {Array<V1Permission>}
     * @memberof V1Role
     */
    permissions?: Array<V1Permission>;
    /**
     * Allowed scope types.
     * @type {V1ScopeTypeMask}
     * @memberof V1Role
     */
    scopeTypeMask?: V1ScopeTypeMask;
}
/**
 * RoleAssignment contains information about the scope of the role.
 * @export
 * @interface V1RoleAssignment
 */
export interface V1RoleAssignment {
    /**
     * The role of the assignment.
     * @type {V1Role}
     * @memberof V1RoleAssignment
     */
    role: V1Role;
    /**
     * The id of the workspace the role belongs to. Empty for cluster-wide scope.
     * @type {number}
     * @memberof V1RoleAssignment
     */
    scopeWorkspaceId?: number;
    /**
     * Whether the role is assigned cluster-wide.
     * @type {boolean}
     * @memberof V1RoleAssignment
     */
    scopeCluster?: boolean;
}
/**
 * RoleAssignmentSummary is used to describe permissions a user has.
 * @export
 * @interface V1RoleAssignmentSummary
 */
export interface V1RoleAssignmentSummary {
    /**
     * The id of the role being detailed
     * @type {number}
     * @memberof V1RoleAssignmentSummary
     */
    roleId: number;
    /**
     * List of workspace IDs to apply the role.
     * @type {Array<number>}
     * @memberof V1RoleAssignmentSummary
     */
    scopeWorkspaceIds?: Array<number>;
    /**
     * Whether the role is assigned cluster-wide.
     * @type {boolean}
     * @memberof V1RoleAssignmentSummary
     */
    scopeCluster?: boolean;
}
/**
 * RoleWithAssignments contains a detailed description of a role and the groups and users belonging to it.
 * @export
 * @interface V1RoleWithAssignments
 */
export interface V1RoleWithAssignments {
    /**
     * The embedded Role.
     * @type {V1Role}
     * @memberof V1RoleWithAssignments
     */
    role?: V1Role;
    /**
     * The embedded GroupRoleAssignment.
     * @type {Array<V1GroupRoleAssignment>}
     * @memberof V1RoleWithAssignments
     */
    groupRoleAssignments?: Array<V1GroupRoleAssignment>;
    /**
     * The embedded UserRoleAssignment.
     * @type {Array<V1UserRoleAssignment>}
     * @memberof V1RoleWithAssignments
     */
    userRoleAssignments?: Array<V1UserRoleAssignment>;
}
/**
 * Job stats for a resource pool.
 * @export
 * @interface V1RPQueueStat
 */
export interface V1RPQueueStat {
    /**
     * Job queue stats.
     * @type {V1QueueStats}
     * @memberof V1RPQueueStat
     */
    stats: V1QueueStats;
    /**
     * Resource pool.
     * @type {string}
     * @memberof V1RPQueueStat
     */
    resourcePool: string;
    /**
     * Aggregate stats.
     * @type {Array<V1AggregateQueueStats>}
     * @memberof V1RPQueueStat
     */
    aggregates?: Array<V1AggregateQueueStats>;
}
/**
 * RunnableOperation represents a single runnable operation emitted by a searcher.
 * @export
 * @interface V1RunnableOperation
 */
export interface V1RunnableOperation {
    /**
     * This is the type of the operation.
     * @type {V1RunnableType}
     * @memberof V1RunnableOperation
     */
    type?: V1RunnableType;
    /**
     * If the type == WORKLOAD_KIND_TRAIN, this is the number of units
     * @type {string}
     * @memberof V1RunnableOperation
     */
    length?: string;
}
/**
 * RunnableType defines the type of operation that should be executed by trial runners.   - RUNNABLE_TYPE_UNSPECIFIED: Denotes an unknown runnable type.  - RUNNABLE_TYPE_TRAIN: Signals to a trial runner that it should run a train.  - RUNNABLE_TYPE_VALIDATE: Signals to a trial runner it should compute validation metrics.
 * @export
 * @enum {string}
 */
export const V1RunnableType = {
    UNSPECIFIED: 'RUNNABLE_TYPE_UNSPECIFIED',
    TRAIN: 'RUNNABLE_TYPE_TRAIN',
    VALIDATE: 'RUNNABLE_TYPE_VALIDATE',
} as const
export type V1RunnableType = ValueOf<typeof V1RunnableType>
/**
 * The type of the Scheduler.   - SCHEDULER_TYPE_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - SCHEDULER_TYPE_PRIORITY: The priority scheduler.  - SCHEDULER_TYPE_FAIR_SHARE: The fair share scheduler.  - SCHEDULER_TYPE_ROUND_ROBIN: The round robin scheduler  - SCHEDULER_TYPE_KUBERNETES: The kubernetes scheduler.  - SCHEDULER_TYPE_SLURM: A slurm placeholder. When running on slurm, all scheduling behavior is delegated.  - SCHEDULER_TYPE_PBS: A PBS placeholder. When running on PBS, all scheduling behavior is delegated.
 * @export
 * @enum {string}
 */
export const V1SchedulerType = {
    UNSPECIFIED: 'SCHEDULER_TYPE_UNSPECIFIED',
    PRIORITY: 'SCHEDULER_TYPE_PRIORITY',
    FAIRSHARE: 'SCHEDULER_TYPE_FAIR_SHARE',
    ROUNDROBIN: 'SCHEDULER_TYPE_ROUND_ROBIN',
    KUBERNETES: 'SCHEDULER_TYPE_KUBERNETES',
    SLURM: 'SCHEDULER_TYPE_SLURM',
    PBS: 'SCHEDULER_TYPE_PBS',
} as const
export type V1SchedulerType = ValueOf<typeof V1SchedulerType>
/**
 * 
 * @export
 * @interface V1ScopeTypeMask
 */
export interface V1ScopeTypeMask {
    /**
     * Whether this permission or role can be assigned globally, i.e. cluster-wide. Currently, all permissions can be assigned globally, so this is always true.
     * @type {boolean}
     * @memberof V1ScopeTypeMask
     */
    cluster?: boolean;
    /**
     * Whether this permission or role can be assigned on a particular workspace. For example, `ADMINISTRATE_USER` permission will have this field set to false, since user creation can only be done at a cluster level, and it doesn't make sense for a single workspace.
     * @type {boolean}
     * @memberof V1ScopeTypeMask
     */
    workspace?: boolean;
}
/**
 * SearcherEvent is a message from master to a client-driven custom searcher informing it of relevant changes in the state of an experiment.
 * @export
 * @interface V1SearcherEvent
 */
export interface V1SearcherEvent {
    /**
     * Incremental ID of the event.
     * @type {number}
     * @memberof V1SearcherEvent
     */
    id: number;
    /**
     * An experiment has just been created.
     * @type {V1InitialOperations}
     * @memberof V1SearcherEvent
     */
    initialOperations?: V1InitialOperations;
    /**
     * A trial has been created.
     * @type {V1TrialCreated}
     * @memberof V1SearcherEvent
     */
    trialCreated?: V1TrialCreated;
    /**
     * Validation has completed.
     * @type {V1ValidationCompleted}
     * @memberof V1SearcherEvent
     */
    validationCompleted?: V1ValidationCompleted;
    /**
     * Trial has finished.
     * @type {V1TrialClosed}
     * @memberof V1SearcherEvent
     */
    trialClosed?: V1TrialClosed;
    /**
     * Trial exited early.
     * @type {V1TrialExitedEarly}
     * @memberof V1SearcherEvent
     */
    trialExitedEarly?: V1TrialExitedEarly;
    /**
     * Trial progress.
     * @type {V1TrialProgress}
     * @memberof V1SearcherEvent
     */
    trialProgress?: V1TrialProgress;
    /**
     * Experiment is inactive.
     * @type {V1ExperimentInactive}
     * @memberof V1SearcherEvent
     */
    experimentInactive?: V1ExperimentInactive;
}
/**
 * SearcherOperation is an operation issued by the custom searcher.
 * @export
 * @interface V1SearcherOperation
 */
export interface V1SearcherOperation {
    /**
     * TrialOperation is issued to tell an existing trial to do something.
     * @type {V1TrialOperation}
     * @memberof V1SearcherOperation
     */
    trialOperation?: V1TrialOperation;
    /**
     * CreateTrialOperation is issued to create a trial.
     * @type {V1CreateTrialOperation}
     * @memberof V1SearcherOperation
     */
    createTrial?: V1CreateTrialOperation;
    /**
     * CloseTrialOperation is issued to close a trial.
     * @type {V1CloseTrialOperation}
     * @memberof V1SearcherOperation
     */
    closeTrial?: V1CloseTrialOperation;
    /**
     * ShutDownOperation is issued to shut down the custom search method.
     * @type {V1ShutDownOperation}
     * @memberof V1SearcherOperation
     */
    shutDown?: V1ShutDownOperation;
    /**
     * SetSearcherProgressOperation is issued to set the progress of the custom search method.
     * @type {V1SetSearcherProgressOperation}
     * @memberof V1SearcherOperation
     */
    setSearcherProgress?: V1SetSearcherProgressOperation;
}
/**
 * 
 * @export
 * @interface V1SearchExperimentExperiment
 */
export interface V1SearchExperimentExperiment {
    /**
     * The experiment in question
     * @type {V1Experiment}
     * @memberof V1SearchExperimentExperiment
     */
    experiment: V1Experiment;
    /**
     * The best performing trial associated with the experiment
     * @type {Trialv1Trial}
     * @memberof V1SearchExperimentExperiment
     */
    bestTrial?: Trialv1Trial;
}
/**
 * 
 * @export
 * @interface V1SearchExperimentsResponse
 */
export interface V1SearchExperimentsResponse {
    /**
     * The list of returned experiments.
     * @type {Array<V1SearchExperimentExperiment>}
     * @memberof V1SearchExperimentsResponse
     */
    experiments: Array<V1SearchExperimentExperiment>;
    /**
     * Pagination information of the full dataset
     * @type {V1Pagination}
     * @memberof V1SearchExperimentsResponse
     */
    pagination: V1Pagination;
}
/**
 * 
 * @export
 * @interface V1SearchRolesAssignableToScopeRequest
 */
export interface V1SearchRolesAssignableToScopeRequest {
    /**
     * The maximum number of results to return
     * @type {number}
     * @memberof V1SearchRolesAssignableToScopeRequest
     */
    limit: number;
    /**
     * The offset to use with pagination
     * @type {number}
     * @memberof V1SearchRolesAssignableToScopeRequest
     */
    offset?: number;
    /**
     * The id of the workspace to use if searching for a workspace-assignable role
     * @type {number}
     * @memberof V1SearchRolesAssignableToScopeRequest
     */
    workspaceId?: number;
}
/**
 * 
 * @export
 * @interface V1SearchRolesAssignableToScopeResponse
 */
export interface V1SearchRolesAssignableToScopeResponse {
    /**
     * pagination information.
     * @type {V1Pagination}
     * @memberof V1SearchRolesAssignableToScopeResponse
     */
    pagination?: V1Pagination;
    /**
     * the set of roles and all assignments belonging to it.
     * @type {Array<V1Role>}
     * @memberof V1SearchRolesAssignableToScopeResponse
     */
    roles?: Array<V1Role>;
}
/**
 * Set the priority of the requested command.
 * @export
 * @interface V1SetCommandPriorityRequest
 */
export interface V1SetCommandPriorityRequest {
    /**
     * The id of the command.
     * @type {string}
     * @memberof V1SetCommandPriorityRequest
     */
    commandId?: string;
    /**
     * The new priority.
     * @type {number}
     * @memberof V1SetCommandPriorityRequest
     */
    priority?: number;
}
/**
 * Response to SetCommandPriorityRequest.
 * @export
 * @interface V1SetCommandPriorityResponse
 */
export interface V1SetCommandPriorityResponse {
    /**
     * The requested command.
     * @type {V1Command}
     * @memberof V1SetCommandPriorityResponse
     */
    command?: V1Command;
}
/**
 * Set the priority of the requested notebook.
 * @export
 * @interface V1SetNotebookPriorityRequest
 */
export interface V1SetNotebookPriorityRequest {
    /**
     * The id of the notebook.
     * @type {string}
     * @memberof V1SetNotebookPriorityRequest
     */
    notebookId?: string;
    /**
     * The new priority.
     * @type {number}
     * @memberof V1SetNotebookPriorityRequest
     */
    priority?: number;
}
/**
 * Response to SetNotebookPriorityRequest.
 * @export
 * @interface V1SetNotebookPriorityResponse
 */
export interface V1SetNotebookPriorityResponse {
    /**
     * The requested notebook.
     * @type {V1Notebook}
     * @memberof V1SetNotebookPriorityResponse
     */
    notebook?: V1Notebook;
}
/**
 * SetSearcherProgressOperation informs the master of the progress of the custom searcher.
 * @export
 * @interface V1SetSearcherProgressOperation
 */
export interface V1SetSearcherProgressOperation {
    /**
     * Experiment progress as a float between 0.0 and 1.0.
     * @type {number}
     * @memberof V1SetSearcherProgressOperation
     */
    progress?: number;
}
/**
 * Set the priority of the requested shell.
 * @export
 * @interface V1SetShellPriorityRequest
 */
export interface V1SetShellPriorityRequest {
    /**
     * The id of the shell.
     * @type {string}
     * @memberof V1SetShellPriorityRequest
     */
    shellId?: string;
    /**
     * The new priority.
     * @type {number}
     * @memberof V1SetShellPriorityRequest
     */
    priority?: number;
}
/**
 * Response to SetShellPriorityRequest.
 * @export
 * @interface V1SetShellPriorityResponse
 */
export interface V1SetShellPriorityResponse {
    /**
     * The requested shell.
     * @type {V1Shell}
     * @memberof V1SetShellPriorityResponse
     */
    shell?: V1Shell;
}
/**
 * Set the priority of the requested TensorBoard.
 * @export
 * @interface V1SetTensorboardPriorityRequest
 */
export interface V1SetTensorboardPriorityRequest {
    /**
     * The id of the TensorBoard.
     * @type {string}
     * @memberof V1SetTensorboardPriorityRequest
     */
    tensorboardId?: string;
    /**
     * The new priority.
     * @type {number}
     * @memberof V1SetTensorboardPriorityRequest
     */
    priority?: number;
}
/**
 * Response to SetTensorboardPriorityRequest.
 * @export
 * @interface V1SetTensorboardPriorityResponse
 */
export interface V1SetTensorboardPriorityResponse {
    /**
     * The requested Tensorboard.
     * @type {V1Tensorboard}
     * @memberof V1SetTensorboardPriorityResponse
     */
    tensorboard?: V1Tensorboard;
}
/**
 * Response to SetUserPasswordRequest.
 * @export
 * @interface V1SetUserPasswordResponse
 */
export interface V1SetUserPasswordResponse {
    /**
     * The updated user.
     * @type {V1User}
     * @memberof V1SetUserPasswordResponse
     */
    user?: V1User;
}
/**
 * Shell is an ssh server in a containerized environment.
 * @export
 * @interface V1Shell
 */
export interface V1Shell {
    /**
     * The id of the shell.
     * @type {string}
     * @memberof V1Shell
     */
    id: string;
    /**
     * The description of the shell.
     * @type {string}
     * @memberof V1Shell
     */
    description: string;
    /**
     * The state of the shell.
     * @type {Taskv1State}
     * @memberof V1Shell
     */
    state: Taskv1State;
    /**
     * The time the shell was started.
     * @type {Date}
     * @memberof V1Shell
     */
    startTime: Date;
    /**
     * The container running the shell.
     * @type {V1Container}
     * @memberof V1Shell
     */
    container?: V1Container;
    /**
     * The private key for this shell.
     * @type {string}
     * @memberof V1Shell
     */
    privateKey?: string;
    /**
     * The public key for this shell.
     * @type {string}
     * @memberof V1Shell
     */
    publicKey?: string;
    /**
     * The display name of the user that created the shell.
     * @type {string}
     * @memberof V1Shell
     */
    displayName?: string;
    /**
     * The id of the user that created the shell.
     * @type {number}
     * @memberof V1Shell
     */
    userId?: number;
    /**
     * The username of the user that created the shell.
     * @type {string}
     * @memberof V1Shell
     */
    username: string;
    /**
     * The name of the resource pool the Shell was created in
     * @type {string}
     * @memberof V1Shell
     */
    resourcePool: string;
    /**
     * The exit status;
     * @type {string}
     * @memberof V1Shell
     */
    exitStatus?: string;
    /**
     * The addresses;
     * @type {Array<any>}
     * @memberof V1Shell
     */
    addresses?: Array<any>;
    /**
     * The agent user group;
     * @type {any}
     * @memberof V1Shell
     */
    agentUserGroup?: any;
    /**
     * The associated job id.
     * @type {string}
     * @memberof V1Shell
     */
    jobId: string;
    /**
     * The workspace id.
     * @type {number}
     * @memberof V1Shell
     */
    workspaceId: number;
}
/**
 * Shut down custom searcher method.
 * @export
 * @interface V1ShutDownOperation
 */
export interface V1ShutDownOperation {
    /**
     * Defines whether the Searcher was cancelled
     * @type {boolean}
     * @memberof V1ShutDownOperation
     */
    cancel?: boolean;
    /**
     * Defines whether the Searcher failed
     * @type {boolean}
     * @memberof V1ShutDownOperation
     */
    failure?: boolean;
}
/**
 * Slot wraps a single device on the agent.
 * @export
 * @interface V1Slot
 */
export interface V1Slot {
    /**
     * The unqiue id of the slot for a given agent.
     * @type {string}
     * @memberof V1Slot
     */
    id?: string;
    /**
     * The individual resource this slot wraps.
     * @type {V1Device}
     * @memberof V1Slot
     */
    device?: V1Device;
    /**
     * Flag notifying if containers can be scheduled on this slot.
     * @type {boolean}
     * @memberof V1Slot
     */
    enabled?: boolean;
    /**
     * Container that is currently running on this agent. It is unset if there is no container currently running on this slot.
     * @type {V1Container}
     * @memberof V1Slot
     */
    container?: V1Container;
    /**
     * Flag notifying if this slot is in the draining mode: current containers will be allowed to finish but no new ones will be scheduled.
     * @type {boolean}
     * @memberof V1Slot
     */
    draining?: boolean;
}
/**
 * Describe one SSO provider.
 * @export
 * @interface V1SSOProvider
 */
export interface V1SSOProvider {
    /**
     * A descriptive name for this provider.
     * @type {string}
     * @memberof V1SSOProvider
     */
    name: string;
    /**
     * The URL to use for SSO with this provider.
     * @type {string}
     * @memberof V1SSOProvider
     */
    ssoUrl: string;
}
/**
 * Start a trial.
 * @export
 * @interface V1StartTrialRequest
 */
export interface V1StartTrialRequest {
    /**
     * Trial id.
     * @type {number}
     * @memberof V1StartTrialRequest
     */
    trialId: number;
    /**
     * Whether resume is allowed.
     * @type {boolean}
     * @memberof V1StartTrialRequest
     */
    resume?: boolean;
}
/**
 * Response to StartTrialRequest.
 * @export
 * @interface V1StartTrialResponse
 */
export interface V1StartTrialResponse {
    /**
     * Trial run id.
     * @type {number}
     * @memberof V1StartTrialResponse
     */
    trialRunId: number;
    /**
     * Latest checkpoint.
     * @type {string}
     * @memberof V1StartTrialResponse
     */
    latestCheckpoint?: string;
    /**
     * Steps completed.
     * @type {number}
     * @memberof V1StartTrialResponse
     */
    stepsCompleted: number;
}
/**
 * Task is the model for a task in the database.
 * @export
 * @interface V1Task
 */
export interface V1Task {
    /**
     * Unique ID of task.
     * @type {string}
     * @memberof V1Task
     */
    taskId: string;
    /**
     * Type of Task.
     * @type {V1TaskType}
     * @memberof V1Task
     */
    taskType: V1TaskType;
    /**
     * List of Allocations.
     * @type {Array<V1Allocation>}
     * @memberof V1Task
     */
    allocations: Array<V1Allocation>;
    /**
     * Start timestamp.
     * @type {Date}
     * @memberof V1Task
     */
    startTime: Date;
    /**
     * End timestamp if completed.
     * @type {Date}
     * @memberof V1Task
     */
    endTime?: Date;
}
/**
 * Response to TaskLogsFieldsRequest.
 * @export
 * @interface V1TaskLogsFieldsResponse
 */
export interface V1TaskLogsFieldsResponse {
    /**
     * The distint allocation IDs present in the logs.
     * @type {Array<string>}
     * @memberof V1TaskLogsFieldsResponse
     */
    allocationIds?: Array<string>;
    /**
     * The distinct agent IDs present in the logs.
     * @type {Array<string>}
     * @memberof V1TaskLogsFieldsResponse
     */
    agentIds?: Array<string>;
    /**
     * The distinct container IDs present in the logs.
     * @type {Array<string>}
     * @memberof V1TaskLogsFieldsResponse
     */
    containerIds?: Array<string>;
    /**
     * The distinct rank IDs present in the logs.
     * @type {Array<number>}
     * @memberof V1TaskLogsFieldsResponse
     */
    rankIds?: Array<number>;
    /**
     * The distinct stdtypes present in the logs.
     * @type {Array<string>}
     * @memberof V1TaskLogsFieldsResponse
     */
    stdtypes?: Array<string>;
    /**
     * The distinct sources present in the logs.
     * @type {Array<string>}
     * @memberof V1TaskLogsFieldsResponse
     */
    sources?: Array<string>;
}
/**
 * Response to TaskLogsRequest.
 * @export
 * @interface V1TaskLogsResponse
 */
export interface V1TaskLogsResponse {
    /**
     * The ID of the log.
     * @type {string}
     * @memberof V1TaskLogsResponse
     */
    id: string;
    /**
     * The timestamp of the log.
     * @type {Date}
     * @memberof V1TaskLogsResponse
     */
    timestamp: Date;
    /**
     * The flat version of the log that UIs have shown historically.
     * @type {string}
     * @memberof V1TaskLogsResponse
     */
    message: string;
    /**
     * The level of the log.
     * @type {V1LogLevel}
     * @memberof V1TaskLogsResponse
     */
    level: V1LogLevel;
    /**
     * The ID of the task.
     * @type {string}
     * @memberof V1TaskLogsResponse
     */
    taskId: string;
    /**
     * The ID of the allocation.
     * @type {string}
     * @memberof V1TaskLogsResponse
     */
    allocationId?: string;
    /**
     * The agent the logs came from.
     * @type {string}
     * @memberof V1TaskLogsResponse
     */
    agentId?: string;
    /**
     * The ID of the container or, in the case of k8s, the pod name.
     * @type {string}
     * @memberof V1TaskLogsResponse
     */
    containerId?: string;
    /**
     * The rank ID.
     * @type {number}
     * @memberof V1TaskLogsResponse
     */
    rankId?: number;
    /**
     * The text of the log entry.
     * @type {string}
     * @memberof V1TaskLogsResponse
     */
    log: string;
    /**
     * The source of the log entry.
     * @type {string}
     * @memberof V1TaskLogsResponse
     */
    source?: string;
    /**
     * The output stream (e.g. stdout, stderr).
     * @type {string}
     * @memberof V1TaskLogsResponse
     */
    stdtype?: string;
}
/**
 * - TASK_TYPE_UNSPECIFIED: The task type is unknown  - TASK_TYPE_TRIAL: "TRIAL" task type for the enum public.task_type in Postgres.  - TASK_TYPE_NOTEBOOK: "NOTEBOOK" task type for the enum public.task_type in Postgres.  - TASK_TYPE_SHELL: "SHELL" task type for the enum public.task_type in Postgres.  - TASK_TYPE_COMMAND: "COMMAND" task type for the enum public.task_type in Postgres.  - TASK_TYPE_TENSORBOARD: "TENSORBOARD" task type for the enum public.task_type in Postgres.  - TASK_TYPE_CHECKPOINT_GC: "CHECKPOINT_GC" task type for the enum public.task_type in Postgres.
 * @export
 * @enum {string}
 */
export const V1TaskType = {
    UNSPECIFIED: 'TASK_TYPE_UNSPECIFIED',
    TRIAL: 'TASK_TYPE_TRIAL',
    NOTEBOOK: 'TASK_TYPE_NOTEBOOK',
    SHELL: 'TASK_TYPE_SHELL',
    COMMAND: 'TASK_TYPE_COMMAND',
    TENSORBOARD: 'TASK_TYPE_TENSORBOARD',
    CHECKPOINTGC: 'TASK_TYPE_CHECKPOINT_GC',
} as const
export type V1TaskType = ValueOf<typeof V1TaskType>
/**
 * Templates move settings that are shared by many experiments into a single YAML file.
 * @export
 * @interface V1Template
 */
export interface V1Template {
    /**
     * The name of the template.
     * @type {string}
     * @memberof V1Template
     */
    name: string;
    /**
     * The template value.
     * @type {any}
     * @memberof V1Template
     */
    config: any;
    /**
     * The id of the workspace associated with this model.
     * @type {number}
     * @memberof V1Template
     */
    workspaceId: number;
}
/**
 * Tensorboard is a tensorboard instance in a containerized environment.
 * @export
 * @interface V1Tensorboard
 */
export interface V1Tensorboard {
    /**
     * The id of the tensorboard.
     * @type {string}
     * @memberof V1Tensorboard
     */
    id: string;
    /**
     * The description of the tensorboard.
     * @type {string}
     * @memberof V1Tensorboard
     */
    description: string;
    /**
     * The state of the tensorboard.
     * @type {Taskv1State}
     * @memberof V1Tensorboard
     */
    state: Taskv1State;
    /**
     * The time the tensorboard was started.
     * @type {Date}
     * @memberof V1Tensorboard
     */
    startTime: Date;
    /**
     * The container running the tensorboard.
     * @type {V1Container}
     * @memberof V1Tensorboard
     */
    container?: V1Container;
    /**
     * The experiment ids loaded into this tensorboard instance.
     * @type {Array<number>}
     * @memberof V1Tensorboard
     */
    experimentIds?: Array<number>;
    /**
     * The trial ids loaded into this tensorboard instance.
     * @type {Array<number>}
     * @memberof V1Tensorboard
     */
    trialIds?: Array<number>;
    /**
     * The display name of the user that created the tensorboard.
     * @type {string}
     * @memberof V1Tensorboard
     */
    displayName?: string;
    /**
     * The id of the user that created the tensorboard.
     * @type {number}
     * @memberof V1Tensorboard
     */
    userId?: number;
    /**
     * The username of the user that created the tensorboard.
     * @type {string}
     * @memberof V1Tensorboard
     */
    username: string;
    /**
     * The service address.
     * @type {string}
     * @memberof V1Tensorboard
     */
    serviceAddress?: string;
    /**
     * The name of the resource pool the command was created in
     * @type {string}
     * @memberof V1Tensorboard
     */
    resourcePool: string;
    /**
     * The exit status;
     * @type {string}
     * @memberof V1Tensorboard
     */
    exitStatus?: string;
    /**
     * The associated job id.
     * @type {string}
     * @memberof V1Tensorboard
     */
    jobId: string;
    /**
     * The workspace id.
     * @type {number}
     * @memberof V1Tensorboard
     */
    workspaceId: number;
}
/**
 * Response to TestWebhookRequest.
 * @export
 * @interface V1TestWebhookResponse
 */
export interface V1TestWebhookResponse {
    /**
     * Status of test.
     * @type {boolean}
     * @memberof V1TestWebhookResponse
     */
    completed: boolean;
}
/**
 * Timestamp filters.
 * @export
 * @interface V1TimestampFieldFilter
 */
export interface V1TimestampFieldFilter {
    /**
     * Less than.
     * @type {Date}
     * @memberof V1TimestampFieldFilter
     */
    lt?: Date;
    /**
     * Less than or equal.
     * @type {Date}
     * @memberof V1TimestampFieldFilter
     */
    lte?: Date;
    /**
     * Greater than.
     * @type {Date}
     * @memberof V1TimestampFieldFilter
     */
    gt?: Date;
    /**
     * Greater than or equal.
     * @type {Date}
     * @memberof V1TimestampFieldFilter
     */
    gte?: Date;
}
/**
 * TrialClosed is a searcher event triggered when a trial has successfully finished.
 * @export
 * @interface V1TrialClosed
 */
export interface V1TrialClosed {
    /**
     * UUID identifying the trial to the searcher.
     * @type {string}
     * @memberof V1TrialClosed
     */
    requestId: string;
}
/**
 * TrialCreated is a searcher event signaling the creation of a trial.
 * @export
 * @interface V1TrialCreated
 */
export interface V1TrialCreated {
    /**
     * UUID identifying the trial to the searcher.
     * @type {string}
     * @memberof V1TrialCreated
     */
    requestId: string;
}
/**
 * Signals to the experiment the trial early exited.
 * @export
 * @interface V1TrialEarlyExit
 */
export interface V1TrialEarlyExit {
    /**
     * The reason for the exit.
     * @type {V1TrialEarlyExitExitedReason}
     * @memberof V1TrialEarlyExit
     */
    reason: V1TrialEarlyExitExitedReason;
}
/**
 * The reason for an early exit.   - EXITED_REASON_UNSPECIFIED: Zero-value (not allowed).  - EXITED_REASON_INVALID_HP: Indicates the trial exited due to an invalid hyperparameter.  - EXITED_REASON_INIT_INVALID_HP: Indicates the trial exited due to an invalid hyperparameter in the trial init.
 * @export
 * @enum {string}
 */
export const V1TrialEarlyExitExitedReason = {
    UNSPECIFIED: 'EXITED_REASON_UNSPECIFIED',
    INVALIDHP: 'EXITED_REASON_INVALID_HP',
    INITINVALIDHP: 'EXITED_REASON_INIT_INVALID_HP',
} as const
export type V1TrialEarlyExitExitedReason = ValueOf<typeof V1TrialEarlyExitExitedReason>
/**
 * TrialExitedEarly is a searcher event triggered when a trial exited prematurely.
 * @export
 * @interface V1TrialExitedEarly
 */
export interface V1TrialExitedEarly {
    /**
     * UUID identifying the trial to the searcher.
     * @type {string}
     * @memberof V1TrialExitedEarly
     */
    requestId: string;
    /**
     * The reason for the exit.
     * @type {V1TrialExitedEarlyExitedReason}
     * @memberof V1TrialExitedEarly
     */
    exitedReason: V1TrialExitedEarlyExitedReason;
}
/**
 * The reason for an early exit.   - EXITED_REASON_UNSPECIFIED: Zero-value (not allowed).  - EXITED_REASON_INVALID_HP: Indicates the trial exited due to an invalid hyperparameter.  - EXITED_REASON_USER_REQUESTED_STOP: Indicates the trial exited due to a user requested stop, from code.  - EXITED_REASON_USER_CANCELED: Indicates the trial exited due to a user requested stop, from the CLI or UI.
 * @export
 * @enum {string}
 */
export const V1TrialExitedEarlyExitedReason = {
    UNSPECIFIED: 'EXITED_REASON_UNSPECIFIED',
    INVALIDHP: 'EXITED_REASON_INVALID_HP',
    USERREQUESTEDSTOP: 'EXITED_REASON_USER_REQUESTED_STOP',
    USERCANCELED: 'EXITED_REASON_USER_CANCELED',
} as const
export type V1TrialExitedEarlyExitedReason = ValueOf<typeof V1TrialExitedEarlyExitedReason>
/**
 * Response to TrialLogFieldsRequest.
 * @export
 * @interface V1TrialLogsFieldsResponse
 */
export interface V1TrialLogsFieldsResponse {
    /**
     * The distinct agent IDs present in the logs.
     * @type {Array<string>}
     * @memberof V1TrialLogsFieldsResponse
     */
    agentIds?: Array<string>;
    /**
     * The distinct container IDs present in the logs.
     * @type {Array<string>}
     * @memberof V1TrialLogsFieldsResponse
     */
    containerIds?: Array<string>;
    /**
     * The distinct rank IDs present in the logs.
     * @type {Array<number>}
     * @memberof V1TrialLogsFieldsResponse
     */
    rankIds?: Array<number>;
    /**
     * The distinct stdtypes present in the logs.
     * @type {Array<string>}
     * @memberof V1TrialLogsFieldsResponse
     */
    stdtypes?: Array<string>;
    /**
     * The distinct sources present in the logs.
     * @type {Array<string>}
     * @memberof V1TrialLogsFieldsResponse
     */
    sources?: Array<string>;
}
/**
 * Response to TrialLogsRequest.
 * @export
 * @interface V1TrialLogsResponse
 */
export interface V1TrialLogsResponse {
    /**
     * The ID of the trial log.
     * @type {string}
     * @memberof V1TrialLogsResponse
     */
    id: string;
    /**
     * The timestamp of the log.
     * @type {Date}
     * @memberof V1TrialLogsResponse
     */
    timestamp: Date;
    /**
     * The flat version of the log that UIs have shown historically.
     * @type {string}
     * @memberof V1TrialLogsResponse
     */
    message: string;
    /**
     * The level of the log.
     * @type {V1LogLevel}
     * @memberof V1TrialLogsResponse
     */
    level: V1LogLevel;
    /**
     * The ID of the trial associated with this log entry.
     * @type {number}
     * @memberof V1TrialLogsResponse
     */
    trialId: number;
    /**
     * The ID of the agent that logged this.
     * @type {string}
     * @memberof V1TrialLogsResponse
     */
    agentId?: string;
    /**
     * The ID of the container or, in the case of k8s, the pod name.
     * @type {string}
     * @memberof V1TrialLogsResponse
     */
    containerId?: string;
    /**
     * The rank ID.
     * @type {number}
     * @memberof V1TrialLogsResponse
     */
    rankId?: number;
    /**
     * The text of the log entry.
     * @type {string}
     * @memberof V1TrialLogsResponse
     */
    log?: string;
    /**
     * The source of the log entry.
     * @type {string}
     * @memberof V1TrialLogsResponse
     */
    source?: string;
    /**
     * The output stream (e.g. stdout, stderr).
     * @type {string}
     * @memberof V1TrialLogsResponse
     */
    stdtype?: string;
}
/**
 * Metrics from the trial some duration of training.
 * @export
 * @interface V1TrialMetrics
 */
export interface V1TrialMetrics {
    /**
     * The trial associated with these metrics.
     * @type {number}
     * @memberof V1TrialMetrics
     */
    trialId: number;
    /**
     * The trial run associated with these metrics.
     * @type {number}
     * @memberof V1TrialMetrics
     */
    trialRunId: number;
    /**
     * The number of batches trained on when these metrics were reported.
     * @type {number}
     * @memberof V1TrialMetrics
     */
    stepsCompleted: number;
    /**
     * The metrics for this bit of training, including: - avg_metrics: metrics reduced over the reporting period). - batch_metrics: (optional) per-batch metrics.
     * @type {V1Metrics}
     * @memberof V1TrialMetrics
     */
    metrics: V1Metrics;
}
/**
 * TrialOperation is any operation that a trial can perform while it is active.
 * @export
 * @interface V1TrialOperation
 */
export interface V1TrialOperation {
    /**
     * ValidateAfter means a trial is currently training and will later validate.
     * @type {V1ValidateAfterOperation}
     * @memberof V1TrialOperation
     */
    validateAfter?: V1ValidateAfterOperation;
}
/**
 * 
 * @export
 * @interface V1TrialProfilerMetricLabels
 */
export interface V1TrialProfilerMetricLabels {
    /**
     * The ID of the trial.
     * @type {number}
     * @memberof V1TrialProfilerMetricLabels
     */
    trialId: number;
    /**
     * The name of the metric.
     * @type {string}
     * @memberof V1TrialProfilerMetricLabels
     */
    name: string;
    /**
     * The agent ID associated with the metric.
     * @type {string}
     * @memberof V1TrialProfilerMetricLabels
     */
    agentId?: string;
    /**
     * The GPU UUID associated with the metric.
     * @type {string}
     * @memberof V1TrialProfilerMetricLabels
     */
    gpuUuid?: string;
    /**
     * The type of the metric.
     * @type {TrialProfilerMetricLabelsProfilerMetricType}
     * @memberof V1TrialProfilerMetricLabels
     */
    metricType?: TrialProfilerMetricLabelsProfilerMetricType;
}
/**
 * TrialProfilerMetricsBatch is a batch of trial profiler metrics. A batch will contain metrics pertaining to a single series. The fields values, batches and timestamps will be equal length arrays with each index corresponding to a reading.
 * @export
 * @interface V1TrialProfilerMetricsBatch
 */
export interface V1TrialProfilerMetricsBatch {
    /**
     * The measurement for a reading, repeated for the batch of metrics.
     * @type {Array<number>}
     * @memberof V1TrialProfilerMetricsBatch
     */
    values: Array<number>;
    /**
     * The batch at which a reading occurred, repeated for the batch of metrics.
     * @type {Array<number>}
     * @memberof V1TrialProfilerMetricsBatch
     */
    batches: Array<number>;
    /**
     * The timestamp at which a reading occurred, repeated for the batch of metrics.
     * @type {Array<Date>}
     * @memberof V1TrialProfilerMetricsBatch
     */
    timestamps: Array<Date>;
    /**
     * The labels for this series.
     * @type {V1TrialProfilerMetricLabels}
     * @memberof V1TrialProfilerMetricsBatch
     */
    labels: V1TrialProfilerMetricLabels;
}
/**
 * TrialProgress is a searcher event that tells you the number of batches completed in the trial.
 * @export
 * @interface V1TrialProgress
 */
export interface V1TrialProgress {
    /**
     * UUID identifying the trial to the searcher.
     * @type {string}
     * @memberof V1TrialProgress
     */
    requestId: string;
    /**
     * partial_units represent partial epochs, batches or records where the Unit is implied.
     * @type {number}
     * @memberof V1TrialProgress
     */
    partialUnits: number;
}
/**
 * The metadata pertaining to the current running task for a trial.
 * @export
 * @interface V1TrialRunnerMetadata
 */
export interface V1TrialRunnerMetadata {
    /**
     * The state of the trial runner.
     * @type {string}
     * @memberof V1TrialRunnerMetadata
     */
    state: string;
}
/**
 * TrialSimulation is a specific sequence of workloads that were run before the trial was completed.
 * @export
 * @interface V1TrialSimulation
 */
export interface V1TrialSimulation {
    /**
     * The list of operations that were run before the trial was completed.
     * @type {Array<V1RunnableOperation>}
     * @memberof V1TrialSimulation
     */
    operations?: Array<V1RunnableOperation>;
    /**
     * The number of times that this trial configuration has occurred during the simulation.
     * @type {number}
     * @memberof V1TrialSimulation
     */
    occurrences?: number;
}
/**
 * 
 * @export
 * @interface V1TrialSourceInfo
 */
export interface V1TrialSourceInfo {
    /**
     * ID of the trial.
     * @type {number}
     * @memberof V1TrialSourceInfo
     */
    trialId: number;
    /**
     * UUID of the checkpoint.
     * @type {string}
     * @memberof V1TrialSourceInfo
     */
    checkpointUuid: string;
    /**
     * Source `id`` for the model which generated the checkpoint (if applicable)
     * @type {number}
     * @memberof V1TrialSourceInfo
     */
    modelId?: number;
    /**
     * Source `version` in the model_version version field which generated the checkpoint (if applicable)
     * @type {number}
     * @memberof V1TrialSourceInfo
     */
    modelVersion?: number;
    /**
     * Type for this trial_source_info
     * @type {V1TrialSourceInfoType}
     * @memberof V1TrialSourceInfo
     */
    trialSourceInfoType: V1TrialSourceInfoType;
}
/**
 * - TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: The type is unspecified  - TRIAL_SOURCE_INFO_TYPE_INFERENCE: "Inference" Trial Source Info Type, used for batch inference  - TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: "Fine Tuning" Trial Source Info Type, used in model hub
 * @export
 * @enum {string}
 */
export const V1TrialSourceInfoType = {
    UNSPECIFIED: 'TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED',
    INFERENCE: 'TRIAL_SOURCE_INFO_TYPE_INFERENCE',
    FINETUNING: 'TRIAL_SOURCE_INFO_TYPE_FINE_TUNING',
} as const
export type V1TrialSourceInfoType = ValueOf<typeof V1TrialSourceInfoType>
/**
 * 
 * @export
 * @interface V1TrialsSampleResponse
 */
export interface V1TrialsSampleResponse {
    /**
     * A historical or incremental series of data points for the trials.
     * @type {Array<V1TrialsSampleResponseTrial>}
     * @memberof V1TrialsSampleResponse
     */
    trials: Array<V1TrialsSampleResponseTrial>;
    /**
     * IDs of trials that are newly included in the data.
     * @type {Array<number>}
     * @memberof V1TrialsSampleResponse
     */
    promotedTrials: Array<number>;
    /**
     * IDs of trials that are no longer included in the top N trials.
     * @type {Array<number>}
     * @memberof V1TrialsSampleResponse
     */
    demotedTrials: Array<number>;
}
/**
 * Metadata and metrics stream from a trial.
 * @export
 * @interface V1TrialsSampleResponseTrial
 */
export interface V1TrialsSampleResponseTrial {
    /**
     * The id of the trial.
     * @type {number}
     * @memberof V1TrialsSampleResponseTrial
     */
    trialId: number;
    /**
     * Hyperparamters values for this specific trial.
     * @type {any}
     * @memberof V1TrialsSampleResponseTrial
     */
    hparams: any;
    /**
     * A possibly down-sampled series of metric readings through the progress of the trial.
     * @type {Array<V1DataPoint>}
     * @memberof V1TrialsSampleResponseTrial
     */
    data: Array<V1DataPoint>;
}
/**
 * 
 * @export
 * @interface V1TrialsSnapshotResponse
 */
export interface V1TrialsSnapshotResponse {
    /**
     * A list of trials.
     * @type {Array<V1TrialsSnapshotResponseTrial>}
     * @memberof V1TrialsSnapshotResponse
     */
    trials: Array<V1TrialsSnapshotResponseTrial>;
}
/**
 * Metric value and metadata for a trial that has progress this far.
 * @export
 * @interface V1TrialsSnapshotResponseTrial
 */
export interface V1TrialsSnapshotResponseTrial {
    /**
     * The id of the trial.
     * @type {number}
     * @memberof V1TrialsSnapshotResponseTrial
     */
    trialId: number;
    /**
     * A dictionary of hyperparameter values for this trial.
     * @type {any}
     * @memberof V1TrialsSnapshotResponseTrial
     */
    hparams: any;
    /**
     * The value of the metric in this trial at this point.
     * @type {number}
     * @memberof V1TrialsSnapshotResponseTrial
     */
    metric: number;
    /**
     * The number of batches processed for this particular datapoint.
     * @type {number}
     * @memberof V1TrialsSnapshotResponseTrial
     */
    batchesProcessed: number;
}
/**
 * 
 * @export
 * @interface V1Trigger
 */
export interface V1Trigger {
    /**
     * The id of the trigger.
     * @type {number}
     * @memberof V1Trigger
     */
    id?: number;
    /**
     * The type of the trigger.
     * @type {V1TriggerType}
     * @memberof V1Trigger
     */
    triggerType?: V1TriggerType;
    /**
     * The trigger condition.
     * @type {any}
     * @memberof V1Trigger
     */
    condition?: any;
    /**
     * The parent webhook of the trigger.
     * @type {number}
     * @memberof V1Trigger
     */
    webhookId?: number;
}
/**
 * Enum values for expected trigger types.   - TRIGGER_TYPE_UNSPECIFIED: Default value  - TRIGGER_TYPE_EXPERIMENT_STATE_CHANGE: For an experiment changing state  - TRIGGER_TYPE_METRIC_THRESHOLD_EXCEEDED: For metrics emitted during training.
 * @export
 * @enum {string}
 */
export const V1TriggerType = {
    UNSPECIFIED: 'TRIGGER_TYPE_UNSPECIFIED',
    EXPERIMENTSTATECHANGE: 'TRIGGER_TYPE_EXPERIMENT_STATE_CHANGE',
    METRICTHRESHOLDEXCEEDED: 'TRIGGER_TYPE_METRIC_THRESHOLD_EXCEEDED',
} as const
export type V1TriggerType = ValueOf<typeof V1TriggerType>
/**
 * Response to UnarchiveExperimentRequest.
 * @export
 * @interface V1UnarchiveExperimentResponse
 */
export interface V1UnarchiveExperimentResponse {
}
/**
 * Unarchive multiple experiments.
 * @export
 * @interface V1UnarchiveExperimentsRequest
 */
export interface V1UnarchiveExperimentsRequest {
    /**
     * Selecting experiments by id.
     * @type {Array<number>}
     * @memberof V1UnarchiveExperimentsRequest
     */
    experimentIds: Array<number>;
    /**
     * Targets all experiments matching filters.
     * @type {V1BulkExperimentFilters}
     * @memberof V1UnarchiveExperimentsRequest
     */
    filters?: V1BulkExperimentFilters;
}
/**
 * Response to UnarchiveExperimentsRequest.
 * @export
 * @interface V1UnarchiveExperimentsResponse
 */
export interface V1UnarchiveExperimentsResponse {
    /**
     * Details on success or error for each experiment.
     * @type {Array<V1ExperimentActionResult>}
     * @memberof V1UnarchiveExperimentsResponse
     */
    results: Array<V1ExperimentActionResult>;
}
/**
 * 
 * @export
 * @interface V1UnarchiveModelResponse
 */
export interface V1UnarchiveModelResponse {
}
/**
 * Response to UnarchiveProjectRequest.
 * @export
 * @interface V1UnarchiveProjectResponse
 */
export interface V1UnarchiveProjectResponse {
}
/**
 * Response to UnarchiveWorkspaceRequest.
 * @export
 * @interface V1UnarchiveWorkspaceResponse
 */
export interface V1UnarchiveWorkspaceResponse {
}
/**
 * Unbind a resource pool to workspaces.
 * @export
 * @interface V1UnbindRPFromWorkspaceRequest
 */
export interface V1UnbindRPFromWorkspaceRequest {
    /**
     * The resource pool name.
     * @type {string}
     * @memberof V1UnbindRPFromWorkspaceRequest
     */
    resourcePoolName: string;
    /**
     * The workspace IDs to be unbound.
     * @type {Array<number>}
     * @memberof V1UnbindRPFromWorkspaceRequest
     */
    workspaceIds?: Array<number>;
    /**
     * The workspace names to be unbound.
     * @type {Array<string>}
     * @memberof V1UnbindRPFromWorkspaceRequest
     */
    workspaceNames?: Array<string>;
}
/**
 * Unbind a resource pool to workspaces response.
 * @export
 * @interface V1UnbindRPFromWorkspaceResponse
 */
export interface V1UnbindRPFromWorkspaceResponse {
}
/**
 * Response to UnpinWorkspaceRequest.
 * @export
 * @interface V1UnpinWorkspaceResponse
 */
export interface V1UnpinWorkspaceResponse {
}
/**
 * UpdateGroupRequest is the body of the request for the call to update a group and its members.
 * @export
 * @interface V1UpdateGroupRequest
 */
export interface V1UpdateGroupRequest {
    /**
     * The id of the group
     * @type {number}
     * @memberof V1UpdateGroupRequest
     */
    groupId: number;
    /**
     * The name of the group
     * @type {string}
     * @memberof V1UpdateGroupRequest
     */
    name?: string;
    /**
     * The user ids of users to add to the group
     * @type {Array<number>}
     * @memberof V1UpdateGroupRequest
     */
    addUsers?: Array<number>;
    /**
     * The user ids of users to delete from the group
     * @type {Array<number>}
     * @memberof V1UpdateGroupRequest
     */
    removeUsers?: Array<number>;
}
/**
 * UpdateGroupResponse is the body of the response for the call to update a group and its members.
 * @export
 * @interface V1UpdateGroupResponse
 */
export interface V1UpdateGroupResponse {
    /**
     * Info about the group after the update succeeded.
     * @type {V1GroupDetails}
     * @memberof V1UpdateGroupResponse
     */
    group: V1GroupDetails;
}
/**
 * Request to update the job queue.
 * @export
 * @interface V1UpdateJobQueueRequest
 */
export interface V1UpdateJobQueueRequest {
    /**
     * List of job queue control requests.
     * @type {Array<V1QueueControl>}
     * @memberof V1UpdateJobQueueRequest
     */
    updates: Array<V1QueueControl>;
}
/**
 * Response to UpdateJobQueueRequest.
 * @export
 * @interface V1UpdateJobQueueResponse
 */
export interface V1UpdateJobQueueResponse {
}
/**
 * User is an account in the determined cluster.
 * @export
 * @interface V1User
 */
export interface V1User {
    /**
     * The user ID.
     * @type {number}
     * @memberof V1User
     */
    id?: number;
    /**
     * The user login name of the user.
     * @type {string}
     * @memberof V1User
     */
    username: string;
    /**
     * Bool denoting whether the account is an admin account.
     * @type {boolean}
     * @memberof V1User
     */
    admin: boolean;
    /**
     * Bool denoting whether the account is active.
     * @type {boolean}
     * @memberof V1User
     */
    active: boolean;
    /**
     * The user and group on the agent host machine.
     * @type {V1AgentUserGroup}
     * @memberof V1User
     */
    agentUserGroup?: V1AgentUserGroup;
    /**
     * Name to display in the web UI.
     * @type {string}
     * @memberof V1User
     */
    displayName?: string;
    /**
     * The version of the user object for caching purposes.
     * @type {Date}
     * @memberof V1User
     */
    modifiedAt?: Date;
    /**
     * Bool denoting whether the user should be able to login with or change a password.
     * @type {boolean}
     * @memberof V1User
     */
    remote?: boolean;
}
/**
 * UserRoleAssignment contains information about the users belonging to a role.
 * @export
 * @interface V1UserRoleAssignment
 */
export interface V1UserRoleAssignment {
    /**
     * the user id of the role assignment
     * @type {number}
     * @memberof V1UserRoleAssignment
     */
    userId: number;
    /**
     * the role and scope of the assignment
     * @type {V1RoleAssignment}
     * @memberof V1UserRoleAssignment
     */
    roleAssignment: V1RoleAssignment;
}
/**
 * UserWebSetting represents user web setting.
 * @export
 * @interface V1UserWebSetting
 */
export interface V1UserWebSetting {
    /**
     * The key of setting.
     * @type {string}
     * @memberof V1UserWebSetting
     */
    key: string;
    /**
     * The storage path of setting.
     * @type {string}
     * @memberof V1UserWebSetting
     */
    storagePath?: string;
    /**
     * The value of setting.
     * @type {string}
     * @memberof V1UserWebSetting
     */
    value?: string;
}
/**
 * ValidateAfterOperation means the trial should train and validate after training the given length.
 * @export
 * @interface V1ValidateAfterOperation
 */
export interface V1ValidateAfterOperation {
    /**
     * The ID of the trial that should train.
     * @type {string}
     * @memberof V1ValidateAfterOperation
     */
    requestId?: string;
    /**
     * The length to train before reporting a validation.
     * @type {string}
     * @memberof V1ValidateAfterOperation
     */
    length?: string;
}
/**
 * ValidationCompleted is a searcher event triggered when a validation has been completed.
 * @export
 * @interface V1ValidationCompleted
 */
export interface V1ValidationCompleted {
    /**
     * UUID identifying the trial to the searcher.
     * @type {string}
     * @memberof V1ValidationCompleted
     */
    requestId: string;
    /**
     * Value of the validation metric used to direct the search.
     * @type {any}
     * @memberof V1ValidationCompleted
     */
    metric: any;
    /**
     * Length from ValidateAfterOperation.
     * @type {string}
     * @memberof V1ValidationCompleted
     */
    validateAfterLength: string;
}
/**
 * ValidationHistoryEntry is a single entry for a validation history for an experiment.
 * @export
 * @interface V1ValidationHistoryEntry
 */
export interface V1ValidationHistoryEntry {
    /**
     * The id for the trial associated with this validation entry.
     * @type {number}
     * @memberof V1ValidationHistoryEntry
     */
    trialId: number;
    /**
     * The time at which the completed validation was reported.
     * @type {Date}
     * @memberof V1ValidationHistoryEntry
     */
    endTime: Date;
    /**
     * The value of the `searcher.metric`, indicated by the experiment config, for the validation.
     * @type {number}
     * @memberof V1ValidationHistoryEntry
     */
    searcherMetric: number;
}
/**
 * 
 * @export
 * @interface V1Webhook
 */
export interface V1Webhook {
    /**
     * The id of the webhook.
     * @type {number}
     * @memberof V1Webhook
     */
    id?: number;
    /**
     * The url of the webhook.
     * @type {string}
     * @memberof V1Webhook
     */
    url: string;
    /**
     * The triggers of the webhook.
     * @type {Array<V1Trigger>}
     * @memberof V1Webhook
     */
    triggers?: Array<V1Trigger>;
    /**
     * The type of the webhook.
     * @type {V1WebhookType}
     * @memberof V1Webhook
     */
    webhookType: V1WebhookType;
}
/**
 * Enum values for expected webhook types.   - WEBHOOK_TYPE_UNSPECIFIED: Default value  - WEBHOOK_TYPE_DEFAULT: For a default webhook  - WEBHOOK_TYPE_SLACK: For a slack webhook.
 * @export
 * @enum {string}
 */
export const V1WebhookType = {
    UNSPECIFIED: 'WEBHOOK_TYPE_UNSPECIFIED',
    DEFAULT: 'WEBHOOK_TYPE_DEFAULT',
    SLACK: 'WEBHOOK_TYPE_SLACK',
} as const
export type V1WebhookType = ValueOf<typeof V1WebhookType>
/**
 * WorkloadContainer is a wrapper for Determined workloads to allow repeated oneof types.
 * @export
 * @interface V1WorkloadContainer
 */
export interface V1WorkloadContainer {
    /**
     * Training workload.
     * @type {V1MetricsWorkload}
     * @memberof V1WorkloadContainer
     */
    training?: V1MetricsWorkload;
    /**
     * Validation workload.
     * @type {V1MetricsWorkload}
     * @memberof V1WorkloadContainer
     */
    validation?: V1MetricsWorkload;
    /**
     * Checkpoint workload.
     * @type {V1CheckpointWorkload}
     * @memberof V1WorkloadContainer
     */
    checkpoint?: V1CheckpointWorkload;
}
/**
 * Workspace is a named collection of projects.
 * @export
 * @interface V1Workspace
 */
export interface V1Workspace {
    /**
     * The unique id of the workspace.
     * @type {number}
     * @memberof V1Workspace
     */
    id: number;
    /**
     * The unique name of the workspace.
     * @type {string}
     * @memberof V1Workspace
     */
    name: string;
    /**
     * Whether this workspace is archived or not.
     * @type {boolean}
     * @memberof V1Workspace
     */
    archived: boolean;
    /**
     * User who created this workspace.
     * @type {string}
     * @memberof V1Workspace
     */
    username: string;
    /**
     * Whether this workspace is immutable (default uncategorized workspace).
     * @type {boolean}
     * @memberof V1Workspace
     */
    immutable: boolean;
    /**
     * Number of projects associated with this workspace.
     * @type {number}
     * @memberof V1Workspace
     */
    numProjects: number;
    /**
     * Pin status of this workspace for the current user.
     * @type {boolean}
     * @memberof V1Workspace
     */
    pinned: boolean;
    /**
     * ID of the user who created this project.
     * @type {number}
     * @memberof V1Workspace
     */
    userId: number;
    /**
     * Number of experiments associated with this workspace.
     * @type {number}
     * @memberof V1Workspace
     */
    numExperiments: number;
    /**
     * State of workspace during deletion.
     * @type {V1WorkspaceState}
     * @memberof V1Workspace
     */
    state: V1WorkspaceState;
    /**
     * Message stored from errors on async-deleting a workspace.
     * @type {string}
     * @memberof V1Workspace
     */
    errorMessage: string;
    /**
     * Optional agent host uid and gid override.
     * @type {V1AgentUserGroup}
     * @memberof V1Workspace
     */
    agentUserGroup?: V1AgentUserGroup;
    /**
     * Optional checkpoint storage config. Expects same format as experiment config's checkpoint storage.
     * @type {any}
     * @memberof V1Workspace
     */
    checkpointStorageConfig?: any;
    /**
     * Optional date when workspace was pinned.
     * @type {Date}
     * @memberof V1Workspace
     */
    pinnedAt?: Date;
    /**
     * Name of the default compute pool.
     * @type {string}
     * @memberof V1Workspace
     */
    defaultComputePool?: string;
    /**
     * Name of the default aux pool.
     * @type {string}
     * @memberof V1Workspace
     */
    defaultAuxPool?: string;
}
/**
 * WorkspaceState is used to track progress during a deletion.   - WORKSPACE_STATE_UNSPECIFIED: Object deletion is not in progress.  - WORKSPACE_STATE_DELETING: The object is being deleted.  - WORKSPACE_STATE_DELETE_FAILED: The object failed to delete.  - WORKSPACE_STATE_DELETED: The object finished deleting.
 * @export
 * @enum {string}
 */
export const V1WorkspaceState = {
    UNSPECIFIED: 'WORKSPACE_STATE_UNSPECIFIED',
    DELETING: 'WORKSPACE_STATE_DELETING',
    DELETEFAILED: 'WORKSPACE_STATE_DELETE_FAILED',
    DELETED: 'WORKSPACE_STATE_DELETED',
} as const
export type V1WorkspaceState = ValueOf<typeof V1WorkspaceState>
/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUser(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/auth/user`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login the user.
         * @param {V1LoginRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1LoginRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling login.');
            }
            const localVarPath = `/api/v1/auth/login`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/auth/logout`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CurrentUserResponse> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).currentUser(options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Login the user.
         * @param {V1LoginRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1LoginRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LoginResponse> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).login(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Logout the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LogoutResponse> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).logout(options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUser(options?: any) {
            return AuthenticationApiFp(configuration).currentUser(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login the user.
         * @param {V1LoginRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1LoginRequest, options?: any) {
            return AuthenticationApiFp(configuration).login(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logout the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any) {
            return AuthenticationApiFp(configuration).logout(options)(fetch, basePath);
        },
    }
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Get the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public currentUser(options?: any) {
        return AuthenticationApiFp(this.configuration).currentUser(options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Login the user.
     * @param {V1LoginRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(body: V1LoginRequest, options?: any) {
        return AuthenticationApiFp(this.configuration).login(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Logout the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(options?: any) {
        return AuthenticationApiFp(this.configuration).logout(options)(this.fetch, this.basePath)
    }
    
}

/**
 * CheckpointsApi - fetch parameter creator
 * @export
 */
export const CheckpointsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove files from checkpoints.
         * @param {V1CheckpointsRemoveFilesRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkpointsRemoveFiles(body: V1CheckpointsRemoveFilesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling checkpointsRemoveFiles.');
            }
            const localVarPath = `/api/v1/checkpoints/rm`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Checkpoints.
         * @param {V1DeleteCheckpointsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckpoints(body: V1DeleteCheckpointsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteCheckpoints.');
            }
            const localVarPath = `/api/v1/checkpoints`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'DELETE', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested checkpoint.
         * @param {string} checkpointUuid The uuid for the requested checkpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckpoint(checkpointUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'checkpointUuid' is not null or undefined
            if (checkpointUuid === null || checkpointUuid === undefined) {
                throw new RequiredError('checkpointUuid','Required parameter checkpointUuid was null or undefined when calling getCheckpoint.');
            }
            const localVarPath = `/api/v1/checkpoints/{checkpointUuid}`
                .replace(`{${"checkpointUuid"}}`, encodeURIComponent(String(checkpointUuid)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update checkpoint metadata.
         * @param {string} checkpointUuid UUID of the checkpoint.
         * @param {V1PostCheckpointMetadataRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCheckpointMetadata(checkpointUuid: string, body: V1PostCheckpointMetadataRequest, options: any = {}): FetchArgs {
            // verify required parameter 'checkpointUuid' is not null or undefined
            if (checkpointUuid === null || checkpointUuid === undefined) {
                throw new RequiredError('checkpointUuid','Required parameter checkpointUuid was null or undefined when calling postCheckpointMetadata.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postCheckpointMetadata.');
            }
            const localVarPath = `/api/v1/checkpoints/{checkpointUuid}/metadata`
                .replace(`{${"checkpointUuid"}}`, encodeURIComponent(String(checkpointUuid)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckpointsApi - functional programming interface
 * @export
 */
export const CheckpointsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove files from checkpoints.
         * @param {V1CheckpointsRemoveFilesRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkpointsRemoveFiles(body: V1CheckpointsRemoveFilesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CheckpointsRemoveFilesResponse> {
            const localVarFetchArgs = CheckpointsApiFetchParamCreator(configuration).checkpointsRemoveFiles(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Checkpoints.
         * @param {V1DeleteCheckpointsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckpoints(body: V1DeleteCheckpointsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeleteCheckpointsResponse> {
            const localVarFetchArgs = CheckpointsApiFetchParamCreator(configuration).deleteCheckpoints(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested checkpoint.
         * @param {string} checkpointUuid The uuid for the requested checkpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckpoint(checkpointUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetCheckpointResponse> {
            const localVarFetchArgs = CheckpointsApiFetchParamCreator(configuration).getCheckpoint(checkpointUuid, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update checkpoint metadata.
         * @param {string} checkpointUuid UUID of the checkpoint.
         * @param {V1PostCheckpointMetadataRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCheckpointMetadata(checkpointUuid: string, body: V1PostCheckpointMetadataRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostCheckpointMetadataResponse> {
            const localVarFetchArgs = CheckpointsApiFetchParamCreator(configuration).postCheckpointMetadata(checkpointUuid, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckpointsApi - factory interface
 * @export
 */
export const CheckpointsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Remove files from checkpoints.
         * @param {V1CheckpointsRemoveFilesRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkpointsRemoveFiles(body: V1CheckpointsRemoveFilesRequest, options?: any) {
            return CheckpointsApiFp(configuration).checkpointsRemoveFiles(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Checkpoints.
         * @param {V1DeleteCheckpointsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckpoints(body: V1DeleteCheckpointsRequest, options?: any) {
            return CheckpointsApiFp(configuration).deleteCheckpoints(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested checkpoint.
         * @param {string} checkpointUuid The uuid for the requested checkpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckpoint(checkpointUuid: string, options?: any) {
            return CheckpointsApiFp(configuration).getCheckpoint(checkpointUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update checkpoint metadata.
         * @param {string} checkpointUuid UUID of the checkpoint.
         * @param {V1PostCheckpointMetadataRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCheckpointMetadata(checkpointUuid: string, body: V1PostCheckpointMetadataRequest, options?: any) {
            return CheckpointsApiFp(configuration).postCheckpointMetadata(checkpointUuid, body, options)(fetch, basePath);
        },
    }
};

/**
 * CheckpointsApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class CheckpointsApi extends BaseAPI {
    /**
     * 
     * @summary Remove files from checkpoints.
     * @param {V1CheckpointsRemoveFilesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckpointsApi
     */
    public checkpointsRemoveFiles(body: V1CheckpointsRemoveFilesRequest, options?: any) {
        return CheckpointsApiFp(this.configuration).checkpointsRemoveFiles(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Delete Checkpoints.
     * @param {V1DeleteCheckpointsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckpointsApi
     */
    public deleteCheckpoints(body: V1DeleteCheckpointsRequest, options?: any) {
        return CheckpointsApiFp(this.configuration).deleteCheckpoints(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the requested checkpoint.
     * @param {string} checkpointUuid The uuid for the requested checkpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckpointsApi
     */
    public getCheckpoint(checkpointUuid: string, options?: any) {
        return CheckpointsApiFp(this.configuration).getCheckpoint(checkpointUuid, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Update checkpoint metadata.
     * @param {string} checkpointUuid UUID of the checkpoint.
     * @param {V1PostCheckpointMetadataRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckpointsApi
     */
    public postCheckpointMetadata(checkpointUuid: string, body: V1PostCheckpointMetadataRequest, options?: any) {
        return CheckpointsApiFp(this.configuration).postCheckpointMetadata(checkpointUuid, body, options)(this.fetch, this.basePath)
    }
    
}

/**
 * ClusterApi - fetch parameter creator
 * @export
 */
export const ClusterApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Disable the agent.
         * @param {string} agentId The id of the agent.
         * @param {V1DisableAgentRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableAgent(agentId: string, body: V1DisableAgentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling disableAgent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling disableAgent.');
            }
            const localVarPath = `/api/v1/agents/{agentId}/disable`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {V1DisableSlotRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableSlot(agentId: string, slotId: string, body: V1DisableSlotRequest, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling disableSlot.');
            }
            // verify required parameter 'slotId' is not null or undefined
            if (slotId === null || slotId === undefined) {
                throw new RequiredError('slotId','Required parameter slotId was null or undefined when calling disableSlot.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling disableSlot.');
            }
            const localVarPath = `/api/v1/agents/{agentId}/slots/{slotId}/disable`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"slotId"}}`, encodeURIComponent(String(slotId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable the agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableAgent(agentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling enableAgent.');
            }
            const localVarPath = `/api/v1/agents/{agentId}/enable`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableSlot(agentId: string, slotId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling enableSlot.');
            }
            // verify required parameter 'slotId' is not null or undefined
            if (slotId === null || slotId === undefined) {
                throw new RequiredError('slotId','Required parameter slotId was null or undefined when calling enableSlot.');
            }
            const localVarPath = `/api/v1/agents/{agentId}/slots/{slotId}/enable`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"slotId"}}`, encodeURIComponent(String(slotId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent(agentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling getAgent.');
            }
            const localVarPath = `/api/v1/agents/{agentId}`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of agents from the cluster.
         * @param {V1GetAgentsRequestSortBy} [sortBy] Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
         * @param {V1OrderBy} [orderBy] Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of agents before returning results. Negative values denote number of agents to skip from the end before returning results.
         * @param {number} [limit] Limit the number of agents. A value of 0 denotes no limit.
         * @param {string} [label] This field has been deprecated and will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgents(sortBy?: V1GetAgentsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, label?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/agents`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (label !== undefined) {
                localVarQueryParameter['label'] = label
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get master information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaster(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/master`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get master config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterConfig(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/master/config`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested slot for an agent.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlot(agentId: string, slotId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling getSlot.');
            }
            // verify required parameter 'slotId' is not null or undefined
            if (slotId === null || slotId === undefined) {
                throw new RequiredError('slotId','Required parameter slotId was null or undefined when calling getSlot.');
            }
            const localVarPath = `/api/v1/agents/{agentId}/slots/{slotId}`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"slotId"}}`, encodeURIComponent(String(slotId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the slots for an agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlots(agentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling getSlots.');
            }
            const localVarPath = `/api/v1/agents/{agentId}/slots`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream master logs.
         * @param {number} [offset] Skip the number of master logs before returning results. Negative values denote number of master logs to skip from the end before returning results.
         * @param {number} [limit] Limit the number of master logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the master stops or the limit is reached.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        masterLogs(offset?: number, limit?: number, follow?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/master/logs`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch master config.
         * @param {V1PatchMasterConfigRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterConfig(body: V1PatchMasterConfigRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchMasterConfig.');
            }
            const localVarPath = `/api/v1/master/config`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PATCH', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an aggregated view of resource allocation during the given time period.
         * @param {string} startDate The first day to consider (the exact time is midnight UTC at the beginning of the day).
         * @param {string} endDate The last day to consider (the exact time is midnight UTC at the end of the day).
         * @param {V1ResourceAllocationAggregationPeriod} period The period over which to perform aggregation.   - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceAllocationAggregated(startDate: string, endDate: string, period: V1ResourceAllocationAggregationPeriod, options: any = {}): FetchArgs {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling resourceAllocationAggregated.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling resourceAllocationAggregated.');
            }
            // verify required parameter 'period' is not null or undefined
            if (period === null || period === undefined) {
                throw new RequiredError('period','Required parameter period was null or undefined when calling resourceAllocationAggregated.');
            }
            const localVarPath = `/api/v1/resources/allocation/aggregated`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate
            }
            
            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate
            }
            
            if (period !== undefined) {
                localVarQueryParameter['period'] = period
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a detailed view of resource allocation during the given time period.
         * @param {Date} timestampAfter The start of the period to consider.
         * @param {Date} timestampBefore The end of the period to consider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceAllocationRaw(timestampAfter: Date, timestampBefore: Date, options: any = {}): FetchArgs {
            // verify required parameter 'timestampAfter' is not null or undefined
            if (timestampAfter === null || timestampAfter === undefined) {
                throw new RequiredError('timestampAfter','Required parameter timestampAfter was null or undefined when calling resourceAllocationRaw.');
            }
            // verify required parameter 'timestampBefore' is not null or undefined
            if (timestampBefore === null || timestampBefore === undefined) {
                throw new RequiredError('timestampBefore','Required parameter timestampBefore was null or undefined when calling resourceAllocationRaw.');
            }
            const localVarPath = `/api/v1/resources/allocation/raw`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (timestampAfter) {
                localVarQueryParameter['timestampAfter'] = timestampAfter.toISOString()
            }
            
            if (timestampBefore) {
                localVarQueryParameter['timestampBefore'] = timestampBefore.toISOString()
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterApi - functional programming interface
 * @export
 */
export const ClusterApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Disable the agent.
         * @param {string} agentId The id of the agent.
         * @param {V1DisableAgentRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableAgent(agentId: string, body: V1DisableAgentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DisableAgentResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).disableAgent(agentId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Disable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {V1DisableSlotRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableSlot(agentId: string, slotId: string, body: V1DisableSlotRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DisableSlotResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).disableSlot(agentId, slotId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Enable the agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableAgent(agentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1EnableAgentResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).enableAgent(agentId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Enable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableSlot(agentId: string, slotId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1EnableSlotResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).enableSlot(agentId, slotId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent(agentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetAgentResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).getAgent(agentId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a set of agents from the cluster.
         * @param {V1GetAgentsRequestSortBy} [sortBy] Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
         * @param {V1OrderBy} [orderBy] Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of agents before returning results. Negative values denote number of agents to skip from the end before returning results.
         * @param {number} [limit] Limit the number of agents. A value of 0 denotes no limit.
         * @param {string} [label] This field has been deprecated and will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgents(sortBy?: V1GetAgentsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, label?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetAgentsResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).getAgents(sortBy, orderBy, offset, limit, label, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get master information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaster(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetMasterResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).getMaster(options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get master config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterConfig(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetMasterConfigResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).getMasterConfig(options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested slot for an agent.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlot(agentId: string, slotId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetSlotResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).getSlot(agentId, slotId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all the slots for an agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlots(agentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetSlotsResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).getSlots(agentId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream master logs.
         * @param {number} [offset] Skip the number of master logs before returning results. Negative values denote number of master logs to skip from the end before returning results.
         * @param {number} [limit] Limit the number of master logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the master stops or the limit is reached.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        masterLogs(offset?: number, limit?: number, follow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1MasterLogsResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).masterLogs(offset, limit, follow, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch master config.
         * @param {V1PatchMasterConfigRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterConfig(body: V1PatchMasterConfigRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PatchMasterConfigResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).patchMasterConfig(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get an aggregated view of resource allocation during the given time period.
         * @param {string} startDate The first day to consider (the exact time is midnight UTC at the beginning of the day).
         * @param {string} endDate The last day to consider (the exact time is midnight UTC at the end of the day).
         * @param {V1ResourceAllocationAggregationPeriod} period The period over which to perform aggregation.   - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceAllocationAggregated(startDate: string, endDate: string, period: V1ResourceAllocationAggregationPeriod, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ResourceAllocationAggregatedResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).resourceAllocationAggregated(startDate, endDate, period, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a detailed view of resource allocation during the given time period.
         * @param {Date} timestampAfter The start of the period to consider.
         * @param {Date} timestampBefore The end of the period to consider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceAllocationRaw(timestampAfter: Date, timestampBefore: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ResourceAllocationRawResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).resourceAllocationRaw(timestampAfter, timestampBefore, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClusterApi - factory interface
 * @export
 */
export const ClusterApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Disable the agent.
         * @param {string} agentId The id of the agent.
         * @param {V1DisableAgentRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableAgent(agentId: string, body: V1DisableAgentRequest, options?: any) {
            return ClusterApiFp(configuration).disableAgent(agentId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Disable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {V1DisableSlotRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableSlot(agentId: string, slotId: string, body: V1DisableSlotRequest, options?: any) {
            return ClusterApiFp(configuration).disableSlot(agentId, slotId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Enable the agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableAgent(agentId: string, options?: any) {
            return ClusterApiFp(configuration).enableAgent(agentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Enable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableSlot(agentId: string, slotId: string, options?: any) {
            return ClusterApiFp(configuration).enableSlot(agentId, slotId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent(agentId: string, options?: any) {
            return ClusterApiFp(configuration).getAgent(agentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a set of agents from the cluster.
         * @param {V1GetAgentsRequestSortBy} [sortBy] Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
         * @param {V1OrderBy} [orderBy] Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of agents before returning results. Negative values denote number of agents to skip from the end before returning results.
         * @param {number} [limit] Limit the number of agents. A value of 0 denotes no limit.
         * @param {string} [label] This field has been deprecated and will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgents(sortBy?: V1GetAgentsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, label?: string, options?: any) {
            return ClusterApiFp(configuration).getAgents(sortBy, orderBy, offset, limit, label, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get master information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaster(options?: any) {
            return ClusterApiFp(configuration).getMaster(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get master config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterConfig(options?: any) {
            return ClusterApiFp(configuration).getMasterConfig(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested slot for an agent.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlot(agentId: string, slotId: string, options?: any) {
            return ClusterApiFp(configuration).getSlot(agentId, slotId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all the slots for an agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlots(agentId: string, options?: any) {
            return ClusterApiFp(configuration).getSlots(agentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream master logs.
         * @param {number} [offset] Skip the number of master logs before returning results. Negative values denote number of master logs to skip from the end before returning results.
         * @param {number} [limit] Limit the number of master logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the master stops or the limit is reached.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        masterLogs(offset?: number, limit?: number, follow?: boolean, options?: any) {
            return ClusterApiFp(configuration).masterLogs(offset, limit, follow, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch master config.
         * @param {V1PatchMasterConfigRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMasterConfig(body: V1PatchMasterConfigRequest, options?: any) {
            return ClusterApiFp(configuration).patchMasterConfig(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get an aggregated view of resource allocation during the given time period.
         * @param {string} startDate The first day to consider (the exact time is midnight UTC at the beginning of the day).
         * @param {string} endDate The last day to consider (the exact time is midnight UTC at the end of the day).
         * @param {V1ResourceAllocationAggregationPeriod} period The period over which to perform aggregation.   - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceAllocationAggregated(startDate: string, endDate: string, period: V1ResourceAllocationAggregationPeriod, options?: any) {
            return ClusterApiFp(configuration).resourceAllocationAggregated(startDate, endDate, period, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a detailed view of resource allocation during the given time period.
         * @param {Date} timestampAfter The start of the period to consider.
         * @param {Date} timestampBefore The end of the period to consider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceAllocationRaw(timestampAfter: Date, timestampBefore: Date, options?: any) {
            return ClusterApiFp(configuration).resourceAllocationRaw(timestampAfter, timestampBefore, options)(fetch, basePath);
        },
    }
};

/**
 * ClusterApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class ClusterApi extends BaseAPI {
    /**
     * 
     * @summary Disable the agent.
     * @param {string} agentId The id of the agent.
     * @param {V1DisableAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public disableAgent(agentId: string, body: V1DisableAgentRequest, options?: any) {
        return ClusterApiFp(this.configuration).disableAgent(agentId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Disable the slot.
     * @param {string} agentId The id of the agent.
     * @param {string} slotId The id of the slot.
     * @param {V1DisableSlotRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public disableSlot(agentId: string, slotId: string, body: V1DisableSlotRequest, options?: any) {
        return ClusterApiFp(this.configuration).disableSlot(agentId, slotId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Enable the agent.
     * @param {string} agentId The id of the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public enableAgent(agentId: string, options?: any) {
        return ClusterApiFp(this.configuration).enableAgent(agentId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Enable the slot.
     * @param {string} agentId The id of the agent.
     * @param {string} slotId The id of the slot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public enableSlot(agentId: string, slotId: string, options?: any) {
        return ClusterApiFp(this.configuration).enableSlot(agentId, slotId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the requested agent.
     * @param {string} agentId The id of the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public getAgent(agentId: string, options?: any) {
        return ClusterApiFp(this.configuration).getAgent(agentId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a set of agents from the cluster.
     * @param {V1GetAgentsRequestSortBy} [sortBy] Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
     * @param {V1OrderBy} [orderBy] Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of agents before returning results. Negative values denote number of agents to skip from the end before returning results.
     * @param {number} [limit] Limit the number of agents. A value of 0 denotes no limit.
     * @param {string} [label] This field has been deprecated and will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public getAgents(sortBy?: V1GetAgentsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, label?: string, options?: any) {
        return ClusterApiFp(this.configuration).getAgents(sortBy, orderBy, offset, limit, label, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get master information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public getMaster(options?: any) {
        return ClusterApiFp(this.configuration).getMaster(options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get master config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public getMasterConfig(options?: any) {
        return ClusterApiFp(this.configuration).getMasterConfig(options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the requested slot for an agent.
     * @param {string} agentId The id of the agent.
     * @param {string} slotId The id of the slot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public getSlot(agentId: string, slotId: string, options?: any) {
        return ClusterApiFp(this.configuration).getSlot(agentId, slotId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get all the slots for an agent.
     * @param {string} agentId The id of the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public getSlots(agentId: string, options?: any) {
        return ClusterApiFp(this.configuration).getSlots(agentId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Stream master logs.
     * @param {number} [offset] Skip the number of master logs before returning results. Negative values denote number of master logs to skip from the end before returning results.
     * @param {number} [limit] Limit the number of master logs. A value of 0 denotes no limit.
     * @param {boolean} [follow] Continue following logs until the master stops or the limit is reached.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public masterLogs(offset?: number, limit?: number, follow?: boolean, options?: any) {
        return ClusterApiFp(this.configuration).masterLogs(offset, limit, follow, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Patch master config.
     * @param {V1PatchMasterConfigRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public patchMasterConfig(body: V1PatchMasterConfigRequest, options?: any) {
        return ClusterApiFp(this.configuration).patchMasterConfig(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get an aggregated view of resource allocation during the given time period.
     * @param {string} startDate The first day to consider (the exact time is midnight UTC at the beginning of the day).
     * @param {string} endDate The last day to consider (the exact time is midnight UTC at the end of the day).
     * @param {V1ResourceAllocationAggregationPeriod} period The period over which to perform aggregation.   - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public resourceAllocationAggregated(startDate: string, endDate: string, period: V1ResourceAllocationAggregationPeriod, options?: any) {
        return ClusterApiFp(this.configuration).resourceAllocationAggregated(startDate, endDate, period, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a detailed view of resource allocation during the given time period.
     * @param {Date} timestampAfter The start of the period to consider.
     * @param {Date} timestampBefore The end of the period to consider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public resourceAllocationRaw(timestampAfter: Date, timestampBefore: Date, options?: any) {
        return ClusterApiFp(this.configuration).resourceAllocationRaw(timestampAfter, timestampBefore, options)(this.fetch, this.basePath)
    }
    
}

/**
 * CommandsApi - fetch parameter creator
 * @export
 */
export const CommandsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested command.
         * @param {string} commandId The id of the command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommand(commandId: string, options: any = {}): FetchArgs {
            // verify required parameter 'commandId' is not null or undefined
            if (commandId === null || commandId === undefined) {
                throw new RequiredError('commandId','Required parameter commandId was null or undefined when calling getCommand.');
            }
            const localVarPath = `/api/v1/commands/{commandId}`
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of commands.
         * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort commands by the given field.   - SORT_BY_UNSPECIFIED: Returns commands in an unsorted list.  - SORT_BY_ID: Returns commands sorted by id.  - SORT_BY_DESCRIPTION: Returns commands sorted by description.  - SORT_BY_START_TIME: Return commands sorted by start time.  - SORT_BY_WORKSPACE_ID: Return commands sorted by workspace_id.
         * @param {V1OrderBy} [orderBy] Order commands in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of commands before returning results. Negative values denote number of commands to skip from the end before returning results.
         * @param {number} [limit] Limit the number of commands. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit commands to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit commands to those that are owned by users with the specified userIds.
         * @param {number} [workspaceId] Limit commands to those within a specific workspace, or 0 for all accessible workspaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommands(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/commands`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (users) {
                localVarQueryParameter['users'] = users
            }
            
            if (userIds) {
                localVarQueryParameter['userIds'] = userIds
            }
            
            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill the requested command.
         * @param {string} commandId The id of the command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killCommand(commandId: string, options: any = {}): FetchArgs {
            // verify required parameter 'commandId' is not null or undefined
            if (commandId === null || commandId === undefined) {
                throw new RequiredError('commandId','Required parameter commandId was null or undefined when calling killCommand.');
            }
            const localVarPath = `/api/v1/commands/{commandId}/kill`
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Launch a command.
         * @param {V1LaunchCommandRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchCommand(body: V1LaunchCommandRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling launchCommand.');
            }
            const localVarPath = `/api/v1/commands`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the priority of the requested command.
         * @param {string} commandId The id of the command.
         * @param {V1SetCommandPriorityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCommandPriority(commandId: string, body: V1SetCommandPriorityRequest, options: any = {}): FetchArgs {
            // verify required parameter 'commandId' is not null or undefined
            if (commandId === null || commandId === undefined) {
                throw new RequiredError('commandId','Required parameter commandId was null or undefined when calling setCommandPriority.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setCommandPriority.');
            }
            const localVarPath = `/api/v1/commands/{commandId}/set_priority`
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandsApi - functional programming interface
 * @export
 */
export const CommandsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested command.
         * @param {string} commandId The id of the command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommand(commandId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetCommandResponse> {
            const localVarFetchArgs = CommandsApiFetchParamCreator(configuration).getCommand(commandId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of commands.
         * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort commands by the given field.   - SORT_BY_UNSPECIFIED: Returns commands in an unsorted list.  - SORT_BY_ID: Returns commands sorted by id.  - SORT_BY_DESCRIPTION: Returns commands sorted by description.  - SORT_BY_START_TIME: Return commands sorted by start time.  - SORT_BY_WORKSPACE_ID: Return commands sorted by workspace_id.
         * @param {V1OrderBy} [orderBy] Order commands in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of commands before returning results. Negative values denote number of commands to skip from the end before returning results.
         * @param {number} [limit] Limit the number of commands. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit commands to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit commands to those that are owned by users with the specified userIds.
         * @param {number} [workspaceId] Limit commands to those within a specific workspace, or 0 for all accessible workspaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommands(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetCommandsResponse> {
            const localVarFetchArgs = CommandsApiFetchParamCreator(configuration).getCommands(sortBy, orderBy, offset, limit, users, userIds, workspaceId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill the requested command.
         * @param {string} commandId The id of the command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killCommand(commandId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillCommandResponse> {
            const localVarFetchArgs = CommandsApiFetchParamCreator(configuration).killCommand(commandId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Launch a command.
         * @param {V1LaunchCommandRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchCommand(body: V1LaunchCommandRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LaunchCommandResponse> {
            const localVarFetchArgs = CommandsApiFetchParamCreator(configuration).launchCommand(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the priority of the requested command.
         * @param {string} commandId The id of the command.
         * @param {V1SetCommandPriorityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCommandPriority(commandId: string, body: V1SetCommandPriorityRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SetCommandPriorityResponse> {
            const localVarFetchArgs = CommandsApiFetchParamCreator(configuration).setCommandPriority(commandId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CommandsApi - factory interface
 * @export
 */
export const CommandsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the requested command.
         * @param {string} commandId The id of the command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommand(commandId: string, options?: any) {
            return CommandsApiFp(configuration).getCommand(commandId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of commands.
         * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort commands by the given field.   - SORT_BY_UNSPECIFIED: Returns commands in an unsorted list.  - SORT_BY_ID: Returns commands sorted by id.  - SORT_BY_DESCRIPTION: Returns commands sorted by description.  - SORT_BY_START_TIME: Return commands sorted by start time.  - SORT_BY_WORKSPACE_ID: Return commands sorted by workspace_id.
         * @param {V1OrderBy} [orderBy] Order commands in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of commands before returning results. Negative values denote number of commands to skip from the end before returning results.
         * @param {number} [limit] Limit the number of commands. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit commands to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit commands to those that are owned by users with the specified userIds.
         * @param {number} [workspaceId] Limit commands to those within a specific workspace, or 0 for all accessible workspaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommands(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options?: any) {
            return CommandsApiFp(configuration).getCommands(sortBy, orderBy, offset, limit, users, userIds, workspaceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill the requested command.
         * @param {string} commandId The id of the command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killCommand(commandId: string, options?: any) {
            return CommandsApiFp(configuration).killCommand(commandId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Launch a command.
         * @param {V1LaunchCommandRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchCommand(body: V1LaunchCommandRequest, options?: any) {
            return CommandsApiFp(configuration).launchCommand(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the priority of the requested command.
         * @param {string} commandId The id of the command.
         * @param {V1SetCommandPriorityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCommandPriority(commandId: string, body: V1SetCommandPriorityRequest, options?: any) {
            return CommandsApiFp(configuration).setCommandPriority(commandId, body, options)(fetch, basePath);
        },
    }
};

/**
 * CommandsApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class CommandsApi extends BaseAPI {
    /**
     * 
     * @summary Get the requested command.
     * @param {string} commandId The id of the command.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getCommand(commandId: string, options?: any) {
        return CommandsApiFp(this.configuration).getCommand(commandId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of commands.
     * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort commands by the given field.   - SORT_BY_UNSPECIFIED: Returns commands in an unsorted list.  - SORT_BY_ID: Returns commands sorted by id.  - SORT_BY_DESCRIPTION: Returns commands sorted by description.  - SORT_BY_START_TIME: Return commands sorted by start time.  - SORT_BY_WORKSPACE_ID: Return commands sorted by workspace_id.
     * @param {V1OrderBy} [orderBy] Order commands in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of commands before returning results. Negative values denote number of commands to skip from the end before returning results.
     * @param {number} [limit] Limit the number of commands. A value of 0 denotes no limit.
     * @param {Array<string>} [users] Limit commands to those that are owned by users with the specified usernames.
     * @param {Array<number>} [userIds] Limit commands to those that are owned by users with the specified userIds.
     * @param {number} [workspaceId] Limit commands to those within a specific workspace, or 0 for all accessible workspaces.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getCommands(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options?: any) {
        return CommandsApiFp(this.configuration).getCommands(sortBy, orderBy, offset, limit, users, userIds, workspaceId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Kill the requested command.
     * @param {string} commandId The id of the command.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public killCommand(commandId: string, options?: any) {
        return CommandsApiFp(this.configuration).killCommand(commandId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Launch a command.
     * @param {V1LaunchCommandRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public launchCommand(body: V1LaunchCommandRequest, options?: any) {
        return CommandsApiFp(this.configuration).launchCommand(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Set the priority of the requested command.
     * @param {string} commandId The id of the command.
     * @param {V1SetCommandPriorityRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public setCommandPriority(commandId: string, body: V1SetCommandPriorityRequest, options?: any) {
        return CommandsApiFp(this.configuration).setCommandPriority(commandId, body, options)(this.fetch, this.basePath)
    }
    
}

/**
 * ExperimentsApi - fetch parameter creator
 * @export
 */
export const ExperimentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activate an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateExperiment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling activateExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Activate multiple experiments.
         * @param {V1ActivateExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateExperiments(body: V1ActivateExperimentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling activateExperiments.');
            }
            const localVarPath = `/api/v1/experiments/activate`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveExperiment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling archiveExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive multiple experiments.
         * @param {V1ArchiveExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveExperiments(body: V1ArchiveExperimentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling archiveExperiments.');
            }
            const localVarPath = `/api/v1/experiments/archive`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelExperiment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cancelExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel multiple experiments.
         * @param {V1CancelExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelExperiments(body: V1CancelExperimentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cancelExperiments.');
            }
            const localVarPath = `/api/v1/experiments/cancel`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a downsampled time series of metrics from multiple trials to compare them side-by-side.
         * @param {Array<number>} [trialIds] The requested trial ids.
         * @param {number} [maxDatapoints] The maximum number of data points to return after downsampling.
         * @param {Array<string>} [metricNames] The names of selected metrics.
         * @param {number} [startBatches] Sample from metrics after this batch number.
         * @param {number} [endBatches] Sample from metrics before this batch number.
         * @param {V1MetricType} [metricType] Metric group.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {Array<string>} [metricIds] metric ids for the query. must be in the form group.metric_name.
         * @param {string} [timeSeriesFilterName] metric or column name for the filter.
         * @param {number} [timeSeriesFilterDoubleRangeLt] Less than.
         * @param {number} [timeSeriesFilterDoubleRangeLte] Less than or equal.
         * @param {number} [timeSeriesFilterDoubleRangeGt] Greater than.
         * @param {number} [timeSeriesFilterDoubleRangeGte] Greater than or equal.
         * @param {number} [timeSeriesFilterIntegerRangeLt] Less than.
         * @param {number} [timeSeriesFilterIntegerRangeLte] Less than or equal.
         * @param {number} [timeSeriesFilterIntegerRangeGt] Greater than.
         * @param {number} [timeSeriesFilterIntegerRangeGte] Greater than or equal.
         * @param {Array<number>} [timeSeriesFilterIntegerRangeIncl] In a set. `in` is a reserved word in python.
         * @param {Array<number>} [timeSeriesFilterIntegerRangeNotIn] Not in a set.
         * @param {Date} [timeSeriesFilterTimeRangeLt] Less than.
         * @param {Date} [timeSeriesFilterTimeRangeLte] Less than or equal.
         * @param {Date} [timeSeriesFilterTimeRangeGt] Greater than.
         * @param {Date} [timeSeriesFilterTimeRangeGte] Greater than or equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareTrials(trialIds?: Array<number>, maxDatapoints?: number, metricNames?: Array<string>, startBatches?: number, endBatches?: number, metricType?: V1MetricType, group?: string, metricIds?: Array<string>, timeSeriesFilterName?: string, timeSeriesFilterDoubleRangeLt?: number, timeSeriesFilterDoubleRangeLte?: number, timeSeriesFilterDoubleRangeGt?: number, timeSeriesFilterDoubleRangeGte?: number, timeSeriesFilterIntegerRangeLt?: number, timeSeriesFilterIntegerRangeLte?: number, timeSeriesFilterIntegerRangeGt?: number, timeSeriesFilterIntegerRangeGte?: number, timeSeriesFilterIntegerRangeIncl?: Array<number>, timeSeriesFilterIntegerRangeNotIn?: Array<number>, timeSeriesFilterTimeRangeLt?: Date, timeSeriesFilterTimeRangeLte?: Date, timeSeriesFilterTimeRangeGt?: Date, timeSeriesFilterTimeRangeGte?: Date, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/trials/time-series`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (trialIds) {
                localVarQueryParameter['trialIds'] = trialIds
            }
            
            if (maxDatapoints !== undefined) {
                localVarQueryParameter['maxDatapoints'] = maxDatapoints
            }
            
            if (metricNames) {
                localVarQueryParameter['metricNames'] = metricNames
            }
            
            if (startBatches !== undefined) {
                localVarQueryParameter['startBatches'] = startBatches
            }
            
            if (endBatches !== undefined) {
                localVarQueryParameter['endBatches'] = endBatches
            }
            
            if (metricType !== undefined) {
                localVarQueryParameter['metricType'] = metricType
            }
            
            if (group !== undefined) {
                localVarQueryParameter['group'] = group
            }
            
            if (metricIds) {
                localVarQueryParameter['metricIds'] = metricIds
            }
            
            if (timeSeriesFilterName !== undefined) {
                localVarQueryParameter['timeSeriesFilter.name'] = timeSeriesFilterName
            }
            
            if (timeSeriesFilterDoubleRangeLt !== undefined) {
                localVarQueryParameter['timeSeriesFilter.doubleRange.lt'] = timeSeriesFilterDoubleRangeLt
            }
            
            if (timeSeriesFilterDoubleRangeLte !== undefined) {
                localVarQueryParameter['timeSeriesFilter.doubleRange.lte'] = timeSeriesFilterDoubleRangeLte
            }
            
            if (timeSeriesFilterDoubleRangeGt !== undefined) {
                localVarQueryParameter['timeSeriesFilter.doubleRange.gt'] = timeSeriesFilterDoubleRangeGt
            }
            
            if (timeSeriesFilterDoubleRangeGte !== undefined) {
                localVarQueryParameter['timeSeriesFilter.doubleRange.gte'] = timeSeriesFilterDoubleRangeGte
            }
            
            if (timeSeriesFilterIntegerRangeLt !== undefined) {
                localVarQueryParameter['timeSeriesFilter.integerRange.lt'] = timeSeriesFilterIntegerRangeLt
            }
            
            if (timeSeriesFilterIntegerRangeLte !== undefined) {
                localVarQueryParameter['timeSeriesFilter.integerRange.lte'] = timeSeriesFilterIntegerRangeLte
            }
            
            if (timeSeriesFilterIntegerRangeGt !== undefined) {
                localVarQueryParameter['timeSeriesFilter.integerRange.gt'] = timeSeriesFilterIntegerRangeGt
            }
            
            if (timeSeriesFilterIntegerRangeGte !== undefined) {
                localVarQueryParameter['timeSeriesFilter.integerRange.gte'] = timeSeriesFilterIntegerRangeGte
            }
            
            if (timeSeriesFilterIntegerRangeIncl) {
                localVarQueryParameter['timeSeriesFilter.integerRange.incl'] = timeSeriesFilterIntegerRangeIncl
            }
            
            if (timeSeriesFilterIntegerRangeNotIn) {
                localVarQueryParameter['timeSeriesFilter.integerRange.notIn'] = timeSeriesFilterIntegerRangeNotIn
            }
            
            if (timeSeriesFilterTimeRangeLt) {
                localVarQueryParameter['timeSeriesFilter.timeRange.lt'] = timeSeriesFilterTimeRangeLt.toISOString()
            }
            
            if (timeSeriesFilterTimeRangeLte) {
                localVarQueryParameter['timeSeriesFilter.timeRange.lte'] = timeSeriesFilterTimeRangeLte.toISOString()
            }
            
            if (timeSeriesFilterTimeRangeGt) {
                localVarQueryParameter['timeSeriesFilter.timeRange.gt'] = timeSeriesFilterTimeRangeGt.toISOString()
            }
            
            if (timeSeriesFilterTimeRangeGte) {
                localVarQueryParameter['timeSeriesFilter.timeRange.gte'] = timeSeriesFilterTimeRangeGte.toISOString()
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the requested experiment.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(experimentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling deleteExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'DELETE', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete multiple experiments.
         * @param {V1DeleteExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiments(body: V1DeleteExperimentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteExperiments.');
            }
            const localVarPath = `/api/v1/experiments/delete`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'DELETE', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment(experimentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling getExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of checkpoints for an experiment.
         * @param {number} id The experiment id.
         * @param {V1GetExperimentCheckpointsRequestSortBy} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_TRIAL_ID: Returns checkpoints sorted by trial id.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_STATE: Returns checkpoints sorted by state.  - SORT_BY_SEARCHER_METRIC: Returns checkpoints sorted by the experiment's `searcher.metric` configuration setting.
         * @param {V1OrderBy} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
         * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
         * @param {Array<Checkpointv1State>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.  - STATE_PARTIALLY_DELETED: The checkpoint has been partially deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentCheckpoints(id: number, sortBy?: V1GetExperimentCheckpointsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Checkpointv1State>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getExperimentCheckpoints.');
            }
            const localVarPath = `/api/v1/experiments/{id}/checkpoints`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (states) {
                localVarQueryParameter['states'] = states
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of unique experiment labels (sorted by popularity).
         * @param {number} [projectId] Filter experiments by project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentLabels(projectId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/experiment/labels`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of experiments.
         * @param {V1GetExperimentsRequestSortBy} [sortBy] Sort experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end_time are returned after the ones with end_time.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.  - SORT_BY_NAME: Returns experiments sorted by name.  - SORT_BY_FORKED_FROM: Returns experiments sorted by originating model.  - SORT_BY_RESOURCE_POOL: Returns experiments sorted by resource pool.  - SORT_BY_PROJECT_ID: Returns experiments sorted by project.  - SORT_BY_CHECKPOINT_SIZE: Returns experiments sorted by checkpoint size.  - SORT_BY_CHECKPOINT_COUNT: Returns experiments sorted by checkpoint count.  - SORT_BY_SEARCHER_METRIC_VAL: Returns experiments sorted by searcher metric value..
         * @param {V1OrderBy} [orderBy] Order experiments in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of experiments before returning results. Negative values denote number of experiments to skip from the end before returning results.
         * @param {number} [limit] Limit the number of experiments. 0 or Unspecified - returns a default of 100. -1               - returns everything. -2               - returns pagination info but no experiments.
         * @param {string} [description] Limit experiments to those that match the description.
         * @param {string} [name] Limit experiments to those that match the name.
         * @param {Array<string>} [labels] Limit experiments to those that match the provided labels.
         * @param {boolean} [archived] Limit experiments to those that are archived.
         * @param {Array<Experimentv1State>} [states] Limit experiments to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.  - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.  - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The experiment is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The experiment has an allocation actively running. Running is a substate of the Active state.
         * @param {Array<string>} [users] Limit experiments to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit experiments to those that are owned by users with the specified userIds.
         * @param {number} [projectId] Limit experiments to those within a specified project, or 0 for all projects.
         * @param {number} [experimentIdFilterLt] Less than.
         * @param {number} [experimentIdFilterLte] Less than or equal.
         * @param {number} [experimentIdFilterGt] Greater than.
         * @param {number} [experimentIdFilterGte] Greater than or equal.
         * @param {Array<number>} [experimentIdFilterIncl] In a set. `in` is a reserved word in python.
         * @param {Array<number>} [experimentIdFilterNotIn] Not in a set.
         * @param {boolean} [showTrialData] whether to surface trial specific data from the best trial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiments(sortBy?: V1GetExperimentsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, description?: string, name?: string, labels?: Array<string>, archived?: boolean, states?: Array<Experimentv1State>, users?: Array<string>, userIds?: Array<number>, projectId?: number, experimentIdFilterLt?: number, experimentIdFilterLte?: number, experimentIdFilterGt?: number, experimentIdFilterGte?: number, experimentIdFilterIncl?: Array<number>, experimentIdFilterNotIn?: Array<number>, showTrialData?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/experiments`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (description !== undefined) {
                localVarQueryParameter['description'] = description
            }
            
            if (name !== undefined) {
                localVarQueryParameter['name'] = name
            }
            
            if (labels) {
                localVarQueryParameter['labels'] = labels
            }
            
            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived
            }
            
            if (states) {
                localVarQueryParameter['states'] = states
            }
            
            if (users) {
                localVarQueryParameter['users'] = users
            }
            
            if (userIds) {
                localVarQueryParameter['userIds'] = userIds
            }
            
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId
            }
            
            if (experimentIdFilterLt !== undefined) {
                localVarQueryParameter['experimentIdFilter.lt'] = experimentIdFilterLt
            }
            
            if (experimentIdFilterLte !== undefined) {
                localVarQueryParameter['experimentIdFilter.lte'] = experimentIdFilterLte
            }
            
            if (experimentIdFilterGt !== undefined) {
                localVarQueryParameter['experimentIdFilter.gt'] = experimentIdFilterGt
            }
            
            if (experimentIdFilterGte !== undefined) {
                localVarQueryParameter['experimentIdFilter.gte'] = experimentIdFilterGte
            }
            
            if (experimentIdFilterIncl) {
                localVarQueryParameter['experimentIdFilter.incl'] = experimentIdFilterIncl
            }
            
            if (experimentIdFilterNotIn) {
                localVarQueryParameter['experimentIdFilter.notIn'] = experimentIdFilterNotIn
            }
            
            if (showTrialData !== undefined) {
                localVarQueryParameter['showTrialData'] = showTrialData
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of trials for an experiment.
         * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
         * @param {V1GetExperimentTrialsRequestSortBy} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.  - SORT_BY_RESTARTS: Return the trials sorted by the number of restarts.  - SORT_BY_CHECKPOINT_SIZE: Return the trials sorted by checkpoint size.
         * @param {V1OrderBy} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
         * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
         * @param {Array<Experimentv1State>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.  - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.  - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The experiment is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The experiment has an allocation actively running. Running is a substate of the Active state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentTrials(experimentId: number, sortBy?: V1GetExperimentTrialsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Experimentv1State>, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling getExperimentTrials.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/trials`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (states) {
                localVarQueryParameter['states'] = states
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the validation history for an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentValidationHistory(experimentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling getExperimentValidationHistory.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/validation-history`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the model definition of an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelDef(experimentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling getModelDef.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/model_def`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get one file content of model definition of an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {V1GetModelDefFileRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelDefFile(experimentId: number, body: V1GetModelDefFileRequest, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling getModelDefFile.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getModelDefFile.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/file`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the model definition file tree of an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelDefTree(experimentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling getModelDefTree.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/file_tree`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of custom searcher events with long polling.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearcherEvents(experimentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling getSearcherEvents.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/searcher_events`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single trial.
         * @param {number} trialId The requested trial's id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrial(trialId: number, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling getTrial.');
            }
            const localVarPath = `/api/v1/trials/{trialId}`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of checkpoints for a trial.
         * @param {number} id The trial id.
         * @param {V1GetTrialCheckpointsRequestSortBy} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_STATE: Returns checkpoints sorted by state.
         * @param {V1OrderBy} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
         * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
         * @param {Array<Checkpointv1State>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.  - STATE_PARTIALLY_DELETED: The checkpoint has been partially deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialCheckpoints(id: number, sortBy?: V1GetTrialCheckpointsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Checkpointv1State>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTrialCheckpoints.');
            }
            const localVarPath = `/api/v1/trials/{id}/checkpoints`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (states) {
                localVarQueryParameter['states'] = states
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killExperiment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling killExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{id}/kill`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill multiple experiments.
         * @param {V1KillExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killExperiments(body: V1KillExperimentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling killExperiments.');
            }
            const localVarPath = `/api/v1/experiments/kill`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill a trial.
         * @param {number} id The trial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killTrial(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling killTrial.');
            }
            const localVarPath = `/api/v1/trials/{id}/kill`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move an experiment into a project.
         * @param {number} experimentId The id of the experiment being moved.
         * @param {V1MoveExperimentRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveExperiment(experimentId: number, body: V1MoveExperimentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling moveExperiment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling moveExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/move`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move multiple experiments into a project.
         * @param {V1MoveExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveExperiments(body: V1MoveExperimentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling moveExperiments.');
            }
            const localVarPath = `/api/v1/experiments/move`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch an experiment's fields.
         * @param {number} experimentId The id of the experiment.
         * @param {V1PatchExperiment} body Patched experiment attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExperiment(experimentId: number, body: V1PatchExperiment, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling patchExperiment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PATCH', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pause an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseExperiment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pauseExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{id}/pause`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pause multiple experiments.
         * @param {V1PauseExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseExperiments(body: V1PauseExperimentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pauseExperiments.');
            }
            const localVarPath = `/api/v1/experiments/pause`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit operations to a custom searcher.
         * @param {number} experimentId The experiment ID.
         * @param {V1PostSearcherOperationsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSearcherOperations(experimentId: number, body: V1PostSearcherOperationsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling postSearcherOperations.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSearcherOperations.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/searcher_operations`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Preview hyperparameter search.
         * @param {V1PreviewHPSearchRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewHPSearch(body: V1PreviewHPSearchRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling previewHPSearch.');
            }
            const localVarPath = `/api/v1/preview-hp-search`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get experiments with grouping and search syntax
         * @param {number} [projectId] ID of the project to look at.
         * @param {number} [offset] How many experiments to skip before including in the results.
         * @param {number} [limit] How many results to show.
         * @param {string} [sort] Sort parameters in the format <col1>=(asc|desc),<col2>=(asc|desc).
         * @param {string} [filter] Filter expression.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchExperiments(projectId?: number, offset?: number, limit?: number, sort?: string, filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/experiments-search`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort
            }
            
            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream trial logs.
         * @param {number} trialId The id of the trial.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {string} [searchText] Search the logs by whether the text contains a substring.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling trialLogs.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/logs`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow
            }
            
            if (agentIds) {
                localVarQueryParameter['agentIds'] = agentIds
            }
            
            if (containerIds) {
                localVarQueryParameter['containerIds'] = containerIds
            }
            
            if (rankIds) {
                localVarQueryParameter['rankIds'] = rankIds
            }
            
            if (levels) {
                localVarQueryParameter['levels'] = levels
            }
            
            if (stdtypes) {
                localVarQueryParameter['stdtypes'] = stdtypes
            }
            
            if (sources) {
                localVarQueryParameter['sources'] = sources
            }
            
            if (timestampBefore) {
                localVarQueryParameter['timestampBefore'] = timestampBefore.toISOString()
            }
            
            if (timestampAfter) {
                localVarQueryParameter['timestampAfter'] = timestampAfter.toISOString()
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream trial log fields.
         * @param {number} trialId The ID of the trial.
         * @param {boolean} [follow] Continue following fields until the trial stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialLogsFields(trialId: number, follow?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling trialLogsFields.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/logs/fields`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unarchive an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveExperiment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unarchiveExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{id}/unarchive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unarchive multiple experiments.
         * @param {V1UnarchiveExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveExperiments(body: V1UnarchiveExperimentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling unarchiveExperiments.');
            }
            const localVarPath = `/api/v1/experiments/unarchive`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperimentsApi - functional programming interface
 * @export
 */
export const ExperimentsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activate an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateExperiment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ActivateExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).activateExperiment(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Activate multiple experiments.
         * @param {V1ActivateExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateExperiments(body: V1ActivateExperimentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ActivateExperimentsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).activateExperiments(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Archive an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveExperiment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArchiveExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).archiveExperiment(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Archive multiple experiments.
         * @param {V1ArchiveExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveExperiments(body: V1ArchiveExperimentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArchiveExperimentsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).archiveExperiments(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Cancel an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelExperiment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CancelExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).cancelExperiment(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Cancel multiple experiments.
         * @param {V1CancelExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelExperiments(body: V1CancelExperimentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CancelExperimentsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).cancelExperiments(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return a downsampled time series of metrics from multiple trials to compare them side-by-side.
         * @param {Array<number>} [trialIds] The requested trial ids.
         * @param {number} [maxDatapoints] The maximum number of data points to return after downsampling.
         * @param {Array<string>} [metricNames] The names of selected metrics.
         * @param {number} [startBatches] Sample from metrics after this batch number.
         * @param {number} [endBatches] Sample from metrics before this batch number.
         * @param {V1MetricType} [metricType] Metric group.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {Array<string>} [metricIds] metric ids for the query. must be in the form group.metric_name.
         * @param {string} [timeSeriesFilterName] metric or column name for the filter.
         * @param {number} [timeSeriesFilterDoubleRangeLt] Less than.
         * @param {number} [timeSeriesFilterDoubleRangeLte] Less than or equal.
         * @param {number} [timeSeriesFilterDoubleRangeGt] Greater than.
         * @param {number} [timeSeriesFilterDoubleRangeGte] Greater than or equal.
         * @param {number} [timeSeriesFilterIntegerRangeLt] Less than.
         * @param {number} [timeSeriesFilterIntegerRangeLte] Less than or equal.
         * @param {number} [timeSeriesFilterIntegerRangeGt] Greater than.
         * @param {number} [timeSeriesFilterIntegerRangeGte] Greater than or equal.
         * @param {Array<number>} [timeSeriesFilterIntegerRangeIncl] In a set. `in` is a reserved word in python.
         * @param {Array<number>} [timeSeriesFilterIntegerRangeNotIn] Not in a set.
         * @param {Date} [timeSeriesFilterTimeRangeLt] Less than.
         * @param {Date} [timeSeriesFilterTimeRangeLte] Less than or equal.
         * @param {Date} [timeSeriesFilterTimeRangeGt] Greater than.
         * @param {Date} [timeSeriesFilterTimeRangeGte] Greater than or equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareTrials(trialIds?: Array<number>, maxDatapoints?: number, metricNames?: Array<string>, startBatches?: number, endBatches?: number, metricType?: V1MetricType, group?: string, metricIds?: Array<string>, timeSeriesFilterName?: string, timeSeriesFilterDoubleRangeLt?: number, timeSeriesFilterDoubleRangeLte?: number, timeSeriesFilterDoubleRangeGt?: number, timeSeriesFilterDoubleRangeGte?: number, timeSeriesFilterIntegerRangeLt?: number, timeSeriesFilterIntegerRangeLte?: number, timeSeriesFilterIntegerRangeGt?: number, timeSeriesFilterIntegerRangeGte?: number, timeSeriesFilterIntegerRangeIncl?: Array<number>, timeSeriesFilterIntegerRangeNotIn?: Array<number>, timeSeriesFilterTimeRangeLt?: Date, timeSeriesFilterTimeRangeLte?: Date, timeSeriesFilterTimeRangeGt?: Date, timeSeriesFilterTimeRangeGte?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CompareTrialsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).compareTrials(trialIds, maxDatapoints, metricNames, startBatches, endBatches, metricType, group, metricIds, timeSeriesFilterName, timeSeriesFilterDoubleRangeLt, timeSeriesFilterDoubleRangeLte, timeSeriesFilterDoubleRangeGt, timeSeriesFilterDoubleRangeGte, timeSeriesFilterIntegerRangeLt, timeSeriesFilterIntegerRangeLte, timeSeriesFilterIntegerRangeGt, timeSeriesFilterIntegerRangeGte, timeSeriesFilterIntegerRangeIncl, timeSeriesFilterIntegerRangeNotIn, timeSeriesFilterTimeRangeLt, timeSeriesFilterTimeRangeLte, timeSeriesFilterTimeRangeGt, timeSeriesFilterTimeRangeGte, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the requested experiment.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(experimentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeleteExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).deleteExperiment(experimentId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete multiple experiments.
         * @param {V1DeleteExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiments(body: V1DeleteExperimentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeleteExperimentsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).deleteExperiments(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment(experimentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).getExperiment(experimentId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of checkpoints for an experiment.
         * @param {number} id The experiment id.
         * @param {V1GetExperimentCheckpointsRequestSortBy} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_TRIAL_ID: Returns checkpoints sorted by trial id.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_STATE: Returns checkpoints sorted by state.  - SORT_BY_SEARCHER_METRIC: Returns checkpoints sorted by the experiment's `searcher.metric` configuration setting.
         * @param {V1OrderBy} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
         * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
         * @param {Array<Checkpointv1State>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.  - STATE_PARTIALLY_DELETED: The checkpoint has been partially deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentCheckpoints(id: number, sortBy?: V1GetExperimentCheckpointsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Checkpointv1State>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentCheckpointsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).getExperimentCheckpoints(id, sortBy, orderBy, offset, limit, states, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of unique experiment labels (sorted by popularity).
         * @param {number} [projectId] Filter experiments by project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentLabels(projectId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentLabelsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).getExperimentLabels(projectId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of experiments.
         * @param {V1GetExperimentsRequestSortBy} [sortBy] Sort experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end_time are returned after the ones with end_time.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.  - SORT_BY_NAME: Returns experiments sorted by name.  - SORT_BY_FORKED_FROM: Returns experiments sorted by originating model.  - SORT_BY_RESOURCE_POOL: Returns experiments sorted by resource pool.  - SORT_BY_PROJECT_ID: Returns experiments sorted by project.  - SORT_BY_CHECKPOINT_SIZE: Returns experiments sorted by checkpoint size.  - SORT_BY_CHECKPOINT_COUNT: Returns experiments sorted by checkpoint count.  - SORT_BY_SEARCHER_METRIC_VAL: Returns experiments sorted by searcher metric value..
         * @param {V1OrderBy} [orderBy] Order experiments in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of experiments before returning results. Negative values denote number of experiments to skip from the end before returning results.
         * @param {number} [limit] Limit the number of experiments. 0 or Unspecified - returns a default of 100. -1               - returns everything. -2               - returns pagination info but no experiments.
         * @param {string} [description] Limit experiments to those that match the description.
         * @param {string} [name] Limit experiments to those that match the name.
         * @param {Array<string>} [labels] Limit experiments to those that match the provided labels.
         * @param {boolean} [archived] Limit experiments to those that are archived.
         * @param {Array<Experimentv1State>} [states] Limit experiments to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.  - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.  - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The experiment is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The experiment has an allocation actively running. Running is a substate of the Active state.
         * @param {Array<string>} [users] Limit experiments to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit experiments to those that are owned by users with the specified userIds.
         * @param {number} [projectId] Limit experiments to those within a specified project, or 0 for all projects.
         * @param {number} [experimentIdFilterLt] Less than.
         * @param {number} [experimentIdFilterLte] Less than or equal.
         * @param {number} [experimentIdFilterGt] Greater than.
         * @param {number} [experimentIdFilterGte] Greater than or equal.
         * @param {Array<number>} [experimentIdFilterIncl] In a set. `in` is a reserved word in python.
         * @param {Array<number>} [experimentIdFilterNotIn] Not in a set.
         * @param {boolean} [showTrialData] whether to surface trial specific data from the best trial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiments(sortBy?: V1GetExperimentsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, description?: string, name?: string, labels?: Array<string>, archived?: boolean, states?: Array<Experimentv1State>, users?: Array<string>, userIds?: Array<number>, projectId?: number, experimentIdFilterLt?: number, experimentIdFilterLte?: number, experimentIdFilterGt?: number, experimentIdFilterGte?: number, experimentIdFilterIncl?: Array<number>, experimentIdFilterNotIn?: Array<number>, showTrialData?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).getExperiments(sortBy, orderBy, offset, limit, description, name, labels, archived, states, users, userIds, projectId, experimentIdFilterLt, experimentIdFilterLte, experimentIdFilterGt, experimentIdFilterGte, experimentIdFilterIncl, experimentIdFilterNotIn, showTrialData, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of trials for an experiment.
         * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
         * @param {V1GetExperimentTrialsRequestSortBy} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.  - SORT_BY_RESTARTS: Return the trials sorted by the number of restarts.  - SORT_BY_CHECKPOINT_SIZE: Return the trials sorted by checkpoint size.
         * @param {V1OrderBy} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
         * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
         * @param {Array<Experimentv1State>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.  - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.  - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The experiment is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The experiment has an allocation actively running. Running is a substate of the Active state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentTrials(experimentId: number, sortBy?: V1GetExperimentTrialsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Experimentv1State>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentTrialsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).getExperimentTrials(experimentId, sortBy, orderBy, offset, limit, states, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the validation history for an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentValidationHistory(experimentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentValidationHistoryResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).getExperimentValidationHistory(experimentId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the model definition of an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelDef(experimentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelDefResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).getModelDef(experimentId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get one file content of model definition of an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {V1GetModelDefFileRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelDefFile(experimentId: number, body: V1GetModelDefFileRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelDefFileResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).getModelDefFile(experimentId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the model definition file tree of an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelDefTree(experimentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelDefTreeResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).getModelDefTree(experimentId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of custom searcher events with long polling.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearcherEvents(experimentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetSearcherEventsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).getSearcherEvents(experimentId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a single trial.
         * @param {number} trialId The requested trial's id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrial(trialId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTrialResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).getTrial(trialId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of checkpoints for a trial.
         * @param {number} id The trial id.
         * @param {V1GetTrialCheckpointsRequestSortBy} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_STATE: Returns checkpoints sorted by state.
         * @param {V1OrderBy} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
         * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
         * @param {Array<Checkpointv1State>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.  - STATE_PARTIALLY_DELETED: The checkpoint has been partially deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialCheckpoints(id: number, sortBy?: V1GetTrialCheckpointsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Checkpointv1State>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTrialCheckpointsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).getTrialCheckpoints(id, sortBy, orderBy, offset, limit, states, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killExperiment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).killExperiment(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill multiple experiments.
         * @param {V1KillExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killExperiments(body: V1KillExperimentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillExperimentsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).killExperiments(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill a trial.
         * @param {number} id The trial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killTrial(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillTrialResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).killTrial(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Move an experiment into a project.
         * @param {number} experimentId The id of the experiment being moved.
         * @param {V1MoveExperimentRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveExperiment(experimentId: number, body: V1MoveExperimentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1MoveExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).moveExperiment(experimentId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Move multiple experiments into a project.
         * @param {V1MoveExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveExperiments(body: V1MoveExperimentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1MoveExperimentsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).moveExperiments(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch an experiment's fields.
         * @param {number} experimentId The id of the experiment.
         * @param {V1PatchExperiment} body Patched experiment attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExperiment(experimentId: number, body: V1PatchExperiment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PatchExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).patchExperiment(experimentId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Pause an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseExperiment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PauseExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).pauseExperiment(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Pause multiple experiments.
         * @param {V1PauseExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseExperiments(body: V1PauseExperimentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PauseExperimentsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).pauseExperiments(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Submit operations to a custom searcher.
         * @param {number} experimentId The experiment ID.
         * @param {V1PostSearcherOperationsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSearcherOperations(experimentId: number, body: V1PostSearcherOperationsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostSearcherOperationsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).postSearcherOperations(experimentId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Preview hyperparameter search.
         * @param {V1PreviewHPSearchRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewHPSearch(body: V1PreviewHPSearchRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PreviewHPSearchResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).previewHPSearch(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get experiments with grouping and search syntax
         * @param {number} [projectId] ID of the project to look at.
         * @param {number} [offset] How many experiments to skip before including in the results.
         * @param {number} [limit] How many results to show.
         * @param {string} [sort] Sort parameters in the format <col1>=(asc|desc),<col2>=(asc|desc).
         * @param {string} [filter] Filter expression.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchExperiments(projectId?: number, offset?: number, limit?: number, sort?: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SearchExperimentsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).searchExperiments(projectId, offset, limit, sort, filter, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream trial logs.
         * @param {number} trialId The id of the trial.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {string} [searchText] Search the logs by whether the text contains a substring.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TrialLogsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).trialLogs(trialId, limit, follow, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, searchText, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream trial log fields.
         * @param {number} trialId The ID of the trial.
         * @param {boolean} [follow] Continue following fields until the trial stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialLogsFields(trialId: number, follow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TrialLogsFieldsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).trialLogsFields(trialId, follow, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unarchive an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveExperiment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UnarchiveExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).unarchiveExperiment(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unarchive multiple experiments.
         * @param {V1UnarchiveExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveExperiments(body: V1UnarchiveExperimentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UnarchiveExperimentsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).unarchiveExperiments(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ExperimentsApi - factory interface
 * @export
 */
export const ExperimentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Activate an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateExperiment(id: number, options?: any) {
            return ExperimentsApiFp(configuration).activateExperiment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Activate multiple experiments.
         * @param {V1ActivateExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateExperiments(body: V1ActivateExperimentsRequest, options?: any) {
            return ExperimentsApiFp(configuration).activateExperiments(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Archive an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveExperiment(id: number, options?: any) {
            return ExperimentsApiFp(configuration).archiveExperiment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Archive multiple experiments.
         * @param {V1ArchiveExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveExperiments(body: V1ArchiveExperimentsRequest, options?: any) {
            return ExperimentsApiFp(configuration).archiveExperiments(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Cancel an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelExperiment(id: number, options?: any) {
            return ExperimentsApiFp(configuration).cancelExperiment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Cancel multiple experiments.
         * @param {V1CancelExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelExperiments(body: V1CancelExperimentsRequest, options?: any) {
            return ExperimentsApiFp(configuration).cancelExperiments(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return a downsampled time series of metrics from multiple trials to compare them side-by-side.
         * @param {Array<number>} [trialIds] The requested trial ids.
         * @param {number} [maxDatapoints] The maximum number of data points to return after downsampling.
         * @param {Array<string>} [metricNames] The names of selected metrics.
         * @param {number} [startBatches] Sample from metrics after this batch number.
         * @param {number} [endBatches] Sample from metrics before this batch number.
         * @param {V1MetricType} [metricType] Metric group.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {Array<string>} [metricIds] metric ids for the query. must be in the form group.metric_name.
         * @param {string} [timeSeriesFilterName] metric or column name for the filter.
         * @param {number} [timeSeriesFilterDoubleRangeLt] Less than.
         * @param {number} [timeSeriesFilterDoubleRangeLte] Less than or equal.
         * @param {number} [timeSeriesFilterDoubleRangeGt] Greater than.
         * @param {number} [timeSeriesFilterDoubleRangeGte] Greater than or equal.
         * @param {number} [timeSeriesFilterIntegerRangeLt] Less than.
         * @param {number} [timeSeriesFilterIntegerRangeLte] Less than or equal.
         * @param {number} [timeSeriesFilterIntegerRangeGt] Greater than.
         * @param {number} [timeSeriesFilterIntegerRangeGte] Greater than or equal.
         * @param {Array<number>} [timeSeriesFilterIntegerRangeIncl] In a set. `in` is a reserved word in python.
         * @param {Array<number>} [timeSeriesFilterIntegerRangeNotIn] Not in a set.
         * @param {Date} [timeSeriesFilterTimeRangeLt] Less than.
         * @param {Date} [timeSeriesFilterTimeRangeLte] Less than or equal.
         * @param {Date} [timeSeriesFilterTimeRangeGt] Greater than.
         * @param {Date} [timeSeriesFilterTimeRangeGte] Greater than or equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareTrials(trialIds?: Array<number>, maxDatapoints?: number, metricNames?: Array<string>, startBatches?: number, endBatches?: number, metricType?: V1MetricType, group?: string, metricIds?: Array<string>, timeSeriesFilterName?: string, timeSeriesFilterDoubleRangeLt?: number, timeSeriesFilterDoubleRangeLte?: number, timeSeriesFilterDoubleRangeGt?: number, timeSeriesFilterDoubleRangeGte?: number, timeSeriesFilterIntegerRangeLt?: number, timeSeriesFilterIntegerRangeLte?: number, timeSeriesFilterIntegerRangeGt?: number, timeSeriesFilterIntegerRangeGte?: number, timeSeriesFilterIntegerRangeIncl?: Array<number>, timeSeriesFilterIntegerRangeNotIn?: Array<number>, timeSeriesFilterTimeRangeLt?: Date, timeSeriesFilterTimeRangeLte?: Date, timeSeriesFilterTimeRangeGt?: Date, timeSeriesFilterTimeRangeGte?: Date, options?: any) {
            return ExperimentsApiFp(configuration).compareTrials(trialIds, maxDatapoints, metricNames, startBatches, endBatches, metricType, group, metricIds, timeSeriesFilterName, timeSeriesFilterDoubleRangeLt, timeSeriesFilterDoubleRangeLte, timeSeriesFilterDoubleRangeGt, timeSeriesFilterDoubleRangeGte, timeSeriesFilterIntegerRangeLt, timeSeriesFilterIntegerRangeLte, timeSeriesFilterIntegerRangeGt, timeSeriesFilterIntegerRangeGte, timeSeriesFilterIntegerRangeIncl, timeSeriesFilterIntegerRangeNotIn, timeSeriesFilterTimeRangeLt, timeSeriesFilterTimeRangeLte, timeSeriesFilterTimeRangeGt, timeSeriesFilterTimeRangeGte, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the requested experiment.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(experimentId: number, options?: any) {
            return ExperimentsApiFp(configuration).deleteExperiment(experimentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete multiple experiments.
         * @param {V1DeleteExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiments(body: V1DeleteExperimentsRequest, options?: any) {
            return ExperimentsApiFp(configuration).deleteExperiments(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment(experimentId: number, options?: any) {
            return ExperimentsApiFp(configuration).getExperiment(experimentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of checkpoints for an experiment.
         * @param {number} id The experiment id.
         * @param {V1GetExperimentCheckpointsRequestSortBy} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_TRIAL_ID: Returns checkpoints sorted by trial id.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_STATE: Returns checkpoints sorted by state.  - SORT_BY_SEARCHER_METRIC: Returns checkpoints sorted by the experiment's `searcher.metric` configuration setting.
         * @param {V1OrderBy} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
         * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
         * @param {Array<Checkpointv1State>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.  - STATE_PARTIALLY_DELETED: The checkpoint has been partially deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentCheckpoints(id: number, sortBy?: V1GetExperimentCheckpointsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Checkpointv1State>, options?: any) {
            return ExperimentsApiFp(configuration).getExperimentCheckpoints(id, sortBy, orderBy, offset, limit, states, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of unique experiment labels (sorted by popularity).
         * @param {number} [projectId] Filter experiments by project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentLabels(projectId?: number, options?: any) {
            return ExperimentsApiFp(configuration).getExperimentLabels(projectId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of experiments.
         * @param {V1GetExperimentsRequestSortBy} [sortBy] Sort experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end_time are returned after the ones with end_time.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.  - SORT_BY_NAME: Returns experiments sorted by name.  - SORT_BY_FORKED_FROM: Returns experiments sorted by originating model.  - SORT_BY_RESOURCE_POOL: Returns experiments sorted by resource pool.  - SORT_BY_PROJECT_ID: Returns experiments sorted by project.  - SORT_BY_CHECKPOINT_SIZE: Returns experiments sorted by checkpoint size.  - SORT_BY_CHECKPOINT_COUNT: Returns experiments sorted by checkpoint count.  - SORT_BY_SEARCHER_METRIC_VAL: Returns experiments sorted by searcher metric value..
         * @param {V1OrderBy} [orderBy] Order experiments in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of experiments before returning results. Negative values denote number of experiments to skip from the end before returning results.
         * @param {number} [limit] Limit the number of experiments. 0 or Unspecified - returns a default of 100. -1               - returns everything. -2               - returns pagination info but no experiments.
         * @param {string} [description] Limit experiments to those that match the description.
         * @param {string} [name] Limit experiments to those that match the name.
         * @param {Array<string>} [labels] Limit experiments to those that match the provided labels.
         * @param {boolean} [archived] Limit experiments to those that are archived.
         * @param {Array<Experimentv1State>} [states] Limit experiments to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.  - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.  - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The experiment is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The experiment has an allocation actively running. Running is a substate of the Active state.
         * @param {Array<string>} [users] Limit experiments to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit experiments to those that are owned by users with the specified userIds.
         * @param {number} [projectId] Limit experiments to those within a specified project, or 0 for all projects.
         * @param {number} [experimentIdFilterLt] Less than.
         * @param {number} [experimentIdFilterLte] Less than or equal.
         * @param {number} [experimentIdFilterGt] Greater than.
         * @param {number} [experimentIdFilterGte] Greater than or equal.
         * @param {Array<number>} [experimentIdFilterIncl] In a set. `in` is a reserved word in python.
         * @param {Array<number>} [experimentIdFilterNotIn] Not in a set.
         * @param {boolean} [showTrialData] whether to surface trial specific data from the best trial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiments(sortBy?: V1GetExperimentsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, description?: string, name?: string, labels?: Array<string>, archived?: boolean, states?: Array<Experimentv1State>, users?: Array<string>, userIds?: Array<number>, projectId?: number, experimentIdFilterLt?: number, experimentIdFilterLte?: number, experimentIdFilterGt?: number, experimentIdFilterGte?: number, experimentIdFilterIncl?: Array<number>, experimentIdFilterNotIn?: Array<number>, showTrialData?: boolean, options?: any) {
            return ExperimentsApiFp(configuration).getExperiments(sortBy, orderBy, offset, limit, description, name, labels, archived, states, users, userIds, projectId, experimentIdFilterLt, experimentIdFilterLte, experimentIdFilterGt, experimentIdFilterGte, experimentIdFilterIncl, experimentIdFilterNotIn, showTrialData, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of trials for an experiment.
         * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
         * @param {V1GetExperimentTrialsRequestSortBy} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.  - SORT_BY_RESTARTS: Return the trials sorted by the number of restarts.  - SORT_BY_CHECKPOINT_SIZE: Return the trials sorted by checkpoint size.
         * @param {V1OrderBy} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
         * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
         * @param {Array<Experimentv1State>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.  - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.  - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The experiment is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The experiment has an allocation actively running. Running is a substate of the Active state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentTrials(experimentId: number, sortBy?: V1GetExperimentTrialsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Experimentv1State>, options?: any) {
            return ExperimentsApiFp(configuration).getExperimentTrials(experimentId, sortBy, orderBy, offset, limit, states, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the validation history for an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentValidationHistory(experimentId: number, options?: any) {
            return ExperimentsApiFp(configuration).getExperimentValidationHistory(experimentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the model definition of an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelDef(experimentId: number, options?: any) {
            return ExperimentsApiFp(configuration).getModelDef(experimentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get one file content of model definition of an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {V1GetModelDefFileRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelDefFile(experimentId: number, body: V1GetModelDefFileRequest, options?: any) {
            return ExperimentsApiFp(configuration).getModelDefFile(experimentId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the model definition file tree of an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelDefTree(experimentId: number, options?: any) {
            return ExperimentsApiFp(configuration).getModelDefTree(experimentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of custom searcher events with long polling.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearcherEvents(experimentId: number, options?: any) {
            return ExperimentsApiFp(configuration).getSearcherEvents(experimentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single trial.
         * @param {number} trialId The requested trial's id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrial(trialId: number, options?: any) {
            return ExperimentsApiFp(configuration).getTrial(trialId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of checkpoints for a trial.
         * @param {number} id The trial id.
         * @param {V1GetTrialCheckpointsRequestSortBy} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_STATE: Returns checkpoints sorted by state.
         * @param {V1OrderBy} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
         * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
         * @param {Array<Checkpointv1State>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.  - STATE_PARTIALLY_DELETED: The checkpoint has been partially deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialCheckpoints(id: number, sortBy?: V1GetTrialCheckpointsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Checkpointv1State>, options?: any) {
            return ExperimentsApiFp(configuration).getTrialCheckpoints(id, sortBy, orderBy, offset, limit, states, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killExperiment(id: number, options?: any) {
            return ExperimentsApiFp(configuration).killExperiment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill multiple experiments.
         * @param {V1KillExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killExperiments(body: V1KillExperimentsRequest, options?: any) {
            return ExperimentsApiFp(configuration).killExperiments(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill a trial.
         * @param {number} id The trial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killTrial(id: number, options?: any) {
            return ExperimentsApiFp(configuration).killTrial(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Move an experiment into a project.
         * @param {number} experimentId The id of the experiment being moved.
         * @param {V1MoveExperimentRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveExperiment(experimentId: number, body: V1MoveExperimentRequest, options?: any) {
            return ExperimentsApiFp(configuration).moveExperiment(experimentId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Move multiple experiments into a project.
         * @param {V1MoveExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveExperiments(body: V1MoveExperimentsRequest, options?: any) {
            return ExperimentsApiFp(configuration).moveExperiments(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an experiment's fields.
         * @param {number} experimentId The id of the experiment.
         * @param {V1PatchExperiment} body Patched experiment attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExperiment(experimentId: number, body: V1PatchExperiment, options?: any) {
            return ExperimentsApiFp(configuration).patchExperiment(experimentId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Pause an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseExperiment(id: number, options?: any) {
            return ExperimentsApiFp(configuration).pauseExperiment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Pause multiple experiments.
         * @param {V1PauseExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseExperiments(body: V1PauseExperimentsRequest, options?: any) {
            return ExperimentsApiFp(configuration).pauseExperiments(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Submit operations to a custom searcher.
         * @param {number} experimentId The experiment ID.
         * @param {V1PostSearcherOperationsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSearcherOperations(experimentId: number, body: V1PostSearcherOperationsRequest, options?: any) {
            return ExperimentsApiFp(configuration).postSearcherOperations(experimentId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Preview hyperparameter search.
         * @param {V1PreviewHPSearchRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewHPSearch(body: V1PreviewHPSearchRequest, options?: any) {
            return ExperimentsApiFp(configuration).previewHPSearch(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get experiments with grouping and search syntax
         * @param {number} [projectId] ID of the project to look at.
         * @param {number} [offset] How many experiments to skip before including in the results.
         * @param {number} [limit] How many results to show.
         * @param {string} [sort] Sort parameters in the format <col1>=(asc|desc),<col2>=(asc|desc).
         * @param {string} [filter] Filter expression.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchExperiments(projectId?: number, offset?: number, limit?: number, sort?: string, filter?: string, options?: any) {
            return ExperimentsApiFp(configuration).searchExperiments(projectId, offset, limit, sort, filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream trial logs.
         * @param {number} trialId The id of the trial.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {string} [searchText] Search the logs by whether the text contains a substring.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options?: any) {
            return ExperimentsApiFp(configuration).trialLogs(trialId, limit, follow, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, searchText, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream trial log fields.
         * @param {number} trialId The ID of the trial.
         * @param {boolean} [follow] Continue following fields until the trial stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialLogsFields(trialId: number, follow?: boolean, options?: any) {
            return ExperimentsApiFp(configuration).trialLogsFields(trialId, follow, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unarchive an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveExperiment(id: number, options?: any) {
            return ExperimentsApiFp(configuration).unarchiveExperiment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unarchive multiple experiments.
         * @param {V1UnarchiveExperimentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveExperiments(body: V1UnarchiveExperimentsRequest, options?: any) {
            return ExperimentsApiFp(configuration).unarchiveExperiments(body, options)(fetch, basePath);
        },
    }
};

/**
 * ExperimentsApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class ExperimentsApi extends BaseAPI {
    /**
     * 
     * @summary Activate an experiment.
     * @param {number} id The experiment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public activateExperiment(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).activateExperiment(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Activate multiple experiments.
     * @param {V1ActivateExperimentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public activateExperiments(body: V1ActivateExperimentsRequest, options?: any) {
        return ExperimentsApiFp(this.configuration).activateExperiments(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Archive an experiment.
     * @param {number} id The experiment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public archiveExperiment(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).archiveExperiment(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Archive multiple experiments.
     * @param {V1ArchiveExperimentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public archiveExperiments(body: V1ArchiveExperimentsRequest, options?: any) {
        return ExperimentsApiFp(this.configuration).archiveExperiments(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Cancel an experiment.
     * @param {number} id The experiment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public cancelExperiment(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).cancelExperiment(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Cancel multiple experiments.
     * @param {V1CancelExperimentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public cancelExperiments(body: V1CancelExperimentsRequest, options?: any) {
        return ExperimentsApiFp(this.configuration).cancelExperiments(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Return a downsampled time series of metrics from multiple trials to compare them side-by-side.
     * @param {Array<number>} [trialIds] The requested trial ids.
     * @param {number} [maxDatapoints] The maximum number of data points to return after downsampling.
     * @param {Array<string>} [metricNames] The names of selected metrics.
     * @param {number} [startBatches] Sample from metrics after this batch number.
     * @param {number} [endBatches] Sample from metrics before this batch number.
     * @param {V1MetricType} [metricType] Metric group.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
     * @param {string} [group] Metric group (training, validation, etc).
     * @param {Array<string>} [metricIds] metric ids for the query. must be in the form group.metric_name.
     * @param {string} [timeSeriesFilterName] metric or column name for the filter.
     * @param {number} [timeSeriesFilterDoubleRangeLt] Less than.
     * @param {number} [timeSeriesFilterDoubleRangeLte] Less than or equal.
     * @param {number} [timeSeriesFilterDoubleRangeGt] Greater than.
     * @param {number} [timeSeriesFilterDoubleRangeGte] Greater than or equal.
     * @param {number} [timeSeriesFilterIntegerRangeLt] Less than.
     * @param {number} [timeSeriesFilterIntegerRangeLte] Less than or equal.
     * @param {number} [timeSeriesFilterIntegerRangeGt] Greater than.
     * @param {number} [timeSeriesFilterIntegerRangeGte] Greater than or equal.
     * @param {Array<number>} [timeSeriesFilterIntegerRangeIncl] In a set. `in` is a reserved word in python.
     * @param {Array<number>} [timeSeriesFilterIntegerRangeNotIn] Not in a set.
     * @param {Date} [timeSeriesFilterTimeRangeLt] Less than.
     * @param {Date} [timeSeriesFilterTimeRangeLte] Less than or equal.
     * @param {Date} [timeSeriesFilterTimeRangeGt] Greater than.
     * @param {Date} [timeSeriesFilterTimeRangeGte] Greater than or equal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public compareTrials(trialIds?: Array<number>, maxDatapoints?: number, metricNames?: Array<string>, startBatches?: number, endBatches?: number, metricType?: V1MetricType, group?: string, metricIds?: Array<string>, timeSeriesFilterName?: string, timeSeriesFilterDoubleRangeLt?: number, timeSeriesFilterDoubleRangeLte?: number, timeSeriesFilterDoubleRangeGt?: number, timeSeriesFilterDoubleRangeGte?: number, timeSeriesFilterIntegerRangeLt?: number, timeSeriesFilterIntegerRangeLte?: number, timeSeriesFilterIntegerRangeGt?: number, timeSeriesFilterIntegerRangeGte?: number, timeSeriesFilterIntegerRangeIncl?: Array<number>, timeSeriesFilterIntegerRangeNotIn?: Array<number>, timeSeriesFilterTimeRangeLt?: Date, timeSeriesFilterTimeRangeLte?: Date, timeSeriesFilterTimeRangeGt?: Date, timeSeriesFilterTimeRangeGte?: Date, options?: any) {
        return ExperimentsApiFp(this.configuration).compareTrials(trialIds, maxDatapoints, metricNames, startBatches, endBatches, metricType, group, metricIds, timeSeriesFilterName, timeSeriesFilterDoubleRangeLt, timeSeriesFilterDoubleRangeLte, timeSeriesFilterDoubleRangeGt, timeSeriesFilterDoubleRangeGte, timeSeriesFilterIntegerRangeLt, timeSeriesFilterIntegerRangeLte, timeSeriesFilterIntegerRangeGt, timeSeriesFilterIntegerRangeGte, timeSeriesFilterIntegerRangeIncl, timeSeriesFilterIntegerRangeNotIn, timeSeriesFilterTimeRangeLt, timeSeriesFilterTimeRangeLte, timeSeriesFilterTimeRangeGt, timeSeriesFilterTimeRangeGte, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Delete the requested experiment.
     * @param {number} experimentId The ID of the experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public deleteExperiment(experimentId: number, options?: any) {
        return ExperimentsApiFp(this.configuration).deleteExperiment(experimentId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Delete multiple experiments.
     * @param {V1DeleteExperimentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public deleteExperiments(body: V1DeleteExperimentsRequest, options?: any) {
        return ExperimentsApiFp(this.configuration).deleteExperiments(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the requested experiment.
     * @param {number} experimentId The id of the experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getExperiment(experimentId: number, options?: any) {
        return ExperimentsApiFp(this.configuration).getExperiment(experimentId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of checkpoints for an experiment.
     * @param {number} id The experiment id.
     * @param {V1GetExperimentCheckpointsRequestSortBy} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_TRIAL_ID: Returns checkpoints sorted by trial id.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_STATE: Returns checkpoints sorted by state.  - SORT_BY_SEARCHER_METRIC: Returns checkpoints sorted by the experiment's `searcher.metric` configuration setting.
     * @param {V1OrderBy} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
     * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
     * @param {Array<Checkpointv1State>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.  - STATE_PARTIALLY_DELETED: The checkpoint has been partially deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getExperimentCheckpoints(id: number, sortBy?: V1GetExperimentCheckpointsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Checkpointv1State>, options?: any) {
        return ExperimentsApiFp(this.configuration).getExperimentCheckpoints(id, sortBy, orderBy, offset, limit, states, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of unique experiment labels (sorted by popularity).
     * @param {number} [projectId] Filter experiments by project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getExperimentLabels(projectId?: number, options?: any) {
        return ExperimentsApiFp(this.configuration).getExperimentLabels(projectId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of experiments.
     * @param {V1GetExperimentsRequestSortBy} [sortBy] Sort experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end_time are returned after the ones with end_time.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.  - SORT_BY_NAME: Returns experiments sorted by name.  - SORT_BY_FORKED_FROM: Returns experiments sorted by originating model.  - SORT_BY_RESOURCE_POOL: Returns experiments sorted by resource pool.  - SORT_BY_PROJECT_ID: Returns experiments sorted by project.  - SORT_BY_CHECKPOINT_SIZE: Returns experiments sorted by checkpoint size.  - SORT_BY_CHECKPOINT_COUNT: Returns experiments sorted by checkpoint count.  - SORT_BY_SEARCHER_METRIC_VAL: Returns experiments sorted by searcher metric value..
     * @param {V1OrderBy} [orderBy] Order experiments in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of experiments before returning results. Negative values denote number of experiments to skip from the end before returning results.
     * @param {number} [limit] Limit the number of experiments. 0 or Unspecified - returns a default of 100. -1               - returns everything. -2               - returns pagination info but no experiments.
     * @param {string} [description] Limit experiments to those that match the description.
     * @param {string} [name] Limit experiments to those that match the name.
     * @param {Array<string>} [labels] Limit experiments to those that match the provided labels.
     * @param {boolean} [archived] Limit experiments to those that are archived.
     * @param {Array<Experimentv1State>} [states] Limit experiments to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.  - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.  - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The experiment is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The experiment has an allocation actively running. Running is a substate of the Active state.
     * @param {Array<string>} [users] Limit experiments to those that are owned by users with the specified usernames.
     * @param {Array<number>} [userIds] Limit experiments to those that are owned by users with the specified userIds.
     * @param {number} [projectId] Limit experiments to those within a specified project, or 0 for all projects.
     * @param {number} [experimentIdFilterLt] Less than.
     * @param {number} [experimentIdFilterLte] Less than or equal.
     * @param {number} [experimentIdFilterGt] Greater than.
     * @param {number} [experimentIdFilterGte] Greater than or equal.
     * @param {Array<number>} [experimentIdFilterIncl] In a set. `in` is a reserved word in python.
     * @param {Array<number>} [experimentIdFilterNotIn] Not in a set.
     * @param {boolean} [showTrialData] whether to surface trial specific data from the best trial.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getExperiments(sortBy?: V1GetExperimentsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, description?: string, name?: string, labels?: Array<string>, archived?: boolean, states?: Array<Experimentv1State>, users?: Array<string>, userIds?: Array<number>, projectId?: number, experimentIdFilterLt?: number, experimentIdFilterLte?: number, experimentIdFilterGt?: number, experimentIdFilterGte?: number, experimentIdFilterIncl?: Array<number>, experimentIdFilterNotIn?: Array<number>, showTrialData?: boolean, options?: any) {
        return ExperimentsApiFp(this.configuration).getExperiments(sortBy, orderBy, offset, limit, description, name, labels, archived, states, users, userIds, projectId, experimentIdFilterLt, experimentIdFilterLte, experimentIdFilterGt, experimentIdFilterGte, experimentIdFilterIncl, experimentIdFilterNotIn, showTrialData, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the list of trials for an experiment.
     * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
     * @param {V1GetExperimentTrialsRequestSortBy} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.  - SORT_BY_RESTARTS: Return the trials sorted by the number of restarts.  - SORT_BY_CHECKPOINT_SIZE: Return the trials sorted by checkpoint size.
     * @param {V1OrderBy} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
     * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
     * @param {Array<Experimentv1State>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.  - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.  - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The experiment is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The experiment has an allocation actively running. Running is a substate of the Active state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getExperimentTrials(experimentId: number, sortBy?: V1GetExperimentTrialsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Experimentv1State>, options?: any) {
        return ExperimentsApiFp(this.configuration).getExperimentTrials(experimentId, sortBy, orderBy, offset, limit, states, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the validation history for an experiment.
     * @param {number} experimentId The id of the experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getExperimentValidationHistory(experimentId: number, options?: any) {
        return ExperimentsApiFp(this.configuration).getExperimentValidationHistory(experimentId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the model definition of an experiment.
     * @param {number} experimentId The id of the experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getModelDef(experimentId: number, options?: any) {
        return ExperimentsApiFp(this.configuration).getModelDef(experimentId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get one file content of model definition of an experiment.
     * @param {number} experimentId The id of the experiment.
     * @param {V1GetModelDefFileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getModelDefFile(experimentId: number, body: V1GetModelDefFileRequest, options?: any) {
        return ExperimentsApiFp(this.configuration).getModelDefFile(experimentId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the model definition file tree of an experiment.
     * @param {number} experimentId The id of the experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getModelDefTree(experimentId: number, options?: any) {
        return ExperimentsApiFp(this.configuration).getModelDefTree(experimentId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the list of custom searcher events with long polling.
     * @param {number} experimentId The ID of the experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getSearcherEvents(experimentId: number, options?: any) {
        return ExperimentsApiFp(this.configuration).getSearcherEvents(experimentId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a single trial.
     * @param {number} trialId The requested trial's id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getTrial(trialId: number, options?: any) {
        return ExperimentsApiFp(this.configuration).getTrial(trialId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of checkpoints for a trial.
     * @param {number} id The trial id.
     * @param {V1GetTrialCheckpointsRequestSortBy} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_STATE: Returns checkpoints sorted by state.
     * @param {V1OrderBy} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
     * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
     * @param {Array<Checkpointv1State>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.  - STATE_PARTIALLY_DELETED: The checkpoint has been partially deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public getTrialCheckpoints(id: number, sortBy?: V1GetTrialCheckpointsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Checkpointv1State>, options?: any) {
        return ExperimentsApiFp(this.configuration).getTrialCheckpoints(id, sortBy, orderBy, offset, limit, states, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Kill an experiment.
     * @param {number} id The experiment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public killExperiment(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).killExperiment(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Kill multiple experiments.
     * @param {V1KillExperimentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public killExperiments(body: V1KillExperimentsRequest, options?: any) {
        return ExperimentsApiFp(this.configuration).killExperiments(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Kill a trial.
     * @param {number} id The trial id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public killTrial(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).killTrial(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Move an experiment into a project.
     * @param {number} experimentId The id of the experiment being moved.
     * @param {V1MoveExperimentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public moveExperiment(experimentId: number, body: V1MoveExperimentRequest, options?: any) {
        return ExperimentsApiFp(this.configuration).moveExperiment(experimentId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Move multiple experiments into a project.
     * @param {V1MoveExperimentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public moveExperiments(body: V1MoveExperimentsRequest, options?: any) {
        return ExperimentsApiFp(this.configuration).moveExperiments(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Patch an experiment's fields.
     * @param {number} experimentId The id of the experiment.
     * @param {V1PatchExperiment} body Patched experiment attributes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public patchExperiment(experimentId: number, body: V1PatchExperiment, options?: any) {
        return ExperimentsApiFp(this.configuration).patchExperiment(experimentId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Pause an experiment.
     * @param {number} id The experiment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public pauseExperiment(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).pauseExperiment(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Pause multiple experiments.
     * @param {V1PauseExperimentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public pauseExperiments(body: V1PauseExperimentsRequest, options?: any) {
        return ExperimentsApiFp(this.configuration).pauseExperiments(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Submit operations to a custom searcher.
     * @param {number} experimentId The experiment ID.
     * @param {V1PostSearcherOperationsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public postSearcherOperations(experimentId: number, body: V1PostSearcherOperationsRequest, options?: any) {
        return ExperimentsApiFp(this.configuration).postSearcherOperations(experimentId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Preview hyperparameter search.
     * @param {V1PreviewHPSearchRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public previewHPSearch(body: V1PreviewHPSearchRequest, options?: any) {
        return ExperimentsApiFp(this.configuration).previewHPSearch(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get experiments with grouping and search syntax
     * @param {number} [projectId] ID of the project to look at.
     * @param {number} [offset] How many experiments to skip before including in the results.
     * @param {number} [limit] How many results to show.
     * @param {string} [sort] Sort parameters in the format <col1>=(asc|desc),<col2>=(asc|desc).
     * @param {string} [filter] Filter expression.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public searchExperiments(projectId?: number, offset?: number, limit?: number, sort?: string, filter?: string, options?: any) {
        return ExperimentsApiFp(this.configuration).searchExperiments(projectId, offset, limit, sort, filter, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Stream trial logs.
     * @param {number} trialId The id of the trial.
     * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
     * @param {boolean} [follow] Continue following logs until the trial stops.
     * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
     * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
     * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
     * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
     * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
     * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
     * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
     * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
     * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {string} [searchText] Search the logs by whether the text contains a substring.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public trialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options?: any) {
        return ExperimentsApiFp(this.configuration).trialLogs(trialId, limit, follow, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, searchText, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Stream trial log fields.
     * @param {number} trialId The ID of the trial.
     * @param {boolean} [follow] Continue following fields until the trial stops.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public trialLogsFields(trialId: number, follow?: boolean, options?: any) {
        return ExperimentsApiFp(this.configuration).trialLogsFields(trialId, follow, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Unarchive an experiment.
     * @param {number} id The experiment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public unarchiveExperiment(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).unarchiveExperiment(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Unarchive multiple experiments.
     * @param {V1UnarchiveExperimentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public unarchiveExperiments(body: V1UnarchiveExperimentsRequest, options?: any) {
        return ExperimentsApiFp(this.configuration).unarchiveExperiments(body, options)(this.fetch, this.basePath)
    }
    
}

/**
 * InternalApi - fetch parameter creator
 * @export
 */
export const InternalApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Acknowledge the receipt of a signal to stop the given allocation early. This is used indicate and exit 0 isn't final; specifically, it is used for HP search directed early stops and preemption signals (not necessarily just scheduler preemption).
         * @param {string} allocationId The allocation that is acknowledging the request.
         * @param {V1AckAllocationPreemptionSignalRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackAllocationPreemptionSignal(allocationId: string, body: V1AckAllocationPreemptionSignalRequest, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling ackAllocationPreemptionSignal.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling ackAllocationPreemptionSignal.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/signals/ack_preemption`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary AllocationAllGather performs an all gather through the master. An allocation can only perform once all gather at a time.
         * @param {string} allocationId The ID of the allocation.
         * @param {V1AllocationAllGatherRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationAllGather(allocationId: string, body: V1AllocationAllGatherRequest, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling allocationAllGather.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling allocationAllGather.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/all_gather`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Report the receipt of a signal to stop the given allocation early. This is used to communicate back from a SLURM job that it has been notified of a pending preememption. Upon a call to this API the RM should then trigger a checkpoint and immediate exit.
         * @param {string} allocationId The id of the allocation.
         * @param {V1AllocationPendingPreemptionSignalRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationPendingPreemptionSignal(allocationId: string, body: V1AllocationPendingPreemptionSignalRequest, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling allocationPendingPreemptionSignal.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling allocationPendingPreemptionSignal.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/signals/pending_preemption`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Long poll preemption signals for the given allocation. If the allocation has been preempted when called, it will return so immediately. Otherwise, the connection will be kept open until the timeout is reached or the allocation is preempted.
         * @param {string} allocationId The id of the allocation.
         * @param {number} [timeoutSeconds] The timeout in seconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationPreemptionSignal(allocationId: string, timeoutSeconds?: number, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling allocationPreemptionSignal.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/signals/preemption`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (timeoutSeconds !== undefined) {
                localVarQueryParameter['timeoutSeconds'] = timeoutSeconds
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set allocation to ready state.
         * @param {string} allocationId The id of the allocation.
         * @param {V1AllocationReadyRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationReady(allocationId: string, body: V1AllocationReadyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling allocationReady.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling allocationReady.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/ready`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gather an allocation's rendezvous info. Blocks until all trial containers connect to gather their rendezvous information and responds to them all at once.
         * @param {string} allocationId The id of the allocation.
         * @param {string} resourcesId The id of the clump of resources.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationRendezvousInfo(allocationId: string, resourcesId: string, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling allocationRendezvousInfo.');
            }
            // verify required parameter 'resourcesId' is not null or undefined
            if (resourcesId === null || resourcesId === undefined) {
                throw new RequiredError('resourcesId','Required parameter resourcesId was null or undefined when calling allocationRendezvousInfo.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/resources/{resourcesId}/rendezvous`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)))
                .replace(`{${"resourcesId"}}`, encodeURIComponent(String(resourcesId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set allocation to waiting state.
         * @param {string} allocationId The id of the allocation.
         * @param {V1AllocationWaitingRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationWaiting(allocationId: string, body: V1AllocationWaitingRequest, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling allocationWaiting.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling allocationWaiting.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/waiting`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bind resource pool to workspace
         * @param {string} resourcePoolName The resource pool name.
         * @param {V1BindRPToWorkspaceRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindRPToWorkspace(resourcePoolName: string, body: V1BindRPToWorkspaceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'resourcePoolName' is not null or undefined
            if (resourcePoolName === null || resourcePoolName === undefined) {
                throw new RequiredError('resourcePoolName','Required parameter resourcePoolName was null or undefined when calling bindRPToWorkspace.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling bindRPToWorkspace.');
            }
            const localVarPath = `/api/v1/resource-pools/{resourcePoolName}/workspace-bindings`
                .replace(`{${"resourcePoolName"}}`, encodeURIComponent(String(resourcePoolName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports to the searcher that the trial has completed the given searcher operation.
         * @param {number} trialId The id of the trial.
         * @param {V1CompleteValidateAfterOperation} body The completed operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTrialSearcherValidation(trialId: number, body: V1CompleteValidateAfterOperation, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling completeTrialSearcherValidation.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling completeTrialSearcherValidation.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/searcher/completed_operation`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an experiment.
         * @param {V1CreateExperimentRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperiment(body: V1CreateExperimentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createExperiment.');
            }
            const localVarPath = `/api/v1/experiments`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a group with optional members on creation.
         * @param {V1CreateGroupRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(body: V1CreateGroupRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createGroup.');
            }
            const localVarPath = `/api/v1/groups`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create unmanaged trial.
         * @param {V1CreateTrialRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrial(body: V1CreateTrialRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTrial.');
            }
            const localVarPath = `/api/v1/trials`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a group.
         * @param {number} groupId The id of the group that should be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: number, options: any = {}): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling deleteGroup.');
            }
            const localVarPath = `/api/v1/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'DELETE', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the set of metric names recorded for a list of experiments.
         * @param {Array<number>} ids The ids for the experiments.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expMetricNames(ids: Array<number>, periodSeconds?: number, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling expMetricNames.');
            }
            const localVarPath = `/api/v1/experiments/metrics-stream/metric-names`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (ids) {
                localVarQueryParameter['ids'] = ids
            }
            
            if (periodSeconds !== undefined) {
                localVarQueryParameter['periodSeconds'] = periodSeconds
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the best searcher validation for an experiment by the given metric.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBestSearcherValidationMetric(experimentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling getBestSearcherValidationMetric.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/searcher/best_searcher_validation_metric`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current searcher operation.
         * @param {number} trialId The id of the trial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTrialSearcherOperation(trialId: number, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling getCurrentTrialSearcherOperation.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/searcher/operation`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a group by id.
         * @param {number} groupId The id of the group to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: number, options: any = {}): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling getGroup.');
            }
            const localVarPath = `/api/v1/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for groups with optional filters.
         * @param {V1GetGroupsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(body: V1GetGroupsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getGroups.');
            }
            const localVarPath = `/api/v1/groups/search`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job queue stats for a resource pool.
         * @param {Array<string>} [resourcePools] Filter the results based on a set of resource pools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobQueueStats(resourcePools?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/job-queues/stats`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (resourcePools) {
                localVarQueryParameter['resourcePools'] = resourcePools
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of jobs in queue.
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Pagination limit.
         * @param {string} [resourcePool] The target resource-pool for agent resource manager.
         * @param {V1OrderBy} [orderBy] Order results in either ascending or descending order by the number of jobs ahead.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {Array<Jobv1State>} [states] Filter to jobs with states among those given.   - STATE_UNSPECIFIED: Unspecified state.  - STATE_QUEUED: Job is queued and waiting to be schedlued.  - STATE_SCHEDULED: Job is scheduled.  - STATE_SCHEDULED_BACKFILLED: Job is scheduled as a backfill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(offset?: number, limit?: number, resourcePool?: string, orderBy?: V1OrderBy, states?: Array<Jobv1State>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/job-queues`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (resourcePool !== undefined) {
                localVarQueryParameter['resourcePool'] = resourcePool
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (states) {
                localVarQueryParameter['states'] = states
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of jobs in queue.
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Pagination limit.
         * @param {string} [resourcePool] The target resource-pool for agent resource manager.
         * @param {V1OrderBy} [orderBy] Order results in either ascending or descending order by the number of jobs ahead.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {Array<Jobv1State>} [states] Filter to jobs with states among those given.   - STATE_UNSPECIFIED: Unspecified state.  - STATE_QUEUED: Job is queued and waiting to be schedlued.  - STATE_SCHEDULED: Job is scheduled.  - STATE_SCHEDULED_BACKFILLED: Job is scheduled as a backfill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsV2(offset?: number, limit?: number, resourcePool?: string, orderBy?: V1OrderBy, states?: Array<Jobv1State>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/job-queues-v2`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (resourcePool !== undefined) {
                localVarQueryParameter['resourcePool'] = resourcePool
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (states) {
                localVarQueryParameter['states'] = states
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of columns for experiment list table.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectColumns(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProjectColumns.');
            }
            const localVarPath = `/api/v1/projects/{id}/columns`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get metrics range for a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectNumericMetricsRange(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProjectNumericMetricsRange.');
            }
            const localVarPath = `/api/v1/projects/{id}/experiments/metric-ranges`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all resource pools from the cluster.
         * @param {number} [offset] Skip the number of resource pools before returning results. Negative values denote number of resource pools to skip from the end before returning results.
         * @param {number} [limit] Limit the number of resource pools. A value of 0 denotes no limit.
         * @param {boolean} [unbound] Indicate whether or not to return unbound pools only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePools(offset?: number, limit?: number, unbound?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/resource-pools`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (unbound !== undefined) {
                localVarQueryParameter['unbound'] = unbound
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get telemetry information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelemetry(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/master/telemetry`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the metrics for all trials associated with this checkpoint
         * @param {string} checkpointUuid UUID of the checkpoint.
         * @param {V1TrialSourceInfoType} [trialSourceInfoType] Type of the TrialSourceInfo.   - TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: The type is unspecified  - TRIAL_SOURCE_INFO_TYPE_INFERENCE: "Inference" Trial Source Info Type, used for batch inference  - TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: "Fine Tuning" Trial Source Info Type, used in model hub
         * @param {string} [metricGroup] Metric Group string ("training", "validation", or anything else) (nil means all groups).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialMetricsByCheckpoint(checkpointUuid: string, trialSourceInfoType?: V1TrialSourceInfoType, metricGroup?: string, options: any = {}): FetchArgs {
            // verify required parameter 'checkpointUuid' is not null or undefined
            if (checkpointUuid === null || checkpointUuid === undefined) {
                throw new RequiredError('checkpointUuid','Required parameter checkpointUuid was null or undefined when calling getTrialMetricsByCheckpoint.');
            }
            const localVarPath = `/api/v1/checkpoints/{checkpointUuid}/metrics`
                .replace(`{${"checkpointUuid"}}`, encodeURIComponent(String(checkpointUuid)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (trialSourceInfoType !== undefined) {
                localVarQueryParameter['trialSourceInfoType'] = trialSourceInfoType
            }
            
            if (metricGroup !== undefined) {
                localVarQueryParameter['metricGroup'] = metricGroup
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the metrics for all trials associated with this model version
         * @param {string} modelName The name of the model associated with the model version.
         * @param {number} modelVersionNum Sequential model version number.
         * @param {V1TrialSourceInfoType} [trialSourceInfoType] Type of the TrialSourceInfo.   - TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: The type is unspecified  - TRIAL_SOURCE_INFO_TYPE_INFERENCE: "Inference" Trial Source Info Type, used for batch inference  - TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: "Fine Tuning" Trial Source Info Type, used in model hub
         * @param {string} [metricGroup] Metric Group string ("training", "validation", or anything else) (nil means all groups).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialMetricsByModelVersion(modelName: string, modelVersionNum: number, trialSourceInfoType?: V1TrialSourceInfoType, metricGroup?: string, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling getTrialMetricsByModelVersion.');
            }
            // verify required parameter 'modelVersionNum' is not null or undefined
            if (modelVersionNum === null || modelVersionNum === undefined) {
                throw new RequiredError('modelVersionNum','Required parameter modelVersionNum was null or undefined when calling getTrialMetricsByModelVersion.');
            }
            const localVarPath = `/api/v1/models/{modelName}/versions/{modelVersionNum}/metrics`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)))
                .replace(`{${"modelVersionNum"}}`, encodeURIComponent(String(modelVersionNum)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (trialSourceInfoType !== undefined) {
                localVarQueryParameter['trialSourceInfoType'] = trialSourceInfoType
            }
            
            if (metricGroup !== undefined) {
                localVarQueryParameter['metricGroup'] = metricGroup
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of workloads for a trial.
         * @param {number} trialId Limit workloads to those that are owned by the specified trial.
         * @param {V1OrderBy} [orderBy] Order workloads in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of workloads before returning results. Negative values denote number of workloads to skip from the end before returning results.
         * @param {number} [limit] Limit the number of workloads. A value of 0 denotes no limit.
         * @param {string} [sortKey] Sort workloads by batches, a training metric, or a validation metric.
         * @param {GetTrialWorkloadsRequestFilterOption} [filter] Filter workloads with validation and/or checkpoint information.   - FILTER_OPTION_UNSPECIFIED: Any workload.  - FILTER_OPTION_CHECKPOINT: Only workloads with an associated checkpoint.  - FILTER_OPTION_VALIDATION: Only validation workloads.  - FILTER_OPTION_CHECKPOINT_OR_VALIDATION: Only validation workloads or ones with an associated checkpoint.
         * @param {boolean} [includeBatchMetrics] Include per-batch metrics.
         * @param {V1MetricType} [metricType] When sorting workloads by sort_key, specify training or validation form of a metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {boolean} [removeDeletedCheckpoints] Remove deleted checkpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialWorkloads(trialId: number, orderBy?: V1OrderBy, offset?: number, limit?: number, sortKey?: string, filter?: GetTrialWorkloadsRequestFilterOption, includeBatchMetrics?: boolean, metricType?: V1MetricType, group?: string, removeDeletedCheckpoints?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling getTrialWorkloads.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/workloads`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (sortKey !== undefined) {
                localVarQueryParameter['sortKey'] = sortKey
            }
            
            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter
            }
            
            if (includeBatchMetrics !== undefined) {
                localVarQueryParameter['includeBatchMetrics'] = includeBatchMetrics
            }
            
            if (metricType !== undefined) {
                localVarQueryParameter['metricType'] = metricType
            }
            
            if (group !== undefined) {
                localVarQueryParameter['group'] = group
            }
            
            if (removeDeletedCheckpoints !== undefined) {
                localVarQueryParameter['removeDeletedCheckpoints'] = removeDeletedCheckpoints
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send notebook idle data to master
         * @param {string} notebookId The id of the notebook.
         * @param {V1IdleNotebookRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idleNotebook(notebookId: string, body: V1IdleNotebookRequest, options: any = {}): FetchArgs {
            // verify required parameter 'notebookId' is not null or undefined
            if (notebookId === null || notebookId === undefined) {
                throw new RequiredError('notebookId','Required parameter notebookId was null or undefined when calling idleNotebook.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling idleNotebook.');
            }
            const localVarPath = `/api/v1/notebooks/{notebookId}/report_idle`
                .replace(`{${"notebookId"}}`, encodeURIComponent(String(notebookId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PUT', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all resource pools, bound and unbound, available to a specific workspace
         * @param {number} workspaceId Workspace ID.
         * @param {number} [offset] The offset to use with pagination.
         * @param {number} [limit] The maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRPsBoundToWorkspace(workspaceId: number, offset?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError('workspaceId','Required parameter workspaceId was null or undefined when calling listRPsBoundToWorkspace.');
            }
            const localVarPath = `/api/v1/workspaces/{workspaceId}/available-resource-pools`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all workspaces bound to a specific resource pool
         * @param {string} resourcePoolName Resource pool name.
         * @param {number} [offset] The offset to use with pagination.
         * @param {number} [limit] The maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspacesBoundToRP(resourcePoolName: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'resourcePoolName' is not null or undefined
            if (resourcePoolName === null || resourcePoolName === undefined) {
                throw new RequiredError('resourcePoolName','Required parameter resourcePoolName was null or undefined when calling listWorkspacesBoundToRP.');
            }
            const localVarPath = `/api/v1/resource-pools/{resourcePoolName}/workspace-bindings`
                .replace(`{${"resourcePoolName"}}`, encodeURIComponent(String(resourcePoolName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark the given reservation (container, pod, etc) within an allocation as a daemon reservation. In the exit of a successful exit, Determined will wait for all resources to exit - unless they are marked as daemon resources, in which case Determined will clean them up regardless of exit status after all non-daemon resources have exited.
         * @param {string} allocationId The id of the allocation.
         * @param {string} resourcesId The id of the clump of resources to mark as daemon.
         * @param {V1MarkAllocationResourcesDaemonRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllocationResourcesDaemon(allocationId: string, resourcesId: string, body: V1MarkAllocationResourcesDaemonRequest, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling markAllocationResourcesDaemon.');
            }
            // verify required parameter 'resourcesId' is not null or undefined
            if (resourcesId === null || resourcesId === undefined) {
                throw new RequiredError('resourcesId','Required parameter resourcesId was null or undefined when calling markAllocationResourcesDaemon.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling markAllocationResourcesDaemon.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/resources/{resourcesId}/daemon`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)))
                .replace(`{${"resourcesId"}}`, encodeURIComponent(String(resourcesId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the milestones (in batches processed) at which a metric is recorded by an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {V1MetricType} [metricType] The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricBatches(experimentId: number, metricName: string, metricType?: V1MetricType, group?: string, periodSeconds?: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling metricBatches.');
            }
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new RequiredError('metricName','Required parameter metricName was null or undefined when calling metricBatches.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/metrics-stream/batches`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (metricName !== undefined) {
                localVarQueryParameter['metricName'] = metricName
            }
            
            if (metricType !== undefined) {
                localVarQueryParameter['metricType'] = metricType
            }
            
            if (group !== undefined) {
                localVarQueryParameter['group'] = group
            }
            
            if (periodSeconds !== undefined) {
                localVarQueryParameter['periodSeconds'] = periodSeconds
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary NotifyContainterRunning is used to notify the master that the container is running.  On HPC, the launcher will report a state of "Running" as soon as Slurm starts the job, but the container may be in the process of getting pulled down from the Internet, so the experiment is not really considered to be in a "Running" state until all the containers that are part of the experiment are running and not being pulled.
         * @param {string} allocationId The ID of the allocation.
         * @param {V1NotifyContainerRunningRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyContainerRunning(allocationId: string, body: V1NotifyContainerRunningRequest, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling notifyContainerRunning.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling notifyContainerRunning.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/notify_container_running`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Overwrite resource pool - workspace bindings
         * @param {string} resourcePoolName The resource pool name.
         * @param {V1OverwriteRPWorkspaceBindingsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overwriteRPWorkspaceBindings(resourcePoolName: string, body: V1OverwriteRPWorkspaceBindingsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'resourcePoolName' is not null or undefined
            if (resourcePoolName === null || resourcePoolName === undefined) {
                throw new RequiredError('resourcePoolName','Required parameter resourcePoolName was null or undefined when calling overwriteRPWorkspaceBindings.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling overwriteRPWorkspaceBindings.');
            }
            const localVarPath = `/api/v1/resource-pools/{resourcePoolName}/workspace-bindings`
                .replace(`{${"resourcePoolName"}}`, encodeURIComponent(String(resourcePoolName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PUT', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update checkpoints. Won't modify checkpoint files.
         * @param {V1PatchCheckpointsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCheckpoints(body: V1PatchCheckpointsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchCheckpoints.');
            }
            const localVarPath = `/api/v1/checkpoints`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PATCH', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch (an unmanaged) trial.
         * @param {number} trialId Trial id.
         * @param {V1PatchTrialRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTrial(trialId: number, body: V1PatchTrialRequest, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling patchTrial.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchTrial.');
            }
            const localVarPath = `/api/v1/trials/{trialId}`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PATCH', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PostAllocationProxyAddress sets the proxy address to use when proxying to services provided by an allocation. Upon receipt, the master will also register any proxies specified by the task.
         * @param {string} allocationId The id of the allocation.
         * @param {V1PostAllocationProxyAddressRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAllocationProxyAddress(allocationId: string, body: V1PostAllocationProxyAddressRequest, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling postAllocationProxyAddress.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postAllocationProxyAddress.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/proxy_address`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Persist the given TrialProfilerMetricsBatch. The trial ID is in the labels.
         * @param {V1PostTrialProfilerMetricsBatchRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrialProfilerMetricsBatch(body: V1PostTrialProfilerMetricsBatchRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postTrialProfilerMetricsBatch.');
            }
            const localVarPath = `/api/v1/trials/profiler/metrics`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary For bookkeeping, update trial runner metadata (currently just state).
         * @param {number} trialId The id of the trial.
         * @param {V1TrialRunnerMetadata} body The state for the trial runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrialRunnerMetadata(trialId: number, body: V1TrialRunnerMetadata, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling postTrialRunnerMetadata.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postTrialRunnerMetadata.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/runner/metadata`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put an experiment by external id.
         * @param {string} externalExperimentId External experiment id.
         * @param {V1CreateExperimentRequest} body CreateExperimentRequest payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putExperiment(externalExperimentId: string, body: V1CreateExperimentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'externalExperimentId' is not null or undefined
            if (externalExperimentId === null || externalExperimentId === undefined) {
                throw new RequiredError('externalExperimentId','Required parameter externalExperimentId was null or undefined when calling putExperiment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putExperiment.');
            }
            const localVarPath = `/api/v1/experiments/by-external-id/{externalExperimentId}`
                .replace(`{${"externalExperimentId"}}`, encodeURIComponent(String(externalExperimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PUT', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put a trial.
         * @param {V1PutTrialRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTrial(body: V1PutTrialRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putTrial.');
            }
            const localVarPath = `/api/v1/trials`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PUT', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a checkpoint.
         * @param {V1Checkpoint} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportCheckpoint(body: V1Checkpoint, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling reportCheckpoint.');
            }
            const localVarPath = `/api/v1/checkpoints`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record metrics for specified trial.
         * @param {number} metricsTrialId The trial associated with these metrics.
         * @param {V1ReportTrialMetricsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialMetrics(metricsTrialId: number, body: V1ReportTrialMetricsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'metricsTrialId' is not null or undefined
            if (metricsTrialId === null || metricsTrialId === undefined) {
                throw new RequiredError('metricsTrialId','Required parameter metricsTrialId was null or undefined when calling reportTrialMetrics.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling reportTrialMetrics.');
            }
            const localVarPath = `/api/v1/trials/{metricsTrialId}/metrics`
                .replace(`{${"metricsTrialId"}}`, encodeURIComponent(String(metricsTrialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary For bookkeeping, updates the progress towards to current requested searcher training length.
         * @param {number} trialId The id of the trial.
         * @param {number} body Total units completed by the trial, in terms of the unit used to configure the searcher.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialProgress(trialId: number, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling reportTrialProgress.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling reportTrialProgress.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/progress`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports to the searcher that the trial has completed the current requested amount of training with the given searcher validation metric.
         * @param {number} trialId The id of the trial.
         * @param {V1TrialEarlyExit} body The exit reason.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialSearcherEarlyExit(trialId: number, body: V1TrialEarlyExit, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling reportTrialSearcherEarlyExit.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling reportTrialSearcherEarlyExit.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/early_exit`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports a TrialSourceInfo entry for tracking inference or fine-tuning runs
         * @param {V1ReportTrialSourceInfoRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialSourceInfo(body: V1ReportTrialSourceInfoRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling reportTrialSourceInfo.');
            }
            const localVarPath = `/api/v1/trial-source-info`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record training metrics for specified training.
         * @param {number} trainingMetricsTrialId The trial associated with these metrics.
         * @param {V1TrialMetrics} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialTrainingMetrics(trainingMetricsTrialId: number, body: V1TrialMetrics, options: any = {}): FetchArgs {
            // verify required parameter 'trainingMetricsTrialId' is not null or undefined
            if (trainingMetricsTrialId === null || trainingMetricsTrialId === undefined) {
                throw new RequiredError('trainingMetricsTrialId','Required parameter trainingMetricsTrialId was null or undefined when calling reportTrialTrainingMetrics.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling reportTrialTrainingMetrics.');
            }
            const localVarPath = `/api/v1/trials/{trainingMetricsTrialId}/training_metrics`
                .replace(`{${"trainingMetricsTrialId"}}`, encodeURIComponent(String(trainingMetricsTrialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record validation metrics.
         * @param {number} validationMetricsTrialId The trial associated with these metrics.
         * @param {V1TrialMetrics} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialValidationMetrics(validationMetricsTrialId: number, body: V1TrialMetrics, options: any = {}): FetchArgs {
            // verify required parameter 'validationMetricsTrialId' is not null or undefined
            if (validationMetricsTrialId === null || validationMetricsTrialId === undefined) {
                throw new RequiredError('validationMetricsTrialId','Required parameter validationMetricsTrialId was null or undefined when calling reportTrialValidationMetrics.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling reportTrialValidationMetrics.');
            }
            const localVarPath = `/api/v1/trials/{validationMetricsTrialId}/validation_metrics`
                .replace(`{${"validationMetricsTrialId"}}`, encodeURIComponent(String(validationMetricsTrialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get experiments with grouping and search syntax
         * @param {number} [projectId] ID of the project to look at.
         * @param {number} [offset] How many experiments to skip before including in the results.
         * @param {number} [limit] How many results to show.
         * @param {string} [sort] Sort parameters in the format <col1>=(asc|desc),<col2>=(asc|desc).
         * @param {string} [filter] Filter expression.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchExperiments(projectId?: number, offset?: number, limit?: number, sort?: string, filter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/experiments-search`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort
            }
            
            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start (an unmanaged) trial.
         * @param {number} trialId Trial id.
         * @param {V1StartTrialRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTrial(trialId: number, body: V1StartTrialRequest, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling startTrial.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling startTrial.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/start`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a sample of the metrics over time for a sample of the trials.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {V1MetricType} [metricType] The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {number} [maxTrials] Maximum number of trials to fetch data for.
         * @param {number} [maxDatapoints] Maximum number of initial / historical data points.
         * @param {number} [startBatches] Beginning of window (inclusive) to fetch data for.
         * @param {number} [endBatches] Ending of window (inclusive) to fetch data for.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialsSample(experimentId: number, metricName: string, metricType?: V1MetricType, group?: string, maxTrials?: number, maxDatapoints?: number, startBatches?: number, endBatches?: number, periodSeconds?: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling trialsSample.');
            }
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new RequiredError('metricName','Required parameter metricName was null or undefined when calling trialsSample.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/metrics-stream/trials-sample`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (metricName !== undefined) {
                localVarQueryParameter['metricName'] = metricName
            }
            
            if (metricType !== undefined) {
                localVarQueryParameter['metricType'] = metricType
            }
            
            if (group !== undefined) {
                localVarQueryParameter['group'] = group
            }
            
            if (maxTrials !== undefined) {
                localVarQueryParameter['maxTrials'] = maxTrials
            }
            
            if (maxDatapoints !== undefined) {
                localVarQueryParameter['maxDatapoints'] = maxDatapoints
            }
            
            if (startBatches !== undefined) {
                localVarQueryParameter['startBatches'] = startBatches
            }
            
            if (endBatches !== undefined) {
                localVarQueryParameter['endBatches'] = endBatches
            }
            
            if (periodSeconds !== undefined) {
                localVarQueryParameter['periodSeconds'] = periodSeconds
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a snapshot of a metric across all trials at a certain point of progress.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {number} batchesProcessed The point of progress at which to query metrics.
         * @param {V1MetricType} [metricType] The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {number} [batchesMargin] A range either side of batches_processed to include near-misses.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialsSnapshot(experimentId: number, metricName: string, batchesProcessed: number, metricType?: V1MetricType, group?: string, batchesMargin?: number, periodSeconds?: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling trialsSnapshot.');
            }
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new RequiredError('metricName','Required parameter metricName was null or undefined when calling trialsSnapshot.');
            }
            // verify required parameter 'batchesProcessed' is not null or undefined
            if (batchesProcessed === null || batchesProcessed === undefined) {
                throw new RequiredError('batchesProcessed','Required parameter batchesProcessed was null or undefined when calling trialsSnapshot.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/metrics-stream/trials-snapshot`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (metricName !== undefined) {
                localVarQueryParameter['metricName'] = metricName
            }
            
            if (metricType !== undefined) {
                localVarQueryParameter['metricType'] = metricType
            }
            
            if (group !== undefined) {
                localVarQueryParameter['group'] = group
            }
            
            if (batchesProcessed !== undefined) {
                localVarQueryParameter['batchesProcessed'] = batchesProcessed
            }
            
            if (batchesMargin !== undefined) {
                localVarQueryParameter['batchesMargin'] = batchesMargin
            }
            
            if (periodSeconds !== undefined) {
                localVarQueryParameter['periodSeconds'] = periodSeconds
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unbind resource pool to workspace
         * @param {string} resourcePoolName The resource pool name.
         * @param {V1UnbindRPFromWorkspaceRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindRPFromWorkspace(resourcePoolName: string, body: V1UnbindRPFromWorkspaceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'resourcePoolName' is not null or undefined
            if (resourcePoolName === null || resourcePoolName === undefined) {
                throw new RequiredError('resourcePoolName','Required parameter resourcePoolName was null or undefined when calling unbindRPFromWorkspace.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling unbindRPFromWorkspace.');
            }
            const localVarPath = `/api/v1/resource-pools/{resourcePoolName}/workspace-bindings`
                .replace(`{${"resourcePoolName"}}`, encodeURIComponent(String(resourcePoolName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'DELETE', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update group info.
         * @param {number} groupId The id of the group
         * @param {V1UpdateGroupRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupId: number, body: V1UpdateGroupRequest, options: any = {}): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling updateGroup.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateGroup.');
            }
            const localVarPath = `/api/v1/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PUT', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Control the job queues.
         * @param {V1UpdateJobQueueRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobQueue(body: V1UpdateJobQueueRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateJobQueue.');
            }
            const localVarPath = `/api/v1/job-queues`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Acknowledge the receipt of a signal to stop the given allocation early. This is used indicate and exit 0 isn't final; specifically, it is used for HP search directed early stops and preemption signals (not necessarily just scheduler preemption).
         * @param {string} allocationId The allocation that is acknowledging the request.
         * @param {V1AckAllocationPreemptionSignalRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackAllocationPreemptionSignal(allocationId: string, body: V1AckAllocationPreemptionSignalRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AckAllocationPreemptionSignalResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).ackAllocationPreemptionSignal(allocationId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary AllocationAllGather performs an all gather through the master. An allocation can only perform once all gather at a time.
         * @param {string} allocationId The ID of the allocation.
         * @param {V1AllocationAllGatherRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationAllGather(allocationId: string, body: V1AllocationAllGatherRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AllocationAllGatherResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).allocationAllGather(allocationId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Report the receipt of a signal to stop the given allocation early. This is used to communicate back from a SLURM job that it has been notified of a pending preememption. Upon a call to this API the RM should then trigger a checkpoint and immediate exit.
         * @param {string} allocationId The id of the allocation.
         * @param {V1AllocationPendingPreemptionSignalRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationPendingPreemptionSignal(allocationId: string, body: V1AllocationPendingPreemptionSignalRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AllocationPendingPreemptionSignalResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).allocationPendingPreemptionSignal(allocationId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Long poll preemption signals for the given allocation. If the allocation has been preempted when called, it will return so immediately. Otherwise, the connection will be kept open until the timeout is reached or the allocation is preempted.
         * @param {string} allocationId The id of the allocation.
         * @param {number} [timeoutSeconds] The timeout in seconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationPreemptionSignal(allocationId: string, timeoutSeconds?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AllocationPreemptionSignalResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).allocationPreemptionSignal(allocationId, timeoutSeconds, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set allocation to ready state.
         * @param {string} allocationId The id of the allocation.
         * @param {V1AllocationReadyRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationReady(allocationId: string, body: V1AllocationReadyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AllocationReadyResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).allocationReady(allocationId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gather an allocation's rendezvous info. Blocks until all trial containers connect to gather their rendezvous information and responds to them all at once.
         * @param {string} allocationId The id of the allocation.
         * @param {string} resourcesId The id of the clump of resources.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationRendezvousInfo(allocationId: string, resourcesId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AllocationRendezvousInfoResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).allocationRendezvousInfo(allocationId, resourcesId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set allocation to waiting state.
         * @param {string} allocationId The id of the allocation.
         * @param {V1AllocationWaitingRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationWaiting(allocationId: string, body: V1AllocationWaitingRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AllocationWaitingResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).allocationWaiting(allocationId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bind resource pool to workspace
         * @param {string} resourcePoolName The resource pool name.
         * @param {V1BindRPToWorkspaceRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindRPToWorkspace(resourcePoolName: string, body: V1BindRPToWorkspaceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1BindRPToWorkspaceResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).bindRPToWorkspace(resourcePoolName, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reports to the searcher that the trial has completed the given searcher operation.
         * @param {number} trialId The id of the trial.
         * @param {V1CompleteValidateAfterOperation} body The completed operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTrialSearcherValidation(trialId: number, body: V1CompleteValidateAfterOperation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CompleteTrialSearcherValidationResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).completeTrialSearcherValidation(trialId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create an experiment.
         * @param {V1CreateExperimentRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperiment(body: V1CreateExperimentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreateExperimentResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).createExperiment(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a group with optional members on creation.
         * @param {V1CreateGroupRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(body: V1CreateGroupRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreateGroupResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).createGroup(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create unmanaged trial.
         * @param {V1CreateTrialRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrial(body: V1CreateTrialRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreateTrialResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).createTrial(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove a group.
         * @param {number} groupId The id of the group that should be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeleteGroupResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).deleteGroup(groupId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the set of metric names recorded for a list of experiments.
         * @param {Array<number>} ids The ids for the experiments.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expMetricNames(ids: Array<number>, periodSeconds?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1ExpMetricNamesResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).expMetricNames(ids, periodSeconds, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the best searcher validation for an experiment by the given metric.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBestSearcherValidationMetric(experimentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetBestSearcherValidationMetricResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getBestSearcherValidationMetric(experimentId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the current searcher operation.
         * @param {number} trialId The id of the trial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTrialSearcherOperation(trialId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetCurrentTrialSearcherOperationResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getCurrentTrialSearcherOperation(trialId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a group by id.
         * @param {number} groupId The id of the group to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetGroupResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getGroup(groupId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Search for groups with optional filters.
         * @param {V1GetGroupsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(body: V1GetGroupsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetGroupsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getGroups(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get job queue stats for a resource pool.
         * @param {Array<string>} [resourcePools] Filter the results based on a set of resource pools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobQueueStats(resourcePools?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetJobQueueStatsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getJobQueueStats(resourcePools, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of jobs in queue.
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Pagination limit.
         * @param {string} [resourcePool] The target resource-pool for agent resource manager.
         * @param {V1OrderBy} [orderBy] Order results in either ascending or descending order by the number of jobs ahead.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {Array<Jobv1State>} [states] Filter to jobs with states among those given.   - STATE_UNSPECIFIED: Unspecified state.  - STATE_QUEUED: Job is queued and waiting to be schedlued.  - STATE_SCHEDULED: Job is scheduled.  - STATE_SCHEDULED_BACKFILLED: Job is scheduled as a backfill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(offset?: number, limit?: number, resourcePool?: string, orderBy?: V1OrderBy, states?: Array<Jobv1State>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetJobsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getJobs(offset, limit, resourcePool, orderBy, states, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of jobs in queue.
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Pagination limit.
         * @param {string} [resourcePool] The target resource-pool for agent resource manager.
         * @param {V1OrderBy} [orderBy] Order results in either ascending or descending order by the number of jobs ahead.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {Array<Jobv1State>} [states] Filter to jobs with states among those given.   - STATE_UNSPECIFIED: Unspecified state.  - STATE_QUEUED: Job is queued and waiting to be schedlued.  - STATE_SCHEDULED: Job is scheduled.  - STATE_SCHEDULED_BACKFILLED: Job is scheduled as a backfill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsV2(offset?: number, limit?: number, resourcePool?: string, orderBy?: V1OrderBy, states?: Array<Jobv1State>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetJobsV2Response> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getJobsV2(offset, limit, resourcePool, orderBy, states, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of columns for experiment list table.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectColumns(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetProjectColumnsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getProjectColumns(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get metrics range for a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectNumericMetricsRange(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetProjectNumericMetricsRangeResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getProjectNumericMetricsRange(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of all resource pools from the cluster.
         * @param {number} [offset] Skip the number of resource pools before returning results. Negative values denote number of resource pools to skip from the end before returning results.
         * @param {number} [limit] Limit the number of resource pools. A value of 0 denotes no limit.
         * @param {boolean} [unbound] Indicate whether or not to return unbound pools only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePools(offset?: number, limit?: number, unbound?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetResourcePoolsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getResourcePools(offset, limit, unbound, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get telemetry information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelemetry(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTelemetryResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getTelemetry(options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the metrics for all trials associated with this checkpoint
         * @param {string} checkpointUuid UUID of the checkpoint.
         * @param {V1TrialSourceInfoType} [trialSourceInfoType] Type of the TrialSourceInfo.   - TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: The type is unspecified  - TRIAL_SOURCE_INFO_TYPE_INFERENCE: "Inference" Trial Source Info Type, used for batch inference  - TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: "Fine Tuning" Trial Source Info Type, used in model hub
         * @param {string} [metricGroup] Metric Group string ("training", "validation", or anything else) (nil means all groups).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialMetricsByCheckpoint(checkpointUuid: string, trialSourceInfoType?: V1TrialSourceInfoType, metricGroup?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTrialMetricsByCheckpointResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getTrialMetricsByCheckpoint(checkpointUuid, trialSourceInfoType, metricGroup, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the metrics for all trials associated with this model version
         * @param {string} modelName The name of the model associated with the model version.
         * @param {number} modelVersionNum Sequential model version number.
         * @param {V1TrialSourceInfoType} [trialSourceInfoType] Type of the TrialSourceInfo.   - TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: The type is unspecified  - TRIAL_SOURCE_INFO_TYPE_INFERENCE: "Inference" Trial Source Info Type, used for batch inference  - TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: "Fine Tuning" Trial Source Info Type, used in model hub
         * @param {string} [metricGroup] Metric Group string ("training", "validation", or anything else) (nil means all groups).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialMetricsByModelVersion(modelName: string, modelVersionNum: number, trialSourceInfoType?: V1TrialSourceInfoType, metricGroup?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTrialMetricsByModelVersionResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getTrialMetricsByModelVersion(modelName, modelVersionNum, trialSourceInfoType, metricGroup, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of workloads for a trial.
         * @param {number} trialId Limit workloads to those that are owned by the specified trial.
         * @param {V1OrderBy} [orderBy] Order workloads in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of workloads before returning results. Negative values denote number of workloads to skip from the end before returning results.
         * @param {number} [limit] Limit the number of workloads. A value of 0 denotes no limit.
         * @param {string} [sortKey] Sort workloads by batches, a training metric, or a validation metric.
         * @param {GetTrialWorkloadsRequestFilterOption} [filter] Filter workloads with validation and/or checkpoint information.   - FILTER_OPTION_UNSPECIFIED: Any workload.  - FILTER_OPTION_CHECKPOINT: Only workloads with an associated checkpoint.  - FILTER_OPTION_VALIDATION: Only validation workloads.  - FILTER_OPTION_CHECKPOINT_OR_VALIDATION: Only validation workloads or ones with an associated checkpoint.
         * @param {boolean} [includeBatchMetrics] Include per-batch metrics.
         * @param {V1MetricType} [metricType] When sorting workloads by sort_key, specify training or validation form of a metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {boolean} [removeDeletedCheckpoints] Remove deleted checkpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialWorkloads(trialId: number, orderBy?: V1OrderBy, offset?: number, limit?: number, sortKey?: string, filter?: GetTrialWorkloadsRequestFilterOption, includeBatchMetrics?: boolean, metricType?: V1MetricType, group?: string, removeDeletedCheckpoints?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTrialWorkloadsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).getTrialWorkloads(trialId, orderBy, offset, limit, sortKey, filter, includeBatchMetrics, metricType, group, removeDeletedCheckpoints, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Send notebook idle data to master
         * @param {string} notebookId The id of the notebook.
         * @param {V1IdleNotebookRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idleNotebook(notebookId: string, body: V1IdleNotebookRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1IdleNotebookResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).idleNotebook(notebookId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all resource pools, bound and unbound, available to a specific workspace
         * @param {number} workspaceId Workspace ID.
         * @param {number} [offset] The offset to use with pagination.
         * @param {number} [limit] The maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRPsBoundToWorkspace(workspaceId: number, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRPsBoundToWorkspaceResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).listRPsBoundToWorkspace(workspaceId, offset, limit, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all workspaces bound to a specific resource pool
         * @param {string} resourcePoolName Resource pool name.
         * @param {number} [offset] The offset to use with pagination.
         * @param {number} [limit] The maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspacesBoundToRP(resourcePoolName: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListWorkspacesBoundToRPResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).listWorkspacesBoundToRP(resourcePoolName, offset, limit, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mark the given reservation (container, pod, etc) within an allocation as a daemon reservation. In the exit of a successful exit, Determined will wait for all resources to exit - unless they are marked as daemon resources, in which case Determined will clean them up regardless of exit status after all non-daemon resources have exited.
         * @param {string} allocationId The id of the allocation.
         * @param {string} resourcesId The id of the clump of resources to mark as daemon.
         * @param {V1MarkAllocationResourcesDaemonRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllocationResourcesDaemon(allocationId: string, resourcesId: string, body: V1MarkAllocationResourcesDaemonRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1MarkAllocationResourcesDaemonResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).markAllocationResourcesDaemon(allocationId, resourcesId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the milestones (in batches processed) at which a metric is recorded by an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {V1MetricType} [metricType] The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricBatches(experimentId: number, metricName: string, metricType?: V1MetricType, group?: string, periodSeconds?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1MetricBatchesResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).metricBatches(experimentId, metricName, metricType, group, periodSeconds, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary NotifyContainterRunning is used to notify the master that the container is running.  On HPC, the launcher will report a state of "Running" as soon as Slurm starts the job, but the container may be in the process of getting pulled down from the Internet, so the experiment is not really considered to be in a "Running" state until all the containers that are part of the experiment are running and not being pulled.
         * @param {string} allocationId The ID of the allocation.
         * @param {V1NotifyContainerRunningRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyContainerRunning(allocationId: string, body: V1NotifyContainerRunningRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1NotifyContainerRunningResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).notifyContainerRunning(allocationId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Overwrite resource pool - workspace bindings
         * @param {string} resourcePoolName The resource pool name.
         * @param {V1OverwriteRPWorkspaceBindingsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overwriteRPWorkspaceBindings(resourcePoolName: string, body: V1OverwriteRPWorkspaceBindingsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1OverwriteRPWorkspaceBindingsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).overwriteRPWorkspaceBindings(resourcePoolName, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update checkpoints. Won't modify checkpoint files.
         * @param {V1PatchCheckpointsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCheckpoints(body: V1PatchCheckpointsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PatchCheckpointsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).patchCheckpoints(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch (an unmanaged) trial.
         * @param {number} trialId Trial id.
         * @param {V1PatchTrialRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTrial(trialId: number, body: V1PatchTrialRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PatchTrialResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).patchTrial(trialId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary PostAllocationProxyAddress sets the proxy address to use when proxying to services provided by an allocation. Upon receipt, the master will also register any proxies specified by the task.
         * @param {string} allocationId The id of the allocation.
         * @param {V1PostAllocationProxyAddressRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAllocationProxyAddress(allocationId: string, body: V1PostAllocationProxyAddressRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostAllocationProxyAddressResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).postAllocationProxyAddress(allocationId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Persist the given TrialProfilerMetricsBatch. The trial ID is in the labels.
         * @param {V1PostTrialProfilerMetricsBatchRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrialProfilerMetricsBatch(body: V1PostTrialProfilerMetricsBatchRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostTrialProfilerMetricsBatchResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).postTrialProfilerMetricsBatch(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary For bookkeeping, update trial runner metadata (currently just state).
         * @param {number} trialId The id of the trial.
         * @param {V1TrialRunnerMetadata} body The state for the trial runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrialRunnerMetadata(trialId: number, body: V1TrialRunnerMetadata, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostTrialRunnerMetadataResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).postTrialRunnerMetadata(trialId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Put an experiment by external id.
         * @param {string} externalExperimentId External experiment id.
         * @param {V1CreateExperimentRequest} body CreateExperimentRequest payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putExperiment(externalExperimentId: string, body: V1CreateExperimentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PutExperimentResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).putExperiment(externalExperimentId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Put a trial.
         * @param {V1PutTrialRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTrial(body: V1PutTrialRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PutTrialResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).putTrial(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Record a checkpoint.
         * @param {V1Checkpoint} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportCheckpoint(body: V1Checkpoint, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ReportCheckpointResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).reportCheckpoint(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Record metrics for specified trial.
         * @param {number} metricsTrialId The trial associated with these metrics.
         * @param {V1ReportTrialMetricsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialMetrics(metricsTrialId: number, body: V1ReportTrialMetricsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ReportTrialMetricsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).reportTrialMetrics(metricsTrialId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary For bookkeeping, updates the progress towards to current requested searcher training length.
         * @param {number} trialId The id of the trial.
         * @param {number} body Total units completed by the trial, in terms of the unit used to configure the searcher.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialProgress(trialId: number, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ReportTrialProgressResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).reportTrialProgress(trialId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reports to the searcher that the trial has completed the current requested amount of training with the given searcher validation metric.
         * @param {number} trialId The id of the trial.
         * @param {V1TrialEarlyExit} body The exit reason.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialSearcherEarlyExit(trialId: number, body: V1TrialEarlyExit, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ReportTrialSearcherEarlyExitResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).reportTrialSearcherEarlyExit(trialId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reports a TrialSourceInfo entry for tracking inference or fine-tuning runs
         * @param {V1ReportTrialSourceInfoRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialSourceInfo(body: V1ReportTrialSourceInfoRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ReportTrialSourceInfoResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).reportTrialSourceInfo(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Record training metrics for specified training.
         * @param {number} trainingMetricsTrialId The trial associated with these metrics.
         * @param {V1TrialMetrics} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialTrainingMetrics(trainingMetricsTrialId: number, body: V1TrialMetrics, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ReportTrialTrainingMetricsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).reportTrialTrainingMetrics(trainingMetricsTrialId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Record validation metrics.
         * @param {number} validationMetricsTrialId The trial associated with these metrics.
         * @param {V1TrialMetrics} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialValidationMetrics(validationMetricsTrialId: number, body: V1TrialMetrics, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ReportTrialValidationMetricsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).reportTrialValidationMetrics(validationMetricsTrialId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get experiments with grouping and search syntax
         * @param {number} [projectId] ID of the project to look at.
         * @param {number} [offset] How many experiments to skip before including in the results.
         * @param {number} [limit] How many results to show.
         * @param {string} [sort] Sort parameters in the format <col1>=(asc|desc),<col2>=(asc|desc).
         * @param {string} [filter] Filter expression.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchExperiments(projectId?: number, offset?: number, limit?: number, sort?: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SearchExperimentsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).searchExperiments(projectId, offset, limit, sort, filter, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Start (an unmanaged) trial.
         * @param {number} trialId Trial id.
         * @param {V1StartTrialRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTrial(trialId: number, body: V1StartTrialRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1StartTrialResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).startTrial(trialId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a sample of the metrics over time for a sample of the trials.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {V1MetricType} [metricType] The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {number} [maxTrials] Maximum number of trials to fetch data for.
         * @param {number} [maxDatapoints] Maximum number of initial / historical data points.
         * @param {number} [startBatches] Beginning of window (inclusive) to fetch data for.
         * @param {number} [endBatches] Ending of window (inclusive) to fetch data for.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialsSample(experimentId: number, metricName: string, metricType?: V1MetricType, group?: string, maxTrials?: number, maxDatapoints?: number, startBatches?: number, endBatches?: number, periodSeconds?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TrialsSampleResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).trialsSample(experimentId, metricName, metricType, group, maxTrials, maxDatapoints, startBatches, endBatches, periodSeconds, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a snapshot of a metric across all trials at a certain point of progress.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {number} batchesProcessed The point of progress at which to query metrics.
         * @param {V1MetricType} [metricType] The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {number} [batchesMargin] A range either side of batches_processed to include near-misses.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialsSnapshot(experimentId: number, metricName: string, batchesProcessed: number, metricType?: V1MetricType, group?: string, batchesMargin?: number, periodSeconds?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TrialsSnapshotResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).trialsSnapshot(experimentId, metricName, batchesProcessed, metricType, group, batchesMargin, periodSeconds, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unbind resource pool to workspace
         * @param {string} resourcePoolName The resource pool name.
         * @param {V1UnbindRPFromWorkspaceRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindRPFromWorkspace(resourcePoolName: string, body: V1UnbindRPFromWorkspaceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UnbindRPFromWorkspaceResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).unbindRPFromWorkspace(resourcePoolName, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update group info.
         * @param {number} groupId The id of the group
         * @param {V1UpdateGroupRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupId: number, body: V1UpdateGroupRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UpdateGroupResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).updateGroup(groupId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Control the job queues.
         * @param {V1UpdateJobQueueRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobQueue(body: V1UpdateJobQueueRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UpdateJobQueueResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).updateJobQueue(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Acknowledge the receipt of a signal to stop the given allocation early. This is used indicate and exit 0 isn't final; specifically, it is used for HP search directed early stops and preemption signals (not necessarily just scheduler preemption).
         * @param {string} allocationId The allocation that is acknowledging the request.
         * @param {V1AckAllocationPreemptionSignalRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackAllocationPreemptionSignal(allocationId: string, body: V1AckAllocationPreemptionSignalRequest, options?: any) {
            return InternalApiFp(configuration).ackAllocationPreemptionSignal(allocationId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary AllocationAllGather performs an all gather through the master. An allocation can only perform once all gather at a time.
         * @param {string} allocationId The ID of the allocation.
         * @param {V1AllocationAllGatherRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationAllGather(allocationId: string, body: V1AllocationAllGatherRequest, options?: any) {
            return InternalApiFp(configuration).allocationAllGather(allocationId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Report the receipt of a signal to stop the given allocation early. This is used to communicate back from a SLURM job that it has been notified of a pending preememption. Upon a call to this API the RM should then trigger a checkpoint and immediate exit.
         * @param {string} allocationId The id of the allocation.
         * @param {V1AllocationPendingPreemptionSignalRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationPendingPreemptionSignal(allocationId: string, body: V1AllocationPendingPreemptionSignalRequest, options?: any) {
            return InternalApiFp(configuration).allocationPendingPreemptionSignal(allocationId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Long poll preemption signals for the given allocation. If the allocation has been preempted when called, it will return so immediately. Otherwise, the connection will be kept open until the timeout is reached or the allocation is preempted.
         * @param {string} allocationId The id of the allocation.
         * @param {number} [timeoutSeconds] The timeout in seconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationPreemptionSignal(allocationId: string, timeoutSeconds?: number, options?: any) {
            return InternalApiFp(configuration).allocationPreemptionSignal(allocationId, timeoutSeconds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set allocation to ready state.
         * @param {string} allocationId The id of the allocation.
         * @param {V1AllocationReadyRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationReady(allocationId: string, body: V1AllocationReadyRequest, options?: any) {
            return InternalApiFp(configuration).allocationReady(allocationId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gather an allocation's rendezvous info. Blocks until all trial containers connect to gather their rendezvous information and responds to them all at once.
         * @param {string} allocationId The id of the allocation.
         * @param {string} resourcesId The id of the clump of resources.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationRendezvousInfo(allocationId: string, resourcesId: string, options?: any) {
            return InternalApiFp(configuration).allocationRendezvousInfo(allocationId, resourcesId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set allocation to waiting state.
         * @param {string} allocationId The id of the allocation.
         * @param {V1AllocationWaitingRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocationWaiting(allocationId: string, body: V1AllocationWaitingRequest, options?: any) {
            return InternalApiFp(configuration).allocationWaiting(allocationId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bind resource pool to workspace
         * @param {string} resourcePoolName The resource pool name.
         * @param {V1BindRPToWorkspaceRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindRPToWorkspace(resourcePoolName: string, body: V1BindRPToWorkspaceRequest, options?: any) {
            return InternalApiFp(configuration).bindRPToWorkspace(resourcePoolName, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reports to the searcher that the trial has completed the given searcher operation.
         * @param {number} trialId The id of the trial.
         * @param {V1CompleteValidateAfterOperation} body The completed operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTrialSearcherValidation(trialId: number, body: V1CompleteValidateAfterOperation, options?: any) {
            return InternalApiFp(configuration).completeTrialSearcherValidation(trialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create an experiment.
         * @param {V1CreateExperimentRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperiment(body: V1CreateExperimentRequest, options?: any) {
            return InternalApiFp(configuration).createExperiment(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a group with optional members on creation.
         * @param {V1CreateGroupRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(body: V1CreateGroupRequest, options?: any) {
            return InternalApiFp(configuration).createGroup(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create unmanaged trial.
         * @param {V1CreateTrialRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrial(body: V1CreateTrialRequest, options?: any) {
            return InternalApiFp(configuration).createTrial(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a group.
         * @param {number} groupId The id of the group that should be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: number, options?: any) {
            return InternalApiFp(configuration).deleteGroup(groupId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the set of metric names recorded for a list of experiments.
         * @param {Array<number>} ids The ids for the experiments.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expMetricNames(ids: Array<number>, periodSeconds?: number, options?: any) {
            return InternalApiFp(configuration).expMetricNames(ids, periodSeconds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the best searcher validation for an experiment by the given metric.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBestSearcherValidationMetric(experimentId: number, options?: any) {
            return InternalApiFp(configuration).getBestSearcherValidationMetric(experimentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the current searcher operation.
         * @param {number} trialId The id of the trial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTrialSearcherOperation(trialId: number, options?: any) {
            return InternalApiFp(configuration).getCurrentTrialSearcherOperation(trialId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a group by id.
         * @param {number} groupId The id of the group to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: number, options?: any) {
            return InternalApiFp(configuration).getGroup(groupId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Search for groups with optional filters.
         * @param {V1GetGroupsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(body: V1GetGroupsRequest, options?: any) {
            return InternalApiFp(configuration).getGroups(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get job queue stats for a resource pool.
         * @param {Array<string>} [resourcePools] Filter the results based on a set of resource pools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobQueueStats(resourcePools?: Array<string>, options?: any) {
            return InternalApiFp(configuration).getJobQueueStats(resourcePools, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of jobs in queue.
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Pagination limit.
         * @param {string} [resourcePool] The target resource-pool for agent resource manager.
         * @param {V1OrderBy} [orderBy] Order results in either ascending or descending order by the number of jobs ahead.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {Array<Jobv1State>} [states] Filter to jobs with states among those given.   - STATE_UNSPECIFIED: Unspecified state.  - STATE_QUEUED: Job is queued and waiting to be schedlued.  - STATE_SCHEDULED: Job is scheduled.  - STATE_SCHEDULED_BACKFILLED: Job is scheduled as a backfill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(offset?: number, limit?: number, resourcePool?: string, orderBy?: V1OrderBy, states?: Array<Jobv1State>, options?: any) {
            return InternalApiFp(configuration).getJobs(offset, limit, resourcePool, orderBy, states, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of jobs in queue.
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Pagination limit.
         * @param {string} [resourcePool] The target resource-pool for agent resource manager.
         * @param {V1OrderBy} [orderBy] Order results in either ascending or descending order by the number of jobs ahead.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {Array<Jobv1State>} [states] Filter to jobs with states among those given.   - STATE_UNSPECIFIED: Unspecified state.  - STATE_QUEUED: Job is queued and waiting to be schedlued.  - STATE_SCHEDULED: Job is scheduled.  - STATE_SCHEDULED_BACKFILLED: Job is scheduled as a backfill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsV2(offset?: number, limit?: number, resourcePool?: string, orderBy?: V1OrderBy, states?: Array<Jobv1State>, options?: any) {
            return InternalApiFp(configuration).getJobsV2(offset, limit, resourcePool, orderBy, states, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of columns for experiment list table.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectColumns(id: number, options?: any) {
            return InternalApiFp(configuration).getProjectColumns(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get metrics range for a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectNumericMetricsRange(id: number, options?: any) {
            return InternalApiFp(configuration).getProjectNumericMetricsRange(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of all resource pools from the cluster.
         * @param {number} [offset] Skip the number of resource pools before returning results. Negative values denote number of resource pools to skip from the end before returning results.
         * @param {number} [limit] Limit the number of resource pools. A value of 0 denotes no limit.
         * @param {boolean} [unbound] Indicate whether or not to return unbound pools only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePools(offset?: number, limit?: number, unbound?: boolean, options?: any) {
            return InternalApiFp(configuration).getResourcePools(offset, limit, unbound, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get telemetry information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTelemetry(options?: any) {
            return InternalApiFp(configuration).getTelemetry(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the metrics for all trials associated with this checkpoint
         * @param {string} checkpointUuid UUID of the checkpoint.
         * @param {V1TrialSourceInfoType} [trialSourceInfoType] Type of the TrialSourceInfo.   - TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: The type is unspecified  - TRIAL_SOURCE_INFO_TYPE_INFERENCE: "Inference" Trial Source Info Type, used for batch inference  - TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: "Fine Tuning" Trial Source Info Type, used in model hub
         * @param {string} [metricGroup] Metric Group string ("training", "validation", or anything else) (nil means all groups).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialMetricsByCheckpoint(checkpointUuid: string, trialSourceInfoType?: V1TrialSourceInfoType, metricGroup?: string, options?: any) {
            return InternalApiFp(configuration).getTrialMetricsByCheckpoint(checkpointUuid, trialSourceInfoType, metricGroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the metrics for all trials associated with this model version
         * @param {string} modelName The name of the model associated with the model version.
         * @param {number} modelVersionNum Sequential model version number.
         * @param {V1TrialSourceInfoType} [trialSourceInfoType] Type of the TrialSourceInfo.   - TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: The type is unspecified  - TRIAL_SOURCE_INFO_TYPE_INFERENCE: "Inference" Trial Source Info Type, used for batch inference  - TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: "Fine Tuning" Trial Source Info Type, used in model hub
         * @param {string} [metricGroup] Metric Group string ("training", "validation", or anything else) (nil means all groups).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialMetricsByModelVersion(modelName: string, modelVersionNum: number, trialSourceInfoType?: V1TrialSourceInfoType, metricGroup?: string, options?: any) {
            return InternalApiFp(configuration).getTrialMetricsByModelVersion(modelName, modelVersionNum, trialSourceInfoType, metricGroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of workloads for a trial.
         * @param {number} trialId Limit workloads to those that are owned by the specified trial.
         * @param {V1OrderBy} [orderBy] Order workloads in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of workloads before returning results. Negative values denote number of workloads to skip from the end before returning results.
         * @param {number} [limit] Limit the number of workloads. A value of 0 denotes no limit.
         * @param {string} [sortKey] Sort workloads by batches, a training metric, or a validation metric.
         * @param {GetTrialWorkloadsRequestFilterOption} [filter] Filter workloads with validation and/or checkpoint information.   - FILTER_OPTION_UNSPECIFIED: Any workload.  - FILTER_OPTION_CHECKPOINT: Only workloads with an associated checkpoint.  - FILTER_OPTION_VALIDATION: Only validation workloads.  - FILTER_OPTION_CHECKPOINT_OR_VALIDATION: Only validation workloads or ones with an associated checkpoint.
         * @param {boolean} [includeBatchMetrics] Include per-batch metrics.
         * @param {V1MetricType} [metricType] When sorting workloads by sort_key, specify training or validation form of a metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {boolean} [removeDeletedCheckpoints] Remove deleted checkpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialWorkloads(trialId: number, orderBy?: V1OrderBy, offset?: number, limit?: number, sortKey?: string, filter?: GetTrialWorkloadsRequestFilterOption, includeBatchMetrics?: boolean, metricType?: V1MetricType, group?: string, removeDeletedCheckpoints?: boolean, options?: any) {
            return InternalApiFp(configuration).getTrialWorkloads(trialId, orderBy, offset, limit, sortKey, filter, includeBatchMetrics, metricType, group, removeDeletedCheckpoints, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send notebook idle data to master
         * @param {string} notebookId The id of the notebook.
         * @param {V1IdleNotebookRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idleNotebook(notebookId: string, body: V1IdleNotebookRequest, options?: any) {
            return InternalApiFp(configuration).idleNotebook(notebookId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all resource pools, bound and unbound, available to a specific workspace
         * @param {number} workspaceId Workspace ID.
         * @param {number} [offset] The offset to use with pagination.
         * @param {number} [limit] The maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRPsBoundToWorkspace(workspaceId: number, offset?: number, limit?: number, options?: any) {
            return InternalApiFp(configuration).listRPsBoundToWorkspace(workspaceId, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all workspaces bound to a specific resource pool
         * @param {string} resourcePoolName Resource pool name.
         * @param {number} [offset] The offset to use with pagination.
         * @param {number} [limit] The maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspacesBoundToRP(resourcePoolName: string, offset?: number, limit?: number, options?: any) {
            return InternalApiFp(configuration).listWorkspacesBoundToRP(resourcePoolName, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mark the given reservation (container, pod, etc) within an allocation as a daemon reservation. In the exit of a successful exit, Determined will wait for all resources to exit - unless they are marked as daemon resources, in which case Determined will clean them up regardless of exit status after all non-daemon resources have exited.
         * @param {string} allocationId The id of the allocation.
         * @param {string} resourcesId The id of the clump of resources to mark as daemon.
         * @param {V1MarkAllocationResourcesDaemonRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllocationResourcesDaemon(allocationId: string, resourcesId: string, body: V1MarkAllocationResourcesDaemonRequest, options?: any) {
            return InternalApiFp(configuration).markAllocationResourcesDaemon(allocationId, resourcesId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the milestones (in batches processed) at which a metric is recorded by an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {V1MetricType} [metricType] The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricBatches(experimentId: number, metricName: string, metricType?: V1MetricType, group?: string, periodSeconds?: number, options?: any) {
            return InternalApiFp(configuration).metricBatches(experimentId, metricName, metricType, group, periodSeconds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary NotifyContainterRunning is used to notify the master that the container is running.  On HPC, the launcher will report a state of "Running" as soon as Slurm starts the job, but the container may be in the process of getting pulled down from the Internet, so the experiment is not really considered to be in a "Running" state until all the containers that are part of the experiment are running and not being pulled.
         * @param {string} allocationId The ID of the allocation.
         * @param {V1NotifyContainerRunningRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyContainerRunning(allocationId: string, body: V1NotifyContainerRunningRequest, options?: any) {
            return InternalApiFp(configuration).notifyContainerRunning(allocationId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Overwrite resource pool - workspace bindings
         * @param {string} resourcePoolName The resource pool name.
         * @param {V1OverwriteRPWorkspaceBindingsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overwriteRPWorkspaceBindings(resourcePoolName: string, body: V1OverwriteRPWorkspaceBindingsRequest, options?: any) {
            return InternalApiFp(configuration).overwriteRPWorkspaceBindings(resourcePoolName, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update checkpoints. Won't modify checkpoint files.
         * @param {V1PatchCheckpointsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCheckpoints(body: V1PatchCheckpointsRequest, options?: any) {
            return InternalApiFp(configuration).patchCheckpoints(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch (an unmanaged) trial.
         * @param {number} trialId Trial id.
         * @param {V1PatchTrialRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTrial(trialId: number, body: V1PatchTrialRequest, options?: any) {
            return InternalApiFp(configuration).patchTrial(trialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary PostAllocationProxyAddress sets the proxy address to use when proxying to services provided by an allocation. Upon receipt, the master will also register any proxies specified by the task.
         * @param {string} allocationId The id of the allocation.
         * @param {V1PostAllocationProxyAddressRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAllocationProxyAddress(allocationId: string, body: V1PostAllocationProxyAddressRequest, options?: any) {
            return InternalApiFp(configuration).postAllocationProxyAddress(allocationId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Persist the given TrialProfilerMetricsBatch. The trial ID is in the labels.
         * @param {V1PostTrialProfilerMetricsBatchRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrialProfilerMetricsBatch(body: V1PostTrialProfilerMetricsBatchRequest, options?: any) {
            return InternalApiFp(configuration).postTrialProfilerMetricsBatch(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary For bookkeeping, update trial runner metadata (currently just state).
         * @param {number} trialId The id of the trial.
         * @param {V1TrialRunnerMetadata} body The state for the trial runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrialRunnerMetadata(trialId: number, body: V1TrialRunnerMetadata, options?: any) {
            return InternalApiFp(configuration).postTrialRunnerMetadata(trialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Put an experiment by external id.
         * @param {string} externalExperimentId External experiment id.
         * @param {V1CreateExperimentRequest} body CreateExperimentRequest payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putExperiment(externalExperimentId: string, body: V1CreateExperimentRequest, options?: any) {
            return InternalApiFp(configuration).putExperiment(externalExperimentId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Put a trial.
         * @param {V1PutTrialRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTrial(body: V1PutTrialRequest, options?: any) {
            return InternalApiFp(configuration).putTrial(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Record a checkpoint.
         * @param {V1Checkpoint} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportCheckpoint(body: V1Checkpoint, options?: any) {
            return InternalApiFp(configuration).reportCheckpoint(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Record metrics for specified trial.
         * @param {number} metricsTrialId The trial associated with these metrics.
         * @param {V1ReportTrialMetricsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialMetrics(metricsTrialId: number, body: V1ReportTrialMetricsRequest, options?: any) {
            return InternalApiFp(configuration).reportTrialMetrics(metricsTrialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary For bookkeeping, updates the progress towards to current requested searcher training length.
         * @param {number} trialId The id of the trial.
         * @param {number} body Total units completed by the trial, in terms of the unit used to configure the searcher.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialProgress(trialId: number, body: number, options?: any) {
            return InternalApiFp(configuration).reportTrialProgress(trialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reports to the searcher that the trial has completed the current requested amount of training with the given searcher validation metric.
         * @param {number} trialId The id of the trial.
         * @param {V1TrialEarlyExit} body The exit reason.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialSearcherEarlyExit(trialId: number, body: V1TrialEarlyExit, options?: any) {
            return InternalApiFp(configuration).reportTrialSearcherEarlyExit(trialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reports a TrialSourceInfo entry for tracking inference or fine-tuning runs
         * @param {V1ReportTrialSourceInfoRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialSourceInfo(body: V1ReportTrialSourceInfoRequest, options?: any) {
            return InternalApiFp(configuration).reportTrialSourceInfo(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Record training metrics for specified training.
         * @param {number} trainingMetricsTrialId The trial associated with these metrics.
         * @param {V1TrialMetrics} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialTrainingMetrics(trainingMetricsTrialId: number, body: V1TrialMetrics, options?: any) {
            return InternalApiFp(configuration).reportTrialTrainingMetrics(trainingMetricsTrialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Record validation metrics.
         * @param {number} validationMetricsTrialId The trial associated with these metrics.
         * @param {V1TrialMetrics} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTrialValidationMetrics(validationMetricsTrialId: number, body: V1TrialMetrics, options?: any) {
            return InternalApiFp(configuration).reportTrialValidationMetrics(validationMetricsTrialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get experiments with grouping and search syntax
         * @param {number} [projectId] ID of the project to look at.
         * @param {number} [offset] How many experiments to skip before including in the results.
         * @param {number} [limit] How many results to show.
         * @param {string} [sort] Sort parameters in the format <col1>=(asc|desc),<col2>=(asc|desc).
         * @param {string} [filter] Filter expression.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchExperiments(projectId?: number, offset?: number, limit?: number, sort?: string, filter?: string, options?: any) {
            return InternalApiFp(configuration).searchExperiments(projectId, offset, limit, sort, filter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Start (an unmanaged) trial.
         * @param {number} trialId Trial id.
         * @param {V1StartTrialRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTrial(trialId: number, body: V1StartTrialRequest, options?: any) {
            return InternalApiFp(configuration).startTrial(trialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a sample of the metrics over time for a sample of the trials.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {V1MetricType} [metricType] The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {number} [maxTrials] Maximum number of trials to fetch data for.
         * @param {number} [maxDatapoints] Maximum number of initial / historical data points.
         * @param {number} [startBatches] Beginning of window (inclusive) to fetch data for.
         * @param {number} [endBatches] Ending of window (inclusive) to fetch data for.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialsSample(experimentId: number, metricName: string, metricType?: V1MetricType, group?: string, maxTrials?: number, maxDatapoints?: number, startBatches?: number, endBatches?: number, periodSeconds?: number, options?: any) {
            return InternalApiFp(configuration).trialsSample(experimentId, metricName, metricType, group, maxTrials, maxDatapoints, startBatches, endBatches, periodSeconds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a snapshot of a metric across all trials at a certain point of progress.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {number} batchesProcessed The point of progress at which to query metrics.
         * @param {V1MetricType} [metricType] The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {number} [batchesMargin] A range either side of batches_processed to include near-misses.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialsSnapshot(experimentId: number, metricName: string, batchesProcessed: number, metricType?: V1MetricType, group?: string, batchesMargin?: number, periodSeconds?: number, options?: any) {
            return InternalApiFp(configuration).trialsSnapshot(experimentId, metricName, batchesProcessed, metricType, group, batchesMargin, periodSeconds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unbind resource pool to workspace
         * @param {string} resourcePoolName The resource pool name.
         * @param {V1UnbindRPFromWorkspaceRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindRPFromWorkspace(resourcePoolName: string, body: V1UnbindRPFromWorkspaceRequest, options?: any) {
            return InternalApiFp(configuration).unbindRPFromWorkspace(resourcePoolName, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update group info.
         * @param {number} groupId The id of the group
         * @param {V1UpdateGroupRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupId: number, body: V1UpdateGroupRequest, options?: any) {
            return InternalApiFp(configuration).updateGroup(groupId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Control the job queues.
         * @param {V1UpdateJobQueueRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobQueue(body: V1UpdateJobQueueRequest, options?: any) {
            return InternalApiFp(configuration).updateJobQueue(body, options)(fetch, basePath);
        },
    }
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * 
     * @summary Acknowledge the receipt of a signal to stop the given allocation early. This is used indicate and exit 0 isn't final; specifically, it is used for HP search directed early stops and preemption signals (not necessarily just scheduler preemption).
     * @param {string} allocationId The allocation that is acknowledging the request.
     * @param {V1AckAllocationPreemptionSignalRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public ackAllocationPreemptionSignal(allocationId: string, body: V1AckAllocationPreemptionSignalRequest, options?: any) {
        return InternalApiFp(this.configuration).ackAllocationPreemptionSignal(allocationId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary AllocationAllGather performs an all gather through the master. An allocation can only perform once all gather at a time.
     * @param {string} allocationId The ID of the allocation.
     * @param {V1AllocationAllGatherRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public allocationAllGather(allocationId: string, body: V1AllocationAllGatherRequest, options?: any) {
        return InternalApiFp(this.configuration).allocationAllGather(allocationId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Report the receipt of a signal to stop the given allocation early. This is used to communicate back from a SLURM job that it has been notified of a pending preememption. Upon a call to this API the RM should then trigger a checkpoint and immediate exit.
     * @param {string} allocationId The id of the allocation.
     * @param {V1AllocationPendingPreemptionSignalRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public allocationPendingPreemptionSignal(allocationId: string, body: V1AllocationPendingPreemptionSignalRequest, options?: any) {
        return InternalApiFp(this.configuration).allocationPendingPreemptionSignal(allocationId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Long poll preemption signals for the given allocation. If the allocation has been preempted when called, it will return so immediately. Otherwise, the connection will be kept open until the timeout is reached or the allocation is preempted.
     * @param {string} allocationId The id of the allocation.
     * @param {number} [timeoutSeconds] The timeout in seconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public allocationPreemptionSignal(allocationId: string, timeoutSeconds?: number, options?: any) {
        return InternalApiFp(this.configuration).allocationPreemptionSignal(allocationId, timeoutSeconds, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Set allocation to ready state.
     * @param {string} allocationId The id of the allocation.
     * @param {V1AllocationReadyRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public allocationReady(allocationId: string, body: V1AllocationReadyRequest, options?: any) {
        return InternalApiFp(this.configuration).allocationReady(allocationId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Gather an allocation's rendezvous info. Blocks until all trial containers connect to gather their rendezvous information and responds to them all at once.
     * @param {string} allocationId The id of the allocation.
     * @param {string} resourcesId The id of the clump of resources.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public allocationRendezvousInfo(allocationId: string, resourcesId: string, options?: any) {
        return InternalApiFp(this.configuration).allocationRendezvousInfo(allocationId, resourcesId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Set allocation to waiting state.
     * @param {string} allocationId The id of the allocation.
     * @param {V1AllocationWaitingRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public allocationWaiting(allocationId: string, body: V1AllocationWaitingRequest, options?: any) {
        return InternalApiFp(this.configuration).allocationWaiting(allocationId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Bind resource pool to workspace
     * @param {string} resourcePoolName The resource pool name.
     * @param {V1BindRPToWorkspaceRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public bindRPToWorkspace(resourcePoolName: string, body: V1BindRPToWorkspaceRequest, options?: any) {
        return InternalApiFp(this.configuration).bindRPToWorkspace(resourcePoolName, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Reports to the searcher that the trial has completed the given searcher operation.
     * @param {number} trialId The id of the trial.
     * @param {V1CompleteValidateAfterOperation} body The completed operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public completeTrialSearcherValidation(trialId: number, body: V1CompleteValidateAfterOperation, options?: any) {
        return InternalApiFp(this.configuration).completeTrialSearcherValidation(trialId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Create an experiment.
     * @param {V1CreateExperimentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public createExperiment(body: V1CreateExperimentRequest, options?: any) {
        return InternalApiFp(this.configuration).createExperiment(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Create a group with optional members on creation.
     * @param {V1CreateGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public createGroup(body: V1CreateGroupRequest, options?: any) {
        return InternalApiFp(this.configuration).createGroup(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Create unmanaged trial.
     * @param {V1CreateTrialRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public createTrial(body: V1CreateTrialRequest, options?: any) {
        return InternalApiFp(this.configuration).createTrial(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Remove a group.
     * @param {number} groupId The id of the group that should be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public deleteGroup(groupId: number, options?: any) {
        return InternalApiFp(this.configuration).deleteGroup(groupId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the set of metric names recorded for a list of experiments.
     * @param {Array<number>} ids The ids for the experiments.
     * @param {number} [periodSeconds] Seconds to wait when polling for updates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public expMetricNames(ids: Array<number>, periodSeconds?: number, options?: any) {
        return InternalApiFp(this.configuration).expMetricNames(ids, periodSeconds, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the best searcher validation for an experiment by the given metric.
     * @param {number} experimentId The ID of the experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getBestSearcherValidationMetric(experimentId: number, options?: any) {
        return InternalApiFp(this.configuration).getBestSearcherValidationMetric(experimentId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the current searcher operation.
     * @param {number} trialId The id of the trial.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getCurrentTrialSearcherOperation(trialId: number, options?: any) {
        return InternalApiFp(this.configuration).getCurrentTrialSearcherOperation(trialId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a group by id.
     * @param {number} groupId The id of the group to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getGroup(groupId: number, options?: any) {
        return InternalApiFp(this.configuration).getGroup(groupId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Search for groups with optional filters.
     * @param {V1GetGroupsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getGroups(body: V1GetGroupsRequest, options?: any) {
        return InternalApiFp(this.configuration).getGroups(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get job queue stats for a resource pool.
     * @param {Array<string>} [resourcePools] Filter the results based on a set of resource pools.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getJobQueueStats(resourcePools?: Array<string>, options?: any) {
        return InternalApiFp(this.configuration).getJobQueueStats(resourcePools, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of jobs in queue.
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Pagination limit.
     * @param {string} [resourcePool] The target resource-pool for agent resource manager.
     * @param {V1OrderBy} [orderBy] Order results in either ascending or descending order by the number of jobs ahead.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {Array<Jobv1State>} [states] Filter to jobs with states among those given.   - STATE_UNSPECIFIED: Unspecified state.  - STATE_QUEUED: Job is queued and waiting to be schedlued.  - STATE_SCHEDULED: Job is scheduled.  - STATE_SCHEDULED_BACKFILLED: Job is scheduled as a backfill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getJobs(offset?: number, limit?: number, resourcePool?: string, orderBy?: V1OrderBy, states?: Array<Jobv1State>, options?: any) {
        return InternalApiFp(this.configuration).getJobs(offset, limit, resourcePool, orderBy, states, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of jobs in queue.
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Pagination limit.
     * @param {string} [resourcePool] The target resource-pool for agent resource manager.
     * @param {V1OrderBy} [orderBy] Order results in either ascending or descending order by the number of jobs ahead.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {Array<Jobv1State>} [states] Filter to jobs with states among those given.   - STATE_UNSPECIFIED: Unspecified state.  - STATE_QUEUED: Job is queued and waiting to be schedlued.  - STATE_SCHEDULED: Job is scheduled.  - STATE_SCHEDULED_BACKFILLED: Job is scheduled as a backfill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getJobsV2(offset?: number, limit?: number, resourcePool?: string, orderBy?: V1OrderBy, states?: Array<Jobv1State>, options?: any) {
        return InternalApiFp(this.configuration).getJobsV2(offset, limit, resourcePool, orderBy, states, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of columns for experiment list table.
     * @param {number} id The id of the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getProjectColumns(id: number, options?: any) {
        return InternalApiFp(this.configuration).getProjectColumns(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get metrics range for a project.
     * @param {number} id The id of the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getProjectNumericMetricsRange(id: number, options?: any) {
        return InternalApiFp(this.configuration).getProjectNumericMetricsRange(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of all resource pools from the cluster.
     * @param {number} [offset] Skip the number of resource pools before returning results. Negative values denote number of resource pools to skip from the end before returning results.
     * @param {number} [limit] Limit the number of resource pools. A value of 0 denotes no limit.
     * @param {boolean} [unbound] Indicate whether or not to return unbound pools only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getResourcePools(offset?: number, limit?: number, unbound?: boolean, options?: any) {
        return InternalApiFp(this.configuration).getResourcePools(offset, limit, unbound, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get telemetry information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getTelemetry(options?: any) {
        return InternalApiFp(this.configuration).getTelemetry(options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Gets the metrics for all trials associated with this checkpoint
     * @param {string} checkpointUuid UUID of the checkpoint.
     * @param {V1TrialSourceInfoType} [trialSourceInfoType] Type of the TrialSourceInfo.   - TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: The type is unspecified  - TRIAL_SOURCE_INFO_TYPE_INFERENCE: "Inference" Trial Source Info Type, used for batch inference  - TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: "Fine Tuning" Trial Source Info Type, used in model hub
     * @param {string} [metricGroup] Metric Group string ("training", "validation", or anything else) (nil means all groups).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getTrialMetricsByCheckpoint(checkpointUuid: string, trialSourceInfoType?: V1TrialSourceInfoType, metricGroup?: string, options?: any) {
        return InternalApiFp(this.configuration).getTrialMetricsByCheckpoint(checkpointUuid, trialSourceInfoType, metricGroup, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Gets the metrics for all trials associated with this model version
     * @param {string} modelName The name of the model associated with the model version.
     * @param {number} modelVersionNum Sequential model version number.
     * @param {V1TrialSourceInfoType} [trialSourceInfoType] Type of the TrialSourceInfo.   - TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: The type is unspecified  - TRIAL_SOURCE_INFO_TYPE_INFERENCE: "Inference" Trial Source Info Type, used for batch inference  - TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: "Fine Tuning" Trial Source Info Type, used in model hub
     * @param {string} [metricGroup] Metric Group string ("training", "validation", or anything else) (nil means all groups).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getTrialMetricsByModelVersion(modelName: string, modelVersionNum: number, trialSourceInfoType?: V1TrialSourceInfoType, metricGroup?: string, options?: any) {
        return InternalApiFp(this.configuration).getTrialMetricsByModelVersion(modelName, modelVersionNum, trialSourceInfoType, metricGroup, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the list of workloads for a trial.
     * @param {number} trialId Limit workloads to those that are owned by the specified trial.
     * @param {V1OrderBy} [orderBy] Order workloads in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of workloads before returning results. Negative values denote number of workloads to skip from the end before returning results.
     * @param {number} [limit] Limit the number of workloads. A value of 0 denotes no limit.
     * @param {string} [sortKey] Sort workloads by batches, a training metric, or a validation metric.
     * @param {GetTrialWorkloadsRequestFilterOption} [filter] Filter workloads with validation and/or checkpoint information.   - FILTER_OPTION_UNSPECIFIED: Any workload.  - FILTER_OPTION_CHECKPOINT: Only workloads with an associated checkpoint.  - FILTER_OPTION_VALIDATION: Only validation workloads.  - FILTER_OPTION_CHECKPOINT_OR_VALIDATION: Only validation workloads or ones with an associated checkpoint.
     * @param {boolean} [includeBatchMetrics] Include per-batch metrics.
     * @param {V1MetricType} [metricType] When sorting workloads by sort_key, specify training or validation form of a metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
     * @param {string} [group] Metric group (training, validation, etc).
     * @param {boolean} [removeDeletedCheckpoints] Remove deleted checkpoints.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public getTrialWorkloads(trialId: number, orderBy?: V1OrderBy, offset?: number, limit?: number, sortKey?: string, filter?: GetTrialWorkloadsRequestFilterOption, includeBatchMetrics?: boolean, metricType?: V1MetricType, group?: string, removeDeletedCheckpoints?: boolean, options?: any) {
        return InternalApiFp(this.configuration).getTrialWorkloads(trialId, orderBy, offset, limit, sortKey, filter, includeBatchMetrics, metricType, group, removeDeletedCheckpoints, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Send notebook idle data to master
     * @param {string} notebookId The id of the notebook.
     * @param {V1IdleNotebookRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public idleNotebook(notebookId: string, body: V1IdleNotebookRequest, options?: any) {
        return InternalApiFp(this.configuration).idleNotebook(notebookId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary List all resource pools, bound and unbound, available to a specific workspace
     * @param {number} workspaceId Workspace ID.
     * @param {number} [offset] The offset to use with pagination.
     * @param {number} [limit] The maximum number of results to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public listRPsBoundToWorkspace(workspaceId: number, offset?: number, limit?: number, options?: any) {
        return InternalApiFp(this.configuration).listRPsBoundToWorkspace(workspaceId, offset, limit, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary List all workspaces bound to a specific resource pool
     * @param {string} resourcePoolName Resource pool name.
     * @param {number} [offset] The offset to use with pagination.
     * @param {number} [limit] The maximum number of results to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public listWorkspacesBoundToRP(resourcePoolName: string, offset?: number, limit?: number, options?: any) {
        return InternalApiFp(this.configuration).listWorkspacesBoundToRP(resourcePoolName, offset, limit, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Mark the given reservation (container, pod, etc) within an allocation as a daemon reservation. In the exit of a successful exit, Determined will wait for all resources to exit - unless they are marked as daemon resources, in which case Determined will clean them up regardless of exit status after all non-daemon resources have exited.
     * @param {string} allocationId The id of the allocation.
     * @param {string} resourcesId The id of the clump of resources to mark as daemon.
     * @param {V1MarkAllocationResourcesDaemonRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public markAllocationResourcesDaemon(allocationId: string, resourcesId: string, body: V1MarkAllocationResourcesDaemonRequest, options?: any) {
        return InternalApiFp(this.configuration).markAllocationResourcesDaemon(allocationId, resourcesId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the milestones (in batches processed) at which a metric is recorded by an experiment.
     * @param {number} experimentId The id of the experiment.
     * @param {string} metricName A metric name.
     * @param {V1MetricType} [metricType] The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
     * @param {string} [group] Metric group (training, validation, etc).
     * @param {number} [periodSeconds] Seconds to wait when polling for updates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public metricBatches(experimentId: number, metricName: string, metricType?: V1MetricType, group?: string, periodSeconds?: number, options?: any) {
        return InternalApiFp(this.configuration).metricBatches(experimentId, metricName, metricType, group, periodSeconds, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary NotifyContainterRunning is used to notify the master that the container is running.  On HPC, the launcher will report a state of "Running" as soon as Slurm starts the job, but the container may be in the process of getting pulled down from the Internet, so the experiment is not really considered to be in a "Running" state until all the containers that are part of the experiment are running and not being pulled.
     * @param {string} allocationId The ID of the allocation.
     * @param {V1NotifyContainerRunningRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public notifyContainerRunning(allocationId: string, body: V1NotifyContainerRunningRequest, options?: any) {
        return InternalApiFp(this.configuration).notifyContainerRunning(allocationId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Overwrite resource pool - workspace bindings
     * @param {string} resourcePoolName The resource pool name.
     * @param {V1OverwriteRPWorkspaceBindingsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public overwriteRPWorkspaceBindings(resourcePoolName: string, body: V1OverwriteRPWorkspaceBindingsRequest, options?: any) {
        return InternalApiFp(this.configuration).overwriteRPWorkspaceBindings(resourcePoolName, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Update checkpoints. Won't modify checkpoint files.
     * @param {V1PatchCheckpointsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public patchCheckpoints(body: V1PatchCheckpointsRequest, options?: any) {
        return InternalApiFp(this.configuration).patchCheckpoints(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Patch (an unmanaged) trial.
     * @param {number} trialId Trial id.
     * @param {V1PatchTrialRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public patchTrial(trialId: number, body: V1PatchTrialRequest, options?: any) {
        return InternalApiFp(this.configuration).patchTrial(trialId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary PostAllocationProxyAddress sets the proxy address to use when proxying to services provided by an allocation. Upon receipt, the master will also register any proxies specified by the task.
     * @param {string} allocationId The id of the allocation.
     * @param {V1PostAllocationProxyAddressRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public postAllocationProxyAddress(allocationId: string, body: V1PostAllocationProxyAddressRequest, options?: any) {
        return InternalApiFp(this.configuration).postAllocationProxyAddress(allocationId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Persist the given TrialProfilerMetricsBatch. The trial ID is in the labels.
     * @param {V1PostTrialProfilerMetricsBatchRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public postTrialProfilerMetricsBatch(body: V1PostTrialProfilerMetricsBatchRequest, options?: any) {
        return InternalApiFp(this.configuration).postTrialProfilerMetricsBatch(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary For bookkeeping, update trial runner metadata (currently just state).
     * @param {number} trialId The id of the trial.
     * @param {V1TrialRunnerMetadata} body The state for the trial runner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public postTrialRunnerMetadata(trialId: number, body: V1TrialRunnerMetadata, options?: any) {
        return InternalApiFp(this.configuration).postTrialRunnerMetadata(trialId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Put an experiment by external id.
     * @param {string} externalExperimentId External experiment id.
     * @param {V1CreateExperimentRequest} body CreateExperimentRequest payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public putExperiment(externalExperimentId: string, body: V1CreateExperimentRequest, options?: any) {
        return InternalApiFp(this.configuration).putExperiment(externalExperimentId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Put a trial.
     * @param {V1PutTrialRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public putTrial(body: V1PutTrialRequest, options?: any) {
        return InternalApiFp(this.configuration).putTrial(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Record a checkpoint.
     * @param {V1Checkpoint} body The training metrics to persist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public reportCheckpoint(body: V1Checkpoint, options?: any) {
        return InternalApiFp(this.configuration).reportCheckpoint(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Record metrics for specified trial.
     * @param {number} metricsTrialId The trial associated with these metrics.
     * @param {V1ReportTrialMetricsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public reportTrialMetrics(metricsTrialId: number, body: V1ReportTrialMetricsRequest, options?: any) {
        return InternalApiFp(this.configuration).reportTrialMetrics(metricsTrialId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary For bookkeeping, updates the progress towards to current requested searcher training length.
     * @param {number} trialId The id of the trial.
     * @param {number} body Total units completed by the trial, in terms of the unit used to configure the searcher.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public reportTrialProgress(trialId: number, body: number, options?: any) {
        return InternalApiFp(this.configuration).reportTrialProgress(trialId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Reports to the searcher that the trial has completed the current requested amount of training with the given searcher validation metric.
     * @param {number} trialId The id of the trial.
     * @param {V1TrialEarlyExit} body The exit reason.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public reportTrialSearcherEarlyExit(trialId: number, body: V1TrialEarlyExit, options?: any) {
        return InternalApiFp(this.configuration).reportTrialSearcherEarlyExit(trialId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Reports a TrialSourceInfo entry for tracking inference or fine-tuning runs
     * @param {V1ReportTrialSourceInfoRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public reportTrialSourceInfo(body: V1ReportTrialSourceInfoRequest, options?: any) {
        return InternalApiFp(this.configuration).reportTrialSourceInfo(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Record training metrics for specified training.
     * @param {number} trainingMetricsTrialId The trial associated with these metrics.
     * @param {V1TrialMetrics} body The training metrics to persist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public reportTrialTrainingMetrics(trainingMetricsTrialId: number, body: V1TrialMetrics, options?: any) {
        return InternalApiFp(this.configuration).reportTrialTrainingMetrics(trainingMetricsTrialId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Record validation metrics.
     * @param {number} validationMetricsTrialId The trial associated with these metrics.
     * @param {V1TrialMetrics} body The training metrics to persist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public reportTrialValidationMetrics(validationMetricsTrialId: number, body: V1TrialMetrics, options?: any) {
        return InternalApiFp(this.configuration).reportTrialValidationMetrics(validationMetricsTrialId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get experiments with grouping and search syntax
     * @param {number} [projectId] ID of the project to look at.
     * @param {number} [offset] How many experiments to skip before including in the results.
     * @param {number} [limit] How many results to show.
     * @param {string} [sort] Sort parameters in the format <col1>=(asc|desc),<col2>=(asc|desc).
     * @param {string} [filter] Filter expression.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public searchExperiments(projectId?: number, offset?: number, limit?: number, sort?: string, filter?: string, options?: any) {
        return InternalApiFp(this.configuration).searchExperiments(projectId, offset, limit, sort, filter, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Start (an unmanaged) trial.
     * @param {number} trialId Trial id.
     * @param {V1StartTrialRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public startTrial(trialId: number, body: V1StartTrialRequest, options?: any) {
        return InternalApiFp(this.configuration).startTrial(trialId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a sample of the metrics over time for a sample of the trials.
     * @param {number} experimentId The id of the experiment.
     * @param {string} metricName A metric name.
     * @param {V1MetricType} [metricType] The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
     * @param {string} [group] Metric group (training, validation, etc).
     * @param {number} [maxTrials] Maximum number of trials to fetch data for.
     * @param {number} [maxDatapoints] Maximum number of initial / historical data points.
     * @param {number} [startBatches] Beginning of window (inclusive) to fetch data for.
     * @param {number} [endBatches] Ending of window (inclusive) to fetch data for.
     * @param {number} [periodSeconds] Seconds to wait when polling for updates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public trialsSample(experimentId: number, metricName: string, metricType?: V1MetricType, group?: string, maxTrials?: number, maxDatapoints?: number, startBatches?: number, endBatches?: number, periodSeconds?: number, options?: any) {
        return InternalApiFp(this.configuration).trialsSample(experimentId, metricName, metricType, group, maxTrials, maxDatapoints, startBatches, endBatches, periodSeconds, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a snapshot of a metric across all trials at a certain point of progress.
     * @param {number} experimentId The id of the experiment.
     * @param {string} metricName A metric name.
     * @param {number} batchesProcessed The point of progress at which to query metrics.
     * @param {V1MetricType} [metricType] The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
     * @param {string} [group] Metric group (training, validation, etc).
     * @param {number} [batchesMargin] A range either side of batches_processed to include near-misses.
     * @param {number} [periodSeconds] Seconds to wait when polling for updates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public trialsSnapshot(experimentId: number, metricName: string, batchesProcessed: number, metricType?: V1MetricType, group?: string, batchesMargin?: number, periodSeconds?: number, options?: any) {
        return InternalApiFp(this.configuration).trialsSnapshot(experimentId, metricName, batchesProcessed, metricType, group, batchesMargin, periodSeconds, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Unbind resource pool to workspace
     * @param {string} resourcePoolName The resource pool name.
     * @param {V1UnbindRPFromWorkspaceRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public unbindRPFromWorkspace(resourcePoolName: string, body: V1UnbindRPFromWorkspaceRequest, options?: any) {
        return InternalApiFp(this.configuration).unbindRPFromWorkspace(resourcePoolName, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Update group info.
     * @param {number} groupId The id of the group
     * @param {V1UpdateGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateGroup(groupId: number, body: V1UpdateGroupRequest, options?: any) {
        return InternalApiFp(this.configuration).updateGroup(groupId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Control the job queues.
     * @param {V1UpdateJobQueueRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public updateJobQueue(body: V1UpdateJobQueueRequest, options?: any) {
        return InternalApiFp(this.configuration).updateJobQueue(body, options)(this.fetch, this.basePath)
    }
    
}

/**
 * JobsApi - fetch parameter creator
 * @export
 */
export const JobsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stream task logs.
         * @param {string} taskId The id of the task.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [allocationIds] Limit the task logs to particular allocations.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {string} [searchText] Search the logs by whether the text contains a substring.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogs(taskId: string, limit?: number, follow?: boolean, allocationIds?: Array<string>, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options: any = {}): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling taskLogs.');
            }
            const localVarPath = `/api/v1/tasks/{taskId}/logs`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow
            }
            
            if (allocationIds) {
                localVarQueryParameter['allocationIds'] = allocationIds
            }
            
            if (agentIds) {
                localVarQueryParameter['agentIds'] = agentIds
            }
            
            if (containerIds) {
                localVarQueryParameter['containerIds'] = containerIds
            }
            
            if (rankIds) {
                localVarQueryParameter['rankIds'] = rankIds
            }
            
            if (levels) {
                localVarQueryParameter['levels'] = levels
            }
            
            if (stdtypes) {
                localVarQueryParameter['stdtypes'] = stdtypes
            }
            
            if (sources) {
                localVarQueryParameter['sources'] = sources
            }
            
            if (timestampBefore) {
                localVarQueryParameter['timestampBefore'] = timestampBefore.toISOString()
            }
            
            if (timestampAfter) {
                localVarQueryParameter['timestampAfter'] = timestampAfter.toISOString()
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream task log fields.
         * @param {string} taskId The ID of the task.
         * @param {boolean} [follow] Continue following fields until the task stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogsFields(taskId: string, follow?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling taskLogsFields.');
            }
            const localVarPath = `/api/v1/tasks/{taskId}/logs/fields`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stream task logs.
         * @param {string} taskId The id of the task.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [allocationIds] Limit the task logs to particular allocations.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {string} [searchText] Search the logs by whether the text contains a substring.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogs(taskId: string, limit?: number, follow?: boolean, allocationIds?: Array<string>, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TaskLogsResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).taskLogs(taskId, limit, follow, allocationIds, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, searchText, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream task log fields.
         * @param {string} taskId The ID of the task.
         * @param {boolean} [follow] Continue following fields until the task stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogsFields(taskId: string, follow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TaskLogsFieldsResponse> {
            const localVarFetchArgs = JobsApiFetchParamCreator(configuration).taskLogsFields(taskId, follow, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Stream task logs.
         * @param {string} taskId The id of the task.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [allocationIds] Limit the task logs to particular allocations.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {string} [searchText] Search the logs by whether the text contains a substring.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogs(taskId: string, limit?: number, follow?: boolean, allocationIds?: Array<string>, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options?: any) {
            return JobsApiFp(configuration).taskLogs(taskId, limit, follow, allocationIds, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, searchText, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream task log fields.
         * @param {string} taskId The ID of the task.
         * @param {boolean} [follow] Continue following fields until the task stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogsFields(taskId: string, follow?: boolean, options?: any) {
            return JobsApiFp(configuration).taskLogsFields(taskId, follow, options)(fetch, basePath);
        },
    }
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * 
     * @summary Stream task logs.
     * @param {string} taskId The id of the task.
     * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
     * @param {boolean} [follow] Continue following logs until the trial stops.
     * @param {Array<string>} [allocationIds] Limit the task logs to particular allocations.
     * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
     * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
     * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
     * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
     * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
     * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
     * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
     * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
     * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {string} [searchText] Search the logs by whether the text contains a substring.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public taskLogs(taskId: string, limit?: number, follow?: boolean, allocationIds?: Array<string>, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options?: any) {
        return JobsApiFp(this.configuration).taskLogs(taskId, limit, follow, allocationIds, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, searchText, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Stream task log fields.
     * @param {string} taskId The ID of the task.
     * @param {boolean} [follow] Continue following fields until the task stops.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public taskLogsFields(taskId: string, follow?: boolean, options?: any) {
        return JobsApiFp(this.configuration).taskLogsFields(taskId, follow, options)(this.fetch, this.basePath)
    }
    
}

/**
 * ModelsApi - fetch parameter creator
 * @export
 */
export const ModelsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive a model
         * @param {string} modelName The name of the model to archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveModel(modelName: string, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling archiveModel.');
            }
            const localVarPath = `/api/v1/models/{modelName}/archive`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a model
         * @param {string} modelName The name of the model to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(modelName: string, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling deleteModel.');
            }
            const localVarPath = `/api/v1/models/{modelName}`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'DELETE', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a model version
         * @param {string} modelName The name of the model associated with the model version.
         * @param {number} modelVersionNum Sequential model version number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModelVersion(modelName: string, modelVersionNum: number, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling deleteModelVersion.');
            }
            // verify required parameter 'modelVersionNum' is not null or undefined
            if (modelVersionNum === null || modelVersionNum === undefined) {
                throw new RequiredError('modelVersionNum','Required parameter modelVersionNum was null or undefined when calling deleteModelVersion.');
            }
            const localVarPath = `/api/v1/models/{modelName}/versions/{modelVersionNum}`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)))
                .replace(`{${"modelVersionNum"}}`, encodeURIComponent(String(modelVersionNum)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'DELETE', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested model.
         * @param {string} modelName The name of the model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(modelName: string, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling getModel.');
            }
            const localVarPath = `/api/v1/models/{modelName}`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of unique model labels (sorted by popularity).
         * @param {number} [workspaceId] Optional workspace ID to limit query for model tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelLabels(workspaceId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/model/labels`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of models.
         * @param {V1GetModelsRequestSortBy} [sortBy] Sort the models by the given field.   - SORT_BY_UNSPECIFIED: Returns models in an unsorted list.  - SORT_BY_NAME: Returns models sorted by name.  - SORT_BY_DESCRIPTION: Returns models sorted by description.  - SORT_BY_CREATION_TIME: Returns models sorted by creation time.  - SORT_BY_LAST_UPDATED_TIME: Returns models sorted by last updated time.  - SORT_BY_NUM_VERSIONS: Returns models sorted by number of version.  - SORT_BY_WORKSPACE: Returns models sorted by workspace name.
         * @param {V1OrderBy} [orderBy] Order models in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of models before returning results. Negative values denote number of models to skip from the end before returning results.
         * @param {number} [limit] Limit the number of models. A value of 0 denotes no limit.
         * @param {string} [name] Limit the models to those matching or partially-matching the name.
         * @param {string} [description] Limit the models to those matching or partially-matching the description.
         * @param {Array<string>} [labels] Limit the models to those with the following labels.
         * @param {boolean} [archived] Limit to unarchived models only.
         * @param {Array<string>} [users] Limit the models to those made by the users with the following usernames.
         * @param {Array<string>} [workspaceNames] Limit models to those that belong to the following workspace names.
         * @param {Array<number>} [userIds] Limit the models to those made by the users with the following userIds.
         * @param {number} [id] Limit the models to this model id.
         * @param {Array<number>} [workspaceIds] Limit models to those that belong to the following workspace ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModels(sortBy?: V1GetModelsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, description?: string, labels?: Array<string>, archived?: boolean, users?: Array<string>, workspaceNames?: Array<string>, userIds?: Array<number>, id?: number, workspaceIds?: Array<number>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/models`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (name !== undefined) {
                localVarQueryParameter['name'] = name
            }
            
            if (description !== undefined) {
                localVarQueryParameter['description'] = description
            }
            
            if (labels) {
                localVarQueryParameter['labels'] = labels
            }
            
            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived
            }
            
            if (users) {
                localVarQueryParameter['users'] = users
            }
            
            if (workspaceNames) {
                localVarQueryParameter['workspaceNames'] = workspaceNames
            }
            
            if (userIds) {
                localVarQueryParameter['userIds'] = userIds
            }
            
            if (id !== undefined) {
                localVarQueryParameter['id'] = id
            }
            
            if (workspaceIds) {
                localVarQueryParameter['workspaceIds'] = workspaceIds
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested model version.
         * @param {string} modelName The name of the model.
         * @param {number} modelVersionNum Sequential model version number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelVersion(modelName: string, modelVersionNum: number, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling getModelVersion.');
            }
            // verify required parameter 'modelVersionNum' is not null or undefined
            if (modelVersionNum === null || modelVersionNum === undefined) {
                throw new RequiredError('modelVersionNum','Required parameter modelVersionNum was null or undefined when calling getModelVersion.');
            }
            const localVarPath = `/api/v1/models/{modelName}/versions/{modelVersionNum}`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)))
                .replace(`{${"modelVersionNum"}}`, encodeURIComponent(String(modelVersionNum)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of versions for the requested model.
         * @param {string} modelName The name of the model.
         * @param {V1GetModelVersionsRequestSortBy} [sortBy] Sort the model versions by the given field.   - SORT_BY_UNSPECIFIED: Returns model versions in an unsorted list.  - SORT_BY_VERSION: Returns model versions sorted by version number.  - SORT_BY_CREATION_TIME: Returns model versions sorted by creation_time.
         * @param {V1OrderBy} [orderBy] Order model versions in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of model versions before returning results. Negative values denote number of models to skip from the end before returning results.
         * @param {number} [limit] Limit the number of model versions. A value of 0 denotes no limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelVersions(modelName: string, sortBy?: V1GetModelVersionsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling getModelVersions.');
            }
            const localVarPath = `/api/v1/models/{modelName}/versions`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a model into a workspace
         * @param {string} modelName The target model name.
         * @param {V1MoveModelRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveModel(modelName: string, body: V1MoveModelRequest, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling moveModel.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling moveModel.');
            }
            const localVarPath = `/api/v1/models/{modelName}/move`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a model's fields.
         * @param {string} modelName The name of the model being updated.
         * @param {V1PatchModel} body The model desired model fields and values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchModel(modelName: string, body: V1PatchModel, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling patchModel.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchModel.');
            }
            const localVarPath = `/api/v1/models/{modelName}`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PATCH', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a model version's fields.
         * @param {string} modelName The name of the model being updated.
         * @param {number} modelVersionNum The model version number being updated.
         * @param {V1PatchModelVersion} body Patch payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchModelVersion(modelName: string, modelVersionNum: number, body: V1PatchModelVersion, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling patchModelVersion.');
            }
            // verify required parameter 'modelVersionNum' is not null or undefined
            if (modelVersionNum === null || modelVersionNum === undefined) {
                throw new RequiredError('modelVersionNum','Required parameter modelVersionNum was null or undefined when calling patchModelVersion.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchModelVersion.');
            }
            const localVarPath = `/api/v1/models/{modelName}/versions/{modelVersionNum}`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)))
                .replace(`{${"modelVersionNum"}}`, encodeURIComponent(String(modelVersionNum)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PATCH', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a model in the registry.
         * @param {V1PostModelRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postModel(body: V1PostModelRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postModel.');
            }
            const localVarPath = `/api/v1/models`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a model version.
         * @param {string} modelName The name of the model to add this version to.
         * @param {V1PostModelVersionRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postModelVersion(modelName: string, body: V1PostModelVersionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling postModelVersion.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postModelVersion.');
            }
            const localVarPath = `/api/v1/models/{modelName}/versions`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unarchive a model
         * @param {string} modelName The name of the model to un-archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveModel(modelName: string, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling unarchiveModel.');
            }
            const localVarPath = `/api/v1/models/{modelName}/unarchive`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelsApi - functional programming interface
 * @export
 */
export const ModelsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive a model
         * @param {string} modelName The name of the model to archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveModel(modelName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArchiveModelResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).archiveModel(modelName, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a model
         * @param {string} modelName The name of the model to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(modelName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeleteModelResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).deleteModel(modelName, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a model version
         * @param {string} modelName The name of the model associated with the model version.
         * @param {number} modelVersionNum Sequential model version number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModelVersion(modelName: string, modelVersionNum: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeleteModelVersionResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).deleteModelVersion(modelName, modelVersionNum, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested model.
         * @param {string} modelName The name of the model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(modelName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).getModel(modelName, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of unique model labels (sorted by popularity).
         * @param {number} [workspaceId] Optional workspace ID to limit query for model tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelLabels(workspaceId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelLabelsResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).getModelLabels(workspaceId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of models.
         * @param {V1GetModelsRequestSortBy} [sortBy] Sort the models by the given field.   - SORT_BY_UNSPECIFIED: Returns models in an unsorted list.  - SORT_BY_NAME: Returns models sorted by name.  - SORT_BY_DESCRIPTION: Returns models sorted by description.  - SORT_BY_CREATION_TIME: Returns models sorted by creation time.  - SORT_BY_LAST_UPDATED_TIME: Returns models sorted by last updated time.  - SORT_BY_NUM_VERSIONS: Returns models sorted by number of version.  - SORT_BY_WORKSPACE: Returns models sorted by workspace name.
         * @param {V1OrderBy} [orderBy] Order models in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of models before returning results. Negative values denote number of models to skip from the end before returning results.
         * @param {number} [limit] Limit the number of models. A value of 0 denotes no limit.
         * @param {string} [name] Limit the models to those matching or partially-matching the name.
         * @param {string} [description] Limit the models to those matching or partially-matching the description.
         * @param {Array<string>} [labels] Limit the models to those with the following labels.
         * @param {boolean} [archived] Limit to unarchived models only.
         * @param {Array<string>} [users] Limit the models to those made by the users with the following usernames.
         * @param {Array<string>} [workspaceNames] Limit models to those that belong to the following workspace names.
         * @param {Array<number>} [userIds] Limit the models to those made by the users with the following userIds.
         * @param {number} [id] Limit the models to this model id.
         * @param {Array<number>} [workspaceIds] Limit models to those that belong to the following workspace ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModels(sortBy?: V1GetModelsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, description?: string, labels?: Array<string>, archived?: boolean, users?: Array<string>, workspaceNames?: Array<string>, userIds?: Array<number>, id?: number, workspaceIds?: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelsResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).getModels(sortBy, orderBy, offset, limit, name, description, labels, archived, users, workspaceNames, userIds, id, workspaceIds, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested model version.
         * @param {string} modelName The name of the model.
         * @param {number} modelVersionNum Sequential model version number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelVersion(modelName: string, modelVersionNum: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelVersionResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).getModelVersion(modelName, modelVersionNum, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of versions for the requested model.
         * @param {string} modelName The name of the model.
         * @param {V1GetModelVersionsRequestSortBy} [sortBy] Sort the model versions by the given field.   - SORT_BY_UNSPECIFIED: Returns model versions in an unsorted list.  - SORT_BY_VERSION: Returns model versions sorted by version number.  - SORT_BY_CREATION_TIME: Returns model versions sorted by creation_time.
         * @param {V1OrderBy} [orderBy] Order model versions in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of model versions before returning results. Negative values denote number of models to skip from the end before returning results.
         * @param {number} [limit] Limit the number of model versions. A value of 0 denotes no limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelVersions(modelName: string, sortBy?: V1GetModelVersionsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelVersionsResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).getModelVersions(modelName, sortBy, orderBy, offset, limit, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Move a model into a workspace
         * @param {string} modelName The target model name.
         * @param {V1MoveModelRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveModel(modelName: string, body: V1MoveModelRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1MoveModelResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).moveModel(modelName, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch a model's fields.
         * @param {string} modelName The name of the model being updated.
         * @param {V1PatchModel} body The model desired model fields and values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchModel(modelName: string, body: V1PatchModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PatchModelResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).patchModel(modelName, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch a model version's fields.
         * @param {string} modelName The name of the model being updated.
         * @param {number} modelVersionNum The model version number being updated.
         * @param {V1PatchModelVersion} body Patch payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchModelVersion(modelName: string, modelVersionNum: number, body: V1PatchModelVersion, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PatchModelVersionResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).patchModelVersion(modelName, modelVersionNum, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a model in the registry.
         * @param {V1PostModelRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postModel(body: V1PostModelRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostModelResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).postModel(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a model version.
         * @param {string} modelName The name of the model to add this version to.
         * @param {V1PostModelVersionRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postModelVersion(modelName: string, body: V1PostModelVersionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostModelVersionResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).postModelVersion(modelName, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unarchive a model
         * @param {string} modelName The name of the model to un-archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveModel(modelName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UnarchiveModelResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).unarchiveModel(modelName, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ModelsApi - factory interface
 * @export
 */
export const ModelsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Archive a model
         * @param {string} modelName The name of the model to archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveModel(modelName: string, options?: any) {
            return ModelsApiFp(configuration).archiveModel(modelName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model
         * @param {string} modelName The name of the model to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(modelName: string, options?: any) {
            return ModelsApiFp(configuration).deleteModel(modelName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model version
         * @param {string} modelName The name of the model associated with the model version.
         * @param {number} modelVersionNum Sequential model version number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModelVersion(modelName: string, modelVersionNum: number, options?: any) {
            return ModelsApiFp(configuration).deleteModelVersion(modelName, modelVersionNum, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested model.
         * @param {string} modelName The name of the model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(modelName: string, options?: any) {
            return ModelsApiFp(configuration).getModel(modelName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of unique model labels (sorted by popularity).
         * @param {number} [workspaceId] Optional workspace ID to limit query for model tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelLabels(workspaceId?: number, options?: any) {
            return ModelsApiFp(configuration).getModelLabels(workspaceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of models.
         * @param {V1GetModelsRequestSortBy} [sortBy] Sort the models by the given field.   - SORT_BY_UNSPECIFIED: Returns models in an unsorted list.  - SORT_BY_NAME: Returns models sorted by name.  - SORT_BY_DESCRIPTION: Returns models sorted by description.  - SORT_BY_CREATION_TIME: Returns models sorted by creation time.  - SORT_BY_LAST_UPDATED_TIME: Returns models sorted by last updated time.  - SORT_BY_NUM_VERSIONS: Returns models sorted by number of version.  - SORT_BY_WORKSPACE: Returns models sorted by workspace name.
         * @param {V1OrderBy} [orderBy] Order models in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of models before returning results. Negative values denote number of models to skip from the end before returning results.
         * @param {number} [limit] Limit the number of models. A value of 0 denotes no limit.
         * @param {string} [name] Limit the models to those matching or partially-matching the name.
         * @param {string} [description] Limit the models to those matching or partially-matching the description.
         * @param {Array<string>} [labels] Limit the models to those with the following labels.
         * @param {boolean} [archived] Limit to unarchived models only.
         * @param {Array<string>} [users] Limit the models to those made by the users with the following usernames.
         * @param {Array<string>} [workspaceNames] Limit models to those that belong to the following workspace names.
         * @param {Array<number>} [userIds] Limit the models to those made by the users with the following userIds.
         * @param {number} [id] Limit the models to this model id.
         * @param {Array<number>} [workspaceIds] Limit models to those that belong to the following workspace ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModels(sortBy?: V1GetModelsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, description?: string, labels?: Array<string>, archived?: boolean, users?: Array<string>, workspaceNames?: Array<string>, userIds?: Array<number>, id?: number, workspaceIds?: Array<number>, options?: any) {
            return ModelsApiFp(configuration).getModels(sortBy, orderBy, offset, limit, name, description, labels, archived, users, workspaceNames, userIds, id, workspaceIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested model version.
         * @param {string} modelName The name of the model.
         * @param {number} modelVersionNum Sequential model version number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelVersion(modelName: string, modelVersionNum: number, options?: any) {
            return ModelsApiFp(configuration).getModelVersion(modelName, modelVersionNum, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of versions for the requested model.
         * @param {string} modelName The name of the model.
         * @param {V1GetModelVersionsRequestSortBy} [sortBy] Sort the model versions by the given field.   - SORT_BY_UNSPECIFIED: Returns model versions in an unsorted list.  - SORT_BY_VERSION: Returns model versions sorted by version number.  - SORT_BY_CREATION_TIME: Returns model versions sorted by creation_time.
         * @param {V1OrderBy} [orderBy] Order model versions in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of model versions before returning results. Negative values denote number of models to skip from the end before returning results.
         * @param {number} [limit] Limit the number of model versions. A value of 0 denotes no limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelVersions(modelName: string, sortBy?: V1GetModelVersionsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, options?: any) {
            return ModelsApiFp(configuration).getModelVersions(modelName, sortBy, orderBy, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Move a model into a workspace
         * @param {string} modelName The target model name.
         * @param {V1MoveModelRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveModel(modelName: string, body: V1MoveModelRequest, options?: any) {
            return ModelsApiFp(configuration).moveModel(modelName, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch a model's fields.
         * @param {string} modelName The name of the model being updated.
         * @param {V1PatchModel} body The model desired model fields and values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchModel(modelName: string, body: V1PatchModel, options?: any) {
            return ModelsApiFp(configuration).patchModel(modelName, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch a model version's fields.
         * @param {string} modelName The name of the model being updated.
         * @param {number} modelVersionNum The model version number being updated.
         * @param {V1PatchModelVersion} body Patch payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchModelVersion(modelName: string, modelVersionNum: number, body: V1PatchModelVersion, options?: any) {
            return ModelsApiFp(configuration).patchModelVersion(modelName, modelVersionNum, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a model in the registry.
         * @param {V1PostModelRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postModel(body: V1PostModelRequest, options?: any) {
            return ModelsApiFp(configuration).postModel(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a model version.
         * @param {string} modelName The name of the model to add this version to.
         * @param {V1PostModelVersionRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postModelVersion(modelName: string, body: V1PostModelVersionRequest, options?: any) {
            return ModelsApiFp(configuration).postModelVersion(modelName, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unarchive a model
         * @param {string} modelName The name of the model to un-archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveModel(modelName: string, options?: any) {
            return ModelsApiFp(configuration).unarchiveModel(modelName, options)(fetch, basePath);
        },
    }
};

/**
 * ModelsApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class ModelsApi extends BaseAPI {
    /**
     * 
     * @summary Archive a model
     * @param {string} modelName The name of the model to archive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public archiveModel(modelName: string, options?: any) {
        return ModelsApiFp(this.configuration).archiveModel(modelName, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Delete a model
     * @param {string} modelName The name of the model to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public deleteModel(modelName: string, options?: any) {
        return ModelsApiFp(this.configuration).deleteModel(modelName, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Delete a model version
     * @param {string} modelName The name of the model associated with the model version.
     * @param {number} modelVersionNum Sequential model version number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public deleteModelVersion(modelName: string, modelVersionNum: number, options?: any) {
        return ModelsApiFp(this.configuration).deleteModelVersion(modelName, modelVersionNum, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the requested model.
     * @param {string} modelName The name of the model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public getModel(modelName: string, options?: any) {
        return ModelsApiFp(this.configuration).getModel(modelName, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of unique model labels (sorted by popularity).
     * @param {number} [workspaceId] Optional workspace ID to limit query for model tags.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public getModelLabels(workspaceId?: number, options?: any) {
        return ModelsApiFp(this.configuration).getModelLabels(workspaceId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of models.
     * @param {V1GetModelsRequestSortBy} [sortBy] Sort the models by the given field.   - SORT_BY_UNSPECIFIED: Returns models in an unsorted list.  - SORT_BY_NAME: Returns models sorted by name.  - SORT_BY_DESCRIPTION: Returns models sorted by description.  - SORT_BY_CREATION_TIME: Returns models sorted by creation time.  - SORT_BY_LAST_UPDATED_TIME: Returns models sorted by last updated time.  - SORT_BY_NUM_VERSIONS: Returns models sorted by number of version.  - SORT_BY_WORKSPACE: Returns models sorted by workspace name.
     * @param {V1OrderBy} [orderBy] Order models in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of models before returning results. Negative values denote number of models to skip from the end before returning results.
     * @param {number} [limit] Limit the number of models. A value of 0 denotes no limit.
     * @param {string} [name] Limit the models to those matching or partially-matching the name.
     * @param {string} [description] Limit the models to those matching or partially-matching the description.
     * @param {Array<string>} [labels] Limit the models to those with the following labels.
     * @param {boolean} [archived] Limit to unarchived models only.
     * @param {Array<string>} [users] Limit the models to those made by the users with the following usernames.
     * @param {Array<string>} [workspaceNames] Limit models to those that belong to the following workspace names.
     * @param {Array<number>} [userIds] Limit the models to those made by the users with the following userIds.
     * @param {number} [id] Limit the models to this model id.
     * @param {Array<number>} [workspaceIds] Limit models to those that belong to the following workspace ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public getModels(sortBy?: V1GetModelsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, description?: string, labels?: Array<string>, archived?: boolean, users?: Array<string>, workspaceNames?: Array<string>, userIds?: Array<number>, id?: number, workspaceIds?: Array<number>, options?: any) {
        return ModelsApiFp(this.configuration).getModels(sortBy, orderBy, offset, limit, name, description, labels, archived, users, workspaceNames, userIds, id, workspaceIds, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the requested model version.
     * @param {string} modelName The name of the model.
     * @param {number} modelVersionNum Sequential model version number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public getModelVersion(modelName: string, modelVersionNum: number, options?: any) {
        return ModelsApiFp(this.configuration).getModelVersion(modelName, modelVersionNum, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of versions for the requested model.
     * @param {string} modelName The name of the model.
     * @param {V1GetModelVersionsRequestSortBy} [sortBy] Sort the model versions by the given field.   - SORT_BY_UNSPECIFIED: Returns model versions in an unsorted list.  - SORT_BY_VERSION: Returns model versions sorted by version number.  - SORT_BY_CREATION_TIME: Returns model versions sorted by creation_time.
     * @param {V1OrderBy} [orderBy] Order model versions in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of model versions before returning results. Negative values denote number of models to skip from the end before returning results.
     * @param {number} [limit] Limit the number of model versions. A value of 0 denotes no limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public getModelVersions(modelName: string, sortBy?: V1GetModelVersionsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, options?: any) {
        return ModelsApiFp(this.configuration).getModelVersions(modelName, sortBy, orderBy, offset, limit, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Move a model into a workspace
     * @param {string} modelName The target model name.
     * @param {V1MoveModelRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public moveModel(modelName: string, body: V1MoveModelRequest, options?: any) {
        return ModelsApiFp(this.configuration).moveModel(modelName, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Patch a model's fields.
     * @param {string} modelName The name of the model being updated.
     * @param {V1PatchModel} body The model desired model fields and values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public patchModel(modelName: string, body: V1PatchModel, options?: any) {
        return ModelsApiFp(this.configuration).patchModel(modelName, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Patch a model version's fields.
     * @param {string} modelName The name of the model being updated.
     * @param {number} modelVersionNum The model version number being updated.
     * @param {V1PatchModelVersion} body Patch payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public patchModelVersion(modelName: string, modelVersionNum: number, body: V1PatchModelVersion, options?: any) {
        return ModelsApiFp(this.configuration).patchModelVersion(modelName, modelVersionNum, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Create a model in the registry.
     * @param {V1PostModelRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public postModel(body: V1PostModelRequest, options?: any) {
        return ModelsApiFp(this.configuration).postModel(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Create a model version.
     * @param {string} modelName The name of the model to add this version to.
     * @param {V1PostModelVersionRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public postModelVersion(modelName: string, body: V1PostModelVersionRequest, options?: any) {
        return ModelsApiFp(this.configuration).postModelVersion(modelName, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Unarchive a model
     * @param {string} modelName The name of the model to un-archive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public unarchiveModel(modelName: string, options?: any) {
        return ModelsApiFp(this.configuration).unarchiveModel(modelName, options)(this.fetch, this.basePath)
    }
    
}

/**
 * NotebooksApi - fetch parameter creator
 * @export
 */
export const NotebooksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebook(notebookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'notebookId' is not null or undefined
            if (notebookId === null || notebookId === undefined) {
                throw new RequiredError('notebookId','Required parameter notebookId was null or undefined when calling getNotebook.');
            }
            const localVarPath = `/api/v1/notebooks/{notebookId}`
                .replace(`{${"notebookId"}}`, encodeURIComponent(String(notebookId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of notebooks.
         * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort notebooks by the given field.   - SORT_BY_UNSPECIFIED: Returns notebooks in an unsorted list.  - SORT_BY_ID: Returns notebooks sorted by id.  - SORT_BY_DESCRIPTION: Returns notebooks sorted by description.  - SORT_BY_START_TIME: Return notebooks sorted by start time.  - SORT_BY_WORKSPACE_ID: Return notebooks sorted by workspace_id
         * @param {V1OrderBy} [orderBy] Order notebooks in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of notebooks before returning results. Negative values denote number of notebooks to skip from the end before returning results.
         * @param {number} [limit] Limit the number of notebooks. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit notebooks to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit notebooks to those that are owned by users with the specified userIds.
         * @param {number} [workspaceId] Limit to those within a specified workspace, or 0 for all accessible workspaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebooks(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/notebooks`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (users) {
                localVarQueryParameter['users'] = users
            }
            
            if (userIds) {
                localVarQueryParameter['userIds'] = userIds
            }
            
            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killNotebook(notebookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'notebookId' is not null or undefined
            if (notebookId === null || notebookId === undefined) {
                throw new RequiredError('notebookId','Required parameter notebookId was null or undefined when calling killNotebook.');
            }
            const localVarPath = `/api/v1/notebooks/{notebookId}/kill`
                .replace(`{${"notebookId"}}`, encodeURIComponent(String(notebookId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Launch a notebook.
         * @param {V1LaunchNotebookRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchNotebook(body: V1LaunchNotebookRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling launchNotebook.');
            }
            const localVarPath = `/api/v1/notebooks`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the priority of the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {V1SetNotebookPriorityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNotebookPriority(notebookId: string, body: V1SetNotebookPriorityRequest, options: any = {}): FetchArgs {
            // verify required parameter 'notebookId' is not null or undefined
            if (notebookId === null || notebookId === undefined) {
                throw new RequiredError('notebookId','Required parameter notebookId was null or undefined when calling setNotebookPriority.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setNotebookPriority.');
            }
            const localVarPath = `/api/v1/notebooks/{notebookId}/set_priority`
                .replace(`{${"notebookId"}}`, encodeURIComponent(String(notebookId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotebooksApi - functional programming interface
 * @export
 */
export const NotebooksApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebook(notebookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetNotebookResponse> {
            const localVarFetchArgs = NotebooksApiFetchParamCreator(configuration).getNotebook(notebookId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of notebooks.
         * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort notebooks by the given field.   - SORT_BY_UNSPECIFIED: Returns notebooks in an unsorted list.  - SORT_BY_ID: Returns notebooks sorted by id.  - SORT_BY_DESCRIPTION: Returns notebooks sorted by description.  - SORT_BY_START_TIME: Return notebooks sorted by start time.  - SORT_BY_WORKSPACE_ID: Return notebooks sorted by workspace_id
         * @param {V1OrderBy} [orderBy] Order notebooks in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of notebooks before returning results. Negative values denote number of notebooks to skip from the end before returning results.
         * @param {number} [limit] Limit the number of notebooks. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit notebooks to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit notebooks to those that are owned by users with the specified userIds.
         * @param {number} [workspaceId] Limit to those within a specified workspace, or 0 for all accessible workspaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebooks(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetNotebooksResponse> {
            const localVarFetchArgs = NotebooksApiFetchParamCreator(configuration).getNotebooks(sortBy, orderBy, offset, limit, users, userIds, workspaceId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killNotebook(notebookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillNotebookResponse> {
            const localVarFetchArgs = NotebooksApiFetchParamCreator(configuration).killNotebook(notebookId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Launch a notebook.
         * @param {V1LaunchNotebookRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchNotebook(body: V1LaunchNotebookRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LaunchNotebookResponse> {
            const localVarFetchArgs = NotebooksApiFetchParamCreator(configuration).launchNotebook(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the priority of the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {V1SetNotebookPriorityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNotebookPriority(notebookId: string, body: V1SetNotebookPriorityRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SetNotebookPriorityResponse> {
            const localVarFetchArgs = NotebooksApiFetchParamCreator(configuration).setNotebookPriority(notebookId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotebooksApi - factory interface
 * @export
 */
export const NotebooksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebook(notebookId: string, options?: any) {
            return NotebooksApiFp(configuration).getNotebook(notebookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of notebooks.
         * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort notebooks by the given field.   - SORT_BY_UNSPECIFIED: Returns notebooks in an unsorted list.  - SORT_BY_ID: Returns notebooks sorted by id.  - SORT_BY_DESCRIPTION: Returns notebooks sorted by description.  - SORT_BY_START_TIME: Return notebooks sorted by start time.  - SORT_BY_WORKSPACE_ID: Return notebooks sorted by workspace_id
         * @param {V1OrderBy} [orderBy] Order notebooks in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of notebooks before returning results. Negative values denote number of notebooks to skip from the end before returning results.
         * @param {number} [limit] Limit the number of notebooks. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit notebooks to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit notebooks to those that are owned by users with the specified userIds.
         * @param {number} [workspaceId] Limit to those within a specified workspace, or 0 for all accessible workspaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebooks(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options?: any) {
            return NotebooksApiFp(configuration).getNotebooks(sortBy, orderBy, offset, limit, users, userIds, workspaceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killNotebook(notebookId: string, options?: any) {
            return NotebooksApiFp(configuration).killNotebook(notebookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Launch a notebook.
         * @param {V1LaunchNotebookRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchNotebook(body: V1LaunchNotebookRequest, options?: any) {
            return NotebooksApiFp(configuration).launchNotebook(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the priority of the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {V1SetNotebookPriorityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNotebookPriority(notebookId: string, body: V1SetNotebookPriorityRequest, options?: any) {
            return NotebooksApiFp(configuration).setNotebookPriority(notebookId, body, options)(fetch, basePath);
        },
    }
};

/**
 * NotebooksApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class NotebooksApi extends BaseAPI {
    /**
     * 
     * @summary Get the requested notebook.
     * @param {string} notebookId The id of the notebook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    public getNotebook(notebookId: string, options?: any) {
        return NotebooksApiFp(this.configuration).getNotebook(notebookId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of notebooks.
     * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort notebooks by the given field.   - SORT_BY_UNSPECIFIED: Returns notebooks in an unsorted list.  - SORT_BY_ID: Returns notebooks sorted by id.  - SORT_BY_DESCRIPTION: Returns notebooks sorted by description.  - SORT_BY_START_TIME: Return notebooks sorted by start time.  - SORT_BY_WORKSPACE_ID: Return notebooks sorted by workspace_id
     * @param {V1OrderBy} [orderBy] Order notebooks in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of notebooks before returning results. Negative values denote number of notebooks to skip from the end before returning results.
     * @param {number} [limit] Limit the number of notebooks. A value of 0 denotes no limit.
     * @param {Array<string>} [users] Limit notebooks to those that are owned by users with the specified usernames.
     * @param {Array<number>} [userIds] Limit notebooks to those that are owned by users with the specified userIds.
     * @param {number} [workspaceId] Limit to those within a specified workspace, or 0 for all accessible workspaces.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    public getNotebooks(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options?: any) {
        return NotebooksApiFp(this.configuration).getNotebooks(sortBy, orderBy, offset, limit, users, userIds, workspaceId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Kill the requested notebook.
     * @param {string} notebookId The id of the notebook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    public killNotebook(notebookId: string, options?: any) {
        return NotebooksApiFp(this.configuration).killNotebook(notebookId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Launch a notebook.
     * @param {V1LaunchNotebookRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    public launchNotebook(body: V1LaunchNotebookRequest, options?: any) {
        return NotebooksApiFp(this.configuration).launchNotebook(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Set the priority of the requested notebook.
     * @param {string} notebookId The id of the notebook.
     * @param {V1SetNotebookPriorityRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    public setNotebookPriority(notebookId: string, body: V1SetNotebookPriorityRequest, options?: any) {
        return NotebooksApiFp(this.configuration).setNotebookPriority(notebookId, body, options)(this.fetch, this.basePath)
    }
    
}

/**
 * ProfilerApi - fetch parameter creator
 * @export
 */
export const ProfilerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stream the available series in a trial's profiler metrics.
         * @param {number} trialId The requested trial's id.
         * @param {boolean} [follow] Continue streaming labels until the trial stops. Defaults to False.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialProfilerAvailableSeries(trialId: number, follow?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling getTrialProfilerAvailableSeries.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/profiler/available_series`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream trial profiler metrics.
         * @param {number} labelsTrialId The ID of the trial.
         * @param {string} [labelsName] The name of the metric.
         * @param {string} [labelsAgentId] The agent ID associated with the metric.
         * @param {string} [labelsGpuUuid] The GPU UUID associated with the metric.
         * @param {TrialProfilerMetricLabelsProfilerMetricType} [labelsMetricType] The type of the metric.   - PROFILER_METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - PROFILER_METRIC_TYPE_SYSTEM: For systems metrics, like GPU utilization or memory.  - PROFILER_METRIC_TYPE_TIMING: For timing metrics, like how long a backwards pass or getting a batch from the dataloader took.  - PROFILER_METRIC_TYPE_MISC: For other miscellaneous metrics.
         * @param {boolean} [follow] Continue streaming metrics until the trial stops. Defaults to False.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialProfilerMetrics(labelsTrialId: number, labelsName?: string, labelsAgentId?: string, labelsGpuUuid?: string, labelsMetricType?: TrialProfilerMetricLabelsProfilerMetricType, follow?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'labelsTrialId' is not null or undefined
            if (labelsTrialId === null || labelsTrialId === undefined) {
                throw new RequiredError('labelsTrialId','Required parameter labelsTrialId was null or undefined when calling getTrialProfilerMetrics.');
            }
            const localVarPath = `/api/v1/trials/{labelsTrialId}/profiler/metrics`
                .replace(`{${"labelsTrialId"}}`, encodeURIComponent(String(labelsTrialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (labelsName !== undefined) {
                localVarQueryParameter['labels.name'] = labelsName
            }
            
            if (labelsAgentId !== undefined) {
                localVarQueryParameter['labels.agentId'] = labelsAgentId
            }
            
            if (labelsGpuUuid !== undefined) {
                localVarQueryParameter['labels.gpuUuid'] = labelsGpuUuid
            }
            
            if (labelsMetricType !== undefined) {
                localVarQueryParameter['labels.metricType'] = labelsMetricType
            }
            
            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilerApi - functional programming interface
 * @export
 */
export const ProfilerApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stream the available series in a trial's profiler metrics.
         * @param {number} trialId The requested trial's id.
         * @param {boolean} [follow] Continue streaming labels until the trial stops. Defaults to False.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialProfilerAvailableSeries(trialId: number, follow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1GetTrialProfilerAvailableSeriesResponse> {
            const localVarFetchArgs = ProfilerApiFetchParamCreator(configuration).getTrialProfilerAvailableSeries(trialId, follow, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream trial profiler metrics.
         * @param {number} labelsTrialId The ID of the trial.
         * @param {string} [labelsName] The name of the metric.
         * @param {string} [labelsAgentId] The agent ID associated with the metric.
         * @param {string} [labelsGpuUuid] The GPU UUID associated with the metric.
         * @param {TrialProfilerMetricLabelsProfilerMetricType} [labelsMetricType] The type of the metric.   - PROFILER_METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - PROFILER_METRIC_TYPE_SYSTEM: For systems metrics, like GPU utilization or memory.  - PROFILER_METRIC_TYPE_TIMING: For timing metrics, like how long a backwards pass or getting a batch from the dataloader took.  - PROFILER_METRIC_TYPE_MISC: For other miscellaneous metrics.
         * @param {boolean} [follow] Continue streaming metrics until the trial stops. Defaults to False.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialProfilerMetrics(labelsTrialId: number, labelsName?: string, labelsAgentId?: string, labelsGpuUuid?: string, labelsMetricType?: TrialProfilerMetricLabelsProfilerMetricType, follow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1GetTrialProfilerMetricsResponse> {
            const localVarFetchArgs = ProfilerApiFetchParamCreator(configuration).getTrialProfilerMetrics(labelsTrialId, labelsName, labelsAgentId, labelsGpuUuid, labelsMetricType, follow, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProfilerApi - factory interface
 * @export
 */
export const ProfilerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Stream the available series in a trial's profiler metrics.
         * @param {number} trialId The requested trial's id.
         * @param {boolean} [follow] Continue streaming labels until the trial stops. Defaults to False.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialProfilerAvailableSeries(trialId: number, follow?: boolean, options?: any) {
            return ProfilerApiFp(configuration).getTrialProfilerAvailableSeries(trialId, follow, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream trial profiler metrics.
         * @param {number} labelsTrialId The ID of the trial.
         * @param {string} [labelsName] The name of the metric.
         * @param {string} [labelsAgentId] The agent ID associated with the metric.
         * @param {string} [labelsGpuUuid] The GPU UUID associated with the metric.
         * @param {TrialProfilerMetricLabelsProfilerMetricType} [labelsMetricType] The type of the metric.   - PROFILER_METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - PROFILER_METRIC_TYPE_SYSTEM: For systems metrics, like GPU utilization or memory.  - PROFILER_METRIC_TYPE_TIMING: For timing metrics, like how long a backwards pass or getting a batch from the dataloader took.  - PROFILER_METRIC_TYPE_MISC: For other miscellaneous metrics.
         * @param {boolean} [follow] Continue streaming metrics until the trial stops. Defaults to False.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialProfilerMetrics(labelsTrialId: number, labelsName?: string, labelsAgentId?: string, labelsGpuUuid?: string, labelsMetricType?: TrialProfilerMetricLabelsProfilerMetricType, follow?: boolean, options?: any) {
            return ProfilerApiFp(configuration).getTrialProfilerMetrics(labelsTrialId, labelsName, labelsAgentId, labelsGpuUuid, labelsMetricType, follow, options)(fetch, basePath);
        },
    }
};

/**
 * ProfilerApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class ProfilerApi extends BaseAPI {
    /**
     * 
     * @summary Stream the available series in a trial's profiler metrics.
     * @param {number} trialId The requested trial's id.
     * @param {boolean} [follow] Continue streaming labels until the trial stops. Defaults to False.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilerApi
     */
    public getTrialProfilerAvailableSeries(trialId: number, follow?: boolean, options?: any) {
        return ProfilerApiFp(this.configuration).getTrialProfilerAvailableSeries(trialId, follow, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Stream trial profiler metrics.
     * @param {number} labelsTrialId The ID of the trial.
     * @param {string} [labelsName] The name of the metric.
     * @param {string} [labelsAgentId] The agent ID associated with the metric.
     * @param {string} [labelsGpuUuid] The GPU UUID associated with the metric.
     * @param {TrialProfilerMetricLabelsProfilerMetricType} [labelsMetricType] The type of the metric.   - PROFILER_METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - PROFILER_METRIC_TYPE_SYSTEM: For systems metrics, like GPU utilization or memory.  - PROFILER_METRIC_TYPE_TIMING: For timing metrics, like how long a backwards pass or getting a batch from the dataloader took.  - PROFILER_METRIC_TYPE_MISC: For other miscellaneous metrics.
     * @param {boolean} [follow] Continue streaming metrics until the trial stops. Defaults to False.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilerApi
     */
    public getTrialProfilerMetrics(labelsTrialId: number, labelsName?: string, labelsAgentId?: string, labelsGpuUuid?: string, labelsMetricType?: TrialProfilerMetricLabelsProfilerMetricType, follow?: boolean, options?: any) {
        return ProfilerApiFp(this.configuration).getTrialProfilerMetrics(labelsTrialId, labelsName, labelsAgentId, labelsGpuUuid, labelsMetricType, follow, options)(this.fetch, this.basePath)
    }
    
}

/**
 * ProjectsApi - fetch parameter creator
 * @export
 */
export const ProjectsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a note to a project.
         * @param {number} projectId The id of the project.
         * @param {V1Note} body The note to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProjectNote(projectId: number, body: V1Note, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling addProjectNote.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addProjectNote.');
            }
            const localVarPath = `/api/v1/projects/{projectId}/notes`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling archiveProject.');
            }
            const localVarPath = `/api/v1/projects/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProject.');
            }
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'DELETE', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProject.');
            }
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of columns for experiment list table.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectColumns(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProjectColumns.');
            }
            const localVarPath = `/api/v1/projects/{id}/columns`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get metrics range for a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectNumericMetricsRange(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProjectNumericMetricsRange.');
            }
            const localVarPath = `/api/v1/projects/{id}/experiments/metric-ranges`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get projects by user activity
         * @param {number} [limit] Limit number of project entries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsByUserActivity(limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/user/projects/activity`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a project into a workspace.
         * @param {number} projectId The id of the project being moved.
         * @param {V1MoveProjectRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveProject(projectId: number, body: V1MoveProjectRequest, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling moveProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling moveProject.');
            }
            const localVarPath = `/api/v1/projects/{projectId}/move`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a project.
         * @param {number} id The id of the project.
         * @param {V1PatchProject} body The desired project fields and values to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(id: number, body: V1PatchProject, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patchProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProject.');
            }
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PATCH', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a project.
         * @param {number} workspaceId Id of the associated workspace.
         * @param {V1PostProjectRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProject(workspaceId: number, body: V1PostProjectRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError('workspaceId','Required parameter workspaceId was null or undefined when calling postProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postProject.');
            }
            const localVarPath = `/api/v1/workspaces/{workspaceId}/projects`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set project notes.
         * @param {number} projectId The id of the project.
         * @param {V1PutProjectNotesRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProjectNotes(projectId: number, body: V1PutProjectNotesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling putProjectNotes.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putProjectNotes.');
            }
            const localVarPath = `/api/v1/projects/{projectId}/notes`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PUT', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unarchive a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveProject(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unarchiveProject.');
            }
            const localVarPath = `/api/v1/projects/{id}/unarchive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a note to a project.
         * @param {number} projectId The id of the project.
         * @param {V1Note} body The note to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProjectNote(projectId: number, body: V1Note, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AddProjectNoteResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).addProjectNote(projectId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Archive a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArchiveProjectResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).archiveProject(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeleteProjectResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).deleteProject(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetProjectResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProject(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of columns for experiment list table.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectColumns(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetProjectColumnsResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectColumns(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get metrics range for a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectNumericMetricsRange(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetProjectNumericMetricsRangeResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectNumericMetricsRange(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get projects by user activity
         * @param {number} [limit] Limit number of project entries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsByUserActivity(limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetProjectsByUserActivityResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectsByUserActivity(limit, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Move a project into a workspace.
         * @param {number} projectId The id of the project being moved.
         * @param {V1MoveProjectRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveProject(projectId: number, body: V1MoveProjectRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1MoveProjectResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).moveProject(projectId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a project.
         * @param {number} id The id of the project.
         * @param {V1PatchProject} body The desired project fields and values to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(id: number, body: V1PatchProject, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PatchProjectResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).patchProject(id, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a project.
         * @param {number} workspaceId Id of the associated workspace.
         * @param {V1PostProjectRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProject(workspaceId: number, body: V1PostProjectRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostProjectResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).postProject(workspaceId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set project notes.
         * @param {number} projectId The id of the project.
         * @param {V1PutProjectNotesRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProjectNotes(projectId: number, body: V1PutProjectNotesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PutProjectNotesResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).putProjectNotes(projectId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unarchive a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveProject(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UnarchiveProjectResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).unarchiveProject(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add a note to a project.
         * @param {number} projectId The id of the project.
         * @param {V1Note} body The note to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProjectNote(projectId: number, body: V1Note, options?: any) {
            return ProjectsApiFp(configuration).addProjectNote(projectId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Archive a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(id: number, options?: any) {
            return ProjectsApiFp(configuration).archiveProject(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(id: number, options?: any) {
            return ProjectsApiFp(configuration).deleteProject(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(id: number, options?: any) {
            return ProjectsApiFp(configuration).getProject(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of columns for experiment list table.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectColumns(id: number, options?: any) {
            return ProjectsApiFp(configuration).getProjectColumns(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get metrics range for a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectNumericMetricsRange(id: number, options?: any) {
            return ProjectsApiFp(configuration).getProjectNumericMetricsRange(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get projects by user activity
         * @param {number} [limit] Limit number of project entries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsByUserActivity(limit?: number, options?: any) {
            return ProjectsApiFp(configuration).getProjectsByUserActivity(limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Move a project into a workspace.
         * @param {number} projectId The id of the project being moved.
         * @param {V1MoveProjectRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveProject(projectId: number, body: V1MoveProjectRequest, options?: any) {
            return ProjectsApiFp(configuration).moveProject(projectId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a project.
         * @param {number} id The id of the project.
         * @param {V1PatchProject} body The desired project fields and values to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(id: number, body: V1PatchProject, options?: any) {
            return ProjectsApiFp(configuration).patchProject(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a project.
         * @param {number} workspaceId Id of the associated workspace.
         * @param {V1PostProjectRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProject(workspaceId: number, body: V1PostProjectRequest, options?: any) {
            return ProjectsApiFp(configuration).postProject(workspaceId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set project notes.
         * @param {number} projectId The id of the project.
         * @param {V1PutProjectNotesRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProjectNotes(projectId: number, body: V1PutProjectNotesRequest, options?: any) {
            return ProjectsApiFp(configuration).putProjectNotes(projectId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unarchive a project.
         * @param {number} id The id of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveProject(id: number, options?: any) {
            return ProjectsApiFp(configuration).unarchiveProject(id, options)(fetch, basePath);
        },
    }
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Add a note to a project.
     * @param {number} projectId The id of the project.
     * @param {V1Note} body The note to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public addProjectNote(projectId: number, body: V1Note, options?: any) {
        return ProjectsApiFp(this.configuration).addProjectNote(projectId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Archive a project.
     * @param {number} id The id of the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public archiveProject(id: number, options?: any) {
        return ProjectsApiFp(this.configuration).archiveProject(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Delete a project.
     * @param {number} id The id of the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(id: number, options?: any) {
        return ProjectsApiFp(this.configuration).deleteProject(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the requested project.
     * @param {number} id The id of the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(id: number, options?: any) {
        return ProjectsApiFp(this.configuration).getProject(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of columns for experiment list table.
     * @param {number} id The id of the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectColumns(id: number, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectColumns(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get metrics range for a project.
     * @param {number} id The id of the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectNumericMetricsRange(id: number, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectNumericMetricsRange(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get projects by user activity
     * @param {number} [limit] Limit number of project entries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectsByUserActivity(limit?: number, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectsByUserActivity(limit, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Move a project into a workspace.
     * @param {number} projectId The id of the project being moved.
     * @param {V1MoveProjectRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public moveProject(projectId: number, body: V1MoveProjectRequest, options?: any) {
        return ProjectsApiFp(this.configuration).moveProject(projectId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Update a project.
     * @param {number} id The id of the project.
     * @param {V1PatchProject} body The desired project fields and values to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public patchProject(id: number, body: V1PatchProject, options?: any) {
        return ProjectsApiFp(this.configuration).patchProject(id, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Create a project.
     * @param {number} workspaceId Id of the associated workspace.
     * @param {V1PostProjectRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public postProject(workspaceId: number, body: V1PostProjectRequest, options?: any) {
        return ProjectsApiFp(this.configuration).postProject(workspaceId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Set project notes.
     * @param {number} projectId The id of the project.
     * @param {V1PutProjectNotesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public putProjectNotes(projectId: number, body: V1PutProjectNotesRequest, options?: any) {
        return ProjectsApiFp(this.configuration).putProjectNotes(projectId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Unarchive a project.
     * @param {number} id The id of the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public unarchiveProject(id: number, options?: any) {
        return ProjectsApiFp(this.configuration).unarchiveProject(id, options)(this.fetch, this.basePath)
    }
    
}

/**
 * RBACApi - fetch parameter creator
 * @export
 */
export const RBACApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary AssignRoles adds a set of role assignments to the system.
         * @param {V1AssignRolesRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRoles(body: V1AssignRolesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling assignRoles.');
            }
            const localVarPath = `/api/v1/roles/add-assignments`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get groups and users assigned to a given workspace with what roles are assigned.
         * @param {number} workspaceId ID of workspace getting groups and users.
         * @param {string} [name] Name of groups and users to search by. Name filters by group name for groups. Name filters by display name then username if display name is null for users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsAndUsersAssignedToWorkspace(workspaceId: number, name?: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError('workspaceId','Required parameter workspaceId was null or undefined when calling getGroupsAndUsersAssignedToWorkspace.');
            }
            const localVarPath = `/api/v1/roles/workspace/{workspaceId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (name !== undefined) {
                localVarQueryParameter['name'] = name
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all permissions for the logged in user in all scopes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsSummary(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/permissions/summary`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the roles which are assigned to a group.
         * @param {number} groupId The id of the group to search for role assignments for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesAssignedToGroup(groupId: number, options: any = {}): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling getRolesAssignedToGroup.');
            }
            const localVarPath = `/api/v1/roles/search/by-group/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the roles which are assigned to a user.
         * @param {number} userId The id of the user to search for role assignments for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesAssignedToUser(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getRolesAssignedToUser.');
            }
            const localVarPath = `/api/v1/roles/search/by-user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of roles with the corresponding IDs.
         * @param {V1GetRolesByIDRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesByID(body: V1GetRolesByIDRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getRolesByID.');
            }
            const localVarPath = `/api/v1/roles/search/by-ids`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ListRoles returns roles and groups/users granted that role.
         * @param {V1ListRolesRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(body: V1ListRolesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling listRoles.');
            }
            const localVarPath = `/api/v1/roles/search`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary RemoveAssignments removes a set of role assignments from the system.
         * @param {V1RemoveAssignmentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssignments(body: V1RemoveAssignmentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling removeAssignments.');
            }
            const localVarPath = `/api/v1/roles/remove-assignments`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for roles assignable to a given scope.
         * @param {V1SearchRolesAssignableToScopeRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRolesAssignableToScope(body: V1SearchRolesAssignableToScopeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling searchRolesAssignableToScope.');
            }
            const localVarPath = `/api/v1/roles/search/by-assignability`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RBACApi - functional programming interface
 * @export
 */
export const RBACApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary AssignRoles adds a set of role assignments to the system.
         * @param {V1AssignRolesRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRoles(body: V1AssignRolesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AssignRolesResponse> {
            const localVarFetchArgs = RBACApiFetchParamCreator(configuration).assignRoles(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get groups and users assigned to a given workspace with what roles are assigned.
         * @param {number} workspaceId ID of workspace getting groups and users.
         * @param {string} [name] Name of groups and users to search by. Name filters by group name for groups. Name filters by display name then username if display name is null for users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsAndUsersAssignedToWorkspace(workspaceId: number, name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetGroupsAndUsersAssignedToWorkspaceResponse> {
            const localVarFetchArgs = RBACApiFetchParamCreator(configuration).getGroupsAndUsersAssignedToWorkspace(workspaceId, name, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all permissions for the logged in user in all scopes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsSummary(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetPermissionsSummaryResponse> {
            const localVarFetchArgs = RBACApiFetchParamCreator(configuration).getPermissionsSummary(options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the roles which are assigned to a group.
         * @param {number} groupId The id of the group to search for role assignments for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesAssignedToGroup(groupId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetRolesAssignedToGroupResponse> {
            const localVarFetchArgs = RBACApiFetchParamCreator(configuration).getRolesAssignedToGroup(groupId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the roles which are assigned to a user.
         * @param {number} userId The id of the user to search for role assignments for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesAssignedToUser(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetRolesAssignedToUserResponse> {
            const localVarFetchArgs = RBACApiFetchParamCreator(configuration).getRolesAssignedToUser(userId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a set of roles with the corresponding IDs.
         * @param {V1GetRolesByIDRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesByID(body: V1GetRolesByIDRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetRolesByIDResponse> {
            const localVarFetchArgs = RBACApiFetchParamCreator(configuration).getRolesByID(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary ListRoles returns roles and groups/users granted that role.
         * @param {V1ListRolesRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(body: V1ListRolesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRolesResponse> {
            const localVarFetchArgs = RBACApiFetchParamCreator(configuration).listRoles(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary RemoveAssignments removes a set of role assignments from the system.
         * @param {V1RemoveAssignmentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssignments(body: V1RemoveAssignmentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RemoveAssignmentsResponse> {
            const localVarFetchArgs = RBACApiFetchParamCreator(configuration).removeAssignments(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Search for roles assignable to a given scope.
         * @param {V1SearchRolesAssignableToScopeRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRolesAssignableToScope(body: V1SearchRolesAssignableToScopeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SearchRolesAssignableToScopeResponse> {
            const localVarFetchArgs = RBACApiFetchParamCreator(configuration).searchRolesAssignableToScope(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RBACApi - factory interface
 * @export
 */
export const RBACApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary AssignRoles adds a set of role assignments to the system.
         * @param {V1AssignRolesRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRoles(body: V1AssignRolesRequest, options?: any) {
            return RBACApiFp(configuration).assignRoles(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get groups and users assigned to a given workspace with what roles are assigned.
         * @param {number} workspaceId ID of workspace getting groups and users.
         * @param {string} [name] Name of groups and users to search by. Name filters by group name for groups. Name filters by display name then username if display name is null for users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsAndUsersAssignedToWorkspace(workspaceId: number, name?: string, options?: any) {
            return RBACApiFp(configuration).getGroupsAndUsersAssignedToWorkspace(workspaceId, name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all permissions for the logged in user in all scopes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsSummary(options?: any) {
            return RBACApiFp(configuration).getPermissionsSummary(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the roles which are assigned to a group.
         * @param {number} groupId The id of the group to search for role assignments for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesAssignedToGroup(groupId: number, options?: any) {
            return RBACApiFp(configuration).getRolesAssignedToGroup(groupId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the roles which are assigned to a user.
         * @param {number} userId The id of the user to search for role assignments for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesAssignedToUser(userId: number, options?: any) {
            return RBACApiFp(configuration).getRolesAssignedToUser(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a set of roles with the corresponding IDs.
         * @param {V1GetRolesByIDRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesByID(body: V1GetRolesByIDRequest, options?: any) {
            return RBACApiFp(configuration).getRolesByID(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary ListRoles returns roles and groups/users granted that role.
         * @param {V1ListRolesRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(body: V1ListRolesRequest, options?: any) {
            return RBACApiFp(configuration).listRoles(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary RemoveAssignments removes a set of role assignments from the system.
         * @param {V1RemoveAssignmentsRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssignments(body: V1RemoveAssignmentsRequest, options?: any) {
            return RBACApiFp(configuration).removeAssignments(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Search for roles assignable to a given scope.
         * @param {V1SearchRolesAssignableToScopeRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRolesAssignableToScope(body: V1SearchRolesAssignableToScopeRequest, options?: any) {
            return RBACApiFp(configuration).searchRolesAssignableToScope(body, options)(fetch, basePath);
        },
    }
};

/**
 * RBACApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class RBACApi extends BaseAPI {
    /**
     * 
     * @summary AssignRoles adds a set of role assignments to the system.
     * @param {V1AssignRolesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RBACApi
     */
    public assignRoles(body: V1AssignRolesRequest, options?: any) {
        return RBACApiFp(this.configuration).assignRoles(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get groups and users assigned to a given workspace with what roles are assigned.
     * @param {number} workspaceId ID of workspace getting groups and users.
     * @param {string} [name] Name of groups and users to search by. Name filters by group name for groups. Name filters by display name then username if display name is null for users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RBACApi
     */
    public getGroupsAndUsersAssignedToWorkspace(workspaceId: number, name?: string, options?: any) {
        return RBACApiFp(this.configuration).getGroupsAndUsersAssignedToWorkspace(workspaceId, name, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary List all permissions for the logged in user in all scopes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RBACApi
     */
    public getPermissionsSummary(options?: any) {
        return RBACApiFp(this.configuration).getPermissionsSummary(options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the roles which are assigned to a group.
     * @param {number} groupId The id of the group to search for role assignments for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RBACApi
     */
    public getRolesAssignedToGroup(groupId: number, options?: any) {
        return RBACApiFp(this.configuration).getRolesAssignedToGroup(groupId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the roles which are assigned to a user.
     * @param {number} userId The id of the user to search for role assignments for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RBACApi
     */
    public getRolesAssignedToUser(userId: number, options?: any) {
        return RBACApiFp(this.configuration).getRolesAssignedToUser(userId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a set of roles with the corresponding IDs.
     * @param {V1GetRolesByIDRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RBACApi
     */
    public getRolesByID(body: V1GetRolesByIDRequest, options?: any) {
        return RBACApiFp(this.configuration).getRolesByID(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary ListRoles returns roles and groups/users granted that role.
     * @param {V1ListRolesRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RBACApi
     */
    public listRoles(body: V1ListRolesRequest, options?: any) {
        return RBACApiFp(this.configuration).listRoles(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary RemoveAssignments removes a set of role assignments from the system.
     * @param {V1RemoveAssignmentsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RBACApi
     */
    public removeAssignments(body: V1RemoveAssignmentsRequest, options?: any) {
        return RBACApiFp(this.configuration).removeAssignments(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Search for roles assignable to a given scope.
     * @param {V1SearchRolesAssignableToScopeRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RBACApi
     */
    public searchRolesAssignableToScope(body: V1SearchRolesAssignableToScopeRequest, options?: any) {
        return RBACApiFp(this.configuration).searchRolesAssignableToScope(body, options)(this.fetch, this.basePath)
    }
    
}

/**
 * ShellsApi - fetch parameter creator
 * @export
 */
export const ShellsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShell(shellId: string, options: any = {}): FetchArgs {
            // verify required parameter 'shellId' is not null or undefined
            if (shellId === null || shellId === undefined) {
                throw new RequiredError('shellId','Required parameter shellId was null or undefined when calling getShell.');
            }
            const localVarPath = `/api/v1/shells/{shellId}`
                .replace(`{${"shellId"}}`, encodeURIComponent(String(shellId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of shells.
         * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort shells by the given field.   - SORT_BY_UNSPECIFIED: Returns shells in an unsorted list.  - SORT_BY_ID: Returns shells sorted by id.  - SORT_BY_DESCRIPTION: Returns shells sorted by description.  - SORT_BY_START_TIME: Return shells sorted by start time.  - SORT_BY_WORKSPACE_ID: Return shells sorted by workspace_id.
         * @param {V1OrderBy} [orderBy] Order shells in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of shells before returning results. Negative values denote number of shells to skip from the end before returning results.
         * @param {number} [limit] Limit the number of shells. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit shells to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit shells to those that are owned by users with the specified userIds.
         * @param {number} [workspaceId] Limit to those within a specified workspace, or 0 for all accessible workspaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShells(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/shells`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (users) {
                localVarQueryParameter['users'] = users
            }
            
            if (userIds) {
                localVarQueryParameter['userIds'] = userIds
            }
            
            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killShell(shellId: string, options: any = {}): FetchArgs {
            // verify required parameter 'shellId' is not null or undefined
            if (shellId === null || shellId === undefined) {
                throw new RequiredError('shellId','Required parameter shellId was null or undefined when calling killShell.');
            }
            const localVarPath = `/api/v1/shells/{shellId}/kill`
                .replace(`{${"shellId"}}`, encodeURIComponent(String(shellId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Launch a shell.
         * @param {V1LaunchShellRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchShell(body: V1LaunchShellRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling launchShell.');
            }
            const localVarPath = `/api/v1/shells`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the priority of the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {V1SetShellPriorityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setShellPriority(shellId: string, body: V1SetShellPriorityRequest, options: any = {}): FetchArgs {
            // verify required parameter 'shellId' is not null or undefined
            if (shellId === null || shellId === undefined) {
                throw new RequiredError('shellId','Required parameter shellId was null or undefined when calling setShellPriority.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setShellPriority.');
            }
            const localVarPath = `/api/v1/shells/{shellId}/set_priority`
                .replace(`{${"shellId"}}`, encodeURIComponent(String(shellId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShellsApi - functional programming interface
 * @export
 */
export const ShellsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShell(shellId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetShellResponse> {
            const localVarFetchArgs = ShellsApiFetchParamCreator(configuration).getShell(shellId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of shells.
         * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort shells by the given field.   - SORT_BY_UNSPECIFIED: Returns shells in an unsorted list.  - SORT_BY_ID: Returns shells sorted by id.  - SORT_BY_DESCRIPTION: Returns shells sorted by description.  - SORT_BY_START_TIME: Return shells sorted by start time.  - SORT_BY_WORKSPACE_ID: Return shells sorted by workspace_id.
         * @param {V1OrderBy} [orderBy] Order shells in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of shells before returning results. Negative values denote number of shells to skip from the end before returning results.
         * @param {number} [limit] Limit the number of shells. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit shells to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit shells to those that are owned by users with the specified userIds.
         * @param {number} [workspaceId] Limit to those within a specified workspace, or 0 for all accessible workspaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShells(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetShellsResponse> {
            const localVarFetchArgs = ShellsApiFetchParamCreator(configuration).getShells(sortBy, orderBy, offset, limit, users, userIds, workspaceId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killShell(shellId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillShellResponse> {
            const localVarFetchArgs = ShellsApiFetchParamCreator(configuration).killShell(shellId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Launch a shell.
         * @param {V1LaunchShellRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchShell(body: V1LaunchShellRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LaunchShellResponse> {
            const localVarFetchArgs = ShellsApiFetchParamCreator(configuration).launchShell(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the priority of the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {V1SetShellPriorityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setShellPriority(shellId: string, body: V1SetShellPriorityRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SetShellPriorityResponse> {
            const localVarFetchArgs = ShellsApiFetchParamCreator(configuration).setShellPriority(shellId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ShellsApi - factory interface
 * @export
 */
export const ShellsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShell(shellId: string, options?: any) {
            return ShellsApiFp(configuration).getShell(shellId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of shells.
         * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort shells by the given field.   - SORT_BY_UNSPECIFIED: Returns shells in an unsorted list.  - SORT_BY_ID: Returns shells sorted by id.  - SORT_BY_DESCRIPTION: Returns shells sorted by description.  - SORT_BY_START_TIME: Return shells sorted by start time.  - SORT_BY_WORKSPACE_ID: Return shells sorted by workspace_id.
         * @param {V1OrderBy} [orderBy] Order shells in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of shells before returning results. Negative values denote number of shells to skip from the end before returning results.
         * @param {number} [limit] Limit the number of shells. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit shells to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit shells to those that are owned by users with the specified userIds.
         * @param {number} [workspaceId] Limit to those within a specified workspace, or 0 for all accessible workspaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShells(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options?: any) {
            return ShellsApiFp(configuration).getShells(sortBy, orderBy, offset, limit, users, userIds, workspaceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killShell(shellId: string, options?: any) {
            return ShellsApiFp(configuration).killShell(shellId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Launch a shell.
         * @param {V1LaunchShellRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchShell(body: V1LaunchShellRequest, options?: any) {
            return ShellsApiFp(configuration).launchShell(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the priority of the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {V1SetShellPriorityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setShellPriority(shellId: string, body: V1SetShellPriorityRequest, options?: any) {
            return ShellsApiFp(configuration).setShellPriority(shellId, body, options)(fetch, basePath);
        },
    }
};

/**
 * ShellsApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class ShellsApi extends BaseAPI {
    /**
     * 
     * @summary Get the requested shell.
     * @param {string} shellId The id of the shell.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShellsApi
     */
    public getShell(shellId: string, options?: any) {
        return ShellsApiFp(this.configuration).getShell(shellId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of shells.
     * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort shells by the given field.   - SORT_BY_UNSPECIFIED: Returns shells in an unsorted list.  - SORT_BY_ID: Returns shells sorted by id.  - SORT_BY_DESCRIPTION: Returns shells sorted by description.  - SORT_BY_START_TIME: Return shells sorted by start time.  - SORT_BY_WORKSPACE_ID: Return shells sorted by workspace_id.
     * @param {V1OrderBy} [orderBy] Order shells in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of shells before returning results. Negative values denote number of shells to skip from the end before returning results.
     * @param {number} [limit] Limit the number of shells. A value of 0 denotes no limit.
     * @param {Array<string>} [users] Limit shells to those that are owned by users with the specified usernames.
     * @param {Array<number>} [userIds] Limit shells to those that are owned by users with the specified userIds.
     * @param {number} [workspaceId] Limit to those within a specified workspace, or 0 for all accessible workspaces.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShellsApi
     */
    public getShells(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options?: any) {
        return ShellsApiFp(this.configuration).getShells(sortBy, orderBy, offset, limit, users, userIds, workspaceId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Kill the requested shell.
     * @param {string} shellId The id of the shell.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShellsApi
     */
    public killShell(shellId: string, options?: any) {
        return ShellsApiFp(this.configuration).killShell(shellId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Launch a shell.
     * @param {V1LaunchShellRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShellsApi
     */
    public launchShell(body: V1LaunchShellRequest, options?: any) {
        return ShellsApiFp(this.configuration).launchShell(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Set the priority of the requested shell.
     * @param {string} shellId The id of the shell.
     * @param {V1SetShellPriorityRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShellsApi
     */
    public setShellPriority(shellId: string, body: V1SetShellPriorityRequest, options?: any) {
        return ShellsApiFp(this.configuration).setShellPriority(shellId, body, options)(this.fetch, this.basePath)
    }
    
}

/**
 * TasksApi - fetch parameter creator
 * @export
 */
export const TasksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a count of active tasks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveTasksCount(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/tasks/count`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check the status of a requested task.
         * @param {string} taskId The requested task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options: any = {}): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling getTask.');
            }
            const localVarPath = `/api/v1/tasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all tasks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/tasks`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream task logs.
         * @param {string} taskId The id of the task.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [allocationIds] Limit the task logs to particular allocations.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {string} [searchText] Search the logs by whether the text contains a substring.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogs(taskId: string, limit?: number, follow?: boolean, allocationIds?: Array<string>, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options: any = {}): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling taskLogs.');
            }
            const localVarPath = `/api/v1/tasks/{taskId}/logs`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow
            }
            
            if (allocationIds) {
                localVarQueryParameter['allocationIds'] = allocationIds
            }
            
            if (agentIds) {
                localVarQueryParameter['agentIds'] = agentIds
            }
            
            if (containerIds) {
                localVarQueryParameter['containerIds'] = containerIds
            }
            
            if (rankIds) {
                localVarQueryParameter['rankIds'] = rankIds
            }
            
            if (levels) {
                localVarQueryParameter['levels'] = levels
            }
            
            if (stdtypes) {
                localVarQueryParameter['stdtypes'] = stdtypes
            }
            
            if (sources) {
                localVarQueryParameter['sources'] = sources
            }
            
            if (timestampBefore) {
                localVarQueryParameter['timestampBefore'] = timestampBefore.toISOString()
            }
            
            if (timestampAfter) {
                localVarQueryParameter['timestampAfter'] = timestampAfter.toISOString()
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream task log fields.
         * @param {string} taskId The ID of the task.
         * @param {boolean} [follow] Continue following fields until the task stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogsFields(taskId: string, follow?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling taskLogsFields.');
            }
            const localVarPath = `/api/v1/tasks/{taskId}/logs/fields`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a count of active tasks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveTasksCount(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetActiveTasksCountResponse> {
            const localVarFetchArgs = TasksApiFetchParamCreator(configuration).getActiveTasksCount(options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check the status of a requested task.
         * @param {string} taskId The requested task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTaskResponse> {
            const localVarFetchArgs = TasksApiFetchParamCreator(configuration).getTask(taskId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all tasks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTasksResponse> {
            const localVarFetchArgs = TasksApiFetchParamCreator(configuration).getTasks(options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream task logs.
         * @param {string} taskId The id of the task.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [allocationIds] Limit the task logs to particular allocations.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {string} [searchText] Search the logs by whether the text contains a substring.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogs(taskId: string, limit?: number, follow?: boolean, allocationIds?: Array<string>, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TaskLogsResponse> {
            const localVarFetchArgs = TasksApiFetchParamCreator(configuration).taskLogs(taskId, limit, follow, allocationIds, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, searchText, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream task log fields.
         * @param {string} taskId The ID of the task.
         * @param {boolean} [follow] Continue following fields until the task stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogsFields(taskId: string, follow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TaskLogsFieldsResponse> {
            const localVarFetchArgs = TasksApiFetchParamCreator(configuration).taskLogsFields(taskId, follow, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get a count of active tasks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveTasksCount(options?: any) {
            return TasksApiFp(configuration).getActiveTasksCount(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check the status of a requested task.
         * @param {string} taskId The requested task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options?: any) {
            return TasksApiFp(configuration).getTask(taskId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all tasks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(options?: any) {
            return TasksApiFp(configuration).getTasks(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream task logs.
         * @param {string} taskId The id of the task.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [allocationIds] Limit the task logs to particular allocations.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {string} [searchText] Search the logs by whether the text contains a substring.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogs(taskId: string, limit?: number, follow?: boolean, allocationIds?: Array<string>, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options?: any) {
            return TasksApiFp(configuration).taskLogs(taskId, limit, follow, allocationIds, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, searchText, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream task log fields.
         * @param {string} taskId The ID of the task.
         * @param {boolean} [follow] Continue following fields until the task stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogsFields(taskId: string, follow?: boolean, options?: any) {
            return TasksApiFp(configuration).taskLogsFields(taskId, follow, options)(fetch, basePath);
        },
    }
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @summary Get a count of active tasks.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getActiveTasksCount(options?: any) {
        return TasksApiFp(this.configuration).getActiveTasksCount(options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Check the status of a requested task.
     * @param {string} taskId The requested task id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTask(taskId: string, options?: any) {
        return TasksApiFp(this.configuration).getTask(taskId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get all tasks.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasks(options?: any) {
        return TasksApiFp(this.configuration).getTasks(options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Stream task logs.
     * @param {string} taskId The id of the task.
     * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
     * @param {boolean} [follow] Continue following logs until the trial stops.
     * @param {Array<string>} [allocationIds] Limit the task logs to particular allocations.
     * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
     * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
     * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
     * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
     * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
     * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
     * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
     * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
     * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {string} [searchText] Search the logs by whether the text contains a substring.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public taskLogs(taskId: string, limit?: number, follow?: boolean, allocationIds?: Array<string>, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options?: any) {
        return TasksApiFp(this.configuration).taskLogs(taskId, limit, follow, allocationIds, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, searchText, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Stream task log fields.
     * @param {string} taskId The ID of the task.
     * @param {boolean} [follow] Continue following fields until the task stops.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public taskLogsFields(taskId: string, follow?: boolean, options?: any) {
        return TasksApiFp(this.configuration).taskLogsFields(taskId, follow, options)(this.fetch, this.basePath)
    }
    
}

/**
 * TemplatesApi - fetch parameter creator
 * @export
 */
export const TemplatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(templateName: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling deleteTemplate.');
            }
            const localVarPath = `/api/v1/templates/{templateName}`
                .replace(`{${"templateName"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'DELETE', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(templateName: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling getTemplate.');
            }
            const localVarPath = `/api/v1/templates/{templateName}`
                .replace(`{${"templateName"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of templates.
         * @param {V1GetTemplatesRequestSortBy} [sortBy] Sort templates by the given field.   - SORT_BY_UNSPECIFIED: Returns templates in an unsorted list.  - SORT_BY_NAME: Returns templates sorted by name.
         * @param {V1OrderBy} [orderBy] Order templates in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of templates before returning results. Negative values denote number of templates to skip from the end before returning results.
         * @param {number} [limit] Limit the number of templates. A value of 0 denotes no limit.
         * @param {string} [name] Limit templates to those that match the name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(sortBy?: V1GetTemplatesRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/templates`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (name !== undefined) {
                localVarQueryParameter['name'] = name
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch template config.
         * @param {string} templateName The name of the template.
         * @param {any} body The template value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTemplateConfig(templateName: string, body: any, options: any = {}): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling patchTemplateConfig.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchTemplateConfig.');
            }
            const localVarPath = `/api/v1/templates/{templateName}`
                .replace(`{${"templateName"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PATCH', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post a new template.
         * @param {string} templateName The name of the template.
         * @param {V1Template} body The template to put.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTemplate(templateName: string, body: V1Template, options: any = {}): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling postTemplate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postTemplate.');
            }
            const localVarPath = `/api/v1/templates/{templateName}`
                .replace(`{${"templateName"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED: Update or create (upsert) the requested template.
         * @param {string} templateName The name of the template.
         * @param {V1Template} body The template to put.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTemplate(templateName: string, body: V1Template, options: any = {}): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling putTemplate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putTemplate.');
            }
            const localVarPath = `/api/v1/templates/{templateName}`
                .replace(`{${"templateName"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PUT', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(templateName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeleteTemplateResponse> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).deleteTemplate(templateName, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(templateName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTemplateResponse> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).getTemplate(templateName, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of templates.
         * @param {V1GetTemplatesRequestSortBy} [sortBy] Sort templates by the given field.   - SORT_BY_UNSPECIFIED: Returns templates in an unsorted list.  - SORT_BY_NAME: Returns templates sorted by name.
         * @param {V1OrderBy} [orderBy] Order templates in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of templates before returning results. Negative values denote number of templates to skip from the end before returning results.
         * @param {number} [limit] Limit the number of templates. A value of 0 denotes no limit.
         * @param {string} [name] Limit templates to those that match the name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(sortBy?: V1GetTemplatesRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTemplatesResponse> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).getTemplates(sortBy, orderBy, offset, limit, name, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch template config.
         * @param {string} templateName The name of the template.
         * @param {any} body The template value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTemplateConfig(templateName: string, body: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PatchTemplateConfigResponse> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).patchTemplateConfig(templateName, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Post a new template.
         * @param {string} templateName The name of the template.
         * @param {V1Template} body The template to put.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTemplate(templateName: string, body: V1Template, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostTemplateResponse> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).postTemplate(templateName, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary DEPRECATED: Update or create (upsert) the requested template.
         * @param {string} templateName The name of the template.
         * @param {V1Template} body The template to put.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTemplate(templateName: string, body: V1Template, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PutTemplateResponse> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).putTemplate(templateName, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete a template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(templateName: string, options?: any) {
            return TemplatesApiFp(configuration).deleteTemplate(templateName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(templateName: string, options?: any) {
            return TemplatesApiFp(configuration).getTemplate(templateName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of templates.
         * @param {V1GetTemplatesRequestSortBy} [sortBy] Sort templates by the given field.   - SORT_BY_UNSPECIFIED: Returns templates in an unsorted list.  - SORT_BY_NAME: Returns templates sorted by name.
         * @param {V1OrderBy} [orderBy] Order templates in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of templates before returning results. Negative values denote number of templates to skip from the end before returning results.
         * @param {number} [limit] Limit the number of templates. A value of 0 denotes no limit.
         * @param {string} [name] Limit templates to those that match the name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(sortBy?: V1GetTemplatesRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, options?: any) {
            return TemplatesApiFp(configuration).getTemplates(sortBy, orderBy, offset, limit, name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch template config.
         * @param {string} templateName The name of the template.
         * @param {any} body The template value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTemplateConfig(templateName: string, body: any, options?: any) {
            return TemplatesApiFp(configuration).patchTemplateConfig(templateName, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Post a new template.
         * @param {string} templateName The name of the template.
         * @param {V1Template} body The template to put.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTemplate(templateName: string, body: V1Template, options?: any) {
            return TemplatesApiFp(configuration).postTemplate(templateName, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary DEPRECATED: Update or create (upsert) the requested template.
         * @param {string} templateName The name of the template.
         * @param {V1Template} body The template to put.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTemplate(templateName: string, body: V1Template, options?: any) {
            return TemplatesApiFp(configuration).putTemplate(templateName, body, options)(fetch, basePath);
        },
    }
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a template.
     * @param {string} templateName The id of the template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public deleteTemplate(templateName: string, options?: any) {
        return TemplatesApiFp(this.configuration).deleteTemplate(templateName, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the requested template.
     * @param {string} templateName The id of the template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getTemplate(templateName: string, options?: any) {
        return TemplatesApiFp(this.configuration).getTemplate(templateName, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of templates.
     * @param {V1GetTemplatesRequestSortBy} [sortBy] Sort templates by the given field.   - SORT_BY_UNSPECIFIED: Returns templates in an unsorted list.  - SORT_BY_NAME: Returns templates sorted by name.
     * @param {V1OrderBy} [orderBy] Order templates in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of templates before returning results. Negative values denote number of templates to skip from the end before returning results.
     * @param {number} [limit] Limit the number of templates. A value of 0 denotes no limit.
     * @param {string} [name] Limit templates to those that match the name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getTemplates(sortBy?: V1GetTemplatesRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, options?: any) {
        return TemplatesApiFp(this.configuration).getTemplates(sortBy, orderBy, offset, limit, name, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Patch template config.
     * @param {string} templateName The name of the template.
     * @param {any} body The template value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public patchTemplateConfig(templateName: string, body: any, options?: any) {
        return TemplatesApiFp(this.configuration).patchTemplateConfig(templateName, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Post a new template.
     * @param {string} templateName The name of the template.
     * @param {V1Template} body The template to put.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public postTemplate(templateName: string, body: V1Template, options?: any) {
        return TemplatesApiFp(this.configuration).postTemplate(templateName, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary DEPRECATED: Update or create (upsert) the requested template.
     * @param {string} templateName The name of the template.
     * @param {V1Template} body The template to put.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public putTemplate(templateName: string, body: V1Template, options?: any) {
        return TemplatesApiFp(this.configuration).putTemplate(templateName, body, options)(this.fetch, this.basePath)
    }
    
}

/**
 * TensorboardsApi - fetch parameter creator
 * @export
 */
export const TensorboardsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested tensorboard.
         * @param {string} tensorboardId The id of the tensorboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTensorboard(tensorboardId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tensorboardId' is not null or undefined
            if (tensorboardId === null || tensorboardId === undefined) {
                throw new RequiredError('tensorboardId','Required parameter tensorboardId was null or undefined when calling getTensorboard.');
            }
            const localVarPath = `/api/v1/tensorboards/{tensorboardId}`
                .replace(`{${"tensorboardId"}}`, encodeURIComponent(String(tensorboardId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of tensorboards.
         * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort tensorboards by the given field.   - SORT_BY_UNSPECIFIED: Returns tensorboards in an unsorted list.  - SORT_BY_ID: Returns tensorboards sorted by id.  - SORT_BY_DESCRIPTION: Returns tensorboards sorted by description.  - SORT_BY_START_TIME: Return tensorboards sorted by start time.  - SORT_BY_WORKSPACE_ID: Return tensorboards sorted by workspace_id.
         * @param {V1OrderBy} [orderBy] Order tensorboards in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of tensorboards before returning results. Negative values denote number of tensorboards to skip from the end before returning results.
         * @param {number} [limit] Limit the number of tensorboards. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit tensorboards to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit tensorboards to those that are owned by users with the specified userIds.
         * @param {number} [workspaceId] Limit tensorboards to those that are in a specific workspace, or 0 for all accessible workspaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTensorboards(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/tensorboards`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (users) {
                localVarQueryParameter['users'] = users
            }
            
            if (userIds) {
                localVarQueryParameter['userIds'] = userIds
            }
            
            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill the requested tensorboard.
         * @param {string} tensorboardId The id of the tensorboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killTensorboard(tensorboardId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tensorboardId' is not null or undefined
            if (tensorboardId === null || tensorboardId === undefined) {
                throw new RequiredError('tensorboardId','Required parameter tensorboardId was null or undefined when calling killTensorboard.');
            }
            const localVarPath = `/api/v1/tensorboards/{tensorboardId}/kill`
                .replace(`{${"tensorboardId"}}`, encodeURIComponent(String(tensorboardId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Launch a tensorboard.
         * @param {V1LaunchTensorboardRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchTensorboard(body: V1LaunchTensorboardRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling launchTensorboard.');
            }
            const localVarPath = `/api/v1/tensorboards`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the priority of the requested TensorBoard.
         * @param {string} tensorboardId The id of the TensorBoard.
         * @param {V1SetTensorboardPriorityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTensorboardPriority(tensorboardId: string, body: V1SetTensorboardPriorityRequest, options: any = {}): FetchArgs {
            // verify required parameter 'tensorboardId' is not null or undefined
            if (tensorboardId === null || tensorboardId === undefined) {
                throw new RequiredError('tensorboardId','Required parameter tensorboardId was null or undefined when calling setTensorboardPriority.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setTensorboardPriority.');
            }
            const localVarPath = `/api/v1/tensorboards/{tensorboardId}/set_priority`
                .replace(`{${"tensorboardId"}}`, encodeURIComponent(String(tensorboardId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TensorboardsApi - functional programming interface
 * @export
 */
export const TensorboardsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested tensorboard.
         * @param {string} tensorboardId The id of the tensorboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTensorboard(tensorboardId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTensorboardResponse> {
            const localVarFetchArgs = TensorboardsApiFetchParamCreator(configuration).getTensorboard(tensorboardId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of tensorboards.
         * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort tensorboards by the given field.   - SORT_BY_UNSPECIFIED: Returns tensorboards in an unsorted list.  - SORT_BY_ID: Returns tensorboards sorted by id.  - SORT_BY_DESCRIPTION: Returns tensorboards sorted by description.  - SORT_BY_START_TIME: Return tensorboards sorted by start time.  - SORT_BY_WORKSPACE_ID: Return tensorboards sorted by workspace_id.
         * @param {V1OrderBy} [orderBy] Order tensorboards in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of tensorboards before returning results. Negative values denote number of tensorboards to skip from the end before returning results.
         * @param {number} [limit] Limit the number of tensorboards. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit tensorboards to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit tensorboards to those that are owned by users with the specified userIds.
         * @param {number} [workspaceId] Limit tensorboards to those that are in a specific workspace, or 0 for all accessible workspaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTensorboards(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTensorboardsResponse> {
            const localVarFetchArgs = TensorboardsApiFetchParamCreator(configuration).getTensorboards(sortBy, orderBy, offset, limit, users, userIds, workspaceId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill the requested tensorboard.
         * @param {string} tensorboardId The id of the tensorboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killTensorboard(tensorboardId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillTensorboardResponse> {
            const localVarFetchArgs = TensorboardsApiFetchParamCreator(configuration).killTensorboard(tensorboardId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Launch a tensorboard.
         * @param {V1LaunchTensorboardRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchTensorboard(body: V1LaunchTensorboardRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LaunchTensorboardResponse> {
            const localVarFetchArgs = TensorboardsApiFetchParamCreator(configuration).launchTensorboard(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the priority of the requested TensorBoard.
         * @param {string} tensorboardId The id of the TensorBoard.
         * @param {V1SetTensorboardPriorityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTensorboardPriority(tensorboardId: string, body: V1SetTensorboardPriorityRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SetTensorboardPriorityResponse> {
            const localVarFetchArgs = TensorboardsApiFetchParamCreator(configuration).setTensorboardPriority(tensorboardId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TensorboardsApi - factory interface
 * @export
 */
export const TensorboardsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the requested tensorboard.
         * @param {string} tensorboardId The id of the tensorboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTensorboard(tensorboardId: string, options?: any) {
            return TensorboardsApiFp(configuration).getTensorboard(tensorboardId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of tensorboards.
         * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort tensorboards by the given field.   - SORT_BY_UNSPECIFIED: Returns tensorboards in an unsorted list.  - SORT_BY_ID: Returns tensorboards sorted by id.  - SORT_BY_DESCRIPTION: Returns tensorboards sorted by description.  - SORT_BY_START_TIME: Return tensorboards sorted by start time.  - SORT_BY_WORKSPACE_ID: Return tensorboards sorted by workspace_id.
         * @param {V1OrderBy} [orderBy] Order tensorboards in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of tensorboards before returning results. Negative values denote number of tensorboards to skip from the end before returning results.
         * @param {number} [limit] Limit the number of tensorboards. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit tensorboards to those that are owned by users with the specified usernames.
         * @param {Array<number>} [userIds] Limit tensorboards to those that are owned by users with the specified userIds.
         * @param {number} [workspaceId] Limit tensorboards to those that are in a specific workspace, or 0 for all accessible workspaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTensorboards(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options?: any) {
            return TensorboardsApiFp(configuration).getTensorboards(sortBy, orderBy, offset, limit, users, userIds, workspaceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill the requested tensorboard.
         * @param {string} tensorboardId The id of the tensorboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killTensorboard(tensorboardId: string, options?: any) {
            return TensorboardsApiFp(configuration).killTensorboard(tensorboardId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Launch a tensorboard.
         * @param {V1LaunchTensorboardRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        launchTensorboard(body: V1LaunchTensorboardRequest, options?: any) {
            return TensorboardsApiFp(configuration).launchTensorboard(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the priority of the requested TensorBoard.
         * @param {string} tensorboardId The id of the TensorBoard.
         * @param {V1SetTensorboardPriorityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTensorboardPriority(tensorboardId: string, body: V1SetTensorboardPriorityRequest, options?: any) {
            return TensorboardsApiFp(configuration).setTensorboardPriority(tensorboardId, body, options)(fetch, basePath);
        },
    }
};

/**
 * TensorboardsApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class TensorboardsApi extends BaseAPI {
    /**
     * 
     * @summary Get the requested tensorboard.
     * @param {string} tensorboardId The id of the tensorboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TensorboardsApi
     */
    public getTensorboard(tensorboardId: string, options?: any) {
        return TensorboardsApiFp(this.configuration).getTensorboard(tensorboardId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of tensorboards.
     * @param {V1GetTensorboardsRequestSortBy} [sortBy] Sort tensorboards by the given field.   - SORT_BY_UNSPECIFIED: Returns tensorboards in an unsorted list.  - SORT_BY_ID: Returns tensorboards sorted by id.  - SORT_BY_DESCRIPTION: Returns tensorboards sorted by description.  - SORT_BY_START_TIME: Return tensorboards sorted by start time.  - SORT_BY_WORKSPACE_ID: Return tensorboards sorted by workspace_id.
     * @param {V1OrderBy} [orderBy] Order tensorboards in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of tensorboards before returning results. Negative values denote number of tensorboards to skip from the end before returning results.
     * @param {number} [limit] Limit the number of tensorboards. A value of 0 denotes no limit.
     * @param {Array<string>} [users] Limit tensorboards to those that are owned by users with the specified usernames.
     * @param {Array<number>} [userIds] Limit tensorboards to those that are owned by users with the specified userIds.
     * @param {number} [workspaceId] Limit tensorboards to those that are in a specific workspace, or 0 for all accessible workspaces.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TensorboardsApi
     */
    public getTensorboards(sortBy?: V1GetTensorboardsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, users?: Array<string>, userIds?: Array<number>, workspaceId?: number, options?: any) {
        return TensorboardsApiFp(this.configuration).getTensorboards(sortBy, orderBy, offset, limit, users, userIds, workspaceId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Kill the requested tensorboard.
     * @param {string} tensorboardId The id of the tensorboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TensorboardsApi
     */
    public killTensorboard(tensorboardId: string, options?: any) {
        return TensorboardsApiFp(this.configuration).killTensorboard(tensorboardId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Launch a tensorboard.
     * @param {V1LaunchTensorboardRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TensorboardsApi
     */
    public launchTensorboard(body: V1LaunchTensorboardRequest, options?: any) {
        return TensorboardsApiFp(this.configuration).launchTensorboard(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Set the priority of the requested TensorBoard.
     * @param {string} tensorboardId The id of the TensorBoard.
     * @param {V1SetTensorboardPriorityRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TensorboardsApi
     */
    public setTensorboardPriority(tensorboardId: string, body: V1SetTensorboardPriorityRequest, options?: any) {
        return TensorboardsApiFp(this.configuration).setTensorboardPriority(tensorboardId, body, options)(this.fetch, this.basePath)
    }
    
}

/**
 * TrialsApi - fetch parameter creator
 * @export
 */
export const TrialsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the list of trials for an experiment.
         * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
         * @param {V1GetExperimentTrialsRequestSortBy} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.  - SORT_BY_RESTARTS: Return the trials sorted by the number of restarts.  - SORT_BY_CHECKPOINT_SIZE: Return the trials sorted by checkpoint size.
         * @param {V1OrderBy} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
         * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
         * @param {Array<Experimentv1State>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.  - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.  - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The experiment is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The experiment has an allocation actively running. Running is a substate of the Active state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentTrials(experimentId: number, sortBy?: V1GetExperimentTrialsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Experimentv1State>, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling getExperimentTrials.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/trials`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (states) {
                localVarQueryParameter['states'] = states
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream one or more trial's metrics.
         * @param {Array<number>} trialIds Trial IDs to get metrics for.
         * @param {string} group The group of metrics to get eg 'training', 'validation', etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(trialIds: Array<number>, group: string, options: any = {}): FetchArgs {
            // verify required parameter 'trialIds' is not null or undefined
            if (trialIds === null || trialIds === undefined) {
                throw new RequiredError('trialIds','Required parameter trialIds was null or undefined when calling getMetrics.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getMetrics.');
            }
            const localVarPath = `/api/v1/trials/metrics/trial_metrics`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (trialIds) {
                localVarQueryParameter['trialIds'] = trialIds
            }
            
            if (group !== undefined) {
                localVarQueryParameter['group'] = group
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream one or more trial's training metrics.
         * @param {Array<number>} [trialIds] Trial IDs to get metrics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingMetrics(trialIds?: Array<number>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/trials/metrics/training_metrics`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (trialIds) {
                localVarQueryParameter['trialIds'] = trialIds
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single trial.
         * @param {number} trialId The requested trial's id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrial(trialId: number, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling getTrial.');
            }
            const localVarPath = `/api/v1/trials/{trialId}`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of workloads for a trial.
         * @param {number} trialId Limit workloads to those that are owned by the specified trial.
         * @param {V1OrderBy} [orderBy] Order workloads in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of workloads before returning results. Negative values denote number of workloads to skip from the end before returning results.
         * @param {number} [limit] Limit the number of workloads. A value of 0 denotes no limit.
         * @param {string} [sortKey] Sort workloads by batches, a training metric, or a validation metric.
         * @param {GetTrialWorkloadsRequestFilterOption} [filter] Filter workloads with validation and/or checkpoint information.   - FILTER_OPTION_UNSPECIFIED: Any workload.  - FILTER_OPTION_CHECKPOINT: Only workloads with an associated checkpoint.  - FILTER_OPTION_VALIDATION: Only validation workloads.  - FILTER_OPTION_CHECKPOINT_OR_VALIDATION: Only validation workloads or ones with an associated checkpoint.
         * @param {boolean} [includeBatchMetrics] Include per-batch metrics.
         * @param {V1MetricType} [metricType] When sorting workloads by sort_key, specify training or validation form of a metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {boolean} [removeDeletedCheckpoints] Remove deleted checkpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialWorkloads(trialId: number, orderBy?: V1OrderBy, offset?: number, limit?: number, sortKey?: string, filter?: GetTrialWorkloadsRequestFilterOption, includeBatchMetrics?: boolean, metricType?: V1MetricType, group?: string, removeDeletedCheckpoints?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling getTrialWorkloads.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/workloads`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (sortKey !== undefined) {
                localVarQueryParameter['sortKey'] = sortKey
            }
            
            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter
            }
            
            if (includeBatchMetrics !== undefined) {
                localVarQueryParameter['includeBatchMetrics'] = includeBatchMetrics
            }
            
            if (metricType !== undefined) {
                localVarQueryParameter['metricType'] = metricType
            }
            
            if (group !== undefined) {
                localVarQueryParameter['group'] = group
            }
            
            if (removeDeletedCheckpoints !== undefined) {
                localVarQueryParameter['removeDeletedCheckpoints'] = removeDeletedCheckpoints
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream one or more trial's validation metrics.
         * @param {Array<number>} [trialIds] Trial IDs to get metrics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidationMetrics(trialIds?: Array<number>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/trials/metrics/validation_metrics`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (trialIds) {
                localVarQueryParameter['trialIds'] = trialIds
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill a trial.
         * @param {number} id The trial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killTrial(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling killTrial.');
            }
            const localVarPath = `/api/v1/trials/{id}/kill`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream trial logs.
         * @param {number} trialId The id of the trial.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {string} [searchText] Search the logs by whether the text contains a substring.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling trialLogs.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/logs`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow
            }
            
            if (agentIds) {
                localVarQueryParameter['agentIds'] = agentIds
            }
            
            if (containerIds) {
                localVarQueryParameter['containerIds'] = containerIds
            }
            
            if (rankIds) {
                localVarQueryParameter['rankIds'] = rankIds
            }
            
            if (levels) {
                localVarQueryParameter['levels'] = levels
            }
            
            if (stdtypes) {
                localVarQueryParameter['stdtypes'] = stdtypes
            }
            
            if (sources) {
                localVarQueryParameter['sources'] = sources
            }
            
            if (timestampBefore) {
                localVarQueryParameter['timestampBefore'] = timestampBefore.toISOString()
            }
            
            if (timestampAfter) {
                localVarQueryParameter['timestampAfter'] = timestampAfter.toISOString()
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream trial log fields.
         * @param {number} trialId The ID of the trial.
         * @param {boolean} [follow] Continue following fields until the trial stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialLogsFields(trialId: number, follow?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling trialLogsFields.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/logs/fields`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrialsApi - functional programming interface
 * @export
 */
export const TrialsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the list of trials for an experiment.
         * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
         * @param {V1GetExperimentTrialsRequestSortBy} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.  - SORT_BY_RESTARTS: Return the trials sorted by the number of restarts.  - SORT_BY_CHECKPOINT_SIZE: Return the trials sorted by checkpoint size.
         * @param {V1OrderBy} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
         * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
         * @param {Array<Experimentv1State>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.  - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.  - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The experiment is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The experiment has an allocation actively running. Running is a substate of the Active state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentTrials(experimentId: number, sortBy?: V1GetExperimentTrialsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Experimentv1State>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentTrialsResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).getExperimentTrials(experimentId, sortBy, orderBy, offset, limit, states, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream one or more trial's metrics.
         * @param {Array<number>} trialIds Trial IDs to get metrics for.
         * @param {string} group The group of metrics to get eg 'training', 'validation', etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(trialIds: Array<number>, group: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1GetMetricsResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).getMetrics(trialIds, group, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream one or more trial's training metrics.
         * @param {Array<number>} [trialIds] Trial IDs to get metrics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingMetrics(trialIds?: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1GetTrainingMetricsResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).getTrainingMetrics(trialIds, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a single trial.
         * @param {number} trialId The requested trial's id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrial(trialId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTrialResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).getTrial(trialId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of workloads for a trial.
         * @param {number} trialId Limit workloads to those that are owned by the specified trial.
         * @param {V1OrderBy} [orderBy] Order workloads in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of workloads before returning results. Negative values denote number of workloads to skip from the end before returning results.
         * @param {number} [limit] Limit the number of workloads. A value of 0 denotes no limit.
         * @param {string} [sortKey] Sort workloads by batches, a training metric, or a validation metric.
         * @param {GetTrialWorkloadsRequestFilterOption} [filter] Filter workloads with validation and/or checkpoint information.   - FILTER_OPTION_UNSPECIFIED: Any workload.  - FILTER_OPTION_CHECKPOINT: Only workloads with an associated checkpoint.  - FILTER_OPTION_VALIDATION: Only validation workloads.  - FILTER_OPTION_CHECKPOINT_OR_VALIDATION: Only validation workloads or ones with an associated checkpoint.
         * @param {boolean} [includeBatchMetrics] Include per-batch metrics.
         * @param {V1MetricType} [metricType] When sorting workloads by sort_key, specify training or validation form of a metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {boolean} [removeDeletedCheckpoints] Remove deleted checkpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialWorkloads(trialId: number, orderBy?: V1OrderBy, offset?: number, limit?: number, sortKey?: string, filter?: GetTrialWorkloadsRequestFilterOption, includeBatchMetrics?: boolean, metricType?: V1MetricType, group?: string, removeDeletedCheckpoints?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTrialWorkloadsResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).getTrialWorkloads(trialId, orderBy, offset, limit, sortKey, filter, includeBatchMetrics, metricType, group, removeDeletedCheckpoints, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream one or more trial's validation metrics.
         * @param {Array<number>} [trialIds] Trial IDs to get metrics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidationMetrics(trialIds?: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1GetValidationMetricsResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).getValidationMetrics(trialIds, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill a trial.
         * @param {number} id The trial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killTrial(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillTrialResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).killTrial(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream trial logs.
         * @param {number} trialId The id of the trial.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {string} [searchText] Search the logs by whether the text contains a substring.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TrialLogsResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).trialLogs(trialId, limit, follow, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, searchText, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream trial log fields.
         * @param {number} trialId The ID of the trial.
         * @param {boolean} [follow] Continue following fields until the trial stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialLogsFields(trialId: number, follow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TrialLogsFieldsResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).trialLogsFields(trialId, follow, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TrialsApi - factory interface
 * @export
 */
export const TrialsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the list of trials for an experiment.
         * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
         * @param {V1GetExperimentTrialsRequestSortBy} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.  - SORT_BY_RESTARTS: Return the trials sorted by the number of restarts.  - SORT_BY_CHECKPOINT_SIZE: Return the trials sorted by checkpoint size.
         * @param {V1OrderBy} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
         * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
         * @param {Array<Experimentv1State>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.  - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.  - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The experiment is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The experiment has an allocation actively running. Running is a substate of the Active state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentTrials(experimentId: number, sortBy?: V1GetExperimentTrialsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Experimentv1State>, options?: any) {
            return TrialsApiFp(configuration).getExperimentTrials(experimentId, sortBy, orderBy, offset, limit, states, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream one or more trial's metrics.
         * @param {Array<number>} trialIds Trial IDs to get metrics for.
         * @param {string} group The group of metrics to get eg 'training', 'validation', etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(trialIds: Array<number>, group: string, options?: any) {
            return TrialsApiFp(configuration).getMetrics(trialIds, group, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream one or more trial's training metrics.
         * @param {Array<number>} [trialIds] Trial IDs to get metrics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingMetrics(trialIds?: Array<number>, options?: any) {
            return TrialsApiFp(configuration).getTrainingMetrics(trialIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single trial.
         * @param {number} trialId The requested trial's id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrial(trialId: number, options?: any) {
            return TrialsApiFp(configuration).getTrial(trialId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of workloads for a trial.
         * @param {number} trialId Limit workloads to those that are owned by the specified trial.
         * @param {V1OrderBy} [orderBy] Order workloads in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of workloads before returning results. Negative values denote number of workloads to skip from the end before returning results.
         * @param {number} [limit] Limit the number of workloads. A value of 0 denotes no limit.
         * @param {string} [sortKey] Sort workloads by batches, a training metric, or a validation metric.
         * @param {GetTrialWorkloadsRequestFilterOption} [filter] Filter workloads with validation and/or checkpoint information.   - FILTER_OPTION_UNSPECIFIED: Any workload.  - FILTER_OPTION_CHECKPOINT: Only workloads with an associated checkpoint.  - FILTER_OPTION_VALIDATION: Only validation workloads.  - FILTER_OPTION_CHECKPOINT_OR_VALIDATION: Only validation workloads or ones with an associated checkpoint.
         * @param {boolean} [includeBatchMetrics] Include per-batch metrics.
         * @param {V1MetricType} [metricType] When sorting workloads by sort_key, specify training or validation form of a metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {string} [group] Metric group (training, validation, etc).
         * @param {boolean} [removeDeletedCheckpoints] Remove deleted checkpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialWorkloads(trialId: number, orderBy?: V1OrderBy, offset?: number, limit?: number, sortKey?: string, filter?: GetTrialWorkloadsRequestFilterOption, includeBatchMetrics?: boolean, metricType?: V1MetricType, group?: string, removeDeletedCheckpoints?: boolean, options?: any) {
            return TrialsApiFp(configuration).getTrialWorkloads(trialId, orderBy, offset, limit, sortKey, filter, includeBatchMetrics, metricType, group, removeDeletedCheckpoints, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream one or more trial's validation metrics.
         * @param {Array<number>} [trialIds] Trial IDs to get metrics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidationMetrics(trialIds?: Array<number>, options?: any) {
            return TrialsApiFp(configuration).getValidationMetrics(trialIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill a trial.
         * @param {number} id The trial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        killTrial(id: number, options?: any) {
            return TrialsApiFp(configuration).killTrial(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream trial logs.
         * @param {number} trialId The id of the trial.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {string} [searchText] Search the logs by whether the text contains a substring.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options?: any) {
            return TrialsApiFp(configuration).trialLogs(trialId, limit, follow, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, searchText, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream trial log fields.
         * @param {number} trialId The ID of the trial.
         * @param {boolean} [follow] Continue following fields until the trial stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trialLogsFields(trialId: number, follow?: boolean, options?: any) {
            return TrialsApiFp(configuration).trialLogsFields(trialId, follow, options)(fetch, basePath);
        },
    }
};

/**
 * TrialsApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class TrialsApi extends BaseAPI {
    /**
     * 
     * @summary Get the list of trials for an experiment.
     * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
     * @param {V1GetExperimentTrialsRequestSortBy} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.  - SORT_BY_RESTARTS: Return the trials sorted by the number of restarts.  - SORT_BY_CHECKPOINT_SIZE: Return the trials sorted by checkpoint size.
     * @param {V1OrderBy} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
     * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
     * @param {Array<Experimentv1State>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.  - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.  - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued). Queued is a substate of the Active state.  - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active state.  - STATE_STARTING: The experiment is preparing the environment after finishing pulling the image. Starting is a substate of the Active state.  - STATE_RUNNING: The experiment has an allocation actively running. Running is a substate of the Active state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public getExperimentTrials(experimentId: number, sortBy?: V1GetExperimentTrialsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, states?: Array<Experimentv1State>, options?: any) {
        return TrialsApiFp(this.configuration).getExperimentTrials(experimentId, sortBy, orderBy, offset, limit, states, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Stream one or more trial's metrics.
     * @param {Array<number>} trialIds Trial IDs to get metrics for.
     * @param {string} group The group of metrics to get eg 'training', 'validation', etc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public getMetrics(trialIds: Array<number>, group: string, options?: any) {
        return TrialsApiFp(this.configuration).getMetrics(trialIds, group, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Stream one or more trial's training metrics.
     * @param {Array<number>} [trialIds] Trial IDs to get metrics for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public getTrainingMetrics(trialIds?: Array<number>, options?: any) {
        return TrialsApiFp(this.configuration).getTrainingMetrics(trialIds, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a single trial.
     * @param {number} trialId The requested trial's id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public getTrial(trialId: number, options?: any) {
        return TrialsApiFp(this.configuration).getTrial(trialId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the list of workloads for a trial.
     * @param {number} trialId Limit workloads to those that are owned by the specified trial.
     * @param {V1OrderBy} [orderBy] Order workloads in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of workloads before returning results. Negative values denote number of workloads to skip from the end before returning results.
     * @param {number} [limit] Limit the number of workloads. A value of 0 denotes no limit.
     * @param {string} [sortKey] Sort workloads by batches, a training metric, or a validation metric.
     * @param {GetTrialWorkloadsRequestFilterOption} [filter] Filter workloads with validation and/or checkpoint information.   - FILTER_OPTION_UNSPECIFIED: Any workload.  - FILTER_OPTION_CHECKPOINT: Only workloads with an associated checkpoint.  - FILTER_OPTION_VALIDATION: Only validation workloads.  - FILTER_OPTION_CHECKPOINT_OR_VALIDATION: Only validation workloads or ones with an associated checkpoint.
     * @param {boolean} [includeBatchMetrics] Include per-batch metrics.
     * @param {V1MetricType} [metricType] When sorting workloads by sort_key, specify training or validation form of a metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
     * @param {string} [group] Metric group (training, validation, etc).
     * @param {boolean} [removeDeletedCheckpoints] Remove deleted checkpoints.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public getTrialWorkloads(trialId: number, orderBy?: V1OrderBy, offset?: number, limit?: number, sortKey?: string, filter?: GetTrialWorkloadsRequestFilterOption, includeBatchMetrics?: boolean, metricType?: V1MetricType, group?: string, removeDeletedCheckpoints?: boolean, options?: any) {
        return TrialsApiFp(this.configuration).getTrialWorkloads(trialId, orderBy, offset, limit, sortKey, filter, includeBatchMetrics, metricType, group, removeDeletedCheckpoints, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Stream one or more trial's validation metrics.
     * @param {Array<number>} [trialIds] Trial IDs to get metrics for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public getValidationMetrics(trialIds?: Array<number>, options?: any) {
        return TrialsApiFp(this.configuration).getValidationMetrics(trialIds, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Kill a trial.
     * @param {number} id The trial id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public killTrial(id: number, options?: any) {
        return TrialsApiFp(this.configuration).killTrial(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Stream trial logs.
     * @param {number} trialId The id of the trial.
     * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
     * @param {boolean} [follow] Continue following logs until the trial stops.
     * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
     * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
     * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
     * @param {Array<V1LogLevel>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
     * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
     * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
     * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
     * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
     * @param {V1OrderBy} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {string} [searchText] Search the logs by whether the text contains a substring.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public trialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<V1LogLevel>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: V1OrderBy, searchText?: string, options?: any) {
        return TrialsApiFp(this.configuration).trialLogs(trialId, limit, follow, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, searchText, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Stream trial log fields.
     * @param {number} trialId The ID of the trial.
     * @param {boolean} [follow] Continue following fields until the trial stops.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public trialLogsFields(trialId: number, follow?: boolean, options?: any) {
        return TrialsApiFp(this.configuration).trialLogsFields(trialId, follow, options)(this.fetch, this.basePath)
    }
    
}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/me`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested user.
         * @param {number} userId The id of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUser.');
            }
            const localVarPath = `/api/v1/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested user with username.
         * @param {string} username The string of the username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(username: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling getUserByUsername.');
            }
            const localVarPath = `/api/v1/users/{username}/by-username`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of users.
         * @param {V1GetUsersRequestSortBy} [sortBy] Sort users by the given field.   - SORT_BY_UNSPECIFIED: Returns users in an unsorted list.  - SORT_BY_DISPLAY_NAME: Returns users sorted by display name.  - SORT_BY_USER_NAME: Returns users sorted by user name.  - SORT_BY_ADMIN: Returns users sorted by if they are admin.  - SORT_BY_ACTIVE: Returns users sorted by if they are active.  - SORT_BY_MODIFIED_TIME: Returns users sorted by modified time.  - SORT_BY_NAME: Returns users sorted by username unless display name exist.
         * @param {V1OrderBy} [orderBy] Order users in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of projects before returning results. Negative values denote number of projects to skip from the end before returning results.
         * @param {number} [limit] Limit the number of projects. A value of 0 denotes no limit.
         * @param {string} [name] Filter by username or display name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(sortBy?: V1GetUsersRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (name !== undefined) {
                localVarQueryParameter['name'] = name
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user's settings for website
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSetting(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users/setting`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a user's fields.
         * @param {number} userId The id of the user.
         * @param {V1PatchUser} body The updated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUser(userId: number, body: V1PatchUser, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling patchUser.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchUser.');
            }
            const localVarPath = `/api/v1/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PATCH', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user.
         * @param {V1PostUserRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser(body: V1PostUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postUser.');
            }
            const localVarPath = `/api/v1/users`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a user's activity
         * @param {V1PostUserActivityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserActivity(body: V1PostUserActivityRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postUserActivity.');
            }
            const localVarPath = `/api/v1/users/activity`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post a user's settings for website
         * @param {V1PostUserSettingRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSetting(body: V1PostUserSettingRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postUserSetting.');
            }
            const localVarPath = `/api/v1/users/setting`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset a user's settings for website
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserSetting(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users/setting/reset`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the requested user's password.
         * @param {number} userId The id of the user.
         * @param {string} body The password of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPassword(userId: number, body: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setUserPassword.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setUserPassword.');
            }
            const localVarPath = `/api/v1/users/{userId}/password`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body) : body
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetMeResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getMe(options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested user.
         * @param {number} userId The id of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetUserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUser(userId, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested user with username.
         * @param {string} username The string of the username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetUserByUsernameResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserByUsername(username, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of users.
         * @param {V1GetUsersRequestSortBy} [sortBy] Sort users by the given field.   - SORT_BY_UNSPECIFIED: Returns users in an unsorted list.  - SORT_BY_DISPLAY_NAME: Returns users sorted by display name.  - SORT_BY_USER_NAME: Returns users sorted by user name.  - SORT_BY_ADMIN: Returns users sorted by if they are admin.  - SORT_BY_ACTIVE: Returns users sorted by if they are active.  - SORT_BY_MODIFIED_TIME: Returns users sorted by modified time.  - SORT_BY_NAME: Returns users sorted by username unless display name exist.
         * @param {V1OrderBy} [orderBy] Order users in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of projects before returning results. Negative values denote number of projects to skip from the end before returning results.
         * @param {number} [limit] Limit the number of projects. A value of 0 denotes no limit.
         * @param {string} [name] Filter by username or display name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(sortBy?: V1GetUsersRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetUsersResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUsers(sortBy, orderBy, offset, limit, name, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a user's settings for website
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSetting(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetUserSettingResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserSetting(options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch a user's fields.
         * @param {number} userId The id of the user.
         * @param {V1PatchUser} body The updated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUser(userId: number, body: V1PatchUser, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PatchUserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).patchUser(userId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new user.
         * @param {V1PostUserRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser(body: V1PostUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostUserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUser(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch a user's activity
         * @param {V1PostUserActivityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserActivity(body: V1PostUserActivityRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostUserActivityResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUserActivity(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Post a user's settings for website
         * @param {V1PostUserSettingRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSetting(body: V1PostUserSettingRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostUserSettingResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUserSetting(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reset a user's settings for website
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserSetting(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ResetUserSettingResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).resetUserSetting(options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the requested user's password.
         * @param {number} userId The id of the user.
         * @param {string} body The password of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPassword(userId: number, body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SetUserPasswordResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).setUserPassword(userId, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any) {
            return UsersApiFp(configuration).getMe(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested user.
         * @param {number} userId The id of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: number, options?: any) {
            return UsersApiFp(configuration).getUser(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested user with username.
         * @param {string} username The string of the username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(username: string, options?: any) {
            return UsersApiFp(configuration).getUserByUsername(username, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of users.
         * @param {V1GetUsersRequestSortBy} [sortBy] Sort users by the given field.   - SORT_BY_UNSPECIFIED: Returns users in an unsorted list.  - SORT_BY_DISPLAY_NAME: Returns users sorted by display name.  - SORT_BY_USER_NAME: Returns users sorted by user name.  - SORT_BY_ADMIN: Returns users sorted by if they are admin.  - SORT_BY_ACTIVE: Returns users sorted by if they are active.  - SORT_BY_MODIFIED_TIME: Returns users sorted by modified time.  - SORT_BY_NAME: Returns users sorted by username unless display name exist.
         * @param {V1OrderBy} [orderBy] Order users in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of projects before returning results. Negative values denote number of projects to skip from the end before returning results.
         * @param {number} [limit] Limit the number of projects. A value of 0 denotes no limit.
         * @param {string} [name] Filter by username or display name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(sortBy?: V1GetUsersRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, options?: any) {
            return UsersApiFp(configuration).getUsers(sortBy, orderBy, offset, limit, name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a user's settings for website
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSetting(options?: any) {
            return UsersApiFp(configuration).getUserSetting(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch a user's fields.
         * @param {number} userId The id of the user.
         * @param {V1PatchUser} body The updated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUser(userId: number, body: V1PatchUser, options?: any) {
            return UsersApiFp(configuration).patchUser(userId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new user.
         * @param {V1PostUserRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser(body: V1PostUserRequest, options?: any) {
            return UsersApiFp(configuration).postUser(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch a user's activity
         * @param {V1PostUserActivityRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserActivity(body: V1PostUserActivityRequest, options?: any) {
            return UsersApiFp(configuration).postUserActivity(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Post a user's settings for website
         * @param {V1PostUserSettingRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSetting(body: V1PostUserSettingRequest, options?: any) {
            return UsersApiFp(configuration).postUserSetting(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset a user's settings for website
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserSetting(options?: any) {
            return UsersApiFp(configuration).resetUserSetting(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the requested user's password.
         * @param {number} userId The id of the user.
         * @param {string} body The password of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPassword(userId: number, body: string, options?: any) {
            return UsersApiFp(configuration).setUserPassword(userId, body, options)(fetch, basePath);
        },
    }
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Get the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getMe(options?: any) {
        return UsersApiFp(this.configuration).getMe(options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the requested user.
     * @param {number} userId The id of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userId: number, options?: any) {
        return UsersApiFp(this.configuration).getUser(userId, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the requested user with username.
     * @param {string} username The string of the username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByUsername(username: string, options?: any) {
        return UsersApiFp(this.configuration).getUserByUsername(username, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of users.
     * @param {V1GetUsersRequestSortBy} [sortBy] Sort users by the given field.   - SORT_BY_UNSPECIFIED: Returns users in an unsorted list.  - SORT_BY_DISPLAY_NAME: Returns users sorted by display name.  - SORT_BY_USER_NAME: Returns users sorted by user name.  - SORT_BY_ADMIN: Returns users sorted by if they are admin.  - SORT_BY_ACTIVE: Returns users sorted by if they are active.  - SORT_BY_MODIFIED_TIME: Returns users sorted by modified time.  - SORT_BY_NAME: Returns users sorted by username unless display name exist.
     * @param {V1OrderBy} [orderBy] Order users in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of projects before returning results. Negative values denote number of projects to skip from the end before returning results.
     * @param {number} [limit] Limit the number of projects. A value of 0 denotes no limit.
     * @param {string} [name] Filter by username or display name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(sortBy?: V1GetUsersRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsers(sortBy, orderBy, offset, limit, name, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a user's settings for website
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserSetting(options?: any) {
        return UsersApiFp(this.configuration).getUserSetting(options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Patch a user's fields.
     * @param {number} userId The id of the user.
     * @param {V1PatchUser} body The updated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public patchUser(userId: number, body: V1PatchUser, options?: any) {
        return UsersApiFp(this.configuration).patchUser(userId, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Create a new user.
     * @param {V1PostUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUser(body: V1PostUserRequest, options?: any) {
        return UsersApiFp(this.configuration).postUser(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Patch a user's activity
     * @param {V1PostUserActivityRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUserActivity(body: V1PostUserActivityRequest, options?: any) {
        return UsersApiFp(this.configuration).postUserActivity(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Post a user's settings for website
     * @param {V1PostUserSettingRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUserSetting(body: V1PostUserSettingRequest, options?: any) {
        return UsersApiFp(this.configuration).postUserSetting(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Reset a user's settings for website
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resetUserSetting(options?: any) {
        return UsersApiFp(this.configuration).resetUserSetting(options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Set the requested user's password.
     * @param {number} userId The id of the user.
     * @param {string} body The password of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setUserPassword(userId: number, body: string, options?: any) {
        return UsersApiFp(this.configuration).setUserPassword(userId, body, options)(this.fetch, this.basePath)
    }
    
}

/**
 * WebhooksApi - fetch parameter creator
 * @export
 */
export const WebhooksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a webhook.
         * @param {number} id The id of the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteWebhook.');
            }
            const localVarPath = `/api/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'DELETE', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of webhooks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/webhooks`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a webhook. TODO(???): Simplify req/response structs?
         * @param {V1Webhook} body The webhook to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(body: V1Webhook, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postWebhook.');
            }
            const localVarPath = `/api/v1/webhooks`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test a webhook.
         * @param {number} id The id of the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testWebhook(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling testWebhook.');
            }
            const localVarPath = `/api/v1/webhooks/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a webhook.
         * @param {number} id The id of the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeleteWebhookResponse> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).deleteWebhook(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of webhooks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetWebhooksResponse> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).getWebhooks(options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a webhook. TODO(???): Simplify req/response structs?
         * @param {V1Webhook} body The webhook to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(body: V1Webhook, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostWebhookResponse> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).postWebhook(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Test a webhook.
         * @param {number} id The id of the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testWebhook(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1TestWebhookResponse> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).testWebhook(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete a webhook.
         * @param {number} id The id of the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id: number, options?: any) {
            return WebhooksApiFp(configuration).deleteWebhook(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of webhooks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options?: any) {
            return WebhooksApiFp(configuration).getWebhooks(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a webhook. TODO(???): Simplify req/response structs?
         * @param {V1Webhook} body The webhook to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(body: V1Webhook, options?: any) {
            return WebhooksApiFp(configuration).postWebhook(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Test a webhook.
         * @param {number} id The id of the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testWebhook(id: number, options?: any) {
            return WebhooksApiFp(configuration).testWebhook(id, options)(fetch, basePath);
        },
    }
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * 
     * @summary Delete a webhook.
     * @param {number} id The id of the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(id: number, options?: any) {
        return WebhooksApiFp(this.configuration).deleteWebhook(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of webhooks.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhooks(options?: any) {
        return WebhooksApiFp(this.configuration).getWebhooks(options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Create a webhook. TODO(???): Simplify req/response structs?
     * @param {V1Webhook} body The webhook to store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public postWebhook(body: V1Webhook, options?: any) {
        return WebhooksApiFp(this.configuration).postWebhook(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Test a webhook.
     * @param {number} id The id of the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public testWebhook(id: number, options?: any) {
        return WebhooksApiFp(this.configuration).testWebhook(id, options)(this.fetch, this.basePath)
    }
    
}

/**
 * WorkspacesApi - fetch parameter creator
 * @export
 */
export const WorkspacesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveWorkspace(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling archiveWorkspace.');
            }
            const localVarPath = `/api/v1/workspaces/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteWorkspace.');
            }
            const localVarPath = `/api/v1/workspaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'DELETE', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getWorkspace.');
            }
            const localVarPath = `/api/v1/workspaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get projects associated with a workspace.
         * @param {number} id The id of the workspace. When id is set to 0, return all projects across the all workspaces.
         * @param {V1GetWorkspaceProjectsRequestSortBy} [sortBy] Sort the projects by the given field.   - SORT_BY_UNSPECIFIED: Returns projects in an unsorted list.  - SORT_BY_CREATION_TIME: Returns projects sorted by time that they were created.  - SORT_BY_LAST_EXPERIMENT_START_TIME: Returns projects sorted by most recent start of an experiment.  - SORT_BY_NAME: Returns projects sorted by name.  - SORT_BY_DESCRIPTION: Returns projects sorted by description.  - SORT_BY_ID: Returns projects sorted by ID.
         * @param {V1OrderBy} [orderBy] Order projects in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of projects before returning results. Negative values denote number of projects to skip from the end before returning results.
         * @param {number} [limit] Limit the number of projects. A value of 0 denotes no limit.
         * @param {string} [name] Limit the projects to those matching the name.
         * @param {boolean} [archived] Limit the projects to those with an archived status.
         * @param {Array<string>} [users] Limit the projects to those from particular users, by usernames.
         * @param {Array<number>} [userIds] Limit the projects to those from particular users, by userIds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceProjects(id: number, sortBy?: V1GetWorkspaceProjectsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, archived?: boolean, users?: Array<string>, userIds?: Array<number>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getWorkspaceProjects.');
            }
            const localVarPath = `/api/v1/workspaces/{id}/projects`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (name !== undefined) {
                localVarQueryParameter['name'] = name
            }
            
            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived
            }
            
            if (users) {
                localVarQueryParameter['users'] = users
            }
            
            if (userIds) {
                localVarQueryParameter['userIds'] = userIds
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of workspaces.
         * @param {V1GetWorkspacesRequestSortBy} [sortBy] Sort the workspaces by the given field.   - SORT_BY_UNSPECIFIED: Returns workspaces in an unsorted list.  - SORT_BY_ID: Returns workspaces sorted by id.  - SORT_BY_NAME: Returns workspaces sorted by name.
         * @param {V1OrderBy} [orderBy] Order workspaces in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of workspaces before returning results. Negative values denote number of workspaces to skip from the end before returning results.
         * @param {number} [limit] Limit the number of workspaces. A value of 0 denotes no limit.
         * @param {string} [name] Limit the workspaces to those matching the name (case insensitive).
         * @param {boolean} [archived] Limit the workspaces to those with an archived status.
         * @param {Array<string>} [users] Limit the workspaces to those from particular users, by usernames.
         * @param {Array<number>} [userIds] Limit the workspaces to those from particular users, by userIds.
         * @param {boolean} [pinned] Limit the workspaces to those with pinned status by the current user.
         * @param {string} [nameCaseSensitive] Limit the workspaces to those matching the name (case sensitive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaces(sortBy?: V1GetWorkspacesRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, archived?: boolean, users?: Array<string>, userIds?: Array<number>, pinned?: boolean, nameCaseSensitive?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/workspaces`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy
            }
            
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            if (name !== undefined) {
                localVarQueryParameter['name'] = name
            }
            
            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived
            }
            
            if (users) {
                localVarQueryParameter['users'] = users
            }
            
            if (userIds) {
                localVarQueryParameter['userIds'] = userIds
            }
            
            if (pinned !== undefined) {
                localVarQueryParameter['pinned'] = pinned
            }
            
            if (nameCaseSensitive !== undefined) {
                localVarQueryParameter['nameCaseSensitive'] = nameCaseSensitive
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all resource pools, bound and unbound, available to a specific workspace
         * @param {number} workspaceId Workspace ID.
         * @param {number} [offset] The offset to use with pagination.
         * @param {number} [limit] The maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRPsBoundToWorkspace(workspaceId: number, offset?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError('workspaceId','Required parameter workspaceId was null or undefined when calling listRPsBoundToWorkspace.');
            }
            const localVarPath = `/api/v1/workspaces/{workspaceId}/available-resource-pools`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'GET', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset
            }
            
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workspace.
         * @param {number} id The id of the workspace.
         * @param {V1PatchWorkspace} body The desired workspace fields and values to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkspace(id: number, body: V1PatchWorkspace, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patchWorkspace.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchWorkspace.');
            }
            const localVarPath = `/api/v1/workspaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'PATCH', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pin a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinWorkspace(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pinWorkspace.');
            }
            const localVarPath = `/api/v1/workspaces/{id}/pin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a workspace.
         * @param {V1PostWorkspaceRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkspace(body: V1PostWorkspaceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postWorkspace.');
            }
            const localVarPath = `/api/v1/workspaces`;
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            localVarHeaderParameter['Content-Type'] = 'application/json';
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.body = JSON.stringify(body)
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unarchive a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveWorkspace(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unarchiveWorkspace.');
            }
            const localVarPath = `/api/v1/workspaces/{id}/unarchive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unpin a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinWorkspace(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unpinWorkspace.');
            }
            const localVarPath = `/api/v1/workspaces/{id}/unpin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = new URL(localVarPath, BASE_PATH);
            const localVarRequestOptions = { method: 'POST', ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            
            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            
            objToSearchParams(localVarQueryParameter, localVarUrlObj.searchParams);
            objToSearchParams(options.query || {}, localVarUrlObj.searchParams);
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            
            return {
                url: `${localVarUrlObj.pathname}${localVarUrlObj.search}`,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveWorkspace(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArchiveWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).archiveWorkspace(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeleteWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).deleteWorkspace(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).getWorkspace(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get projects associated with a workspace.
         * @param {number} id The id of the workspace. When id is set to 0, return all projects across the all workspaces.
         * @param {V1GetWorkspaceProjectsRequestSortBy} [sortBy] Sort the projects by the given field.   - SORT_BY_UNSPECIFIED: Returns projects in an unsorted list.  - SORT_BY_CREATION_TIME: Returns projects sorted by time that they were created.  - SORT_BY_LAST_EXPERIMENT_START_TIME: Returns projects sorted by most recent start of an experiment.  - SORT_BY_NAME: Returns projects sorted by name.  - SORT_BY_DESCRIPTION: Returns projects sorted by description.  - SORT_BY_ID: Returns projects sorted by ID.
         * @param {V1OrderBy} [orderBy] Order projects in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of projects before returning results. Negative values denote number of projects to skip from the end before returning results.
         * @param {number} [limit] Limit the number of projects. A value of 0 denotes no limit.
         * @param {string} [name] Limit the projects to those matching the name.
         * @param {boolean} [archived] Limit the projects to those with an archived status.
         * @param {Array<string>} [users] Limit the projects to those from particular users, by usernames.
         * @param {Array<number>} [userIds] Limit the projects to those from particular users, by userIds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceProjects(id: number, sortBy?: V1GetWorkspaceProjectsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, archived?: boolean, users?: Array<string>, userIds?: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetWorkspaceProjectsResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).getWorkspaceProjects(id, sortBy, orderBy, offset, limit, name, archived, users, userIds, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of workspaces.
         * @param {V1GetWorkspacesRequestSortBy} [sortBy] Sort the workspaces by the given field.   - SORT_BY_UNSPECIFIED: Returns workspaces in an unsorted list.  - SORT_BY_ID: Returns workspaces sorted by id.  - SORT_BY_NAME: Returns workspaces sorted by name.
         * @param {V1OrderBy} [orderBy] Order workspaces in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of workspaces before returning results. Negative values denote number of workspaces to skip from the end before returning results.
         * @param {number} [limit] Limit the number of workspaces. A value of 0 denotes no limit.
         * @param {string} [name] Limit the workspaces to those matching the name (case insensitive).
         * @param {boolean} [archived] Limit the workspaces to those with an archived status.
         * @param {Array<string>} [users] Limit the workspaces to those from particular users, by usernames.
         * @param {Array<number>} [userIds] Limit the workspaces to those from particular users, by userIds.
         * @param {boolean} [pinned] Limit the workspaces to those with pinned status by the current user.
         * @param {string} [nameCaseSensitive] Limit the workspaces to those matching the name (case sensitive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaces(sortBy?: V1GetWorkspacesRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, archived?: boolean, users?: Array<string>, userIds?: Array<number>, pinned?: boolean, nameCaseSensitive?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetWorkspacesResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).getWorkspaces(sortBy, orderBy, offset, limit, name, archived, users, userIds, pinned, nameCaseSensitive, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all resource pools, bound and unbound, available to a specific workspace
         * @param {number} workspaceId Workspace ID.
         * @param {number} [offset] The offset to use with pagination.
         * @param {number} [limit] The maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRPsBoundToWorkspace(workspaceId: number, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRPsBoundToWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).listRPsBoundToWorkspace(workspaceId, offset, limit, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a workspace.
         * @param {number} id The id of the workspace.
         * @param {V1PatchWorkspace} body The desired workspace fields and values to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkspace(id: number, body: V1PatchWorkspace, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PatchWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).patchWorkspace(id, body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Pin a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinWorkspace(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PinWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).pinWorkspace(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a workspace.
         * @param {V1PostWorkspaceRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkspace(body: V1PostWorkspaceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).postWorkspace(body, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unarchive a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveWorkspace(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UnarchiveWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).unarchiveWorkspace(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unpin a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinWorkspace(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UnpinWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).unpinWorkspace(id, options);
            return (fetch: FetchAPI = window.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Archive a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveWorkspace(id: number, options?: any) {
            return WorkspacesApiFp(configuration).archiveWorkspace(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(id: number, options?: any) {
            return WorkspacesApiFp(configuration).deleteWorkspace(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(id: number, options?: any) {
            return WorkspacesApiFp(configuration).getWorkspace(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get projects associated with a workspace.
         * @param {number} id The id of the workspace. When id is set to 0, return all projects across the all workspaces.
         * @param {V1GetWorkspaceProjectsRequestSortBy} [sortBy] Sort the projects by the given field.   - SORT_BY_UNSPECIFIED: Returns projects in an unsorted list.  - SORT_BY_CREATION_TIME: Returns projects sorted by time that they were created.  - SORT_BY_LAST_EXPERIMENT_START_TIME: Returns projects sorted by most recent start of an experiment.  - SORT_BY_NAME: Returns projects sorted by name.  - SORT_BY_DESCRIPTION: Returns projects sorted by description.  - SORT_BY_ID: Returns projects sorted by ID.
         * @param {V1OrderBy} [orderBy] Order projects in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of projects before returning results. Negative values denote number of projects to skip from the end before returning results.
         * @param {number} [limit] Limit the number of projects. A value of 0 denotes no limit.
         * @param {string} [name] Limit the projects to those matching the name.
         * @param {boolean} [archived] Limit the projects to those with an archived status.
         * @param {Array<string>} [users] Limit the projects to those from particular users, by usernames.
         * @param {Array<number>} [userIds] Limit the projects to those from particular users, by userIds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceProjects(id: number, sortBy?: V1GetWorkspaceProjectsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, archived?: boolean, users?: Array<string>, userIds?: Array<number>, options?: any) {
            return WorkspacesApiFp(configuration).getWorkspaceProjects(id, sortBy, orderBy, offset, limit, name, archived, users, userIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of workspaces.
         * @param {V1GetWorkspacesRequestSortBy} [sortBy] Sort the workspaces by the given field.   - SORT_BY_UNSPECIFIED: Returns workspaces in an unsorted list.  - SORT_BY_ID: Returns workspaces sorted by id.  - SORT_BY_NAME: Returns workspaces sorted by name.
         * @param {V1OrderBy} [orderBy] Order workspaces in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of workspaces before returning results. Negative values denote number of workspaces to skip from the end before returning results.
         * @param {number} [limit] Limit the number of workspaces. A value of 0 denotes no limit.
         * @param {string} [name] Limit the workspaces to those matching the name (case insensitive).
         * @param {boolean} [archived] Limit the workspaces to those with an archived status.
         * @param {Array<string>} [users] Limit the workspaces to those from particular users, by usernames.
         * @param {Array<number>} [userIds] Limit the workspaces to those from particular users, by userIds.
         * @param {boolean} [pinned] Limit the workspaces to those with pinned status by the current user.
         * @param {string} [nameCaseSensitive] Limit the workspaces to those matching the name (case sensitive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaces(sortBy?: V1GetWorkspacesRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, archived?: boolean, users?: Array<string>, userIds?: Array<number>, pinned?: boolean, nameCaseSensitive?: string, options?: any) {
            return WorkspacesApiFp(configuration).getWorkspaces(sortBy, orderBy, offset, limit, name, archived, users, userIds, pinned, nameCaseSensitive, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all resource pools, bound and unbound, available to a specific workspace
         * @param {number} workspaceId Workspace ID.
         * @param {number} [offset] The offset to use with pagination.
         * @param {number} [limit] The maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRPsBoundToWorkspace(workspaceId: number, offset?: number, limit?: number, options?: any) {
            return WorkspacesApiFp(configuration).listRPsBoundToWorkspace(workspaceId, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a workspace.
         * @param {number} id The id of the workspace.
         * @param {V1PatchWorkspace} body The desired workspace fields and values to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkspace(id: number, body: V1PatchWorkspace, options?: any) {
            return WorkspacesApiFp(configuration).patchWorkspace(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Pin a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinWorkspace(id: number, options?: any) {
            return WorkspacesApiFp(configuration).pinWorkspace(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a workspace.
         * @param {V1PostWorkspaceRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkspace(body: V1PostWorkspaceRequest, options?: any) {
            return WorkspacesApiFp(configuration).postWorkspace(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unarchive a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveWorkspace(id: number, options?: any) {
            return WorkspacesApiFp(configuration).unarchiveWorkspace(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unpin a workspace.
         * @param {number} id The id of the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinWorkspace(id: number, options?: any) {
            return WorkspacesApiFp(configuration).unpinWorkspace(id, options)(fetch, basePath);
        },
    }
};

/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI {
    /**
     * 
     * @summary Archive a workspace.
     * @param {number} id The id of the workspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public archiveWorkspace(id: number, options?: any) {
        return WorkspacesApiFp(this.configuration).archiveWorkspace(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Delete a workspace.
     * @param {number} id The id of the workspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public deleteWorkspace(id: number, options?: any) {
        return WorkspacesApiFp(this.configuration).deleteWorkspace(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get the requested workspace.
     * @param {number} id The id of the workspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public getWorkspace(id: number, options?: any) {
        return WorkspacesApiFp(this.configuration).getWorkspace(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get projects associated with a workspace.
     * @param {number} id The id of the workspace. When id is set to 0, return all projects across the all workspaces.
     * @param {V1GetWorkspaceProjectsRequestSortBy} [sortBy] Sort the projects by the given field.   - SORT_BY_UNSPECIFIED: Returns projects in an unsorted list.  - SORT_BY_CREATION_TIME: Returns projects sorted by time that they were created.  - SORT_BY_LAST_EXPERIMENT_START_TIME: Returns projects sorted by most recent start of an experiment.  - SORT_BY_NAME: Returns projects sorted by name.  - SORT_BY_DESCRIPTION: Returns projects sorted by description.  - SORT_BY_ID: Returns projects sorted by ID.
     * @param {V1OrderBy} [orderBy] Order projects in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of projects before returning results. Negative values denote number of projects to skip from the end before returning results.
     * @param {number} [limit] Limit the number of projects. A value of 0 denotes no limit.
     * @param {string} [name] Limit the projects to those matching the name.
     * @param {boolean} [archived] Limit the projects to those with an archived status.
     * @param {Array<string>} [users] Limit the projects to those from particular users, by usernames.
     * @param {Array<number>} [userIds] Limit the projects to those from particular users, by userIds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public getWorkspaceProjects(id: number, sortBy?: V1GetWorkspaceProjectsRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, archived?: boolean, users?: Array<string>, userIds?: Array<number>, options?: any) {
        return WorkspacesApiFp(this.configuration).getWorkspaceProjects(id, sortBy, orderBy, offset, limit, name, archived, users, userIds, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Get a list of workspaces.
     * @param {V1GetWorkspacesRequestSortBy} [sortBy] Sort the workspaces by the given field.   - SORT_BY_UNSPECIFIED: Returns workspaces in an unsorted list.  - SORT_BY_ID: Returns workspaces sorted by id.  - SORT_BY_NAME: Returns workspaces sorted by name.
     * @param {V1OrderBy} [orderBy] Order workspaces in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of workspaces before returning results. Negative values denote number of workspaces to skip from the end before returning results.
     * @param {number} [limit] Limit the number of workspaces. A value of 0 denotes no limit.
     * @param {string} [name] Limit the workspaces to those matching the name (case insensitive).
     * @param {boolean} [archived] Limit the workspaces to those with an archived status.
     * @param {Array<string>} [users] Limit the workspaces to those from particular users, by usernames.
     * @param {Array<number>} [userIds] Limit the workspaces to those from particular users, by userIds.
     * @param {boolean} [pinned] Limit the workspaces to those with pinned status by the current user.
     * @param {string} [nameCaseSensitive] Limit the workspaces to those matching the name (case sensitive).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public getWorkspaces(sortBy?: V1GetWorkspacesRequestSortBy, orderBy?: V1OrderBy, offset?: number, limit?: number, name?: string, archived?: boolean, users?: Array<string>, userIds?: Array<number>, pinned?: boolean, nameCaseSensitive?: string, options?: any) {
        return WorkspacesApiFp(this.configuration).getWorkspaces(sortBy, orderBy, offset, limit, name, archived, users, userIds, pinned, nameCaseSensitive, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary List all resource pools, bound and unbound, available to a specific workspace
     * @param {number} workspaceId Workspace ID.
     * @param {number} [offset] The offset to use with pagination.
     * @param {number} [limit] The maximum number of results to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public listRPsBoundToWorkspace(workspaceId: number, offset?: number, limit?: number, options?: any) {
        return WorkspacesApiFp(this.configuration).listRPsBoundToWorkspace(workspaceId, offset, limit, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Update a workspace.
     * @param {number} id The id of the workspace.
     * @param {V1PatchWorkspace} body The desired workspace fields and values to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public patchWorkspace(id: number, body: V1PatchWorkspace, options?: any) {
        return WorkspacesApiFp(this.configuration).patchWorkspace(id, body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Pin a workspace.
     * @param {number} id The id of the workspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public pinWorkspace(id: number, options?: any) {
        return WorkspacesApiFp(this.configuration).pinWorkspace(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Create a workspace.
     * @param {V1PostWorkspaceRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public postWorkspace(body: V1PostWorkspaceRequest, options?: any) {
        return WorkspacesApiFp(this.configuration).postWorkspace(body, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Unarchive a workspace.
     * @param {number} id The id of the workspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public unarchiveWorkspace(id: number, options?: any) {
        return WorkspacesApiFp(this.configuration).unarchiveWorkspace(id, options)(this.fetch, this.basePath)
    }
    
    /**
     * 
     * @summary Unpin a workspace.
     * @param {number} id The id of the workspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public unpinWorkspace(id: number, options?: any) {
        return WorkspacesApiFp(this.configuration).unpinWorkspace(id, options)(this.fetch, this.basePath)
    }
    
}
