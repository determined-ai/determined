/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Determined API (Beta)
 * Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.  You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.
 *
 * OpenAPI spec version: 0.1
 * Contact: community@determined.ai
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * The current state of the checkpoint.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
 * @export
 * @enum {string}
 */
export enum Determinedcheckpointv1State {
    UNSPECIFIED = <any> 'STATE_UNSPECIFIED',
    ACTIVE = <any> 'STATE_ACTIVE',
    COMPLETED = <any> 'STATE_COMPLETED',
    ERROR = <any> 'STATE_ERROR',
    DELETED = <any> 'STATE_DELETED'
}

/**
 * The current state of the container.   - STATE_UNSPECIFIED: The container state is unknown.  - STATE_ASSIGNED: The container has been assigned to an agent but has not started yet.  - STATE_PULLING: The container's base image is being pulled from the Docker registry.  - STATE_STARTING: The image has been built and the container is being started, but the service in the container is not ready yet.  - STATE_RUNNING: The service in the container is able to accept requests.  - STATE_TERMINATED: The container has completely exited or the container has been aborted prior to getting assigned.
 * @export
 * @enum {string}
 */
export enum Determinedcontainerv1State {
    UNSPECIFIED = <any> 'STATE_UNSPECIFIED',
    ASSIGNED = <any> 'STATE_ASSIGNED',
    PULLING = <any> 'STATE_PULLING',
    STARTING = <any> 'STATE_STARTING',
    RUNNING = <any> 'STATE_RUNNING',
    TERMINATED = <any> 'STATE_TERMINATED'
}

/**
 * The current state of the experiment.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.
 * @export
 * @enum {string}
 */
export enum Determinedexperimentv1State {
    UNSPECIFIED = <any> 'STATE_UNSPECIFIED',
    ACTIVE = <any> 'STATE_ACTIVE',
    PAUSED = <any> 'STATE_PAUSED',
    STOPPINGCOMPLETED = <any> 'STATE_STOPPING_COMPLETED',
    STOPPINGCANCELED = <any> 'STATE_STOPPING_CANCELED',
    STOPPINGERROR = <any> 'STATE_STOPPING_ERROR',
    COMPLETED = <any> 'STATE_COMPLETED',
    CANCELED = <any> 'STATE_CANCELED',
    ERROR = <any> 'STATE_ERROR',
    DELETED = <any> 'STATE_DELETED',
    DELETING = <any> 'STATE_DELETING',
    DELETEFAILED = <any> 'STATE_DELETE_FAILED'
}

/**
 * The current state of the task.   - STATE_UNSPECIFIED: The task state is unknown.  - STATE_PENDING: The task is pending assignment.  - STATE_ASSIGNED: The task has been assigned to an agent but has not started yet.  - STATE_PULLING: The task's base image is being pulled from the Docker registry.  - STATE_STARTING: The image has been pulled and the task is being started, but the task is not ready yet.  - STATE_RUNNING: The service in the task is running.  - STATE_TERMINATED: The task has exited or has been aborted.  - STATE_TERMINATING: The task has begun to exit.
 * @export
 * @enum {string}
 */
export enum Determinedtaskv1State {
    UNSPECIFIED = <any> 'STATE_UNSPECIFIED',
    PENDING = <any> 'STATE_PENDING',
    ASSIGNED = <any> 'STATE_ASSIGNED',
    PULLING = <any> 'STATE_PULLING',
    STARTING = <any> 'STATE_STARTING',
    RUNNING = <any> 'STATE_RUNNING',
    TERMINATED = <any> 'STATE_TERMINATED',
    TERMINATING = <any> 'STATE_TERMINATING'
}

/**
 * The type of the Device.   - TYPE_UNSPECIFIED: An unspecified device type.  - TYPE_CPU: A CPU device.  - TYPE_GPU: A GPU device.
 * @export
 * @enum {string}
 */
export enum Devicev1Type {
    UNSPECIFIED = <any> 'TYPE_UNSPECIFIED',
    CPU = <any> 'TYPE_CPU',
    GPU = <any> 'TYPE_GPU'
}

/**
 * Hyperparameter importance as computed with respect for one specific metric.
 * @export
 * @interface GetHPImportanceResponseMetricHPImportance
 */
export interface GetHPImportanceResponseMetricHPImportance {
    /**
     * A map between hyperparameter names and their relative importance.
     * @type {{ [key: string]: number; }}
     * @memberof GetHPImportanceResponseMetricHPImportance
     */
    hpImportance?: { [key: string]: number; };
    /**
     * The approximate portion of the experiment that was complete when the data was read.
     * @type {number}
     * @memberof GetHPImportanceResponseMetricHPImportance
     */
    experimentProgress?: number;
    /**
     * A description of why computation failed. Empty unless the state is (or was) 'failed'.
     * @type {string}
     * @memberof GetHPImportanceResponseMetricHPImportance
     */
    error?: string;
    /**
     * Whether or not a request to compute results for this metric is queued.
     * @type {boolean}
     * @memberof GetHPImportanceResponseMetricHPImportance
     */
    pending?: boolean;
    /**
     * Whether or not results for this metric are currently being computed.
     * @type {boolean}
     * @memberof GetHPImportanceResponseMetricHPImportance
     */
    inProgress?: boolean;
}

/**
 * WorkloadContainer is a wrapper for Determined workloads to allow repeated oneof types.
 * @export
 * @interface GetTrialResponseWorkloadContainer
 */
export interface GetTrialResponseWorkloadContainer {
    /**
     * Training workload.
     * @type {V1MetricsWorkload}
     * @memberof GetTrialResponseWorkloadContainer
     */
    training?: V1MetricsWorkload;
    /**
     * Validation workload.
     * @type {V1MetricsWorkload}
     * @memberof GetTrialResponseWorkloadContainer
     */
    validation?: V1MetricsWorkload;
    /**
     * Checkpoint workload.
     * @type {V1CheckpointWorkload}
     * @memberof GetTrialResponseWorkloadContainer
     */
    checkpoint?: V1CheckpointWorkload;
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ProtobufAny
     */
    typeUrl?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ProtobufAny
     */
    value?: string;
}

/**
 * paths: \"f.a\"     paths: \"f.b.d\"  Here `f` represents a field in some root message, `a` and `b` fields in the message found in `f`, and `d` a field found in the message in `f.b`.  Field masks are used to specify a subset of fields that should be returned by a get operation or modified by an update operation. Field masks also have a custom JSON encoding (see below).  # Field Masks in Projections  When used in the context of a projection, a response message or sub-message is filtered by the API to only contain those fields as specified in the mask. For example, if the mask in the previous example is applied to a response message as follows:      f {       a : 22       b {         d : 1         x : 2       }       y : 13     }     z: 8  The result will not contain specific values for fields x,y and z (their value will be set to the default, and omitted in proto text output):       f {       a : 22       b {         d : 1       }     }  A repeated field is not allowed except at the last position of a paths string.  If a FieldMask object is not present in a get operation, the operation applies to all fields (as if a FieldMask of all fields had been specified).  Note that a field mask does not necessarily apply to the top-level response message. In case of a REST get operation, the field mask applies directly to the response, but in case of a REST list operation, the mask instead applies to each individual message in the returned resource list. In case of a REST custom method, other definitions may be used. Where the mask applies will be clearly documented together with its declaration in the API.  In any case, the effect on the returned resource/resources is required behavior for APIs.  # Field Masks in Update Operations  A field mask in update operations specifies which fields of the targeted resource are going to be updated. The API is required to only change the values of the fields as specified in the mask and leave the others untouched. If a resource is passed in to describe the updated values, the API ignores the values of all fields not covered by the mask.  If a repeated field is specified for an update operation, new values will be appended to the existing repeated field in the target resource. Note that a repeated field is only allowed in the last position of a `paths` string.  If a sub-message is specified in the last position of the field mask for an update operation, then new value will be merged into the existing sub-message in the target resource.  For example, given the target message:      f {       b {         d: 1         x: 2       }       c: [1]     }  And an update message:      f {       b {         d: 10       }       c: [2]     }  then if the field mask is:   paths: [\"f.b\", \"f.c\"]  then the result will be:      f {       b {         d: 10         x: 2       }       c: [1, 2]     }  An implementation may provide options to override this default behavior for repeated and message fields.  In order to reset a field's value to the default, the field must be in the mask and set to the default value in the provided resource. Hence, in order to reset all fields of a resource, provide a default instance of the resource and set all fields in the mask, or do not provide a mask as described below.  If a field mask is not present on update, the operation applies to all fields (as if a field mask of all fields has been specified). Note that in the presence of schema evolution, this may mean that fields the client does not know and has therefore not filled into the request will be reset to their default. If this is unwanted behavior, a specific service may require a client to always specify a field mask, producing an error if not.  As with get operations, the location of the resource which describes the updated values in the request message depends on the operation kind. In any case, the effect of the field mask is required to be honored by the API.  ## Considerations for HTTP REST  The HTTP kind of an update operation which uses a field mask must be set to PATCH instead of PUT in order to satisfy HTTP semantics (PUT must only be used for full updates).  # JSON Encoding of Field Masks  In JSON, a field mask is encoded as a single string where paths are separated by a comma. Fields name in each path are converted to/from lower-camel naming conventions.  As an example, consider the following message declarations:      message Profile {       User user = 1;       Photo photo = 2;     }     message User {       string display_name = 1;       string address = 2;     }  In proto a field mask for `Profile` may look as such:      mask {       paths: \"user.display_name\"       paths: \"photo\"     }  In JSON, the same mask is represented as below:      {       mask: \"user.displayName,photo\"     }  # Field Masks and Oneof Fields  Field masks treat fields in oneofs just as regular fields. Consider the following message:      message SampleMessage {       oneof test_oneof {         string name = 4;         SubMessage sub_message = 9;       }     }  The field mask can be:      mask {       paths: \"name\"     }  Or:      mask {       paths: \"sub_message\"     }  Note that oneof type names (\"test_oneof\" in this case) cannot be used in paths.  ## Field Mask Verification  The implementation of any API method which has a FieldMask type field in the request should verify the included field paths, and return an `INVALID_ARGUMENT` error if any path is unmappable.
 * @export
 * @interface ProtobufFieldMask
 */
export interface ProtobufFieldMask {
    /**
     * The set of field mask paths.
     * @type {Array<string>}
     * @memberof ProtobufFieldMask
     */
    paths?: Array<string>;
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */
export enum ProtobufNullValue {
    NULLVALUE = <any> 'NULL_VALUE'
}

/**
 * 
 * @export
 * @interface RuntimeError
 */
export interface RuntimeError {
    /**
     * 
     * @type {string}
     * @memberof RuntimeError
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof RuntimeError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof RuntimeError
     */
    message?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RuntimeError
     */
    details?: Array<ProtobufAny>;
}

/**
 * 
 * @export
 * @interface RuntimeStreamError
 */
export interface RuntimeStreamError {
    /**
     * 
     * @type {number}
     * @memberof RuntimeStreamError
     */
    grpcCode?: number;
    /**
     * 
     * @type {number}
     * @memberof RuntimeStreamError
     */
    httpCode?: number;
    /**
     * 
     * @type {string}
     * @memberof RuntimeStreamError
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof RuntimeStreamError
     */
    httpStatus?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RuntimeStreamError
     */
    details?: Array<ProtobufAny>;
}

/**
 * 
 * @export
 * @interface StreamResultOfV1GetHPImportanceResponse
 */
export interface StreamResultOfV1GetHPImportanceResponse {
    /**
     * 
     * @type {V1GetHPImportanceResponse}
     * @memberof StreamResultOfV1GetHPImportanceResponse
     */
    result?: V1GetHPImportanceResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1GetHPImportanceResponse
     */
    error?: RuntimeStreamError;
}

/**
 * 
 * @export
 * @interface StreamResultOfV1GetTrialProfilerAvailableSeriesResponse
 */
export interface StreamResultOfV1GetTrialProfilerAvailableSeriesResponse {
    /**
     * 
     * @type {V1GetTrialProfilerAvailableSeriesResponse}
     * @memberof StreamResultOfV1GetTrialProfilerAvailableSeriesResponse
     */
    result?: V1GetTrialProfilerAvailableSeriesResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1GetTrialProfilerAvailableSeriesResponse
     */
    error?: RuntimeStreamError;
}

/**
 * 
 * @export
 * @interface StreamResultOfV1GetTrialProfilerMetricsResponse
 */
export interface StreamResultOfV1GetTrialProfilerMetricsResponse {
    /**
     * 
     * @type {V1GetTrialProfilerMetricsResponse}
     * @memberof StreamResultOfV1GetTrialProfilerMetricsResponse
     */
    result?: V1GetTrialProfilerMetricsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1GetTrialProfilerMetricsResponse
     */
    error?: RuntimeStreamError;
}

/**
 * 
 * @export
 * @interface StreamResultOfV1MasterLogsResponse
 */
export interface StreamResultOfV1MasterLogsResponse {
    /**
     * 
     * @type {V1MasterLogsResponse}
     * @memberof StreamResultOfV1MasterLogsResponse
     */
    result?: V1MasterLogsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1MasterLogsResponse
     */
    error?: RuntimeStreamError;
}

/**
 * 
 * @export
 * @interface StreamResultOfV1MetricBatchesResponse
 */
export interface StreamResultOfV1MetricBatchesResponse {
    /**
     * 
     * @type {V1MetricBatchesResponse}
     * @memberof StreamResultOfV1MetricBatchesResponse
     */
    result?: V1MetricBatchesResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1MetricBatchesResponse
     */
    error?: RuntimeStreamError;
}

/**
 * 
 * @export
 * @interface StreamResultOfV1MetricNamesResponse
 */
export interface StreamResultOfV1MetricNamesResponse {
    /**
     * 
     * @type {V1MetricNamesResponse}
     * @memberof StreamResultOfV1MetricNamesResponse
     */
    result?: V1MetricNamesResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1MetricNamesResponse
     */
    error?: RuntimeStreamError;
}

/**
 * 
 * @export
 * @interface StreamResultOfV1NotebookLogsResponse
 */
export interface StreamResultOfV1NotebookLogsResponse {
    /**
     * 
     * @type {V1NotebookLogsResponse}
     * @memberof StreamResultOfV1NotebookLogsResponse
     */
    result?: V1NotebookLogsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1NotebookLogsResponse
     */
    error?: RuntimeStreamError;
}

/**
 * 
 * @export
 * @interface StreamResultOfV1TrialLogsFieldsResponse
 */
export interface StreamResultOfV1TrialLogsFieldsResponse {
    /**
     * 
     * @type {V1TrialLogsFieldsResponse}
     * @memberof StreamResultOfV1TrialLogsFieldsResponse
     */
    result?: V1TrialLogsFieldsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1TrialLogsFieldsResponse
     */
    error?: RuntimeStreamError;
}

/**
 * 
 * @export
 * @interface StreamResultOfV1TrialLogsResponse
 */
export interface StreamResultOfV1TrialLogsResponse {
    /**
     * 
     * @type {V1TrialLogsResponse}
     * @memberof StreamResultOfV1TrialLogsResponse
     */
    result?: V1TrialLogsResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1TrialLogsResponse
     */
    error?: RuntimeStreamError;
}

/**
 * 
 * @export
 * @interface StreamResultOfV1TrialsSampleResponse
 */
export interface StreamResultOfV1TrialsSampleResponse {
    /**
     * 
     * @type {V1TrialsSampleResponse}
     * @memberof StreamResultOfV1TrialsSampleResponse
     */
    result?: V1TrialsSampleResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1TrialsSampleResponse
     */
    error?: RuntimeStreamError;
}

/**
 * 
 * @export
 * @interface StreamResultOfV1TrialsSnapshotResponse
 */
export interface StreamResultOfV1TrialsSnapshotResponse {
    /**
     * 
     * @type {V1TrialsSnapshotResponse}
     * @memberof StreamResultOfV1TrialsSnapshotResponse
     */
    result?: V1TrialsSnapshotResponse;
    /**
     * 
     * @type {RuntimeStreamError}
     * @memberof StreamResultOfV1TrialsSnapshotResponse
     */
    error?: RuntimeStreamError;
}

/**
 * The units for the training length.   - UNIT_UNSPECIFIED: Zero-value (not allowed).  - UNIT_RECORDS: Indicates a training length is specified in records, samples or another synonymous unit.  - UNIT_BATCHES: Indicates a training length is specified in batches.  - UNIT_EPOCHS: Indicates a training length is specified in epochs.
 * @export
 * @enum {string}
 */
export enum TrainingLengthUnit {
    UNSPECIFIED = <any> 'UNIT_UNSPECIFIED',
    RECORDS = <any> 'UNIT_RECORDS',
    BATCHES = <any> 'UNIT_BATCHES',
    EPOCHS = <any> 'UNIT_EPOCHS'
}

/**
 * The reason for an early exit.   - EXITED_REASON_UNSPECIFIED: Zero-value (not allowed).  - EXITED_REASON_INVALID_HP: Indicates the trial exited due to an invalid hyperparameter.  - EXITED_REASON_USER_REQUESTED_STOP: Indicates the trial exited due to a user requested stop.  - EXITED_REASON_INIT_INVALID_HP: Indicates the trial exited due to an invalid hyperparameter in the trial init.
 * @export
 * @enum {string}
 */
export enum TrialEarlyExitExitedReason {
    UNSPECIFIED = <any> 'EXITED_REASON_UNSPECIFIED',
    INVALIDHP = <any> 'EXITED_REASON_INVALID_HP',
    USERREQUESTEDSTOP = <any> 'EXITED_REASON_USER_REQUESTED_STOP',
    INITINVALIDHP = <any> 'EXITED_REASON_INIT_INVALID_HP'
}

/**
 * To distinguish the 2 different categories of metrics.   - PROFILER_METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - PROFILER_METRIC_TYPE_SYSTEM: For systems metrics, like GPU utilization or memory.  - PROFILER_METRIC_TYPE_TIMING: For timing metrics, like how long a backwards pass or getting a batch from the dataloader took.  - PROFILER_METRIC_TYPE_MISC: For other miscellaneous metrics.
 * @export
 * @enum {string}
 */
export enum TrialProfilerMetricLabelsProfilerMetricType {
    UNSPECIFIED = <any> 'PROFILER_METRIC_TYPE_UNSPECIFIED',
    SYSTEM = <any> 'PROFILER_METRIC_TYPE_SYSTEM',
    TIMING = <any> 'PROFILER_METRIC_TYPE_TIMING',
    MISC = <any> 'PROFILER_METRIC_TYPE_MISC'
}

/**
 * One datapoint in a series of metrics from a trial.
 * @export
 * @interface TrialsSampleResponseDataPoint
 */
export interface TrialsSampleResponseDataPoint {
    /**
     * Total batches processed by the time this measurement is taken.
     * @type {number}
     * @memberof TrialsSampleResponseDataPoint
     */
    batches: number;
    /**
     * Value of the requested metric at this point in the trial.
     * @type {number}
     * @memberof TrialsSampleResponseDataPoint
     */
    value: number;
}

/**
 * Trial is a set of workloads and are exploring a determined set of hyperparameters.
 * @export
 * @interface Trialv1Trial
 */
export interface Trialv1Trial {
    /**
     * The id of the trial.
     * @type {number}
     * @memberof Trialv1Trial
     */
    id: number;
    /**
     * The id of the parent experiment.
     * @type {number}
     * @memberof Trialv1Trial
     */
    experimentId: number;
    /**
     * The time the trial was started.
     * @type {Date}
     * @memberof Trialv1Trial
     */
    startTime: Date;
    /**
     * The time the trial ended if the trial is stopped.
     * @type {Date}
     * @memberof Trialv1Trial
     */
    endTime?: Date;
    /**
     * The current state of the trial.
     * @type {Determinedexperimentv1State}
     * @memberof Trialv1Trial
     */
    state: Determinedexperimentv1State;
    /**
     * Trial hyperparameters.
     * @type {any}
     * @memberof Trialv1Trial
     */
    hparams: any;
    /**
     * The current processed batches.
     * @type {number}
     * @memberof Trialv1Trial
     */
    totalBatchesProcessed: number;
    /**
     * Best validation.
     * @type {V1MetricsWorkload}
     * @memberof Trialv1Trial
     */
    bestValidation?: V1MetricsWorkload;
    /**
     * Latest validation.
     * @type {V1MetricsWorkload}
     * @memberof Trialv1Trial
     */
    latestValidation?: V1MetricsWorkload;
    /**
     * Best checkpoint.
     * @type {V1CheckpointWorkload}
     * @memberof Trialv1Trial
     */
    bestCheckpoint?: V1CheckpointWorkload;
    /**
     * The last reported state of the trial runner (harness code).
     * @type {string}
     * @memberof Trialv1Trial
     */
    runnerState?: string;
}

/**
 * Acknowledge the receipt of some stop signal.
 * @export
 * @interface V1AckAllocationPreemptionSignalRequest
 */
export interface V1AckAllocationPreemptionSignalRequest {
    /**
     * The allocation that is acknowledging the request.
     * @type {string}
     * @memberof V1AckAllocationPreemptionSignalRequest
     */
    allocationId: string;
}

/**
 * Response to AckAllocationPreemptionSignalRequest.
 * @export
 * @interface V1AckAllocationPreemptionSignalResponse
 */
export interface V1AckAllocationPreemptionSignalResponse {
}

/**
 * Response to ActivateExperimentRequest.
 * @export
 * @interface V1ActivateExperimentResponse
 */
export interface V1ActivateExperimentResponse {
}

/**
 * Agent is a pool of resources where containers are run.
 * @export
 * @interface V1Agent
 */
export interface V1Agent {
    /**
     * The unique id of the agent.
     * @type {string}
     * @memberof V1Agent
     */
    id?: string;
    /**
     * The time when the agent registered with the master.
     * @type {Date}
     * @memberof V1Agent
     */
    registeredTime?: Date;
    /**
     * A map of slot id to each slot of this agent.
     * @type {{ [key: string]: V1Slot; }}
     * @memberof V1Agent
     */
    slots?: { [key: string]: V1Slot; };
    /**
     * A map of container id to all containers assigned to this agent.
     * @type {{ [key: string]: V1Container; }}
     * @memberof V1Agent
     */
    containers?: { [key: string]: V1Container; };
    /**
     * An optional label applied to the agent for scheduling restrictions.
     * @type {string}
     * @memberof V1Agent
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    resourcePool?: string;
    /**
     * The addresses of the agent.
     * @type {Array<string>}
     * @memberof V1Agent
     */
    addresses?: Array<string>;
    /**
     * Flag notifying if containers can be scheduled on this agent.
     * @type {boolean}
     * @memberof V1Agent
     */
    enabled?: boolean;
    /**
     * Flag notifying if this agent is in the draining mode: current containers will be allowed to finish but no new ones will be scheduled.
     * @type {boolean}
     * @memberof V1Agent
     */
    draining?: boolean;
}

/**
 * AgentUserGroup represents a username and primary group for a user on an agent host machine.
 * @export
 * @interface V1AgentUserGroup
 */
export interface V1AgentUserGroup {
    /**
     * The user id on the agent.
     * @type {number}
     * @memberof V1AgentUserGroup
     */
    agentUid?: number;
    /**
     * The group id on the agent.
     * @type {number}
     * @memberof V1AgentUserGroup
     */
    agentGid?: number;
}

/**
 * Response to AllocationPreemptionSignalRequest.
 * @export
 * @interface V1AllocationPreemptionSignalResponse
 */
export interface V1AllocationPreemptionSignalResponse {
    /**
     * True if signaling preempt, otherwise just a synchronization marker.
     * @type {boolean}
     * @memberof V1AllocationPreemptionSignalResponse
     */
    preempt?: boolean;
}

/**
 * 
 * @export
 * @interface V1AllocationRendezvousInfoResponse
 */
export interface V1AllocationRendezvousInfoResponse {
    /**
     * The rendezvous information.
     * @type {V1RendezvousInfo}
     * @memberof V1AllocationRendezvousInfoResponse
     */
    rendezvousInfo: V1RendezvousInfo;
}

/**
 * Response to ArchiveExperimentRequest.
 * @export
 * @interface V1ArchiveExperimentResponse
 */
export interface V1ArchiveExperimentResponse {
}

/**
 * 
 * @export
 * @interface V1AwsCustomTag
 */
export interface V1AwsCustomTag {
    /**
     * 
     * @type {string}
     * @memberof V1AwsCustomTag
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof V1AwsCustomTag
     */
    value: string;
}

/**
 * Response to CancelExperimentRequest.
 * @export
 * @interface V1CancelExperimentResponse
 */
export interface V1CancelExperimentResponse {
}

/**
 * Checkpoint is an artifact created by a trial during training.
 * @export
 * @interface V1Checkpoint
 */
export interface V1Checkpoint {
    /**
     * UUID of the checkpoint.
     * @type {string}
     * @memberof V1Checkpoint
     */
    uuid?: string;
    /**
     * The configuration of the experiment that created this checkpoint.
     * @type {any}
     * @memberof V1Checkpoint
     */
    experimentConfig?: any;
    /**
     * The ID of the experiment that created this checkpoint.
     * @type {number}
     * @memberof V1Checkpoint
     */
    experimentId: number;
    /**
     * The ID of the trial that created this checkpoint.
     * @type {number}
     * @memberof V1Checkpoint
     */
    trialId: number;
    /**
     * Hyperparameter values for the trial that created this checkpoint.
     * @type {any}
     * @memberof V1Checkpoint
     */
    hparams?: any;
    /**
     * Batch number of this checkpoint.
     * @type {number}
     * @memberof V1Checkpoint
     */
    batchNumber: number;
    /**
     * Timestamp when the checkpoint was reported as being saved to persistent storage.
     * @type {Date}
     * @memberof V1Checkpoint
     */
    endTime?: Date;
    /**
     * Dictionary of file paths to file sizes in bytes of all files in the checkpoint.
     * @type {{ [key: string]: string; }}
     * @memberof V1Checkpoint
     */
    resources?: { [key: string]: string; };
    /**
     * User defined metadata associated with the checkpoint.
     * @type {any}
     * @memberof V1Checkpoint
     */
    metadata?: any;
    /**
     * The framework of the trial i.e., tensorflow, torch.
     * @type {string}
     * @memberof V1Checkpoint
     */
    framework?: string;
    /**
     * The format of the checkpoint i.e., h5, saved_model, pickle.
     * @type {string}
     * @memberof V1Checkpoint
     */
    format?: string;
    /**
     * The version of Determined the checkpoint was taken with.
     * @type {string}
     * @memberof V1Checkpoint
     */
    determinedVersion?: string;
    /**
     * Dictionary of validation metric names to their values.
     * @type {V1Metrics}
     * @memberof V1Checkpoint
     */
    metrics?: V1Metrics;
    /**
     * The state of the validation associated with this checkpoint.
     * @type {Determinedcheckpointv1State}
     * @memberof V1Checkpoint
     */
    validationState?: Determinedcheckpointv1State;
    /**
     * The state of the checkpoint.
     * @type {Determinedcheckpointv1State}
     * @memberof V1Checkpoint
     */
    state: Determinedcheckpointv1State;
    /**
     * The value of the metric specified by `searcher.metric` for this metric.
     * @type {number}
     * @memberof V1Checkpoint
     */
    searcherMetric?: number;
}

/**
 * The checkpoint metadata for some trial checkpoint.
 * @export
 * @interface V1CheckpointMetadata
 */
export interface V1CheckpointMetadata {
    /**
     * The ID of the trial associated with the checkpoint.
     * @type {number}
     * @memberof V1CheckpointMetadata
     */
    trialId: number;
    /**
     * The run of the trial associated with the checkpoint.
     * @type {number}
     * @memberof V1CheckpointMetadata
     */
    trialRunId: number;
    /**
     * UUID of the checkpoint.
     * @type {string}
     * @memberof V1CheckpointMetadata
     */
    uuid: string;
    /**
     * Dictionary of file paths to file sizes in bytes of all files.
     * @type {{ [key: string]: string; }}
     * @memberof V1CheckpointMetadata
     */
    resources: { [key: string]: string; };
    /**
     * The framework associated with the checkpoint.
     * @type {string}
     * @memberof V1CheckpointMetadata
     */
    framework: string;
    /**
     * The format of the checkpoint.
     * @type {string}
     * @memberof V1CheckpointMetadata
     */
    format: string;
    /**
     * The Determined version associated with the checkpoint.
     * @type {string}
     * @memberof V1CheckpointMetadata
     */
    determinedVersion: string;
    /**
     * The number of batches trained on when these metrics were reported.
     * @type {number}
     * @memberof V1CheckpointMetadata
     */
    latestBatch?: number;
}

/**
 * CheckpointWorkload is an artifact created by a trial during training.
 * @export
 * @interface V1CheckpointWorkload
 */
export interface V1CheckpointWorkload {
    /**
     * UUID of the checkpoint.
     * @type {string}
     * @memberof V1CheckpointWorkload
     */
    uuid?: string;
    /**
     * The time the workload finished or was stopped.
     * @type {Date}
     * @memberof V1CheckpointWorkload
     */
    endTime?: Date;
    /**
     * The state of the checkpoint.
     * @type {Determinedcheckpointv1State}
     * @memberof V1CheckpointWorkload
     */
    state: Determinedcheckpointv1State;
    /**
     * Dictionary of file paths to file sizes in bytes of all files in the checkpoint.
     * @type {{ [key: string]: string; }}
     * @memberof V1CheckpointWorkload
     */
    resources?: { [key: string]: string; };
    /**
     * Total number of batches as of this workload's completion.
     * @type {number}
     * @memberof V1CheckpointWorkload
     */
    totalBatches: number;
}

/**
 * Command is a single container running the configured command.
 * @export
 * @interface V1Command
 */
export interface V1Command {
    /**
     * The id of the command.
     * @type {string}
     * @memberof V1Command
     */
    id: string;
    /**
     * The description of the command.
     * @type {string}
     * @memberof V1Command
     */
    description: string;
    /**
     * The state of the command.
     * @type {Determinedtaskv1State}
     * @memberof V1Command
     */
    state: Determinedtaskv1State;
    /**
     * The time the command was started.
     * @type {Date}
     * @memberof V1Command
     */
    startTime: Date;
    /**
     * The container running the command.
     * @type {V1Container}
     * @memberof V1Command
     */
    container?: V1Container;
    /**
     * The username of the user that created the command.
     * @type {string}
     * @memberof V1Command
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof V1Command
     */
    resourcePool: string;
    /**
     * 
     * @type {string}
     * @memberof V1Command
     */
    exitStatus?: string;
}

/**
 * 
 * @export
 * @interface V1CompleteTrialSearcherValidationResponse
 */
export interface V1CompleteTrialSearcherValidationResponse {
}

/**
 * Used to complete a ValidateAfterOperation.
 * @export
 * @interface V1CompleteValidateAfterOperation
 */
export interface V1CompleteValidateAfterOperation {
    /**
     * The ValidateAfterOperation being completed.
     * @type {V1ValidateAfterOperation}
     * @memberof V1CompleteValidateAfterOperation
     */
    op?: V1ValidateAfterOperation;
    /**
     * The value of searcher metric associated with this completed metric. The metric provided should be the metric used to guide HP search.
     * @type {number}
     * @memberof V1CompleteValidateAfterOperation
     */
    searcherMetric?: number;
}

/**
 * 
 * @export
 * @interface V1ComputeHPImportanceResponse
 */
export interface V1ComputeHPImportanceResponse {
}

/**
 * Container is a Docker container that is either scheduled to run or is currently running on a set of slots.
 * @export
 * @interface V1Container
 */
export interface V1Container {
    /**
     * The id of the task that is currently managing this container.
     * @type {string}
     * @memberof V1Container
     */
    parent?: string;
    /**
     * The unique id of this instance of a container.
     * @type {string}
     * @memberof V1Container
     */
    id: string;
    /**
     * The current state that the container is currently in.
     * @type {Determinedcontainerv1State}
     * @memberof V1Container
     */
    state: Determinedcontainerv1State;
    /**
     * A list of devices that is being used by this container.
     * @type {Array<V1Device>}
     * @memberof V1Container
     */
    devices?: Array<V1Device>;
}

/**
 * Request to create a new experiment.
 * @export
 * @interface V1CreateExperimentRequest
 */
export interface V1CreateExperimentRequest {
    /**
     * Experiment context.
     * @type {Array<V1File>}
     * @memberof V1CreateExperimentRequest
     */
    modelDefinition?: Array<V1File>;
    /**
     * Experiment config (YAML).
     * @type {string}
     * @memberof V1CreateExperimentRequest
     */
    config?: string;
    /**
     * Only validate instead of creating the experiment. A dry run.
     * @type {boolean}
     * @memberof V1CreateExperimentRequest
     */
    validateOnly?: boolean;
    /**
     * Parent experiment id.
     * @type {number}
     * @memberof V1CreateExperimentRequest
     */
    parentId?: number;
}

/**
 * Response to CreateExperimentRequest.
 * @export
 * @interface V1CreateExperimentResponse
 */
export interface V1CreateExperimentResponse {
    /**
     * The created experiment.
     * @type {V1Experiment}
     * @memberof V1CreateExperimentResponse
     */
    experiment: V1Experiment;
    /**
     * The created experiment config.
     * @type {any}
     * @memberof V1CreateExperimentResponse
     */
    config: any;
}

/**
 * Response to CurrentUserRequest.
 * @export
 * @interface V1CurrentUserResponse
 */
export interface V1CurrentUserResponse {
    /**
     * The currently logged in user.
     * @type {V1User}
     * @memberof V1CurrentUserResponse
     */
    user: V1User;
}

/**
 * Response to DeleteExperimentRequest.
 * @export
 * @interface V1DeleteExperimentResponse
 */
export interface V1DeleteExperimentResponse {
}

/**
 * Response to DeleteTemplateRequest.
 * @export
 * @interface V1DeleteTemplateResponse
 */
export interface V1DeleteTemplateResponse {
}

/**
 * Device represents a single computational device on an agent.
 * @export
 * @interface V1Device
 */
export interface V1Device {
    /**
     * The index of the device.
     * @type {number}
     * @memberof V1Device
     */
    id?: number;
    /**
     * The brand name of the device.
     * @type {string}
     * @memberof V1Device
     */
    brand?: string;
    /**
     * The unique UUID of the device.
     * @type {string}
     * @memberof V1Device
     */
    uuid?: string;
    /**
     * The type of the Device.
     * @type {Devicev1Type}
     * @memberof V1Device
     */
    type?: Devicev1Type;
}

/**
 * Disable the agent.
 * @export
 * @interface V1DisableAgentRequest
 */
export interface V1DisableAgentRequest {
    /**
     * The id of the agent.
     * @type {string}
     * @memberof V1DisableAgentRequest
     */
    agentId?: string;
    /**
     * If true, wait for running tasks to finish.
     * @type {boolean}
     * @memberof V1DisableAgentRequest
     */
    drain?: boolean;
}

/**
 * Response to DisableAgentRequest.
 * @export
 * @interface V1DisableAgentResponse
 */
export interface V1DisableAgentResponse {
    /**
     * The disabled agent.
     * @type {V1Agent}
     * @memberof V1DisableAgentResponse
     */
    agent?: V1Agent;
}

/**
 * Response to DisableSlotRequest.
 * @export
 * @interface V1DisableSlotResponse
 */
export interface V1DisableSlotResponse {
    /**
     * The disabled slot.
     * @type {V1Slot}
     * @memberof V1DisableSlotResponse
     */
    slot?: V1Slot;
}

/**
 * Response to EnableAgentRequest.
 * @export
 * @interface V1EnableAgentResponse
 */
export interface V1EnableAgentResponse {
    /**
     * The enabled agent.
     * @type {V1Agent}
     * @memberof V1EnableAgentResponse
     */
    agent?: V1Agent;
}

/**
 * Response to EnableSlotRequest.
 * @export
 * @interface V1EnableSlotResponse
 */
export interface V1EnableSlotResponse {
    /**
     * The enabled slot.
     * @type {V1Slot}
     * @memberof V1EnableSlotResponse
     */
    slot?: V1Slot;
}

/**
 * Experiment is a collection of one or more trials that are exploring a user-defined hyperparameter space.
 * @export
 * @interface V1Experiment
 */
export interface V1Experiment {
    /**
     * The id of the experiment.
     * @type {number}
     * @memberof V1Experiment
     */
    id: number;
    /**
     * The description of the experiment.
     * @type {string}
     * @memberof V1Experiment
     */
    description?: string;
    /**
     * Labels attached to the experiment.
     * @type {Array<string>}
     * @memberof V1Experiment
     */
    labels?: Array<string>;
    /**
     * The time the experiment was started.
     * @type {Date}
     * @memberof V1Experiment
     */
    startTime: Date;
    /**
     * The time the experiment ended if the experiment is stopped.
     * @type {Date}
     * @memberof V1Experiment
     */
    endTime?: Date;
    /**
     * The current state of the experiment.
     * @type {Determinedexperimentv1State}
     * @memberof V1Experiment
     */
    state: Determinedexperimentv1State;
    /**
     * Boolean denoting whether the experiment was archived.
     * @type {boolean}
     * @memberof V1Experiment
     */
    archived: boolean;
    /**
     * The number of trials linked to the experiment.
     * @type {number}
     * @memberof V1Experiment
     */
    numTrials: number;
    /**
     * The current progress of the experiment.
     * @type {number}
     * @memberof V1Experiment
     */
    progress?: number;
    /**
     * The username of the user that created the experiment.
     * @type {string}
     * @memberof V1Experiment
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    resourcePool?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    searcherType: string;
    /**
     * The experiment name.
     * @type {string}
     * @memberof V1Experiment
     */
    name: string;
    /**
     * The experiment notes.
     * @type {string}
     * @memberof V1Experiment
     */
    notes?: string;
}

/**
 * ExperimentSimulation holds the configuration and results of simulated run of a searcher.
 * @export
 * @interface V1ExperimentSimulation
 */
export interface V1ExperimentSimulation {
    /**
     * The simulated experiment config.
     * @type {any}
     * @memberof V1ExperimentSimulation
     */
    config?: any;
    /**
     * The searcher simulation seed.
     * @type {number}
     * @memberof V1ExperimentSimulation
     */
    seed?: number;
    /**
     * The list of trials in the simulation.
     * @type {Array<V1TrialSimulation>}
     * @memberof V1ExperimentSimulation
     */
    trials?: Array<V1TrialSimulation>;
}

/**
 * File is a Unix file.
 * @export
 * @interface V1File
 */
export interface V1File {
    /**
     * Path to the file.
     * @type {string}
     * @memberof V1File
     */
    path: string;
    /**
     * File type.
     * @type {number}
     * @memberof V1File
     */
    type: number;
    /**
     * base64 encoded contents of the file.
     * @type {string}
     * @memberof V1File
     */
    content: string;
    /**
     * Modified time (Unix timestamp).
     * @type {string}
     * @memberof V1File
     */
    mtime: string;
    /**
     * File mode.
     * @type {number}
     * @memberof V1File
     */
    mode: number;
    /**
     * User ID.
     * @type {number}
     * @memberof V1File
     */
    uid: number;
    /**
     * Group ID.
     * @type {number}
     * @memberof V1File
     */
    gid: number;
}

/**
 * The fitting policy of the scheduler.   - FITTING_POLICY_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - FITTING_POLICY_BEST: Best fit. Tasks are preferentially “packed” together on the smallest number of agents  - FITTING_POLICY_WORST: Worst fit. Tasks are placed on under-utilized agents, spreading out the tasks.  - FITTING_POLICY_KUBERNETES: A kubernetes placeholder. In k8s, the task placement is delegated to the k8s scheduler so the fitting policy is not relevant.
 * @export
 * @enum {string}
 */
export enum V1FittingPolicy {
    UNSPECIFIED = <any> 'FITTING_POLICY_UNSPECIFIED',
    BEST = <any> 'FITTING_POLICY_BEST',
    WORST = <any> 'FITTING_POLICY_WORST',
    KUBERNETES = <any> 'FITTING_POLICY_KUBERNETES'
}

/**
 * Response to GetAgentRequest.
 * @export
 * @interface V1GetAgentResponse
 */
export interface V1GetAgentResponse {
    /**
     * The requested agent.
     * @type {V1Agent}
     * @memberof V1GetAgentResponse
     */
    agent?: V1Agent;
}

/**
 * Sorts agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
 * @export
 * @enum {string}
 */
export enum V1GetAgentsRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    ID = <any> 'SORT_BY_ID',
    TIME = <any> 'SORT_BY_TIME'
}

/**
 * Response to GetAgentsRequest.
 * @export
 * @interface V1GetAgentsResponse
 */
export interface V1GetAgentsResponse {
    /**
     * The list of returned agents.
     * @type {Array<V1Agent>}
     * @memberof V1GetAgentsResponse
     */
    agents?: Array<V1Agent>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetAgentsResponse
     */
    pagination?: V1Pagination;
}

/**
 * Response to GetBestSearcherValidationMetricRequest.
 * @export
 * @interface V1GetBestSearcherValidationMetricResponse
 */
export interface V1GetBestSearcherValidationMetricResponse {
    /**
     * The value of the metric.
     * @type {number}
     * @memberof V1GetBestSearcherValidationMetricResponse
     */
    metric?: number;
}

/**
 * Response to GetCheckpointRequest.
 * @export
 * @interface V1GetCheckpointResponse
 */
export interface V1GetCheckpointResponse {
    /**
     * The requested checkpoint.
     * @type {V1Checkpoint}
     * @memberof V1GetCheckpointResponse
     */
    checkpoint?: V1Checkpoint;
}

/**
 * Response to GetCommandRequest.
 * @export
 * @interface V1GetCommandResponse
 */
export interface V1GetCommandResponse {
    /**
     * The requested command.
     * @type {V1Command}
     * @memberof V1GetCommandResponse
     */
    command?: V1Command;
    /**
     * The command config.
     * @type {any}
     * @memberof V1GetCommandResponse
     */
    config?: any;
}

/**
 * Sorts commands by the given field.   - SORT_BY_UNSPECIFIED: Returns commands in an unsorted list.  - SORT_BY_ID: Returns commands sorted by id.  - SORT_BY_DESCRIPTION: Returns commands sorted by description.  - SORT_BY_START_TIME: Return commands sorted by start time.
 * @export
 * @enum {string}
 */
export enum V1GetCommandsRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    ID = <any> 'SORT_BY_ID',
    DESCRIPTION = <any> 'SORT_BY_DESCRIPTION',
    STARTTIME = <any> 'SORT_BY_START_TIME'
}

/**
 * Response to GetCommandsRequest.
 * @export
 * @interface V1GetCommandsResponse
 */
export interface V1GetCommandsResponse {
    /**
     * The list of returned commands.
     * @type {Array<V1Command>}
     * @memberof V1GetCommandsResponse
     */
    commands?: Array<V1Command>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetCommandsResponse
     */
    pagination?: V1Pagination;
}

/**
 * 
 * @export
 * @interface V1GetCurrentTrialSearcherOperationResponse
 */
export interface V1GetCurrentTrialSearcherOperationResponse {
    /**
     * The current searcher operation.
     * @type {V1SearcherOperation}
     * @memberof V1GetCurrentTrialSearcherOperationResponse
     */
    op?: V1SearcherOperation;
    /**
     * The status of the searcher operation.
     * @type {boolean}
     * @memberof V1GetCurrentTrialSearcherOperationResponse
     */
    completed?: boolean;
}

/**
 * Sorts checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_TRIAL_ID: Returns checkpoints sorted by trial id.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_START_TIME: Returns checkpoints sorted by start time.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_VALIDATION_STATE: Returns checkpoints sorted by validation state.  - SORT_BY_STATE: Returns checkpoints sorted by state.  - SORT_BY_SEARCHER_METRIC: Returns checkpoints sorted by the experiment's `searcher.metric` configuration setting.
 * @export
 * @enum {string}
 */
export enum V1GetExperimentCheckpointsRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    UUID = <any> 'SORT_BY_UUID',
    TRIALID = <any> 'SORT_BY_TRIAL_ID',
    BATCHNUMBER = <any> 'SORT_BY_BATCH_NUMBER',
    STARTTIME = <any> 'SORT_BY_START_TIME',
    ENDTIME = <any> 'SORT_BY_END_TIME',
    VALIDATIONSTATE = <any> 'SORT_BY_VALIDATION_STATE',
    STATE = <any> 'SORT_BY_STATE',
    SEARCHERMETRIC = <any> 'SORT_BY_SEARCHER_METRIC'
}

/**
 * Response to GetExperimentCheckpointsRequest.
 * @export
 * @interface V1GetExperimentCheckpointsResponse
 */
export interface V1GetExperimentCheckpointsResponse {
    /**
     * The list of returned checkpoints.
     * @type {Array<V1Checkpoint>}
     * @memberof V1GetExperimentCheckpointsResponse
     */
    checkpoints?: Array<V1Checkpoint>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetExperimentCheckpointsResponse
     */
    pagination?: V1Pagination;
}

/**
 * Response to GetExperimentsLabelsRequest.
 * @export
 * @interface V1GetExperimentLabelsResponse
 */
export interface V1GetExperimentLabelsResponse {
    /**
     * The list of labels used across all experiments.
     * @type {Array<string>}
     * @memberof V1GetExperimentLabelsResponse
     */
    labels?: Array<string>;
}

/**
 * Response to GetExperimentRequest.
 * @export
 * @interface V1GetExperimentResponse
 */
export interface V1GetExperimentResponse {
    /**
     * The requested experiment.
     * @type {V1Experiment}
     * @memberof V1GetExperimentResponse
     */
    experiment: V1Experiment;
    /**
     * The experiment config.
     * @type {any}
     * @memberof V1GetExperimentResponse
     */
    config: any;
}

/**
 * Sorts trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by `searcher.metric` in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.
 * @export
 * @enum {string}
 */
export enum V1GetExperimentTrialsRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    ID = <any> 'SORT_BY_ID',
    STARTTIME = <any> 'SORT_BY_START_TIME',
    ENDTIME = <any> 'SORT_BY_END_TIME',
    STATE = <any> 'SORT_BY_STATE',
    BESTVALIDATIONMETRIC = <any> 'SORT_BY_BEST_VALIDATION_METRIC',
    LATESTVALIDATIONMETRIC = <any> 'SORT_BY_LATEST_VALIDATION_METRIC',
    BATCHESPROCESSED = <any> 'SORT_BY_BATCHES_PROCESSED',
    DURATION = <any> 'SORT_BY_DURATION'
}

/**
 * Response to GetExperimentTrialsRequest.
 * @export
 * @interface V1GetExperimentTrialsResponse
 */
export interface V1GetExperimentTrialsResponse {
    /**
     * The list of returned trials.
     * @type {Array<Trialv1Trial>}
     * @memberof V1GetExperimentTrialsResponse
     */
    trials: Array<Trialv1Trial>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetExperimentTrialsResponse
     */
    pagination: V1Pagination;
}

/**
 * Response to GetExperimentValidationHistoryRequest.
 * @export
 * @interface V1GetExperimentValidationHistoryResponse
 */
export interface V1GetExperimentValidationHistoryResponse {
    /**
     * validation_history is a collection of zero or more validation metrics for an experiment, describing the best metrics as they were reported through the lifetime of an experiment. The historical list of best validations.
     * @type {Array<V1ValidationHistoryEntry>}
     * @memberof V1GetExperimentValidationHistoryResponse
     */
    validationHistory?: Array<V1ValidationHistoryEntry>;
}

/**
 * Sorts experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end_time are returned after the ones with end_time.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.  - SORT_BY_NAME: Returns experiments sorted by name.
 * @export
 * @enum {string}
 */
export enum V1GetExperimentsRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    ID = <any> 'SORT_BY_ID',
    DESCRIPTION = <any> 'SORT_BY_DESCRIPTION',
    STARTTIME = <any> 'SORT_BY_START_TIME',
    ENDTIME = <any> 'SORT_BY_END_TIME',
    STATE = <any> 'SORT_BY_STATE',
    NUMTRIALS = <any> 'SORT_BY_NUM_TRIALS',
    PROGRESS = <any> 'SORT_BY_PROGRESS',
    USER = <any> 'SORT_BY_USER',
    NAME = <any> 'SORT_BY_NAME'
}

/**
 * Response to GetExperimentsRequest.
 * @export
 * @interface V1GetExperimentsResponse
 */
export interface V1GetExperimentsResponse {
    /**
     * The list of returned experiments.
     * @type {Array<V1Experiment>}
     * @memberof V1GetExperimentsResponse
     */
    experiments: Array<V1Experiment>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetExperimentsResponse
     */
    pagination: V1Pagination;
}

/**
 * 
 * @export
 * @interface V1GetHPImportanceResponse
 */
export interface V1GetHPImportanceResponse {
    /**
     * A map of training metric names to their respective entries.
     * @type {{ [key: string]: GetHPImportanceResponseMetricHPImportance; }}
     * @memberof V1GetHPImportanceResponse
     */
    trainingMetrics: { [key: string]: GetHPImportanceResponseMetricHPImportance; };
    /**
     * A map of validation metric names to their respective entries.
     * @type {{ [key: string]: GetHPImportanceResponseMetricHPImportance; }}
     * @memberof V1GetHPImportanceResponse
     */
    validationMetrics: { [key: string]: GetHPImportanceResponseMetricHPImportance; };
}

/**
 * Response to GetMasterRequest.
 * @export
 * @interface V1GetMasterConfigResponse
 */
export interface V1GetMasterConfigResponse {
    /**
     * The config file loaded by the master.
     * @type {any}
     * @memberof V1GetMasterConfigResponse
     */
    config: any;
}

/**
 * Response to GetMasterRequest.
 * @export
 * @interface V1GetMasterResponse
 */
export interface V1GetMasterResponse {
    /**
     * The current version of the master.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    version: string;
    /**
     * The current instance id of the master.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    masterId: string;
    /**
     * The global cluster id of the master.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    clusterId: string;
    /**
     * The cluster name.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    clusterName: string;
    /**
     * Telemetry status.
     * @type {boolean}
     * @memberof V1GetMasterResponse
     */
    telemetryEnabled?: boolean;
    /**
     * SSO providers.
     * @type {Array<V1SSOProvider>}
     * @memberof V1GetMasterResponse
     */
    ssoProviders?: Array<V1SSOProvider>;
    /**
     * Redirect for starting internal sessions..
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    externalLoginUri?: string;
    /**
     * Redirect for ending external sessions.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    externalLogoutUri?: string;
    /**
     * Branding style to use on front-end.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    branding?: string;
}

/**
 * Response to GetModelDefRequest.
 * @export
 * @interface V1GetModelDefResponse
 */
export interface V1GetModelDefResponse {
    /**
     * The base64-encoded, gzipped, tarball.
     * @type {string}
     * @memberof V1GetModelDefResponse
     */
    b64Tgz: string;
}

/**
 * Response to GetModelRequest.
 * @export
 * @interface V1GetModelResponse
 */
export interface V1GetModelResponse {
    /**
     * The model requested.
     * @type {V1Model}
     * @memberof V1GetModelResponse
     */
    model?: V1Model;
}

/**
 * Response for GetModelVersionRequest.
 * @export
 * @interface V1GetModelVersionResponse
 */
export interface V1GetModelVersionResponse {
    /**
     * The model version requested.
     * @type {V1ModelVersion}
     * @memberof V1GetModelVersionResponse
     */
    modelVersion?: V1ModelVersion;
}

/**
 * Sort models by the given field.   - SORT_BY_UNSPECIFIED: Returns model versions in an unsorted list.  - SORT_BY_VERSION: Returns model versions sorted by version number.  - SORT_BY_CREATION_TIME: Returns model versions sorted by creation_time.
 * @export
 * @enum {string}
 */
export enum V1GetModelVersionsRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    VERSION = <any> 'SORT_BY_VERSION',
    CREATIONTIME = <any> 'SORT_BY_CREATION_TIME'
}

/**
 * Response for GetModelVersionRequest.
 * @export
 * @interface V1GetModelVersionsResponse
 */
export interface V1GetModelVersionsResponse {
    /**
     * The model requested.
     * @type {V1Model}
     * @memberof V1GetModelVersionsResponse
     */
    model?: V1Model;
    /**
     * The list of returned model versions.
     * @type {Array<V1ModelVersion>}
     * @memberof V1GetModelVersionsResponse
     */
    modelVersions?: Array<V1ModelVersion>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetModelVersionsResponse
     */
    pagination?: V1Pagination;
}

/**
 * Sort models by the given field.   - SORT_BY_UNSPECIFIED: Returns models in an unsorted list.  - SORT_BY_NAME: Returns models sorted by name.  - SORT_BY_DESCRIPTION: Returns models sorted by description.  - SORT_BY_CREATION_TIME: Returns models sorted by creation time.  - SORT_BY_LAST_UPDATED_TIME: Returns models sorted by last updated time.  - SORT_BY_NUM_VERSIONS: Returns models sorted by number of version.
 * @export
 * @enum {string}
 */
export enum V1GetModelsRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    NAME = <any> 'SORT_BY_NAME',
    DESCRIPTION = <any> 'SORT_BY_DESCRIPTION',
    CREATIONTIME = <any> 'SORT_BY_CREATION_TIME',
    LASTUPDATEDTIME = <any> 'SORT_BY_LAST_UPDATED_TIME',
    NUMVERSIONS = <any> 'SORT_BY_NUM_VERSIONS'
}

/**
 * Response to GetModelsRequest.
 * @export
 * @interface V1GetModelsResponse
 */
export interface V1GetModelsResponse {
    /**
     * The list of returned models.
     * @type {Array<V1Model>}
     * @memberof V1GetModelsResponse
     */
    models: Array<V1Model>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetModelsResponse
     */
    pagination: V1Pagination;
}

/**
 * Response to GetNotebookRequest.
 * @export
 * @interface V1GetNotebookResponse
 */
export interface V1GetNotebookResponse {
    /**
     * The requested notebook.
     * @type {V1Notebook}
     * @memberof V1GetNotebookResponse
     */
    notebook?: V1Notebook;
    /**
     * The notebook config.
     * @type {any}
     * @memberof V1GetNotebookResponse
     */
    config?: any;
}

/**
 * Sorts notebooks by the given field.   - SORT_BY_UNSPECIFIED: Returns notebooks in an unsorted list.  - SORT_BY_ID: Returns notebooks sorted by id.  - SORT_BY_DESCRIPTION: Returns notebooks sorted by description.  - SORT_BY_START_TIME: Return notebooks sorted by start time.
 * @export
 * @enum {string}
 */
export enum V1GetNotebooksRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    ID = <any> 'SORT_BY_ID',
    DESCRIPTION = <any> 'SORT_BY_DESCRIPTION',
    STARTTIME = <any> 'SORT_BY_START_TIME'
}

/**
 * Response to GetNotebooksRequest.
 * @export
 * @interface V1GetNotebooksResponse
 */
export interface V1GetNotebooksResponse {
    /**
     * The list of returned notebooks.
     * @type {Array<V1Notebook>}
     * @memberof V1GetNotebooksResponse
     */
    notebooks?: Array<V1Notebook>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetNotebooksResponse
     */
    pagination?: V1Pagination;
}

/**
 * Response to GetResourcePoolsRequest.
 * @export
 * @interface V1GetResourcePoolsResponse
 */
export interface V1GetResourcePoolsResponse {
    /**
     * The list of returned resource pools.
     * @type {Array<V1ResourcePool>}
     * @memberof V1GetResourcePoolsResponse
     */
    resourcePools?: Array<V1ResourcePool>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetResourcePoolsResponse
     */
    pagination?: V1Pagination;
}

/**
 * Response to GetShellRequest.
 * @export
 * @interface V1GetShellResponse
 */
export interface V1GetShellResponse {
    /**
     * The requested shell.
     * @type {V1Shell}
     * @memberof V1GetShellResponse
     */
    shell?: V1Shell;
    /**
     * The shell config.
     * @type {any}
     * @memberof V1GetShellResponse
     */
    config?: any;
}

/**
 * Sorts shells by the given field.   - SORT_BY_UNSPECIFIED: Returns shells in an unsorted list.  - SORT_BY_ID: Returns shells sorted by id.  - SORT_BY_DESCRIPTION: Returns shells sorted by description.  - SORT_BY_START_TIME: Return shells sorted by start time.
 * @export
 * @enum {string}
 */
export enum V1GetShellsRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    ID = <any> 'SORT_BY_ID',
    DESCRIPTION = <any> 'SORT_BY_DESCRIPTION',
    STARTTIME = <any> 'SORT_BY_START_TIME'
}

/**
 * Response to GetShellsRequest.
 * @export
 * @interface V1GetShellsResponse
 */
export interface V1GetShellsResponse {
    /**
     * The list of returned shells.
     * @type {Array<V1Shell>}
     * @memberof V1GetShellsResponse
     */
    shells?: Array<V1Shell>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetShellsResponse
     */
    pagination?: V1Pagination;
}

/**
 * Response to GetSlotRequest.
 * @export
 * @interface V1GetSlotResponse
 */
export interface V1GetSlotResponse {
    /**
     * The requested slot.
     * @type {V1Slot}
     * @memberof V1GetSlotResponse
     */
    slot?: V1Slot;
}

/**
 * Response to GetSlotsRequest.
 * @export
 * @interface V1GetSlotsResponse
 */
export interface V1GetSlotsResponse {
    /**
     * The requested slots.
     * @type {Array<V1Slot>}
     * @memberof V1GetSlotsResponse
     */
    slots?: Array<V1Slot>;
}

/**
 * Response to GetTelemetryRequest.
 * @export
 * @interface V1GetTelemetryResponse
 */
export interface V1GetTelemetryResponse {
    /**
     * Whether telemetry is enabled or not.
     * @type {boolean}
     * @memberof V1GetTelemetryResponse
     */
    enabled: boolean;
    /**
     * The key used for analytics in the UI.
     * @type {string}
     * @memberof V1GetTelemetryResponse
     */
    segmentKey?: string;
}

/**
 * Response to GetTemplateRequest.
 * @export
 * @interface V1GetTemplateResponse
 */
export interface V1GetTemplateResponse {
    /**
     * The requested template.
     * @type {V1Template}
     * @memberof V1GetTemplateResponse
     */
    template?: V1Template;
}

/**
 * Sorts templates by the given field.   - SORT_BY_UNSPECIFIED: Returns templates in an unsorted list.  - SORT_BY_NAME: Returns templates sorted by name.
 * @export
 * @enum {string}
 */
export enum V1GetTemplatesRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    NAME = <any> 'SORT_BY_NAME'
}

/**
 * Response to GetTemplatesRequest.
 * @export
 * @interface V1GetTemplatesResponse
 */
export interface V1GetTemplatesResponse {
    /**
     * the list of requested templates.
     * @type {Array<V1Template>}
     * @memberof V1GetTemplatesResponse
     */
    templates?: Array<V1Template>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetTemplatesResponse
     */
    pagination?: V1Pagination;
}

/**
 * Response to GetTensorboardRequest.
 * @export
 * @interface V1GetTensorboardResponse
 */
export interface V1GetTensorboardResponse {
    /**
     * The requested tensorboard.
     * @type {V1Tensorboard}
     * @memberof V1GetTensorboardResponse
     */
    tensorboard?: V1Tensorboard;
    /**
     * 
     * @type {any}
     * @memberof V1GetTensorboardResponse
     */
    config?: any;
}

/**
 * Sorts tensorboards by the given field.   - SORT_BY_UNSPECIFIED: Returns tensorboards in an unsorted list.  - SORT_BY_ID: Returns tensorboards sorted by id.  - SORT_BY_DESCRIPTION: Returns tensorboards sorted by description.  - SORT_BY_START_TIME: Return tensorboards sorted by start time.
 * @export
 * @enum {string}
 */
export enum V1GetTensorboardsRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    ID = <any> 'SORT_BY_ID',
    DESCRIPTION = <any> 'SORT_BY_DESCRIPTION',
    STARTTIME = <any> 'SORT_BY_START_TIME'
}

/**
 * Response to GetTensorboardsRequest.
 * @export
 * @interface V1GetTensorboardsResponse
 */
export interface V1GetTensorboardsResponse {
    /**
     * The list of returned tensorboards.
     * @type {Array<V1Tensorboard>}
     * @memberof V1GetTensorboardsResponse
     */
    tensorboards?: Array<V1Tensorboard>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetTensorboardsResponse
     */
    pagination?: V1Pagination;
}

/**
 * Sorts checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_START_TIME: Returns checkpoints sorted by start time.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_VALIDATION_STATE: Returns checkpoints sorted by validation state.  - SORT_BY_STATE: Returns checkpoints sorted by state.
 * @export
 * @enum {string}
 */
export enum V1GetTrialCheckpointsRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    UUID = <any> 'SORT_BY_UUID',
    BATCHNUMBER = <any> 'SORT_BY_BATCH_NUMBER',
    STARTTIME = <any> 'SORT_BY_START_TIME',
    ENDTIME = <any> 'SORT_BY_END_TIME',
    VALIDATIONSTATE = <any> 'SORT_BY_VALIDATION_STATE',
    STATE = <any> 'SORT_BY_STATE'
}

/**
 * Response to GetTrialCheckpointsRequest.
 * @export
 * @interface V1GetTrialCheckpointsResponse
 */
export interface V1GetTrialCheckpointsResponse {
    /**
     * The list of returned checkpoints.
     * @type {Array<V1Checkpoint>}
     * @memberof V1GetTrialCheckpointsResponse
     */
    checkpoints?: Array<V1Checkpoint>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetTrialCheckpointsResponse
     */
    pagination?: V1Pagination;
}

/**
 * Response to TrialProfilerAvailableSeriesRequest.
 * @export
 * @interface V1GetTrialProfilerAvailableSeriesResponse
 */
export interface V1GetTrialProfilerAvailableSeriesResponse {
    /**
     * The labels for the series.
     * @type {Array<V1TrialProfilerMetricLabels>}
     * @memberof V1GetTrialProfilerAvailableSeriesResponse
     */
    labels: Array<V1TrialProfilerMetricLabels>;
}

/**
 * 
 * @export
 * @interface V1GetTrialProfilerMetricsResponse
 */
export interface V1GetTrialProfilerMetricsResponse {
    /**
     * A batch matching the series requested.
     * @type {V1TrialProfilerMetricsBatch}
     * @memberof V1GetTrialProfilerMetricsResponse
     */
    batch: V1TrialProfilerMetricsBatch;
}

/**
 * Response to GetTrialRequest.
 * @export
 * @interface V1GetTrialResponse
 */
export interface V1GetTrialResponse {
    /**
     * The requested trial.
     * @type {Trialv1Trial}
     * @memberof V1GetTrialResponse
     */
    trial: Trialv1Trial;
    /**
     * Trial workloads.
     * @type {Array<GetTrialResponseWorkloadContainer>}
     * @memberof V1GetTrialResponse
     */
    workloads?: Array<GetTrialResponseWorkloadContainer>;
}

/**
 * Response to GetUserRequest.
 * @export
 * @interface V1GetUserResponse
 */
export interface V1GetUserResponse {
    /**
     * The requested user.
     * @type {V1User}
     * @memberof V1GetUserResponse
     */
    user?: V1User;
}

/**
 * Response to GetUsersRequest.
 * @export
 * @interface V1GetUsersResponse
 */
export interface V1GetUsersResponse {
    /**
     * The list of requested users.
     * @type {Array<V1User>}
     * @memberof V1GetUsersResponse
     */
    users?: Array<V1User>;
}

/**
 * Kill the requested notebook if idle.
 * @export
 * @interface V1IdleNotebookRequest
 */
export interface V1IdleNotebookRequest {
    /**
     * The id of the notebook.
     * @type {string}
     * @memberof V1IdleNotebookRequest
     */
    notebookId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1IdleNotebookRequest
     */
    idle?: boolean;
}

/**
 * Response to IdleNotebookRequest.
 * @export
 * @interface V1IdleNotebookResponse
 */
export interface V1IdleNotebookResponse {
}

/**
 * Response to KillCommandRequest.
 * @export
 * @interface V1KillCommandResponse
 */
export interface V1KillCommandResponse {
    /**
     * The requested command.
     * @type {V1Command}
     * @memberof V1KillCommandResponse
     */
    command?: V1Command;
}

/**
 * Response to KillExperimentRequest.
 * @export
 * @interface V1KillExperimentResponse
 */
export interface V1KillExperimentResponse {
}

/**
 * Response to KillNotebookRequest.
 * @export
 * @interface V1KillNotebookResponse
 */
export interface V1KillNotebookResponse {
    /**
     * The requested notebook.
     * @type {V1Notebook}
     * @memberof V1KillNotebookResponse
     */
    notebook?: V1Notebook;
}

/**
 * Response to KillShellRequest.
 * @export
 * @interface V1KillShellResponse
 */
export interface V1KillShellResponse {
    /**
     * The requested shell.
     * @type {V1Shell}
     * @memberof V1KillShellResponse
     */
    shell?: V1Shell;
}

/**
 * Response to KillTensorboardRequest.
 * @export
 * @interface V1KillTensorboardResponse
 */
export interface V1KillTensorboardResponse {
    /**
     * The requested tensorboard.
     * @type {V1Tensorboard}
     * @memberof V1KillTensorboardResponse
     */
    tensorboard?: V1Tensorboard;
}

/**
 * Response to KillTrialRequest.
 * @export
 * @interface V1KillTrialResponse
 */
export interface V1KillTrialResponse {
}

/**
 * Request to launch a command.
 * @export
 * @interface V1LaunchCommandRequest
 */
export interface V1LaunchCommandRequest {
    /**
     * Command config (JSON).
     * @type {any}
     * @memberof V1LaunchCommandRequest
     */
    config?: any;
    /**
     * Template name.
     * @type {string}
     * @memberof V1LaunchCommandRequest
     */
    templateName?: string;
    /**
     * The files to run with the command.
     * @type {Array<V1File>}
     * @memberof V1LaunchCommandRequest
     */
    files?: Array<V1File>;
    /**
     * Additional data.
     * @type {string}
     * @memberof V1LaunchCommandRequest
     */
    data?: string;
}

/**
 * Response to LaunchCommandRequest.
 * @export
 * @interface V1LaunchCommandResponse
 */
export interface V1LaunchCommandResponse {
    /**
     * The requested command.
     * @type {V1Command}
     * @memberof V1LaunchCommandResponse
     */
    command?: V1Command;
    /**
     * 
     * @type {any}
     * @memberof V1LaunchCommandResponse
     */
    config: any;
}

/**
 * Request to launch a notebook.
 * @export
 * @interface V1LaunchNotebookRequest
 */
export interface V1LaunchNotebookRequest {
    /**
     * Notebook config (JSON).
     * @type {any}
     * @memberof V1LaunchNotebookRequest
     */
    config?: any;
    /**
     * Template name.
     * @type {string}
     * @memberof V1LaunchNotebookRequest
     */
    templateName?: string;
    /**
     * The files to run with the command.
     * @type {Array<V1File>}
     * @memberof V1LaunchNotebookRequest
     */
    files?: Array<V1File>;
    /**
     * Preview a launching request without actually creating a Notebook.
     * @type {boolean}
     * @memberof V1LaunchNotebookRequest
     */
    preview?: boolean;
}

/**
 * Response to LaunchNotebookRequest.
 * @export
 * @interface V1LaunchNotebookResponse
 */
export interface V1LaunchNotebookResponse {
    /**
     * The requested notebook.
     * @type {V1Notebook}
     * @memberof V1LaunchNotebookResponse
     */
    notebook: V1Notebook;
    /**
     * 
     * @type {any}
     * @memberof V1LaunchNotebookResponse
     */
    config: any;
}

/**
 * Request to launch a shell.
 * @export
 * @interface V1LaunchShellRequest
 */
export interface V1LaunchShellRequest {
    /**
     * Shell config (JSON).
     * @type {any}
     * @memberof V1LaunchShellRequest
     */
    config?: any;
    /**
     * Template name.
     * @type {string}
     * @memberof V1LaunchShellRequest
     */
    templateName?: string;
    /**
     * The files to run with the command.
     * @type {Array<V1File>}
     * @memberof V1LaunchShellRequest
     */
    files?: Array<V1File>;
    /**
     * Additional data.
     * @type {string}
     * @memberof V1LaunchShellRequest
     */
    data?: string;
}

/**
 * Response to LaunchShellRequest.
 * @export
 * @interface V1LaunchShellResponse
 */
export interface V1LaunchShellResponse {
    /**
     * The requested shell.
     * @type {V1Shell}
     * @memberof V1LaunchShellResponse
     */
    shell?: V1Shell;
    /**
     * 
     * @type {any}
     * @memberof V1LaunchShellResponse
     */
    config: any;
}

/**
 * Request to launch a tensorboard.
 * @export
 * @interface V1LaunchTensorboardRequest
 */
export interface V1LaunchTensorboardRequest {
    /**
     * List of source experiment ids.
     * @type {Array<number>}
     * @memberof V1LaunchTensorboardRequest
     */
    experimentIds?: Array<number>;
    /**
     * List of source trial ids.
     * @type {Array<number>}
     * @memberof V1LaunchTensorboardRequest
     */
    trialIds?: Array<number>;
    /**
     * Tensorboard config (JSON).
     * @type {any}
     * @memberof V1LaunchTensorboardRequest
     */
    config?: any;
    /**
     * Tensorboard template name.
     * @type {string}
     * @memberof V1LaunchTensorboardRequest
     */
    templateName?: string;
    /**
     * The files to run with the command.
     * @type {Array<V1File>}
     * @memberof V1LaunchTensorboardRequest
     */
    files?: Array<V1File>;
}

/**
 * Response to LaunchTensorboardRequest.
 * @export
 * @interface V1LaunchTensorboardResponse
 */
export interface V1LaunchTensorboardResponse {
    /**
     * The requested tensorboard.
     * @type {V1Tensorboard}
     * @memberof V1LaunchTensorboardResponse
     */
    tensorboard: V1Tensorboard;
    /**
     * 
     * @type {any}
     * @memberof V1LaunchTensorboardResponse
     */
    config: any;
}

/**
 * LogEntry is a log event.
 * @export
 * @interface V1LogEntry
 */
export interface V1LogEntry {
    /**
     * The id.
     * @type {number}
     * @memberof V1LogEntry
     */
    id: number;
    /**
     * The message.
     * @type {string}
     * @memberof V1LogEntry
     */
    message?: string;
    /**
     * The timestamp.
     * @type {Date}
     * @memberof V1LogEntry
     */
    timestamp?: Date;
    /**
     * The log level.
     * @type {V1LogLevel}
     * @memberof V1LogEntry
     */
    level?: V1LogLevel;
}

/**
 * LogLevel specifies the level for a log.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
 * @export
 * @enum {string}
 */
export enum V1LogLevel {
    UNSPECIFIED = <any> 'LOG_LEVEL_UNSPECIFIED',
    TRACE = <any> 'LOG_LEVEL_TRACE',
    DEBUG = <any> 'LOG_LEVEL_DEBUG',
    INFO = <any> 'LOG_LEVEL_INFO',
    WARNING = <any> 'LOG_LEVEL_WARNING',
    ERROR = <any> 'LOG_LEVEL_ERROR',
    CRITICAL = <any> 'LOG_LEVEL_CRITICAL'
}

/**
 * Login the user.
 * @export
 * @interface V1LoginRequest
 */
export interface V1LoginRequest {
    /**
     * The username of the user.
     * @type {string}
     * @memberof V1LoginRequest
     */
    username: string;
    /**
     * The password of the user.
     * @type {string}
     * @memberof V1LoginRequest
     */
    password: string;
    /**
     * Indicate whether the provided password is pre-salted & hashed or not.
     * @type {boolean}
     * @memberof V1LoginRequest
     */
    isHashed?: boolean;
}

/**
 * Response to LoginRequest.
 * @export
 * @interface V1LoginResponse
 */
export interface V1LoginResponse {
    /**
     * The token to be used when sending results.
     * @type {string}
     * @memberof V1LoginResponse
     */
    token: string;
    /**
     * The logged in user.
     * @type {V1User}
     * @memberof V1LoginResponse
     */
    user: V1User;
}

/**
 * Response to LogoutRequest.
 * @export
 * @interface V1LogoutResponse
 */
export interface V1LogoutResponse {
}

/**
 * Mark some reservation as a daemon.
 * @export
 * @interface V1MarkAllocationReservationDaemonRequest
 */
export interface V1MarkAllocationReservationDaemonRequest {
    /**
     * The allocation ID for the reservation.
     * @type {string}
     * @memberof V1MarkAllocationReservationDaemonRequest
     */
    allocationId: string;
    /**
     * The container ID for the reservation.
     * @type {string}
     * @memberof V1MarkAllocationReservationDaemonRequest
     */
    containerId: string;
}

/**
 * Response to MarkAllocationReservationDaemonRequest.
 * @export
 * @interface V1MarkAllocationReservationDaemonResponse
 */
export interface V1MarkAllocationReservationDaemonResponse {
}

/**
 * Response to MasterLogsRequest.
 * @export
 * @interface V1MasterLogsResponse
 */
export interface V1MasterLogsResponse {
    /**
     * The log entry.
     * @type {V1LogEntry}
     * @memberof V1MasterLogsResponse
     */
    logEntry?: V1LogEntry;
}

/**
 * Response to MetricBatchesRequest.
 * @export
 * @interface V1MetricBatchesResponse
 */
export interface V1MetricBatchesResponse {
    /**
     * Milestones (in batches processed) at which the specified metric is recorded.
     * @type {Array<number>}
     * @memberof V1MetricBatchesResponse
     */
    batches?: Array<number>;
}

/**
 * Response to MetricNamesRequest.
 * @export
 * @interface V1MetricNamesResponse
 */
export interface V1MetricNamesResponse {
    /**
     * The name of the searcher metric.
     * @type {string}
     * @memberof V1MetricNamesResponse
     */
    searcherMetric?: string;
    /**
     * List of training metric names.
     * @type {Array<string>}
     * @memberof V1MetricNamesResponse
     */
    trainingMetrics?: Array<string>;
    /**
     * List of validation metric names.
     * @type {Array<string>}
     * @memberof V1MetricNamesResponse
     */
    validationMetrics?: Array<string>;
}

/**
 * To distinguish the 2 different categories of metrics.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
 * @export
 * @enum {string}
 */
export enum V1MetricType {
    UNSPECIFIED = <any> 'METRIC_TYPE_UNSPECIFIED',
    TRAINING = <any> 'METRIC_TYPE_TRAINING',
    VALIDATION = <any> 'METRIC_TYPE_VALIDATION'
}

/**
 * Metrics calculated during validation.
 * @export
 * @interface V1Metrics
 */
export interface V1Metrics {
    /**
     * Number of inputs to the model.
     * @type {number}
     * @memberof V1Metrics
     */
    numInputs?: number;
    /**
     * Metrics calculated on the validation set.
     * @type {any}
     * @memberof V1Metrics
     */
    validationMetrics?: any;
}

/**
 * MetricsWorkload is a workload generating metrics.
 * @export
 * @interface V1MetricsWorkload
 */
export interface V1MetricsWorkload {
    /**
     * The time the workload finished or was stopped.
     * @type {Date}
     * @memberof V1MetricsWorkload
     */
    endTime?: Date;
    /**
     * The current validation state.
     * @type {Determinedexperimentv1State}
     * @memberof V1MetricsWorkload
     */
    state: Determinedexperimentv1State;
    /**
     * Metrics.
     * @type {any}
     * @memberof V1MetricsWorkload
     */
    metrics?: any;
    /**
     * Number of inputs processed.
     * @type {number}
     * @memberof V1MetricsWorkload
     */
    numInputs: number;
    /**
     * Total number of batches as of this workload's completion.
     * @type {number}
     * @memberof V1MetricsWorkload
     */
    totalBatches: number;
}

/**
 * Model is a named collection of model versions.
 * @export
 * @interface V1Model
 */
export interface V1Model {
    /**
     * The name of the model.
     * @type {string}
     * @memberof V1Model
     */
    name: string;
    /**
     * The description of the model.
     * @type {string}
     * @memberof V1Model
     */
    description?: string;
    /**
     * The user-defined metadata of the model.
     * @type {any}
     * @memberof V1Model
     */
    metadata: any;
    /**
     * The time the model was created.
     * @type {Date}
     * @memberof V1Model
     */
    creationTime: Date;
    /**
     * The time the model was last updated.
     * @type {Date}
     * @memberof V1Model
     */
    lastUpdatedTime: Date;
    /**
     * The id of this model.
     * @type {number}
     * @memberof V1Model
     */
    id: number;
    /**
     * The number of versions associated with this model.
     * @type {number}
     * @memberof V1Model
     */
    numVersions: number;
    /**
     * Labels associated with this model.
     * @type {Array<string>}
     * @memberof V1Model
     */
    labels?: Array<string>;
    /**
     * README for model.
     * @type {string}
     * @memberof V1Model
     */
    readme?: string;
    /**
     * User who created this model.
     * @type {string}
     * @memberof V1Model
     */
    username: string;
    /**
     * Whether this model is archived or not.
     * @type {boolean}
     * @memberof V1Model
     */
    archived?: boolean;
}

/**
 * A version of a model containing a checkpoint. Users can label checkpoints as a version of a model and use the model name and version to locate a checkpoint.
 * @export
 * @interface V1ModelVersion
 */
export interface V1ModelVersion {
    /**
     * The model the version is related to.
     * @type {V1Model}
     * @memberof V1ModelVersion
     */
    model: V1Model;
    /**
     * The checkpoint of the model version.
     * @type {V1Checkpoint}
     * @memberof V1ModelVersion
     */
    checkpoint: V1Checkpoint;
    /**
     * The version number.
     * @type {number}
     * @memberof V1ModelVersion
     */
    version: number;
    /**
     * The time the model version was created.
     * @type {Date}
     * @memberof V1ModelVersion
     */
    creationTime: Date;
    /**
     * Unique id for each model version.
     * @type {number}
     * @memberof V1ModelVersion
     */
    id: number;
    /**
     * Name for this model version.
     * @type {string}
     * @memberof V1ModelVersion
     */
    name?: string;
    /**
     * Metadata associated with this model version.
     * @type {any}
     * @memberof V1ModelVersion
     */
    metadata?: any;
    /**
     * The time this model version was last updated.
     * @type {Date}
     * @memberof V1ModelVersion
     */
    lastUpdatedTime?: Date;
    /**
     * Comment associated with this model version.
     * @type {string}
     * @memberof V1ModelVersion
     */
    comment?: string;
    /**
     * Readme associated with this model version.
     * @type {string}
     * @memberof V1ModelVersion
     */
    readme?: string;
    /**
     * User who created this model version.
     * @type {string}
     * @memberof V1ModelVersion
     */
    username: string;
}

/**
 * Notebook is a Jupyter notebook in a containerized environment.
 * @export
 * @interface V1Notebook
 */
export interface V1Notebook {
    /**
     * The id of the notebook.
     * @type {string}
     * @memberof V1Notebook
     */
    id: string;
    /**
     * The description of the notebook.
     * @type {string}
     * @memberof V1Notebook
     */
    description: string;
    /**
     * The state of the notebook.
     * @type {Determinedtaskv1State}
     * @memberof V1Notebook
     */
    state: Determinedtaskv1State;
    /**
     * The time the notebook was started.
     * @type {Date}
     * @memberof V1Notebook
     */
    startTime: Date;
    /**
     * The container running the notebook.
     * @type {V1Container}
     * @memberof V1Notebook
     */
    container?: V1Container;
    /**
     * The username of the user that created the notebook.
     * @type {string}
     * @memberof V1Notebook
     */
    username: string;
    /**
     * The service address.
     * @type {string}
     * @memberof V1Notebook
     */
    serviceAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Notebook
     */
    resourcePool: string;
    /**
     * 
     * @type {string}
     * @memberof V1Notebook
     */
    exitStatus?: string;
}

/**
 * Response to NotebookLogsRequest.
 * @export
 * @interface V1NotebookLogsResponse
 */
export interface V1NotebookLogsResponse {
    /**
     * The Notebook's log entry.
     * @type {V1LogEntry}
     * @memberof V1NotebookLogsResponse
     */
    logEntry?: V1LogEntry;
}

/**
 * Order records in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
 * @export
 * @enum {string}
 */
export enum V1OrderBy {
    UNSPECIFIED = <any> 'ORDER_BY_UNSPECIFIED',
    ASC = <any> 'ORDER_BY_ASC',
    DESC = <any> 'ORDER_BY_DESC'
}

/**
 * Pagination provides information about the offset, limit, and total number of records returned in the results.
 * @export
 * @interface V1Pagination
 */
export interface V1Pagination {
    /**
     * The number of records skipped before returning results.
     * @type {number}
     * @memberof V1Pagination
     */
    offset?: number;
    /**
     * The amount of records limited in the results.
     * @type {number}
     * @memberof V1Pagination
     */
    limit?: number;
    /**
     * The index of the first record in the dataset.
     * @type {number}
     * @memberof V1Pagination
     */
    startIndex?: number;
    /**
     * The index+1 of the last record in the dataset.
     * @type {number}
     * @memberof V1Pagination
     */
    endIndex?: number;
    /**
     * The total number of values that match the filter.
     * @type {number}
     * @memberof V1Pagination
     */
    total?: number;
}

/**
 * Response to PatchExperimentRequest.
 * @export
 * @interface V1PatchExperimentResponse
 */
export interface V1PatchExperimentResponse {
    /**
     * Patched experiment.
     * @type {V1Experiment}
     * @memberof V1PatchExperimentResponse
     */
    experiment?: V1Experiment;
}

/**
 * Request for updating a model in the registry.
 * @export
 * @interface V1PatchModelRequest
 */
export interface V1PatchModelRequest {
    /**
     * The model desired model fields and values.
     * @type {V1Model}
     * @memberof V1PatchModelRequest
     */
    model?: V1Model;
}

/**
 * Response to PatchModelRequest.
 * @export
 * @interface V1PatchModelResponse
 */
export interface V1PatchModelResponse {
    /**
     * The model created.
     * @type {V1Model}
     * @memberof V1PatchModelResponse
     */
    model?: V1Model;
}

/**
 * Response to PauseExperimentRequest.
 * @export
 * @interface V1PauseExperimentResponse
 */
export interface V1PauseExperimentResponse {
}

/**
 * Request for updating a checkpoints metadata.
 * @export
 * @interface V1PostCheckpointMetadataRequest
 */
export interface V1PostCheckpointMetadataRequest {
    /**
     * The desired checkpoint fields and values.
     * @type {V1Checkpoint}
     * @memberof V1PostCheckpointMetadataRequest
     */
    checkpoint?: V1Checkpoint;
}

/**
 * Response to PostCheckpointRequest.
 * @export
 * @interface V1PostCheckpointMetadataResponse
 */
export interface V1PostCheckpointMetadataResponse {
    /**
     * The updated checkpoint.
     * @type {V1Checkpoint}
     * @memberof V1PostCheckpointMetadataResponse
     */
    checkpoint?: V1Checkpoint;
}

/**
 * Response to PostModelRequest.
 * @export
 * @interface V1PostModelResponse
 */
export interface V1PostModelResponse {
    /**
     * The model created.
     * @type {V1Model}
     * @memberof V1PostModelResponse
     */
    model?: V1Model;
}

/**
 * Request for creating a model version.
 * @export
 * @interface V1PostModelVersionRequest
 */
export interface V1PostModelVersionRequest {
    /**
     * The id of the model to add a version to.
     * @type {number}
     * @memberof V1PostModelVersionRequest
     */
    modelId?: number;
    /**
     * The checkpoint representing the new version.
     * @type {string}
     * @memberof V1PostModelVersionRequest
     */
    checkpointUuid?: string;
}

/**
 * Response for PostModelVersionRequest.
 * @export
 * @interface V1PostModelVersionResponse
 */
export interface V1PostModelVersionResponse {
    /**
     * The model version requested.
     * @type {V1ModelVersion}
     * @memberof V1PostModelVersionResponse
     */
    modelVersion?: V1ModelVersion;
}

/**
 * Create a batch of trial profiler metrics.
 * @export
 * @interface V1PostTrialProfilerMetricsBatchRequest
 */
export interface V1PostTrialProfilerMetricsBatchRequest {
    /**
     * The batches to create.
     * @type {Array<V1TrialProfilerMetricsBatch>}
     * @memberof V1PostTrialProfilerMetricsBatchRequest
     */
    batches?: Array<V1TrialProfilerMetricsBatch>;
}

/**
 * 
 * @export
 * @interface V1PostTrialProfilerMetricsBatchResponse
 */
export interface V1PostTrialProfilerMetricsBatchResponse {
}

/**
 * 
 * @export
 * @interface V1PostTrialRunnerMetadataResponse
 */
export interface V1PostTrialRunnerMetadataResponse {
}

/**
 * Create a new user.
 * @export
 * @interface V1PostUserRequest
 */
export interface V1PostUserRequest {
    /**
     * The user to create.
     * @type {V1User}
     * @memberof V1PostUserRequest
     */
    user?: V1User;
    /**
     * The password of the user.
     * @type {string}
     * @memberof V1PostUserRequest
     */
    password?: string;
}

/**
 * Response to PostUserRequest.
 * @export
 * @interface V1PostUserResponse
 */
export interface V1PostUserResponse {
    /**
     * The created user.
     * @type {V1User}
     * @memberof V1PostUserResponse
     */
    user?: V1User;
}

/**
 * Preview hyperparameter search.
 * @export
 * @interface V1PreviewHPSearchRequest
 */
export interface V1PreviewHPSearchRequest {
    /**
     * The experiment config to simulate.
     * @type {any}
     * @memberof V1PreviewHPSearchRequest
     */
    config?: any;
    /**
     * The searcher simulation seed.
     * @type {number}
     * @memberof V1PreviewHPSearchRequest
     */
    seed?: number;
}

/**
 * Response to PreviewSearchRequest.
 * @export
 * @interface V1PreviewHPSearchResponse
 */
export interface V1PreviewHPSearchResponse {
    /**
     * The resulting simulation.
     * @type {V1ExperimentSimulation}
     * @memberof V1PreviewHPSearchResponse
     */
    simulation?: V1ExperimentSimulation;
}

/**
 * Response to PutTemplateRequest.
 * @export
 * @interface V1PutTemplateResponse
 */
export interface V1PutTemplateResponse {
    /**
     * The updated or created template.
     * @type {V1Template}
     * @memberof V1PutTemplateResponse
     */
    template?: V1Template;
}

/**
 * The rendezvous info for the trial to rendezvous with sibling containers.
 * @export
 * @interface V1RendezvousInfo
 */
export interface V1RendezvousInfo {
    /**
     * The rendezvous addresses of the other containers.
     * @type {Array<string>}
     * @memberof V1RendezvousInfo
     */
    addresses: Array<string>;
    /**
     * The container rank.
     * @type {number}
     * @memberof V1RendezvousInfo
     */
    rank: number;
}

/**
 * 
 * @export
 * @interface V1ReportTrialCheckpointMetadataResponse
 */
export interface V1ReportTrialCheckpointMetadataResponse {
}

/**
 * 
 * @export
 * @interface V1ReportTrialProgressResponse
 */
export interface V1ReportTrialProgressResponse {
}

/**
 * 
 * @export
 * @interface V1ReportTrialSearcherEarlyExitResponse
 */
export interface V1ReportTrialSearcherEarlyExitResponse {
}

/**
 * 
 * @export
 * @interface V1ReportTrialTrainingMetricsResponse
 */
export interface V1ReportTrialTrainingMetricsResponse {
}

/**
 * 
 * @export
 * @interface V1ReportTrialValidationMetricsResponse
 */
export interface V1ReportTrialValidationMetricsResponse {
}

/**
 * One instance of slots in the cluster being allocated to a task during a period (aggregated).
 * @export
 * @interface V1ResourceAllocationAggregatedEntry
 */
export interface V1ResourceAllocationAggregatedEntry {
    /**
     * The date of this entry.
     * @type {string}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    periodStart: string;
    /**
     * The period over which aggregation occurred.
     * @type {V1ResourceAllocationAggregationPeriod}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    period: V1ResourceAllocationAggregationPeriod;
    /**
     * The total number of seconds included in this allocation entry.
     * @type {number}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    seconds: number;
    /**
     * The seconds in the cluster used by experiments belonging to each user.
     * @type {{ [key: string]: number; }}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    byUsername: { [key: string]: number; };
    /**
     * The seconds in the cluster used by experiments labeled with each label.
     * @type {{ [key: string]: number; }}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    byExperimentLabel: { [key: string]: number; };
    /**
     * The seconds in the cluster used by experiments assigned to each resource pool.
     * @type {{ [key: string]: number; }}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    byResourcePool: { [key: string]: number; };
    /**
     * The seconds in the cluster used by experiments assigned to each agent label.
     * @type {{ [key: string]: number; }}
     * @memberof V1ResourceAllocationAggregatedEntry
     */
    byAgentLabel: { [key: string]: number; };
}

/**
 * Response to ResourceAllocationAggregatedRequest.
 * @export
 * @interface V1ResourceAllocationAggregatedResponse
 */
export interface V1ResourceAllocationAggregatedResponse {
    /**
     * An entry summarizing one workload.
     * @type {Array<V1ResourceAllocationAggregatedEntry>}
     * @memberof V1ResourceAllocationAggregatedResponse
     */
    resourceEntries: Array<V1ResourceAllocationAggregatedEntry>;
}

/**
 * The period over which to perform aggregation.   - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
 * @export
 * @enum {string}
 */
export enum V1ResourceAllocationAggregationPeriod {
    UNSPECIFIED = <any> 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED',
    DAILY = <any> 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY',
    MONTHLY = <any> 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY'
}

/**
 * One instance of slots in the cluster being allocated to a task.
 * @export
 * @interface V1ResourceAllocationRawEntry
 */
export interface V1ResourceAllocationRawEntry {
    /**
     * The kind of workload being run during this allocation (training, checkpoint, or validation).
     * @type {string}
     * @memberof V1ResourceAllocationRawEntry
     */
    kind?: string;
    /**
     * The time at which the allocation began.
     * @type {Date}
     * @memberof V1ResourceAllocationRawEntry
     */
    startTime?: Date;
    /**
     * The time at which the allocation ended.
     * @type {Date}
     * @memberof V1ResourceAllocationRawEntry
     */
    endTime?: Date;
    /**
     * The ID of the experiment the allocation is a part of.
     * @type {number}
     * @memberof V1ResourceAllocationRawEntry
     */
    experimentId?: number;
    /**
     * The username of the user who ran the experiment.
     * @type {string}
     * @memberof V1ResourceAllocationRawEntry
     */
    username?: string;
    /**
     * The labels assigned to the experiment.
     * @type {Array<string>}
     * @memberof V1ResourceAllocationRawEntry
     */
    labels?: Array<string>;
    /**
     * The number of seconds for which the allocation was active during the requested period.
     * @type {number}
     * @memberof V1ResourceAllocationRawEntry
     */
    seconds?: number;
    /**
     * The number of slots used by the allocation.
     * @type {number}
     * @memberof V1ResourceAllocationRawEntry
     */
    slots?: number;
}

/**
 * Response to ResourceAllocationRawRequest.
 * @export
 * @interface V1ResourceAllocationRawResponse
 */
export interface V1ResourceAllocationRawResponse {
    /**
     * An entry summarizing one workload.
     * @type {Array<V1ResourceAllocationRawEntry>}
     * @memberof V1ResourceAllocationRawResponse
     */
    resourceEntries?: Array<V1ResourceAllocationRawEntry>;
}

/**
 * A Resource Pool is a pool of resources where containers are run.
 * @export
 * @interface V1ResourcePool
 */
export interface V1ResourcePool {
    /**
     * The unique name of the resource pool.
     * @type {string}
     * @memberof V1ResourcePool
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePool
     */
    description: string;
    /**
     * 
     * @type {V1ResourcePoolType}
     * @memberof V1ResourcePool
     */
    type: V1ResourcePoolType;
    /**
     * 
     * @type {number}
     * @memberof V1ResourcePool
     */
    numAgents: number;
    /**
     * 
     * @type {number}
     * @memberof V1ResourcePool
     */
    slotsAvailable: number;
    /**
     * 
     * @type {number}
     * @memberof V1ResourcePool
     */
    slotsUsed: number;
    /**
     * Slot device type: cpu, gpu, ...
     * @type {Devicev1Type}
     * @memberof V1ResourcePool
     */
    slotType: Devicev1Type;
    /**
     * 
     * @type {number}
     * @memberof V1ResourcePool
     */
    auxContainerCapacity: number;
    /**
     * 
     * @type {number}
     * @memberof V1ResourcePool
     */
    auxContainersRunning: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1ResourcePool
     */
    defaultComputePool: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1ResourcePool
     */
    defaultAuxPool: boolean;
    /**
     * Is this resource pool using preemptible/spot instances? Only meaningful in an AWS or GCP resource pool.
     * @type {boolean}
     * @memberof V1ResourcePool
     */
    preemptible: boolean;
    /**
     * When using dynamic agents, the minimum number of agents that can exist in the resource pool.
     * @type {number}
     * @memberof V1ResourcePool
     */
    minAgents: number;
    /**
     * When using dynamic agents, the maximum number of agents that can exist in the resource pool.
     * @type {number}
     * @memberof V1ResourcePool
     */
    maxAgents: number;
    /**
     * The number of slots that exists on an dynamic agent.
     * @type {number}
     * @memberof V1ResourcePool
     */
    slotsPerAgent?: number;
    /**
     * 
     * @type {number}
     * @memberof V1ResourcePool
     */
    auxContainerCapacityPerAgent: number;
    /**
     * 
     * @type {V1SchedulerType}
     * @memberof V1ResourcePool
     */
    schedulerType: V1SchedulerType;
    /**
     * The fitting policy of the scheduler.
     * @type {V1FittingPolicy}
     * @memberof V1ResourcePool
     */
    schedulerFittingPolicy: V1FittingPolicy;
    /**
     * The location of the resource pool. For AWS this returns the region and for GCP this return the zone.
     * @type {string}
     * @memberof V1ResourcePool
     */
    location: string;
    /**
     * The VM image used for the agents when using dynamic agents.
     * @type {string}
     * @memberof V1ResourcePool
     */
    imageId: string;
    /**
     * The instance type of the agents when using dynamic agents. For AWS this is the Instance Type. For GCP this is the machine type combined with the number and types of GPUs. To work with this data programattically, we recommend working with the ResourcePool.details.aws.instanceType and ResourcePool.details.gcp.machineType/gpuType/gpuNum.
     * @type {string}
     * @memberof V1ResourcePool
     */
    instanceType: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePool
     */
    masterUrl: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePool
     */
    masterCertName: string;
    /**
     * The startup script for the agent. This runs on the node the agent runs on.
     * @type {string}
     * @memberof V1ResourcePool
     */
    startupScript: string;
    /**
     * The startup script for the agent's container. This runs in the container determined-agent runs in.
     * @type {string}
     * @memberof V1ResourcePool
     */
    containerStartupScript: string;
    /**
     * The Docker network to use for the agent when using dynamic agents.
     * @type {string}
     * @memberof V1ResourcePool
     */
    agentDockerNetwork: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePool
     */
    agentDockerRuntime: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePool
     */
    agentDockerImage: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePool
     */
    agentFluentImage: string;
    /**
     * The maximum idle period of agents in seconds. The master waits for this period of time before shutting down idle agents.
     * @type {number}
     * @memberof V1ResourcePool
     */
    maxIdleAgentPeriod: number;
    /**
     * The maximum starting period of agents in seconds. The master waits for this period of time for starting agents before retrying.
     * @type {number}
     * @memberof V1ResourcePool
     */
    maxAgentStartingPeriod: number;
    /**
     * 
     * @type {V1ResourcePoolDetail}
     * @memberof V1ResourcePool
     */
    details: V1ResourcePoolDetail;
}

/**
 * 
 * @export
 * @interface V1ResourcePoolAwsDetail
 */
export interface V1ResourcePoolAwsDetail {
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    region: string;
    /**
     * 
     * @type {number}
     * @memberof V1ResourcePoolAwsDetail
     */
    rootVolumeSize: number;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    imageId: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    tagKey: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    tagValue: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    instanceName: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    sshKeyName: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1ResourcePoolAwsDetail
     */
    publicIp: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    subnetId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    securityGroupId: string;
    /**
     * The Amazon Resource Name (ARN) of the IAM instance profile to attach to the agent instances.
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    iamInstanceProfileArn: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    instanceType?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    logGroup?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    logStream?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1ResourcePoolAwsDetail
     */
    spotEnabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolAwsDetail
     */
    spotMaxPrice?: string;
    /**
     * 
     * @type {Array<V1AwsCustomTag>}
     * @memberof V1ResourcePoolAwsDetail
     */
    customTags?: Array<V1AwsCustomTag>;
}

/**
 * 
 * @export
 * @interface V1ResourcePoolDetail
 */
export interface V1ResourcePoolDetail {
    /**
     * 
     * @type {V1ResourcePoolAwsDetail}
     * @memberof V1ResourcePoolDetail
     */
    aws?: V1ResourcePoolAwsDetail;
    /**
     * 
     * @type {V1ResourcePoolGcpDetail}
     * @memberof V1ResourcePoolDetail
     */
    gcp?: V1ResourcePoolGcpDetail;
    /**
     * 
     * @type {V1ResourcePoolPrioritySchedulerDetail}
     * @memberof V1ResourcePoolDetail
     */
    priorityScheduler?: V1ResourcePoolPrioritySchedulerDetail;
}

/**
 * 
 * @export
 * @interface V1ResourcePoolGcpDetail
 */
export interface V1ResourcePoolGcpDetail {
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    project: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    zone: string;
    /**
     * 
     * @type {number}
     * @memberof V1ResourcePoolGcpDetail
     */
    bootDiskSize: number;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    bootDiskSourceImage: string;
    /**
     * Key for labeling the Determined agent instances.
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    labelKey: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    labelValue: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    namePrefix: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    network: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    subnetwork?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1ResourcePoolGcpDetail
     */
    externalIp: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ResourcePoolGcpDetail
     */
    networkTags?: Array<string>;
    /**
     * Email of the service account for the Determined agent instances.
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    serviceAccountEmail: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ResourcePoolGcpDetail
     */
    serviceAccountScopes: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    machineType: string;
    /**
     * 
     * @type {string}
     * @memberof V1ResourcePoolGcpDetail
     */
    gpuType: string;
    /**
     * 
     * @type {number}
     * @memberof V1ResourcePoolGcpDetail
     */
    gpuNum: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1ResourcePoolGcpDetail
     */
    preemptible: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1ResourcePoolGcpDetail
     */
    operationTimeoutPeriod: number;
}

/**
 * 
 * @export
 * @interface V1ResourcePoolPrioritySchedulerDetail
 */
export interface V1ResourcePoolPrioritySchedulerDetail {
    /**
     * 
     * @type {boolean}
     * @memberof V1ResourcePoolPrioritySchedulerDetail
     */
    preemption: boolean;
    /**
     * The priority that is assigned to tasks that do not explicitly specify a priority.
     * @type {number}
     * @memberof V1ResourcePoolPrioritySchedulerDetail
     */
    defaultPriority: number;
}

/**
 * The type of the ResourcePool.   - RESOURCE_POOL_TYPE_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_POOL_TYPE_AWS: An AWS resource pool.  - RESOURCE_POOL_TYPE_GCP: A GCP resource pool.  - RESOURCE_POOL_TYPE_STATIC: A static resource pool.  - RESOURCE_POOL_TYPE_K8S: The kubernetes resource pool.
 * @export
 * @enum {string}
 */
export enum V1ResourcePoolType {
    UNSPECIFIED = <any> 'RESOURCE_POOL_TYPE_UNSPECIFIED',
    AWS = <any> 'RESOURCE_POOL_TYPE_AWS',
    GCP = <any> 'RESOURCE_POOL_TYPE_GCP',
    STATIC = <any> 'RESOURCE_POOL_TYPE_STATIC',
    K8S = <any> 'RESOURCE_POOL_TYPE_K8S'
}

/**
 * RunnableOperation represents a single runnable operation emitted by a searcher.
 * @export
 * @interface V1RunnableOperation
 */
export interface V1RunnableOperation {
    /**
     * This is the type of the operation.
     * @type {V1RunnableType}
     * @memberof V1RunnableOperation
     */
    type?: V1RunnableType;
    /**
     * 
     * @type {V1TrainingLength}
     * @memberof V1RunnableOperation
     */
    length?: V1TrainingLength;
}

/**
 * RunnableType defines the type of operation that should be executed by trial runners.   - RUNNABLE_TYPE_UNSPECIFIED: Denotes an unknown runnable type.  - RUNNABLE_TYPE_TRAIN: Signals to a trial runner that it should run a train.  - RUNNABLE_TYPE_VALIDATE: Signals to a trial runner it should compute validation metrics.
 * @export
 * @enum {string}
 */
export enum V1RunnableType {
    UNSPECIFIED = <any> 'RUNNABLE_TYPE_UNSPECIFIED',
    TRAIN = <any> 'RUNNABLE_TYPE_TRAIN',
    VALIDATE = <any> 'RUNNABLE_TYPE_VALIDATE'
}

/**
 * Describe one SSO provider.
 * @export
 * @interface V1SSOProvider
 */
export interface V1SSOProvider {
    /**
     * A descriptive name for this provider.
     * @type {string}
     * @memberof V1SSOProvider
     */
    name: string;
    /**
     * The URL to use for SSO with this provider.
     * @type {string}
     * @memberof V1SSOProvider
     */
    ssoUrl: string;
}

/**
 * The type of the Scheduler.   - SCHEDULER_TYPE_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - SCHEDULER_TYPE_PRIORITY: The priority scheduler.  - SCHEDULER_TYPE_FAIR_SHARE: The fair share scheduler.  - SCHEDULER_TYPE_ROUND_ROBIN: The round robin scheduler  - SCHEDULER_TYPE_KUBERNETES: The kubernetes scheduler.
 * @export
 * @enum {string}
 */
export enum V1SchedulerType {
    UNSPECIFIED = <any> 'SCHEDULER_TYPE_UNSPECIFIED',
    PRIORITY = <any> 'SCHEDULER_TYPE_PRIORITY',
    FAIRSHARE = <any> 'SCHEDULER_TYPE_FAIR_SHARE',
    ROUNDROBIN = <any> 'SCHEDULER_TYPE_ROUND_ROBIN',
    KUBERNETES = <any> 'SCHEDULER_TYPE_KUBERNETES'
}

/**
 * SearcherOperation is an operation issued by the searcher.
 * @export
 * @interface V1SearcherOperation
 */
export interface V1SearcherOperation {
    /**
     * ValidateAfter is issued to tell a trial to train some then validate.
     * @type {V1ValidateAfterOperation}
     * @memberof V1SearcherOperation
     */
    validateAfter?: V1ValidateAfterOperation;
}

/**
 * Set the priority of the requested command.
 * @export
 * @interface V1SetCommandPriorityRequest
 */
export interface V1SetCommandPriorityRequest {
    /**
     * The id of the command.
     * @type {string}
     * @memberof V1SetCommandPriorityRequest
     */
    commandId?: string;
    /**
     * The new priority.
     * @type {number}
     * @memberof V1SetCommandPriorityRequest
     */
    priority?: number;
}

/**
 * Response to SetCommandPriorityRequest.
 * @export
 * @interface V1SetCommandPriorityResponse
 */
export interface V1SetCommandPriorityResponse {
    /**
     * The requested command.
     * @type {V1Command}
     * @memberof V1SetCommandPriorityResponse
     */
    command?: V1Command;
}

/**
 * Set the priority of the requested notebook.
 * @export
 * @interface V1SetNotebookPriorityRequest
 */
export interface V1SetNotebookPriorityRequest {
    /**
     * The id of the notebook.
     * @type {string}
     * @memberof V1SetNotebookPriorityRequest
     */
    notebookId?: string;
    /**
     * The new priority.
     * @type {number}
     * @memberof V1SetNotebookPriorityRequest
     */
    priority?: number;
}

/**
 * Response to SetNotebookPriorityRequest.
 * @export
 * @interface V1SetNotebookPriorityResponse
 */
export interface V1SetNotebookPriorityResponse {
    /**
     * The requested notebook.
     * @type {V1Notebook}
     * @memberof V1SetNotebookPriorityResponse
     */
    notebook?: V1Notebook;
}

/**
 * Set the priority of the requested shell.
 * @export
 * @interface V1SetShellPriorityRequest
 */
export interface V1SetShellPriorityRequest {
    /**
     * The id of the shell.
     * @type {string}
     * @memberof V1SetShellPriorityRequest
     */
    shellId?: string;
    /**
     * The new priority.
     * @type {number}
     * @memberof V1SetShellPriorityRequest
     */
    priority?: number;
}

/**
 * Response to SetShellPriorityRequest.
 * @export
 * @interface V1SetShellPriorityResponse
 */
export interface V1SetShellPriorityResponse {
    /**
     * The requested shell.
     * @type {V1Shell}
     * @memberof V1SetShellPriorityResponse
     */
    shell?: V1Shell;
}

/**
 * Set the priority of the requested TensorBoard.
 * @export
 * @interface V1SetTensorboardPriorityRequest
 */
export interface V1SetTensorboardPriorityRequest {
    /**
     * The id of the TensorBoard.
     * @type {string}
     * @memberof V1SetTensorboardPriorityRequest
     */
    tensorboardId?: string;
    /**
     * The new priority.
     * @type {number}
     * @memberof V1SetTensorboardPriorityRequest
     */
    priority?: number;
}

/**
 * Response to SetTensorboardPriorityRequest.
 * @export
 * @interface V1SetTensorboardPriorityResponse
 */
export interface V1SetTensorboardPriorityResponse {
    /**
     * The requested Tensorboard.
     * @type {V1Tensorboard}
     * @memberof V1SetTensorboardPriorityResponse
     */
    tensorboard?: V1Tensorboard;
}

/**
 * Response to SetUserPasswordRequest.
 * @export
 * @interface V1SetUserPasswordResponse
 */
export interface V1SetUserPasswordResponse {
    /**
     * The updated user.
     * @type {V1User}
     * @memberof V1SetUserPasswordResponse
     */
    user?: V1User;
}

/**
 * Shell is an ssh server in a containerized environment.
 * @export
 * @interface V1Shell
 */
export interface V1Shell {
    /**
     * The id of the shell.
     * @type {string}
     * @memberof V1Shell
     */
    id: string;
    /**
     * The description of the shell.
     * @type {string}
     * @memberof V1Shell
     */
    description: string;
    /**
     * The state of the shell.
     * @type {Determinedtaskv1State}
     * @memberof V1Shell
     */
    state: Determinedtaskv1State;
    /**
     * The time the shell was started.
     * @type {Date}
     * @memberof V1Shell
     */
    startTime: Date;
    /**
     * The container running the shell.
     * @type {V1Container}
     * @memberof V1Shell
     */
    container?: V1Container;
    /**
     * The private key for this shell.
     * @type {string}
     * @memberof V1Shell
     */
    privateKey?: string;
    /**
     * The public key for this shell.
     * @type {string}
     * @memberof V1Shell
     */
    publicKey?: string;
    /**
     * The username of the user that created the shell.
     * @type {string}
     * @memberof V1Shell
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof V1Shell
     */
    resourcePool: string;
    /**
     * 
     * @type {string}
     * @memberof V1Shell
     */
    exitStatus?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Shell
     */
    addresses?: Array<any>;
    /**
     * 
     * @type {any}
     * @memberof V1Shell
     */
    agentUserGroup?: any;
}

/**
 * Slot wraps a single device on the agent.
 * @export
 * @interface V1Slot
 */
export interface V1Slot {
    /**
     * The unqiue id of the slot for a given agent.
     * @type {string}
     * @memberof V1Slot
     */
    id?: string;
    /**
     * The individual resource this slot wraps.
     * @type {V1Device}
     * @memberof V1Slot
     */
    device?: V1Device;
    /**
     * Flag notifying if containers can be scheduled on this slot.
     * @type {boolean}
     * @memberof V1Slot
     */
    enabled?: boolean;
    /**
     * Container that is currently running on this agent. It is unset if there is no container currently running on this slot.
     * @type {V1Container}
     * @memberof V1Slot
     */
    container?: V1Container;
    /**
     * Flag notifying if this slot is in the draining mode: current containers will be allowed to finish but no new ones will be scheduled.
     * @type {boolean}
     * @memberof V1Slot
     */
    draining?: boolean;
}

/**
 * Templates move settings that are shared by many experiments into a single YAML file.
 * @export
 * @interface V1Template
 */
export interface V1Template {
    /**
     * The name of the template.
     * @type {string}
     * @memberof V1Template
     */
    name: string;
    /**
     * The template value.
     * @type {any}
     * @memberof V1Template
     */
    config: any;
}

/**
 * Tensorboard is a tensorboard instance in a containerized environment.
 * @export
 * @interface V1Tensorboard
 */
export interface V1Tensorboard {
    /**
     * The id of the tensorboard.
     * @type {string}
     * @memberof V1Tensorboard
     */
    id: string;
    /**
     * The description of the tensorboard.
     * @type {string}
     * @memberof V1Tensorboard
     */
    description: string;
    /**
     * The state of the tensorboard.
     * @type {Determinedtaskv1State}
     * @memberof V1Tensorboard
     */
    state: Determinedtaskv1State;
    /**
     * The time the tensorboard was started.
     * @type {Date}
     * @memberof V1Tensorboard
     */
    startTime: Date;
    /**
     * The container running the tensorboard.
     * @type {V1Container}
     * @memberof V1Tensorboard
     */
    container?: V1Container;
    /**
     * The experiment ids loaded into this tensorboard instance.
     * @type {Array<number>}
     * @memberof V1Tensorboard
     */
    experimentIds?: Array<number>;
    /**
     * The trial ids loaded into this tensorboard instance.
     * @type {Array<number>}
     * @memberof V1Tensorboard
     */
    trialIds?: Array<number>;
    /**
     * The username of the user that created the tensorboard.
     * @type {string}
     * @memberof V1Tensorboard
     */
    username: string;
    /**
     * The service address.
     * @type {string}
     * @memberof V1Tensorboard
     */
    serviceAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Tensorboard
     */
    resourcePool: string;
    /**
     * 
     * @type {string}
     * @memberof V1Tensorboard
     */
    exitStatus?: string;
}

/**
 * The representation for an amount of training.
 * @export
 * @interface V1TrainingLength
 */
export interface V1TrainingLength {
    /**
     * The units the training length is in terms of.
     * @type {TrainingLengthUnit}
     * @memberof V1TrainingLength
     */
    unit: TrainingLengthUnit;
    /**
     * The value for the training length.
     * @type {number}
     * @memberof V1TrainingLength
     */
    length: number;
}

/**
 * Signals to the experiment the trial early exited.
 * @export
 * @interface V1TrialEarlyExit
 */
export interface V1TrialEarlyExit {
    /**
     * The reason for the exit.
     * @type {TrialEarlyExitExitedReason}
     * @memberof V1TrialEarlyExit
     */
    reason: TrialEarlyExitExitedReason;
}

/**
 * Response to TrialLogFieldsRequest.
 * @export
 * @interface V1TrialLogsFieldsResponse
 */
export interface V1TrialLogsFieldsResponse {
    /**
     * The distinct agent IDs present in the logs.
     * @type {Array<string>}
     * @memberof V1TrialLogsFieldsResponse
     */
    agentIds?: Array<string>;
    /**
     * The distinct container IDs present in the logs.
     * @type {Array<string>}
     * @memberof V1TrialLogsFieldsResponse
     */
    containerIds?: Array<string>;
    /**
     * The distinct rank IDs present in the logs.
     * @type {Array<number>}
     * @memberof V1TrialLogsFieldsResponse
     */
    rankIds?: Array<number>;
    /**
     * The distinct stdtypes present in the logs.
     * @type {Array<string>}
     * @memberof V1TrialLogsFieldsResponse
     */
    stdtypes?: Array<string>;
    /**
     * The distinct sources present in the logs.
     * @type {Array<string>}
     * @memberof V1TrialLogsFieldsResponse
     */
    sources?: Array<string>;
}

/**
 * Response to TrialLogsRequest.
 * @export
 * @interface V1TrialLogsResponse
 */
export interface V1TrialLogsResponse {
    /**
     * The ID of the trial log.
     * @type {string}
     * @memberof V1TrialLogsResponse
     */
    id: string;
    /**
     * The timestamp of the log.
     * @type {Date}
     * @memberof V1TrialLogsResponse
     */
    timestamp: Date;
    /**
     * The log message.
     * @type {string}
     * @memberof V1TrialLogsResponse
     */
    message: string;
    /**
     * The level of the log.
     * @type {V1LogLevel}
     * @memberof V1TrialLogsResponse
     */
    level: V1LogLevel;
}

/**
 * Metrics from the trial some duration of training.
 * @export
 * @interface V1TrialMetrics
 */
export interface V1TrialMetrics {
    /**
     * The trial associated with these metrics.
     * @type {number}
     * @memberof V1TrialMetrics
     */
    trialId: number;
    /**
     * The trial run associated with these metrics.
     * @type {number}
     * @memberof V1TrialMetrics
     */
    trialRunId: number;
    /**
     * The number of batches trained on when these metrics were reported.
     * @type {number}
     * @memberof V1TrialMetrics
     */
    latestBatch: number;
    /**
     * The metrics for this bit of training (reduced over the reporting period).
     * @type {any}
     * @memberof V1TrialMetrics
     */
    metrics: any;
    /**
     * The batch metrics for this bit of training.
     * @type {Array<any>}
     * @memberof V1TrialMetrics
     */
    batchMetrics?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1TrialProfilerMetricLabels
 */
export interface V1TrialProfilerMetricLabels {
    /**
     * The ID of the trial.
     * @type {number}
     * @memberof V1TrialProfilerMetricLabels
     */
    trialId: number;
    /**
     * The name of the metric.
     * @type {string}
     * @memberof V1TrialProfilerMetricLabels
     */
    name: string;
    /**
     * The agent ID associated with the metric.
     * @type {string}
     * @memberof V1TrialProfilerMetricLabels
     */
    agentId?: string;
    /**
     * The GPU UUID associated with the metric.
     * @type {string}
     * @memberof V1TrialProfilerMetricLabels
     */
    gpuUuid?: string;
    /**
     * The type of the metric.
     * @type {TrialProfilerMetricLabelsProfilerMetricType}
     * @memberof V1TrialProfilerMetricLabels
     */
    metricType?: TrialProfilerMetricLabelsProfilerMetricType;
}

/**
 * TrialProfilerMetricsBatch is a batch of trial profiler metrics. A batch will contain metrics pertaining to a single series. The fields values, batches and timestamps will be equal length arrays with each index corresponding to a reading.
 * @export
 * @interface V1TrialProfilerMetricsBatch
 */
export interface V1TrialProfilerMetricsBatch {
    /**
     * The measurement for a reading, repeated for the batch of metrics.
     * @type {Array<number>}
     * @memberof V1TrialProfilerMetricsBatch
     */
    values: Array<number>;
    /**
     * The batch at which a reading occurred, repeated for the batch of metrics.
     * @type {Array<number>}
     * @memberof V1TrialProfilerMetricsBatch
     */
    batches: Array<number>;
    /**
     * The timestamp at which a reading occurred, repeated for the batch of metrics.
     * @type {Array<Date>}
     * @memberof V1TrialProfilerMetricsBatch
     */
    timestamps: Array<Date>;
    /**
     * The labels for this series.
     * @type {V1TrialProfilerMetricLabels}
     * @memberof V1TrialProfilerMetricsBatch
     */
    labels: V1TrialProfilerMetricLabels;
}

/**
 * The metadata pertaining to the current running task for a trial.
 * @export
 * @interface V1TrialRunnerMetadata
 */
export interface V1TrialRunnerMetadata {
    /**
     * The state of the trial runner.
     * @type {string}
     * @memberof V1TrialRunnerMetadata
     */
    state: string;
}

/**
 * TrialSimulation is a specific sequence of workloads that were run before the trial was completed.
 * @export
 * @interface V1TrialSimulation
 */
export interface V1TrialSimulation {
    /**
     * The list of operations that were run before the trial was completed.
     * @type {Array<V1RunnableOperation>}
     * @memberof V1TrialSimulation
     */
    operations?: Array<V1RunnableOperation>;
    /**
     * The number of times that this trial configuration has occurred during the simulation.
     * @type {number}
     * @memberof V1TrialSimulation
     */
    occurrences?: number;
}

/**
 * 
 * @export
 * @interface V1TrialsSampleResponse
 */
export interface V1TrialsSampleResponse {
    /**
     * A historical or incremental series of data points for the trials.
     * @type {Array<V1TrialsSampleResponseTrial>}
     * @memberof V1TrialsSampleResponse
     */
    trials: Array<V1TrialsSampleResponseTrial>;
    /**
     * IDs of trials that are newly included in the data.
     * @type {Array<number>}
     * @memberof V1TrialsSampleResponse
     */
    promotedTrials: Array<number>;
    /**
     * IDs of trials that are no loger included in the top N trials.
     * @type {Array<number>}
     * @memberof V1TrialsSampleResponse
     */
    demotedTrials: Array<number>;
}

/**
 * Metadata and metrics stream from a trial.
 * @export
 * @interface V1TrialsSampleResponseTrial
 */
export interface V1TrialsSampleResponseTrial {
    /**
     * The id of the trial.
     * @type {number}
     * @memberof V1TrialsSampleResponseTrial
     */
    trialId: number;
    /**
     * Hyperparamters values for this specific trial.
     * @type {any}
     * @memberof V1TrialsSampleResponseTrial
     */
    hparams: any;
    /**
     * A possibly down-sampled series of metric readings through the progress of the trial.
     * @type {Array<TrialsSampleResponseDataPoint>}
     * @memberof V1TrialsSampleResponseTrial
     */
    data: Array<TrialsSampleResponseDataPoint>;
}

/**
 * 
 * @export
 * @interface V1TrialsSnapshotResponse
 */
export interface V1TrialsSnapshotResponse {
    /**
     * A list of trials.
     * @type {Array<V1TrialsSnapshotResponseTrial>}
     * @memberof V1TrialsSnapshotResponse
     */
    trials: Array<V1TrialsSnapshotResponseTrial>;
}

/**
 * Metric value and metadata for a trial that has progress this far.
 * @export
 * @interface V1TrialsSnapshotResponseTrial
 */
export interface V1TrialsSnapshotResponseTrial {
    /**
     * The id of the trial.
     * @type {number}
     * @memberof V1TrialsSnapshotResponseTrial
     */
    trialId: number;
    /**
     * A dictionary of hyperparameter values for this trial.
     * @type {any}
     * @memberof V1TrialsSnapshotResponseTrial
     */
    hparams: any;
    /**
     * The value of the metric in this trial at this point.
     * @type {number}
     * @memberof V1TrialsSnapshotResponseTrial
     */
    metric: number;
    /**
     * The number of batches processed for this particular datapoint.
     * @type {number}
     * @memberof V1TrialsSnapshotResponseTrial
     */
    batchesProcessed: number;
}

/**
 * Response to UnarchiveExperimentRequest.
 * @export
 * @interface V1UnarchiveExperimentResponse
 */
export interface V1UnarchiveExperimentResponse {
}

/**
 * User is an account in the determined cluster.
 * @export
 * @interface V1User
 */
export interface V1User {
    /**
     * The user ID.
     * @type {number}
     * @memberof V1User
     */
    id: number;
    /**
     * The user login name of the user.
     * @type {string}
     * @memberof V1User
     */
    username: string;
    /**
     * Bool denoting whether the account is an admin account.
     * @type {boolean}
     * @memberof V1User
     */
    admin: boolean;
    /**
     * Bool denoting whether the account is active.
     * @type {boolean}
     * @memberof V1User
     */
    active: boolean;
    /**
     * The user and group on the agent host machine.
     * @type {V1AgentUserGroup}
     * @memberof V1User
     */
    agentUserGroup?: V1AgentUserGroup;
}

/**
 * ValidateAfterOperation means the trial should train and validate after training the given length.
 * @export
 * @interface V1ValidateAfterOperation
 */
export interface V1ValidateAfterOperation {
    /**
     * The length to train before reporting a validation.
     * @type {V1TrainingLength}
     * @memberof V1ValidateAfterOperation
     */
    length?: V1TrainingLength;
}

/**
 * ValidationHistoryEntry is a single entry for a validation history for an experiment.
 * @export
 * @interface V1ValidationHistoryEntry
 */
export interface V1ValidationHistoryEntry {
    /**
     * The id for the trial associated with this validation entry.
     * @type {number}
     * @memberof V1ValidationHistoryEntry
     */
    trialId: number;
    /**
     * The time at which the completed validation was reported.
     * @type {Date}
     * @memberof V1ValidationHistoryEntry
     */
    endTime: Date;
    /**
     * The value of the `searcher.metric`, indicated by the experiment config, for the validation.
     * @type {number}
     * @memberof V1ValidationHistoryEntry
     */
    searcherMetric: number;
}


/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCurrentUser(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/auth/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login the user.
         * @param {V1LoginRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLogin(body: V1LoginRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedLogin.');
            }
            const localVarPath = `/api/v1/auth/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1LoginRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLogout(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/auth/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCurrentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CurrentUserResponse> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).determinedCurrentUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Login the user.
         * @param {V1LoginRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLogin(body: V1LoginRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LoginResponse> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).determinedLogin(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Logout the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LogoutResponse> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).determinedLogout(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCurrentUser(options?: any) {
            return AuthenticationApiFp(configuration).determinedCurrentUser(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login the user.
         * @param {V1LoginRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLogin(body: V1LoginRequest, options?: any) {
            return AuthenticationApiFp(configuration).determinedLogin(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logout the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLogout(options?: any) {
            return AuthenticationApiFp(configuration).determinedLogout(options)(fetch, basePath);
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Get the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public determinedCurrentUser(options?: any) {
        return AuthenticationApiFp(this.configuration).determinedCurrentUser(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Login the user.
     * @param {V1LoginRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public determinedLogin(body: V1LoginRequest, options?: any) {
        return AuthenticationApiFp(this.configuration).determinedLogin(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Logout the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public determinedLogout(options?: any) {
        return AuthenticationApiFp(this.configuration).determinedLogout(options)(this.fetch, this.basePath);
    }

}

/**
 * CheckpointsApi - fetch parameter creator
 * @export
 */
export const CheckpointsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested checkpoint.
         * @param {string} checkpointUuid The uuid for the requested checkpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetCheckpoint(checkpointUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'checkpointUuid' is not null or undefined
            if (checkpointUuid === null || checkpointUuid === undefined) {
                throw new RequiredError('checkpointUuid','Required parameter checkpointUuid was null or undefined when calling determinedGetCheckpoint.');
            }
            const localVarPath = `/api/v1/checkpoints/{checkpointUuid}`
                .replace(`{${"checkpointUuid"}}`, encodeURIComponent(String(checkpointUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update checkpoint metadata.
         * @param {string} checkpointUuid UUID of the checkpoint.
         * @param {V1PostCheckpointMetadataRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostCheckpointMetadata(checkpointUuid: string, body: V1PostCheckpointMetadataRequest, options: any = {}): FetchArgs {
            // verify required parameter 'checkpointUuid' is not null or undefined
            if (checkpointUuid === null || checkpointUuid === undefined) {
                throw new RequiredError('checkpointUuid','Required parameter checkpointUuid was null or undefined when calling determinedPostCheckpointMetadata.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedPostCheckpointMetadata.');
            }
            const localVarPath = `/api/v1/checkpoints/{checkpoint.uuid}/metadata`
                .replace(`{${"checkpoint.uuid"}}`, encodeURIComponent(String(checkpointUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1PostCheckpointMetadataRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckpointsApi - functional programming interface
 * @export
 */
export const CheckpointsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested checkpoint.
         * @param {string} checkpointUuid The uuid for the requested checkpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetCheckpoint(checkpointUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetCheckpointResponse> {
            const localVarFetchArgs = CheckpointsApiFetchParamCreator(configuration).determinedGetCheckpoint(checkpointUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update checkpoint metadata.
         * @param {string} checkpointUuid UUID of the checkpoint.
         * @param {V1PostCheckpointMetadataRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostCheckpointMetadata(checkpointUuid: string, body: V1PostCheckpointMetadataRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostCheckpointMetadataResponse> {
            const localVarFetchArgs = CheckpointsApiFetchParamCreator(configuration).determinedPostCheckpointMetadata(checkpointUuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckpointsApi - factory interface
 * @export
 */
export const CheckpointsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the requested checkpoint.
         * @param {string} checkpointUuid The uuid for the requested checkpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetCheckpoint(checkpointUuid: string, options?: any) {
            return CheckpointsApiFp(configuration).determinedGetCheckpoint(checkpointUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update checkpoint metadata.
         * @param {string} checkpointUuid UUID of the checkpoint.
         * @param {V1PostCheckpointMetadataRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostCheckpointMetadata(checkpointUuid: string, body: V1PostCheckpointMetadataRequest, options?: any) {
            return CheckpointsApiFp(configuration).determinedPostCheckpointMetadata(checkpointUuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * CheckpointsApi - object-oriented interface
 * @export
 * @class CheckpointsApi
 * @extends {BaseAPI}
 */
export class CheckpointsApi extends BaseAPI {
    /**
     * 
     * @summary Get the requested checkpoint.
     * @param {string} checkpointUuid The uuid for the requested checkpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckpointsApi
     */
    public determinedGetCheckpoint(checkpointUuid: string, options?: any) {
        return CheckpointsApiFp(this.configuration).determinedGetCheckpoint(checkpointUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update checkpoint metadata.
     * @param {string} checkpointUuid UUID of the checkpoint.
     * @param {V1PostCheckpointMetadataRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckpointsApi
     */
    public determinedPostCheckpointMetadata(checkpointUuid: string, body: V1PostCheckpointMetadataRequest, options?: any) {
        return CheckpointsApiFp(this.configuration).determinedPostCheckpointMetadata(checkpointUuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ClusterApi - fetch parameter creator
 * @export
 */
export const ClusterApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Disable the agent.
         * @param {string} agentId The id of the agent.
         * @param {V1DisableAgentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDisableAgent(agentId: string, body: V1DisableAgentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedDisableAgent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedDisableAgent.');
            }
            const localVarPath = `/api/v1/agents/{agentId}/disable`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1DisableAgentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDisableSlot(agentId: string, slotId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedDisableSlot.');
            }
            // verify required parameter 'slotId' is not null or undefined
            if (slotId === null || slotId === undefined) {
                throw new RequiredError('slotId','Required parameter slotId was null or undefined when calling determinedDisableSlot.');
            }
            const localVarPath = `/api/v1/agents/{agentId}/slots/{slotId}/disable`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"slotId"}}`, encodeURIComponent(String(slotId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable the agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedEnableAgent(agentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedEnableAgent.');
            }
            const localVarPath = `/api/v1/agents/{agentId}/enable`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedEnableSlot(agentId: string, slotId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedEnableSlot.');
            }
            // verify required parameter 'slotId' is not null or undefined
            if (slotId === null || slotId === undefined) {
                throw new RequiredError('slotId','Required parameter slotId was null or undefined when calling determinedEnableSlot.');
            }
            const localVarPath = `/api/v1/agents/{agentId}/slots/{slotId}/enable`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"slotId"}}`, encodeURIComponent(String(slotId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetAgent(agentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedGetAgent.');
            }
            const localVarPath = `/api/v1/agents/{agentId}`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of agents from the cluster.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME'} [sortBy] Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of agents before returning results. Negative values denote number of agents to skip from the end before returning results.
         * @param {number} [limit] Limit the number of agents. A value of 0 denotes no limit.
         * @param {string} [label] Filter agents by their label. If no label is specified or is empty, all agents are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetAgents(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, label?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/agents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get master information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetMaster(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/master`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get master config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetMasterConfig(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/master/config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested slot for an agent.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetSlot(agentId: string, slotId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedGetSlot.');
            }
            // verify required parameter 'slotId' is not null or undefined
            if (slotId === null || slotId === undefined) {
                throw new RequiredError('slotId','Required parameter slotId was null or undefined when calling determinedGetSlot.');
            }
            const localVarPath = `/api/v1/agents/{agentId}/slots/{slotId}`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"slotId"}}`, encodeURIComponent(String(slotId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the slots for an agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetSlots(agentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedGetSlots.');
            }
            const localVarPath = `/api/v1/agents/{agentId}/slots`
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream master logs.
         * @param {number} [offset] Skip the number of master logs before returning results. Negative values denote number of master logs to skip from the end before returning results.
         * @param {number} [limit] Limit the number of master logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the master stops or the limit is reached.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedMasterLogs(offset?: number, limit?: number, follow?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/master/logs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an aggregated view of resource allocation during the given time period.
         * @param {string} [startDate] The first day to consider (the exact time is midnight UTC at the beginning of the day).
         * @param {string} [endDate] The last day to consider (the exact time is midnight UTC at the end of the day).
         * @param {'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY'} [period] The period over which to perform aggregation.   - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedResourceAllocationAggregated(startDate?: string, endDate?: string, period?: 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY', options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/resources/allocation/aggregated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a detailed view of resource allocation during the given time period.
         * @param {Date} [timestampAfter] The start of the period to consider.
         * @param {Date} [timestampBefore] The end of the period to consider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedResourceAllocationRaw(timestampAfter?: Date, timestampBefore?: Date, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/resources/allocation/raw`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (timestampAfter !== undefined) {
                localVarQueryParameter['timestampAfter'] = (timestampAfter as any).toISOString();
            }

            if (timestampBefore !== undefined) {
                localVarQueryParameter['timestampBefore'] = (timestampBefore as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an aggregated view of resource allocation during the given time period (CSV).
         * @param {string} startDate Start time to get allocations for (YYYY-MM-DD format for daily, YYYY-MM format for monthly)
         * @param {string} endDate End time to get allocations for (YYYY-MM-DD format for daily, YYYY-MM format for monthly)
         * @param {string} period Period to aggregate over (RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY or RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedResourceAllocationCsv(startDate: string, endDate: string, period: string, options: any = {}): FetchArgs {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getAggregatedResourceAllocationCsv.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getAggregatedResourceAllocationCsv.');
            }
            // verify required parameter 'period' is not null or undefined
            if (period === null || period === undefined) {
                throw new RequiredError('period','Required parameter period was null or undefined when calling getAggregatedResourceAllocationCsv.');
            }
            const localVarPath = `/allocation/aggregated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a detailed view of resource allocation during the given time period (CSV).
         * @param {string} timestampAfter Start time to get allocations for (YYYY-MM-DDTHH:MM:SSZ format)
         * @param {string} timestampBefore End time to get allocations for (YYYY-MM-DDTHH:MM:SSZ format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawResourceAllocationCsv(timestampAfter: string, timestampBefore: string, options: any = {}): FetchArgs {
            // verify required parameter 'timestampAfter' is not null or undefined
            if (timestampAfter === null || timestampAfter === undefined) {
                throw new RequiredError('timestampAfter','Required parameter timestampAfter was null or undefined when calling getRawResourceAllocationCsv.');
            }
            // verify required parameter 'timestampBefore' is not null or undefined
            if (timestampBefore === null || timestampBefore === undefined) {
                throw new RequiredError('timestampBefore','Required parameter timestampBefore was null or undefined when calling getRawResourceAllocationCsv.');
            }
            const localVarPath = `/allocation/raw`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (timestampAfter !== undefined) {
                localVarQueryParameter['timestamp_after'] = timestampAfter;
            }

            if (timestampBefore !== undefined) {
                localVarQueryParameter['timestamp_before'] = timestampBefore;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterApi - functional programming interface
 * @export
 */
export const ClusterApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Disable the agent.
         * @param {string} agentId The id of the agent.
         * @param {V1DisableAgentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDisableAgent(agentId: string, body: V1DisableAgentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DisableAgentResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).determinedDisableAgent(agentId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Disable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDisableSlot(agentId: string, slotId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DisableSlotResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).determinedDisableSlot(agentId, slotId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Enable the agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedEnableAgent(agentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1EnableAgentResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).determinedEnableAgent(agentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Enable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedEnableSlot(agentId: string, slotId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1EnableSlotResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).determinedEnableSlot(agentId, slotId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetAgent(agentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetAgentResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).determinedGetAgent(agentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a set of agents from the cluster.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME'} [sortBy] Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of agents before returning results. Negative values denote number of agents to skip from the end before returning results.
         * @param {number} [limit] Limit the number of agents. A value of 0 denotes no limit.
         * @param {string} [label] Filter agents by their label. If no label is specified or is empty, all agents are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetAgents(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, label?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetAgentsResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).determinedGetAgents(sortBy, orderBy, offset, limit, label, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get master information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetMaster(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetMasterResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).determinedGetMaster(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get master config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetMasterConfig(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetMasterConfigResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).determinedGetMasterConfig(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested slot for an agent.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetSlot(agentId: string, slotId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetSlotResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).determinedGetSlot(agentId, slotId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all the slots for an agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetSlots(agentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetSlotsResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).determinedGetSlots(agentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream master logs.
         * @param {number} [offset] Skip the number of master logs before returning results. Negative values denote number of master logs to skip from the end before returning results.
         * @param {number} [limit] Limit the number of master logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the master stops or the limit is reached.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedMasterLogs(offset?: number, limit?: number, follow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1MasterLogsResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).determinedMasterLogs(offset, limit, follow, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get an aggregated view of resource allocation during the given time period.
         * @param {string} [startDate] The first day to consider (the exact time is midnight UTC at the beginning of the day).
         * @param {string} [endDate] The last day to consider (the exact time is midnight UTC at the end of the day).
         * @param {'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY'} [period] The period over which to perform aggregation.   - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedResourceAllocationAggregated(startDate?: string, endDate?: string, period?: 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ResourceAllocationAggregatedResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).determinedResourceAllocationAggregated(startDate, endDate, period, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a detailed view of resource allocation during the given time period.
         * @param {Date} [timestampAfter] The start of the period to consider.
         * @param {Date} [timestampBefore] The end of the period to consider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedResourceAllocationRaw(timestampAfter?: Date, timestampBefore?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ResourceAllocationRawResponse> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).determinedResourceAllocationRaw(timestampAfter, timestampBefore, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get an aggregated view of resource allocation during the given time period (CSV).
         * @param {string} startDate Start time to get allocations for (YYYY-MM-DD format for daily, YYYY-MM format for monthly)
         * @param {string} endDate End time to get allocations for (YYYY-MM-DD format for daily, YYYY-MM format for monthly)
         * @param {string} period Period to aggregate over (RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY or RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedResourceAllocationCsv(startDate: string, endDate: string, period: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).getAggregatedResourceAllocationCsv(startDate, endDate, period, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a detailed view of resource allocation during the given time period (CSV).
         * @param {string} timestampAfter Start time to get allocations for (YYYY-MM-DDTHH:MM:SSZ format)
         * @param {string} timestampBefore End time to get allocations for (YYYY-MM-DDTHH:MM:SSZ format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawResourceAllocationCsv(timestampAfter: string, timestampBefore: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClusterApiFetchParamCreator(configuration).getRawResourceAllocationCsv(timestampAfter, timestampBefore, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClusterApi - factory interface
 * @export
 */
export const ClusterApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Disable the agent.
         * @param {string} agentId The id of the agent.
         * @param {V1DisableAgentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDisableAgent(agentId: string, body: V1DisableAgentRequest, options?: any) {
            return ClusterApiFp(configuration).determinedDisableAgent(agentId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Disable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDisableSlot(agentId: string, slotId: string, options?: any) {
            return ClusterApiFp(configuration).determinedDisableSlot(agentId, slotId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Enable the agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedEnableAgent(agentId: string, options?: any) {
            return ClusterApiFp(configuration).determinedEnableAgent(agentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Enable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedEnableSlot(agentId: string, slotId: string, options?: any) {
            return ClusterApiFp(configuration).determinedEnableSlot(agentId, slotId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetAgent(agentId: string, options?: any) {
            return ClusterApiFp(configuration).determinedGetAgent(agentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a set of agents from the cluster.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME'} [sortBy] Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of agents before returning results. Negative values denote number of agents to skip from the end before returning results.
         * @param {number} [limit] Limit the number of agents. A value of 0 denotes no limit.
         * @param {string} [label] Filter agents by their label. If no label is specified or is empty, all agents are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetAgents(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, label?: string, options?: any) {
            return ClusterApiFp(configuration).determinedGetAgents(sortBy, orderBy, offset, limit, label, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get master information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetMaster(options?: any) {
            return ClusterApiFp(configuration).determinedGetMaster(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get master config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetMasterConfig(options?: any) {
            return ClusterApiFp(configuration).determinedGetMasterConfig(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested slot for an agent.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetSlot(agentId: string, slotId: string, options?: any) {
            return ClusterApiFp(configuration).determinedGetSlot(agentId, slotId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all the slots for an agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetSlots(agentId: string, options?: any) {
            return ClusterApiFp(configuration).determinedGetSlots(agentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream master logs.
         * @param {number} [offset] Skip the number of master logs before returning results. Negative values denote number of master logs to skip from the end before returning results.
         * @param {number} [limit] Limit the number of master logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the master stops or the limit is reached.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedMasterLogs(offset?: number, limit?: number, follow?: boolean, options?: any) {
            return ClusterApiFp(configuration).determinedMasterLogs(offset, limit, follow, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get an aggregated view of resource allocation during the given time period.
         * @param {string} [startDate] The first day to consider (the exact time is midnight UTC at the beginning of the day).
         * @param {string} [endDate] The last day to consider (the exact time is midnight UTC at the end of the day).
         * @param {'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY'} [period] The period over which to perform aggregation.   - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedResourceAllocationAggregated(startDate?: string, endDate?: string, period?: 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY', options?: any) {
            return ClusterApiFp(configuration).determinedResourceAllocationAggregated(startDate, endDate, period, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a detailed view of resource allocation during the given time period.
         * @param {Date} [timestampAfter] The start of the period to consider.
         * @param {Date} [timestampBefore] The end of the period to consider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedResourceAllocationRaw(timestampAfter?: Date, timestampBefore?: Date, options?: any) {
            return ClusterApiFp(configuration).determinedResourceAllocationRaw(timestampAfter, timestampBefore, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get an aggregated view of resource allocation during the given time period (CSV).
         * @param {string} startDate Start time to get allocations for (YYYY-MM-DD format for daily, YYYY-MM format for monthly)
         * @param {string} endDate End time to get allocations for (YYYY-MM-DD format for daily, YYYY-MM format for monthly)
         * @param {string} period Period to aggregate over (RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY or RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedResourceAllocationCsv(startDate: string, endDate: string, period: string, options?: any) {
            return ClusterApiFp(configuration).getAggregatedResourceAllocationCsv(startDate, endDate, period, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a detailed view of resource allocation during the given time period (CSV).
         * @param {string} timestampAfter Start time to get allocations for (YYYY-MM-DDTHH:MM:SSZ format)
         * @param {string} timestampBefore End time to get allocations for (YYYY-MM-DDTHH:MM:SSZ format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawResourceAllocationCsv(timestampAfter: string, timestampBefore: string, options?: any) {
            return ClusterApiFp(configuration).getRawResourceAllocationCsv(timestampAfter, timestampBefore, options)(fetch, basePath);
        },
    };
};

/**
 * ClusterApi - object-oriented interface
 * @export
 * @class ClusterApi
 * @extends {BaseAPI}
 */
export class ClusterApi extends BaseAPI {
    /**
     * 
     * @summary Disable the agent.
     * @param {string} agentId The id of the agent.
     * @param {V1DisableAgentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public determinedDisableAgent(agentId: string, body: V1DisableAgentRequest, options?: any) {
        return ClusterApiFp(this.configuration).determinedDisableAgent(agentId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Disable the slot.
     * @param {string} agentId The id of the agent.
     * @param {string} slotId The id of the slot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public determinedDisableSlot(agentId: string, slotId: string, options?: any) {
        return ClusterApiFp(this.configuration).determinedDisableSlot(agentId, slotId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Enable the agent.
     * @param {string} agentId The id of the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public determinedEnableAgent(agentId: string, options?: any) {
        return ClusterApiFp(this.configuration).determinedEnableAgent(agentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Enable the slot.
     * @param {string} agentId The id of the agent.
     * @param {string} slotId The id of the slot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public determinedEnableSlot(agentId: string, slotId: string, options?: any) {
        return ClusterApiFp(this.configuration).determinedEnableSlot(agentId, slotId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the requested agent.
     * @param {string} agentId The id of the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public determinedGetAgent(agentId: string, options?: any) {
        return ClusterApiFp(this.configuration).determinedGetAgent(agentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a set of agents from the cluster.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME'} [sortBy] Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of agents before returning results. Negative values denote number of agents to skip from the end before returning results.
     * @param {number} [limit] Limit the number of agents. A value of 0 denotes no limit.
     * @param {string} [label] Filter agents by their label. If no label is specified or is empty, all agents are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public determinedGetAgents(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, label?: string, options?: any) {
        return ClusterApiFp(this.configuration).determinedGetAgents(sortBy, orderBy, offset, limit, label, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get master information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public determinedGetMaster(options?: any) {
        return ClusterApiFp(this.configuration).determinedGetMaster(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get master config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public determinedGetMasterConfig(options?: any) {
        return ClusterApiFp(this.configuration).determinedGetMasterConfig(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the requested slot for an agent.
     * @param {string} agentId The id of the agent.
     * @param {string} slotId The id of the slot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public determinedGetSlot(agentId: string, slotId: string, options?: any) {
        return ClusterApiFp(this.configuration).determinedGetSlot(agentId, slotId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all the slots for an agent.
     * @param {string} agentId The id of the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public determinedGetSlots(agentId: string, options?: any) {
        return ClusterApiFp(this.configuration).determinedGetSlots(agentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stream master logs.
     * @param {number} [offset] Skip the number of master logs before returning results. Negative values denote number of master logs to skip from the end before returning results.
     * @param {number} [limit] Limit the number of master logs. A value of 0 denotes no limit.
     * @param {boolean} [follow] Continue following logs until the master stops or the limit is reached.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public determinedMasterLogs(offset?: number, limit?: number, follow?: boolean, options?: any) {
        return ClusterApiFp(this.configuration).determinedMasterLogs(offset, limit, follow, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get an aggregated view of resource allocation during the given time period.
     * @param {string} [startDate] The first day to consider (the exact time is midnight UTC at the beginning of the day).
     * @param {string} [endDate] The last day to consider (the exact time is midnight UTC at the end of the day).
     * @param {'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY'} [period] The period over which to perform aggregation.   - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public determinedResourceAllocationAggregated(startDate?: string, endDate?: string, period?: 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY' | 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY', options?: any) {
        return ClusterApiFp(this.configuration).determinedResourceAllocationAggregated(startDate, endDate, period, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a detailed view of resource allocation during the given time period.
     * @param {Date} [timestampAfter] The start of the period to consider.
     * @param {Date} [timestampBefore] The end of the period to consider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public determinedResourceAllocationRaw(timestampAfter?: Date, timestampBefore?: Date, options?: any) {
        return ClusterApiFp(this.configuration).determinedResourceAllocationRaw(timestampAfter, timestampBefore, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get an aggregated view of resource allocation during the given time period (CSV).
     * @param {string} startDate Start time to get allocations for (YYYY-MM-DD format for daily, YYYY-MM format for monthly)
     * @param {string} endDate End time to get allocations for (YYYY-MM-DD format for daily, YYYY-MM format for monthly)
     * @param {string} period Period to aggregate over (RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY or RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public getAggregatedResourceAllocationCsv(startDate: string, endDate: string, period: string, options?: any) {
        return ClusterApiFp(this.configuration).getAggregatedResourceAllocationCsv(startDate, endDate, period, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a detailed view of resource allocation during the given time period (CSV).
     * @param {string} timestampAfter Start time to get allocations for (YYYY-MM-DDTHH:MM:SSZ format)
     * @param {string} timestampBefore End time to get allocations for (YYYY-MM-DDTHH:MM:SSZ format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public getRawResourceAllocationCsv(timestampAfter: string, timestampBefore: string, options?: any) {
        return ClusterApiFp(this.configuration).getRawResourceAllocationCsv(timestampAfter, timestampBefore, options)(this.fetch, this.basePath);
    }

}

/**
 * CommandsApi - fetch parameter creator
 * @export
 */
export const CommandsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested command.
         * @param {string} commandId The id of the command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetCommand(commandId: string, options: any = {}): FetchArgs {
            // verify required parameter 'commandId' is not null or undefined
            if (commandId === null || commandId === undefined) {
                throw new RequiredError('commandId','Required parameter commandId was null or undefined when calling determinedGetCommand.');
            }
            const localVarPath = `/api/v1/commands/{commandId}`
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of commands.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort commands by the given field.   - SORT_BY_UNSPECIFIED: Returns commands in an unsorted list.  - SORT_BY_ID: Returns commands sorted by id.  - SORT_BY_DESCRIPTION: Returns commands sorted by description.  - SORT_BY_START_TIME: Return commands sorted by start time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order commands in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of commands before returning results. Negative values denote number of commands to skip from the end before returning results.
         * @param {number} [limit] Limit the number of commands. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit commands to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetCommands(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/commands`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (users) {
                localVarQueryParameter['users'] = users;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill the requested command.
         * @param {string} commandId The id of the command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillCommand(commandId: string, options: any = {}): FetchArgs {
            // verify required parameter 'commandId' is not null or undefined
            if (commandId === null || commandId === undefined) {
                throw new RequiredError('commandId','Required parameter commandId was null or undefined when calling determinedKillCommand.');
            }
            const localVarPath = `/api/v1/commands/{commandId}/kill`
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Launch a command.
         * @param {V1LaunchCommandRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLaunchCommand(body: V1LaunchCommandRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedLaunchCommand.');
            }
            const localVarPath = `/api/v1/commands`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1LaunchCommandRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the priority of the requested command.
         * @param {string} commandId The id of the command.
         * @param {V1SetCommandPriorityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetCommandPriority(commandId: string, body: V1SetCommandPriorityRequest, options: any = {}): FetchArgs {
            // verify required parameter 'commandId' is not null or undefined
            if (commandId === null || commandId === undefined) {
                throw new RequiredError('commandId','Required parameter commandId was null or undefined when calling determinedSetCommandPriority.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedSetCommandPriority.');
            }
            const localVarPath = `/api/v1/commands/{commandId}/set_priority`
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1SetCommandPriorityRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandsApi - functional programming interface
 * @export
 */
export const CommandsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested command.
         * @param {string} commandId The id of the command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetCommand(commandId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetCommandResponse> {
            const localVarFetchArgs = CommandsApiFetchParamCreator(configuration).determinedGetCommand(commandId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of commands.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort commands by the given field.   - SORT_BY_UNSPECIFIED: Returns commands in an unsorted list.  - SORT_BY_ID: Returns commands sorted by id.  - SORT_BY_DESCRIPTION: Returns commands sorted by description.  - SORT_BY_START_TIME: Return commands sorted by start time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order commands in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of commands before returning results. Negative values denote number of commands to skip from the end before returning results.
         * @param {number} [limit] Limit the number of commands. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit commands to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetCommands(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetCommandsResponse> {
            const localVarFetchArgs = CommandsApiFetchParamCreator(configuration).determinedGetCommands(sortBy, orderBy, offset, limit, users, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill the requested command.
         * @param {string} commandId The id of the command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillCommand(commandId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillCommandResponse> {
            const localVarFetchArgs = CommandsApiFetchParamCreator(configuration).determinedKillCommand(commandId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Launch a command.
         * @param {V1LaunchCommandRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLaunchCommand(body: V1LaunchCommandRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LaunchCommandResponse> {
            const localVarFetchArgs = CommandsApiFetchParamCreator(configuration).determinedLaunchCommand(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the priority of the requested command.
         * @param {string} commandId The id of the command.
         * @param {V1SetCommandPriorityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetCommandPriority(commandId: string, body: V1SetCommandPriorityRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SetCommandPriorityResponse> {
            const localVarFetchArgs = CommandsApiFetchParamCreator(configuration).determinedSetCommandPriority(commandId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CommandsApi - factory interface
 * @export
 */
export const CommandsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the requested command.
         * @param {string} commandId The id of the command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetCommand(commandId: string, options?: any) {
            return CommandsApiFp(configuration).determinedGetCommand(commandId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of commands.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort commands by the given field.   - SORT_BY_UNSPECIFIED: Returns commands in an unsorted list.  - SORT_BY_ID: Returns commands sorted by id.  - SORT_BY_DESCRIPTION: Returns commands sorted by description.  - SORT_BY_START_TIME: Return commands sorted by start time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order commands in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of commands before returning results. Negative values denote number of commands to skip from the end before returning results.
         * @param {number} [limit] Limit the number of commands. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit commands to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetCommands(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options?: any) {
            return CommandsApiFp(configuration).determinedGetCommands(sortBy, orderBy, offset, limit, users, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill the requested command.
         * @param {string} commandId The id of the command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillCommand(commandId: string, options?: any) {
            return CommandsApiFp(configuration).determinedKillCommand(commandId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Launch a command.
         * @param {V1LaunchCommandRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLaunchCommand(body: V1LaunchCommandRequest, options?: any) {
            return CommandsApiFp(configuration).determinedLaunchCommand(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the priority of the requested command.
         * @param {string} commandId The id of the command.
         * @param {V1SetCommandPriorityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetCommandPriority(commandId: string, body: V1SetCommandPriorityRequest, options?: any) {
            return CommandsApiFp(configuration).determinedSetCommandPriority(commandId, body, options)(fetch, basePath);
        },
    };
};

/**
 * CommandsApi - object-oriented interface
 * @export
 * @class CommandsApi
 * @extends {BaseAPI}
 */
export class CommandsApi extends BaseAPI {
    /**
     * 
     * @summary Get the requested command.
     * @param {string} commandId The id of the command.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public determinedGetCommand(commandId: string, options?: any) {
        return CommandsApiFp(this.configuration).determinedGetCommand(commandId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of commands.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort commands by the given field.   - SORT_BY_UNSPECIFIED: Returns commands in an unsorted list.  - SORT_BY_ID: Returns commands sorted by id.  - SORT_BY_DESCRIPTION: Returns commands sorted by description.  - SORT_BY_START_TIME: Return commands sorted by start time.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order commands in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of commands before returning results. Negative values denote number of commands to skip from the end before returning results.
     * @param {number} [limit] Limit the number of commands. A value of 0 denotes no limit.
     * @param {Array<string>} [users] Limit commands to those that are owned by the specified users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public determinedGetCommands(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options?: any) {
        return CommandsApiFp(this.configuration).determinedGetCommands(sortBy, orderBy, offset, limit, users, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Kill the requested command.
     * @param {string} commandId The id of the command.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public determinedKillCommand(commandId: string, options?: any) {
        return CommandsApiFp(this.configuration).determinedKillCommand(commandId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Launch a command.
     * @param {V1LaunchCommandRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public determinedLaunchCommand(body: V1LaunchCommandRequest, options?: any) {
        return CommandsApiFp(this.configuration).determinedLaunchCommand(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set the priority of the requested command.
     * @param {string} commandId The id of the command.
     * @param {V1SetCommandPriorityRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public determinedSetCommandPriority(commandId: string, body: V1SetCommandPriorityRequest, options?: any) {
        return CommandsApiFp(this.configuration).determinedSetCommandPriority(commandId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ExperimentsApi - fetch parameter creator
 * @export
 */
export const ExperimentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activate an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedActivateExperiment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling determinedActivateExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedArchiveExperiment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling determinedArchiveExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCancelExperiment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling determinedCancelExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the requested experiment.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDeleteExperiment(experimentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedDeleteExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperiment(experimentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedGetExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of checkpoints for an experiment.
         * @param {number} id The experiment id.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_TRIAL_ID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE' | 'SORT_BY_SEARCHER_METRIC'} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_TRIAL_ID: Returns checkpoints sorted by trial id.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_START_TIME: Returns checkpoints sorted by start time.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_VALIDATION_STATE: Returns checkpoints sorted by validation state.  - SORT_BY_STATE: Returns checkpoints sorted by state.  - SORT_BY_SEARCHER_METRIC: Returns checkpoints sorted by the experiment&#39;s &#x60;searcher.metric&#x60; configuration setting.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
         * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [validationStates] Limit the checkpoints to those that match the validation states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentCheckpoints(id: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_TRIAL_ID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE' | 'SORT_BY_SEARCHER_METRIC', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, validationStates?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling determinedGetExperimentCheckpoints.');
            }
            const localVarPath = `/api/v1/experiments/{id}/checkpoints`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (validationStates) {
                localVarQueryParameter['validationStates'] = validationStates;
            }

            if (states) {
                localVarQueryParameter['states'] = states;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of unique experiment labels (sorted by popularity).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentLabels(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/experiment/labels`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of trials for an experiment.
         * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION'} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
         * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentTrials(experimentId: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedGetExperimentTrials.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/trials`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (states) {
                localVarQueryParameter['states'] = states;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the validation history for an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentValidationHistory(experimentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedGetExperimentValidationHistory.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/validation-history`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of experiments.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER' | 'SORT_BY_NAME'} [sortBy] Sort experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end_time are returned after the ones with end_time.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.  - SORT_BY_NAME: Returns experiments sorted by name.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order experiments in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of experiments before returning results. Negative values denote number of experiments to skip from the end before returning results.
         * @param {number} [limit] Limit the number of experiments. 0 or Unspecified - returns a default of 100. -1               - returns everything. -2               - returns pagination info but no experiments.
         * @param {string} [description] Limit experiments to those that match the description.
         * @param {string} [name] Limit experiments to those that match the name.
         * @param {Array<string>} [labels] Limit experiments to those that match the provided labels.
         * @param {boolean} [archived] Limit experiments to those that are archived.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>} [states] Limit experiments to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.
         * @param {Array<string>} [users] Limit experiments to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperiments(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER' | 'SORT_BY_NAME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, description?: string, name?: string, labels?: Array<string>, archived?: boolean, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>, users?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/experiments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (labels) {
                localVarQueryParameter['labels'] = labels;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (states) {
                localVarQueryParameter['states'] = states;
            }

            if (users) {
                localVarQueryParameter['users'] = users;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the model definition of an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModelDef(experimentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedGetModelDef.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/model_def`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single trial.
         * @param {number} trialId The requested trial&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrial(trialId: number, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling determinedGetTrial.');
            }
            const localVarPath = `/api/v1/trials/{trialId}`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of checkpoints for a trial.
         * @param {number} id The trial id.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE'} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_START_TIME: Returns checkpoints sorted by start time.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_VALIDATION_STATE: Returns checkpoints sorted by validation state.  - SORT_BY_STATE: Returns checkpoints sorted by state.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
         * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [validationStates] Limit the checkpoints to those that match the validation states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrialCheckpoints(id: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, validationStates?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling determinedGetTrialCheckpoints.');
            }
            const localVarPath = `/api/v1/trials/{id}/checkpoints`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (validationStates) {
                localVarQueryParameter['validationStates'] = validationStates;
            }

            if (states) {
                localVarQueryParameter['states'] = states;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillExperiment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling determinedKillExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{id}/kill`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill a trial.
         * @param {number} id The trial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillTrial(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling determinedKillTrial.');
            }
            const localVarPath = `/api/v1/trials/{id}/kill`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch an experiment's fields.
         * @param {number} experimentId The id of the experiment.
         * @param {V1Experiment} body Patched experiment attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPatchExperiment(experimentId: number, body: V1Experiment, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedPatchExperiment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedPatchExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{experiment.id}`
                .replace(`{${"experiment.id"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Experiment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pause an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPauseExperiment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling determinedPauseExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{id}/pause`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Preview hyperparameter search.
         * @param {V1PreviewHPSearchRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPreviewHPSearch(body: V1PreviewHPSearchRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedPreviewHPSearch.');
            }
            const localVarPath = `/api/v1/preview-hp-search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1PreviewHPSearchRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream trial logs.
         * @param {number} trialId The id of the trial.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling determinedTrialLogs.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/logs`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow;
            }

            if (agentIds) {
                localVarQueryParameter['agentIds'] = agentIds;
            }

            if (containerIds) {
                localVarQueryParameter['containerIds'] = containerIds;
            }

            if (rankIds) {
                localVarQueryParameter['rankIds'] = rankIds;
            }

            if (levels) {
                localVarQueryParameter['levels'] = levels;
            }

            if (stdtypes) {
                localVarQueryParameter['stdtypes'] = stdtypes;
            }

            if (sources) {
                localVarQueryParameter['sources'] = sources;
            }

            if (timestampBefore !== undefined) {
                localVarQueryParameter['timestampBefore'] = (timestampBefore as any).toISOString();
            }

            if (timestampAfter !== undefined) {
                localVarQueryParameter['timestampAfter'] = (timestampAfter as any).toISOString();
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream trial log fields.
         * @param {number} trialId The ID of the trial.
         * @param {boolean} [follow] Continue following fields until the trial stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialLogsFields(trialId: number, follow?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling determinedTrialLogsFields.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/logs/fields`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unarchive an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedUnarchiveExperiment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling determinedUnarchiveExperiment.');
            }
            const localVarPath = `/api/v1/experiments/{id}/unarchive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperimentsApi - functional programming interface
 * @export
 */
export const ExperimentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activate an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedActivateExperiment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ActivateExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedActivateExperiment(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Archive an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedArchiveExperiment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArchiveExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedArchiveExperiment(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Cancel an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCancelExperiment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CancelExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedCancelExperiment(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the requested experiment.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDeleteExperiment(experimentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeleteExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedDeleteExperiment(experimentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperiment(experimentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedGetExperiment(experimentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of checkpoints for an experiment.
         * @param {number} id The experiment id.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_TRIAL_ID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE' | 'SORT_BY_SEARCHER_METRIC'} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_TRIAL_ID: Returns checkpoints sorted by trial id.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_START_TIME: Returns checkpoints sorted by start time.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_VALIDATION_STATE: Returns checkpoints sorted by validation state.  - SORT_BY_STATE: Returns checkpoints sorted by state.  - SORT_BY_SEARCHER_METRIC: Returns checkpoints sorted by the experiment&#39;s &#x60;searcher.metric&#x60; configuration setting.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
         * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [validationStates] Limit the checkpoints to those that match the validation states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentCheckpoints(id: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_TRIAL_ID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE' | 'SORT_BY_SEARCHER_METRIC', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, validationStates?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentCheckpointsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedGetExperimentCheckpoints(id, sortBy, orderBy, offset, limit, validationStates, states, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of unique experiment labels (sorted by popularity).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentLabels(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentLabelsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedGetExperimentLabels(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of trials for an experiment.
         * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION'} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
         * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentTrials(experimentId: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentTrialsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedGetExperimentTrials(experimentId, sortBy, orderBy, offset, limit, states, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the validation history for an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentValidationHistory(experimentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentValidationHistoryResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedGetExperimentValidationHistory(experimentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of experiments.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER' | 'SORT_BY_NAME'} [sortBy] Sort experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end_time are returned after the ones with end_time.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.  - SORT_BY_NAME: Returns experiments sorted by name.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order experiments in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of experiments before returning results. Negative values denote number of experiments to skip from the end before returning results.
         * @param {number} [limit] Limit the number of experiments. 0 or Unspecified - returns a default of 100. -1               - returns everything. -2               - returns pagination info but no experiments.
         * @param {string} [description] Limit experiments to those that match the description.
         * @param {string} [name] Limit experiments to those that match the name.
         * @param {Array<string>} [labels] Limit experiments to those that match the provided labels.
         * @param {boolean} [archived] Limit experiments to those that are archived.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>} [states] Limit experiments to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.
         * @param {Array<string>} [users] Limit experiments to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperiments(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER' | 'SORT_BY_NAME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, description?: string, name?: string, labels?: Array<string>, archived?: boolean, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>, users?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedGetExperiments(sortBy, orderBy, offset, limit, description, name, labels, archived, states, users, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the model definition of an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModelDef(experimentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelDefResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedGetModelDef(experimentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a single trial.
         * @param {number} trialId The requested trial&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrial(trialId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTrialResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedGetTrial(trialId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of checkpoints for a trial.
         * @param {number} id The trial id.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE'} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_START_TIME: Returns checkpoints sorted by start time.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_VALIDATION_STATE: Returns checkpoints sorted by validation state.  - SORT_BY_STATE: Returns checkpoints sorted by state.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
         * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [validationStates] Limit the checkpoints to those that match the validation states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrialCheckpoints(id: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, validationStates?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTrialCheckpointsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedGetTrialCheckpoints(id, sortBy, orderBy, offset, limit, validationStates, states, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillExperiment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedKillExperiment(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill a trial.
         * @param {number} id The trial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillTrial(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillTrialResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedKillTrial(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch an experiment's fields.
         * @param {number} experimentId The id of the experiment.
         * @param {V1Experiment} body Patched experiment attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPatchExperiment(experimentId: number, body: V1Experiment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PatchExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedPatchExperiment(experimentId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Pause an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPauseExperiment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PauseExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedPauseExperiment(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Preview hyperparameter search.
         * @param {V1PreviewHPSearchRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPreviewHPSearch(body: V1PreviewHPSearchRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PreviewHPSearchResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedPreviewHPSearch(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream trial logs.
         * @param {number} trialId The id of the trial.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TrialLogsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedTrialLogs(trialId, limit, follow, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream trial log fields.
         * @param {number} trialId The ID of the trial.
         * @param {boolean} [follow] Continue following fields until the trial stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialLogsFields(trialId: number, follow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TrialLogsFieldsResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedTrialLogsFields(trialId, follow, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unarchive an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedUnarchiveExperiment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UnarchiveExperimentResponse> {
            const localVarFetchArgs = ExperimentsApiFetchParamCreator(configuration).determinedUnarchiveExperiment(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ExperimentsApi - factory interface
 * @export
 */
export const ExperimentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Activate an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedActivateExperiment(id: number, options?: any) {
            return ExperimentsApiFp(configuration).determinedActivateExperiment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Archive an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedArchiveExperiment(id: number, options?: any) {
            return ExperimentsApiFp(configuration).determinedArchiveExperiment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Cancel an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCancelExperiment(id: number, options?: any) {
            return ExperimentsApiFp(configuration).determinedCancelExperiment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the requested experiment.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDeleteExperiment(experimentId: number, options?: any) {
            return ExperimentsApiFp(configuration).determinedDeleteExperiment(experimentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperiment(experimentId: number, options?: any) {
            return ExperimentsApiFp(configuration).determinedGetExperiment(experimentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of checkpoints for an experiment.
         * @param {number} id The experiment id.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_TRIAL_ID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE' | 'SORT_BY_SEARCHER_METRIC'} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_TRIAL_ID: Returns checkpoints sorted by trial id.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_START_TIME: Returns checkpoints sorted by start time.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_VALIDATION_STATE: Returns checkpoints sorted by validation state.  - SORT_BY_STATE: Returns checkpoints sorted by state.  - SORT_BY_SEARCHER_METRIC: Returns checkpoints sorted by the experiment&#39;s &#x60;searcher.metric&#x60; configuration setting.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
         * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [validationStates] Limit the checkpoints to those that match the validation states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentCheckpoints(id: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_TRIAL_ID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE' | 'SORT_BY_SEARCHER_METRIC', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, validationStates?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, options?: any) {
            return ExperimentsApiFp(configuration).determinedGetExperimentCheckpoints(id, sortBy, orderBy, offset, limit, validationStates, states, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of unique experiment labels (sorted by popularity).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentLabels(options?: any) {
            return ExperimentsApiFp(configuration).determinedGetExperimentLabels(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of trials for an experiment.
         * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION'} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
         * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentTrials(experimentId: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>, options?: any) {
            return ExperimentsApiFp(configuration).determinedGetExperimentTrials(experimentId, sortBy, orderBy, offset, limit, states, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the validation history for an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentValidationHistory(experimentId: number, options?: any) {
            return ExperimentsApiFp(configuration).determinedGetExperimentValidationHistory(experimentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of experiments.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER' | 'SORT_BY_NAME'} [sortBy] Sort experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end_time are returned after the ones with end_time.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.  - SORT_BY_NAME: Returns experiments sorted by name.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order experiments in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of experiments before returning results. Negative values denote number of experiments to skip from the end before returning results.
         * @param {number} [limit] Limit the number of experiments. 0 or Unspecified - returns a default of 100. -1               - returns everything. -2               - returns pagination info but no experiments.
         * @param {string} [description] Limit experiments to those that match the description.
         * @param {string} [name] Limit experiments to those that match the name.
         * @param {Array<string>} [labels] Limit experiments to those that match the provided labels.
         * @param {boolean} [archived] Limit experiments to those that are archived.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>} [states] Limit experiments to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.
         * @param {Array<string>} [users] Limit experiments to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperiments(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER' | 'SORT_BY_NAME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, description?: string, name?: string, labels?: Array<string>, archived?: boolean, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>, users?: Array<string>, options?: any) {
            return ExperimentsApiFp(configuration).determinedGetExperiments(sortBy, orderBy, offset, limit, description, name, labels, archived, states, users, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the model definition of an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModelDef(experimentId: number, options?: any) {
            return ExperimentsApiFp(configuration).determinedGetModelDef(experimentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single trial.
         * @param {number} trialId The requested trial&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrial(trialId: number, options?: any) {
            return ExperimentsApiFp(configuration).determinedGetTrial(trialId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of checkpoints for a trial.
         * @param {number} id The trial id.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE'} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_START_TIME: Returns checkpoints sorted by start time.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_VALIDATION_STATE: Returns checkpoints sorted by validation state.  - SORT_BY_STATE: Returns checkpoints sorted by state.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
         * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [validationStates] Limit the checkpoints to those that match the validation states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrialCheckpoints(id: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, validationStates?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, options?: any) {
            return ExperimentsApiFp(configuration).determinedGetTrialCheckpoints(id, sortBy, orderBy, offset, limit, validationStates, states, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillExperiment(id: number, options?: any) {
            return ExperimentsApiFp(configuration).determinedKillExperiment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill a trial.
         * @param {number} id The trial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillTrial(id: number, options?: any) {
            return ExperimentsApiFp(configuration).determinedKillTrial(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an experiment's fields.
         * @param {number} experimentId The id of the experiment.
         * @param {V1Experiment} body Patched experiment attributes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPatchExperiment(experimentId: number, body: V1Experiment, options?: any) {
            return ExperimentsApiFp(configuration).determinedPatchExperiment(experimentId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Pause an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPauseExperiment(id: number, options?: any) {
            return ExperimentsApiFp(configuration).determinedPauseExperiment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Preview hyperparameter search.
         * @param {V1PreviewHPSearchRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPreviewHPSearch(body: V1PreviewHPSearchRequest, options?: any) {
            return ExperimentsApiFp(configuration).determinedPreviewHPSearch(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream trial logs.
         * @param {number} trialId The id of the trial.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options?: any) {
            return ExperimentsApiFp(configuration).determinedTrialLogs(trialId, limit, follow, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream trial log fields.
         * @param {number} trialId The ID of the trial.
         * @param {boolean} [follow] Continue following fields until the trial stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialLogsFields(trialId: number, follow?: boolean, options?: any) {
            return ExperimentsApiFp(configuration).determinedTrialLogsFields(trialId, follow, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unarchive an experiment.
         * @param {number} id The experiment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedUnarchiveExperiment(id: number, options?: any) {
            return ExperimentsApiFp(configuration).determinedUnarchiveExperiment(id, options)(fetch, basePath);
        },
    };
};

/**
 * ExperimentsApi - object-oriented interface
 * @export
 * @class ExperimentsApi
 * @extends {BaseAPI}
 */
export class ExperimentsApi extends BaseAPI {
    /**
     * 
     * @summary Activate an experiment.
     * @param {number} id The experiment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedActivateExperiment(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedActivateExperiment(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Archive an experiment.
     * @param {number} id The experiment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedArchiveExperiment(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedArchiveExperiment(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Cancel an experiment.
     * @param {number} id The experiment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedCancelExperiment(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedCancelExperiment(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the requested experiment.
     * @param {number} experimentId The ID of the experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedDeleteExperiment(experimentId: number, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedDeleteExperiment(experimentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the requested experiment.
     * @param {number} experimentId The id of the experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedGetExperiment(experimentId: number, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedGetExperiment(experimentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of checkpoints for an experiment.
     * @param {number} id The experiment id.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_TRIAL_ID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE' | 'SORT_BY_SEARCHER_METRIC'} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_TRIAL_ID: Returns checkpoints sorted by trial id.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_START_TIME: Returns checkpoints sorted by start time.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_VALIDATION_STATE: Returns checkpoints sorted by validation state.  - SORT_BY_STATE: Returns checkpoints sorted by state.  - SORT_BY_SEARCHER_METRIC: Returns checkpoints sorted by the experiment&#39;s &#x60;searcher.metric&#x60; configuration setting.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
     * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
     * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [validationStates] Limit the checkpoints to those that match the validation states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
     * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedGetExperimentCheckpoints(id: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_TRIAL_ID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE' | 'SORT_BY_SEARCHER_METRIC', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, validationStates?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedGetExperimentCheckpoints(id, sortBy, orderBy, offset, limit, validationStates, states, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of unique experiment labels (sorted by popularity).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedGetExperimentLabels(options?: any) {
        return ExperimentsApiFp(this.configuration).determinedGetExperimentLabels(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of trials for an experiment.
     * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION'} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
     * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
     * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedGetExperimentTrials(experimentId: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedGetExperimentTrials(experimentId, sortBy, orderBy, offset, limit, states, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the validation history for an experiment.
     * @param {number} experimentId The id of the experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedGetExperimentValidationHistory(experimentId: number, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedGetExperimentValidationHistory(experimentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of experiments.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER' | 'SORT_BY_NAME'} [sortBy] Sort experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end_time are returned after the ones with end_time.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.  - SORT_BY_NAME: Returns experiments sorted by name.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order experiments in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of experiments before returning results. Negative values denote number of experiments to skip from the end before returning results.
     * @param {number} [limit] Limit the number of experiments. 0 or Unspecified - returns a default of 100. -1               - returns everything. -2               - returns pagination info but no experiments.
     * @param {string} [description] Limit experiments to those that match the description.
     * @param {string} [name] Limit experiments to those that match the name.
     * @param {Array<string>} [labels] Limit experiments to those that match the provided labels.
     * @param {boolean} [archived] Limit experiments to those that are archived.
     * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>} [states] Limit experiments to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.
     * @param {Array<string>} [users] Limit experiments to those that are owned by the specified users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedGetExperiments(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER' | 'SORT_BY_NAME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, description?: string, name?: string, labels?: Array<string>, archived?: boolean, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>, users?: Array<string>, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedGetExperiments(sortBy, orderBy, offset, limit, description, name, labels, archived, states, users, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the model definition of an experiment.
     * @param {number} experimentId The id of the experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedGetModelDef(experimentId: number, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedGetModelDef(experimentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a single trial.
     * @param {number} trialId The requested trial&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedGetTrial(trialId: number, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedGetTrial(trialId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of checkpoints for a trial.
     * @param {number} id The trial id.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE'} [sortBy] Sort checkpoints by the given field.   - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.  - SORT_BY_UUID: Returns checkpoints sorted by UUID.  - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.  - SORT_BY_START_TIME: Returns checkpoints sorted by start time.  - SORT_BY_END_TIME: Returns checkpoints sorted by end time.  - SORT_BY_VALIDATION_STATE: Returns checkpoints sorted by validation state.  - SORT_BY_STATE: Returns checkpoints sorted by state.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order checkpoints in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of checkpoints before returning results. Negative values denote number of checkpoints to skip from the end before returning results.
     * @param {number} [limit] Limit the number of checkpoints. A value of 0 denotes no limit.
     * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [validationStates] Limit the checkpoints to those that match the validation states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
     * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>} [states] Limit the checkpoints to those that match the states.   - STATE_UNSPECIFIED: The state of the checkpoint is unknown.  - STATE_ACTIVE: The checkpoint is in an active state.  - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.  - STATE_ERROR: The checkpoint errored.  - STATE_DELETED: The checkpoint has been deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedGetTrialCheckpoints(id: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_UUID' | 'SORT_BY_BATCH_NUMBER' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_VALIDATION_STATE' | 'SORT_BY_STATE', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, validationStates?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_COMPLETED' | 'STATE_ERROR' | 'STATE_DELETED'>, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedGetTrialCheckpoints(id, sortBy, orderBy, offset, limit, validationStates, states, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Kill an experiment.
     * @param {number} id The experiment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedKillExperiment(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedKillExperiment(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Kill a trial.
     * @param {number} id The trial id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedKillTrial(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedKillTrial(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch an experiment's fields.
     * @param {number} experimentId The id of the experiment.
     * @param {V1Experiment} body Patched experiment attributes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedPatchExperiment(experimentId: number, body: V1Experiment, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedPatchExperiment(experimentId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Pause an experiment.
     * @param {number} id The experiment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedPauseExperiment(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedPauseExperiment(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Preview hyperparameter search.
     * @param {V1PreviewHPSearchRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedPreviewHPSearch(body: V1PreviewHPSearchRequest, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedPreviewHPSearch(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stream trial logs.
     * @param {number} trialId The id of the trial.
     * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
     * @param {boolean} [follow] Continue following logs until the trial stops.
     * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
     * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
     * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
     * @param {Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
     * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
     * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
     * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
     * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedTrialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options?: any) {
        return ExperimentsApiFp(this.configuration).determinedTrialLogs(trialId, limit, follow, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stream trial log fields.
     * @param {number} trialId The ID of the trial.
     * @param {boolean} [follow] Continue following fields until the trial stops.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedTrialLogsFields(trialId: number, follow?: boolean, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedTrialLogsFields(trialId, follow, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unarchive an experiment.
     * @param {number} id The experiment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsApi
     */
    public determinedUnarchiveExperiment(id: number, options?: any) {
        return ExperimentsApiFp(this.configuration).determinedUnarchiveExperiment(id, options)(this.fetch, this.basePath);
    }

}

/**
 * InternalApi - fetch parameter creator
 * @export
 */
export const InternalApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Acknowledge the receipt of a signal to stop the given allocation early. This is used indicate and exit 0 isn't final; specifically, it is used for HP search directed early stops and preemption signals (not necessarily just scheduler preemption).
         * @param {string} allocationId The allocation that is acknowledging the request.
         * @param {V1AckAllocationPreemptionSignalRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedAckAllocationPreemptionSignal(allocationId: string, body: V1AckAllocationPreemptionSignalRequest, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling determinedAckAllocationPreemptionSignal.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedAckAllocationPreemptionSignal.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/signals/ack_preemption`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AckAllocationPreemptionSignalRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Long poll preemption signals for the given allocation. If the allocation has been preempted when called, it will return so immediately. Otherwise, the connection will be kept open until the timeout is reached or the allocation is preempted.
         * @param {string} allocationId The id of the allocation.
         * @param {number} [timeoutSeconds] The timeout in seconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedAllocationPreemptionSignal(allocationId: string, timeoutSeconds?: number, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling determinedAllocationPreemptionSignal.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/signals/preemption`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (timeoutSeconds !== undefined) {
                localVarQueryParameter['timeoutSeconds'] = timeoutSeconds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gather an allocation's rendezvous info. Blocks until all trial containers connect to gather their rendezvous information and responds to them all at once.
         * @param {string} allocationId The id of the allocation.
         * @param {string} containerId The id of the allocation. Used to verify all allocations are connected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedAllocationRendezvousInfo(allocationId: string, containerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling determinedAllocationRendezvousInfo.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling determinedAllocationRendezvousInfo.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/rendezvous_info/{containerId}`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)))
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports to the searcher that the trial has completed the given searcher operation.
         * @param {number} trialId The id of the trial.
         * @param {V1CompleteValidateAfterOperation} body The completed operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCompleteTrialSearcherValidation(trialId: number, body: V1CompleteValidateAfterOperation, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling determinedCompleteTrialSearcherValidation.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedCompleteTrialSearcherValidation.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/searcher/completed_operation`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CompleteValidateAfterOperation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger the computation of hyperparameter importance on-demand for a specific metric on a specific experiment. The status and results can be retrieved with GetHPImportance.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedComputeHPImportance(experimentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedComputeHPImportance.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/hyperparameter-importance`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an experiment.
         * @param {V1CreateExperimentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCreateExperiment(body: V1CreateExperimentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedCreateExperiment.');
            }
            const localVarPath = `/api/v1/experiments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CreateExperimentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the best searcher validation for an experiment by the given metric.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetBestSearcherValidationMetric(experimentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedGetBestSearcherValidationMetric.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/searcher/best_searcher_validation_metric`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current searcher operation.
         * @param {number} trialId The id of the trial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetCurrentTrialSearcherOperation(trialId: number, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling determinedGetCurrentTrialSearcherOperation.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/searcher/operation`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the latest computation of hyperparameter importance. Currently this is triggered for training loss (if emitted) and the searcher metric after 10% increments in an experiment's progress, but no more than every 10 minutes.
         * @param {number} experimentId The id of the experiment.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetHPImportance(experimentId: number, periodSeconds?: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedGetHPImportance.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/hyperparameter-importance`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (periodSeconds !== undefined) {
                localVarQueryParameter['periodSeconds'] = periodSeconds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all resource pools from the cluster.
         * @param {number} [offset] Skip the number of resource pools before returning results. Negative values denote number of resource pools to skip from the end before returning results.
         * @param {number} [limit] Limit the number of resource pools. A value of 0 denotes no limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetResourcePools(offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/resource-pools`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get telemetry information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTelemetry(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/master/telemetry`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send notebook idle data to master
         * @param {string} notebookId The id of the notebook.
         * @param {V1IdleNotebookRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedIdleNotebook(notebookId: string, body: V1IdleNotebookRequest, options: any = {}): FetchArgs {
            // verify required parameter 'notebookId' is not null or undefined
            if (notebookId === null || notebookId === undefined) {
                throw new RequiredError('notebookId','Required parameter notebookId was null or undefined when calling determinedIdleNotebook.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedIdleNotebook.');
            }
            const localVarPath = `/api/v1/notebooks/{notebookId}/report_idle`
                .replace(`{${"notebookId"}}`, encodeURIComponent(String(notebookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1IdleNotebookRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark the given reservation (container, pod, etc) within an allocation as a daemon reservation. In the exit of a successful exit, Determined will wait for all reservations to exit - unless they are marked as daemon reservations, in which case Determined will clean them up regardless of exit status after all non-daemon reservations have exited.
         * @param {string} allocationId The allocation ID for the reservation.
         * @param {string} containerId The container ID for the reservation.
         * @param {V1MarkAllocationReservationDaemonRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedMarkAllocationReservationDaemon(allocationId: string, containerId: string, body: V1MarkAllocationReservationDaemonRequest, options: any = {}): FetchArgs {
            // verify required parameter 'allocationId' is not null or undefined
            if (allocationId === null || allocationId === undefined) {
                throw new RequiredError('allocationId','Required parameter allocationId was null or undefined when calling determinedMarkAllocationReservationDaemon.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling determinedMarkAllocationReservationDaemon.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedMarkAllocationReservationDaemon.');
            }
            const localVarPath = `/api/v1/allocations/{allocationId}/containers/{containerId}/daemon`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)))
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1MarkAllocationReservationDaemonRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the milestones (in batches processed) at which a metric is recorded by an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION'} metricType The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedMetricBatches(experimentId: number, metricName: string, metricType: 'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION', periodSeconds?: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedMetricBatches.');
            }
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new RequiredError('metricName','Required parameter metricName was null or undefined when calling determinedMetricBatches.');
            }
            // verify required parameter 'metricType' is not null or undefined
            if (metricType === null || metricType === undefined) {
                throw new RequiredError('metricType','Required parameter metricType was null or undefined when calling determinedMetricBatches.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/metrics-stream/batches`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (metricName !== undefined) {
                localVarQueryParameter['metricName'] = metricName;
            }

            if (metricType !== undefined) {
                localVarQueryParameter['metricType'] = metricType;
            }

            if (periodSeconds !== undefined) {
                localVarQueryParameter['periodSeconds'] = periodSeconds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the set of metric names recorded for an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedMetricNames(experimentId: number, periodSeconds?: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedMetricNames.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/metrics-stream/metric-names`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (periodSeconds !== undefined) {
                localVarQueryParameter['periodSeconds'] = periodSeconds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Persist the given TrialProfilerMetricsBatch. The trial ID is in the labels.
         * @param {V1PostTrialProfilerMetricsBatchRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostTrialProfilerMetricsBatch(body: V1PostTrialProfilerMetricsBatchRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedPostTrialProfilerMetricsBatch.');
            }
            const localVarPath = `/api/v1/trials/profiler/metrics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1PostTrialProfilerMetricsBatchRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary For bookkeeping, update trial runner metadata (currently just state).
         * @param {number} trialId The id of the trial.
         * @param {V1TrialRunnerMetadata} body The state for the trial runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostTrialRunnerMetadata(trialId: number, body: V1TrialRunnerMetadata, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling determinedPostTrialRunnerMetadata.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedPostTrialRunnerMetadata.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/runner/metadata`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TrialRunnerMetadata" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a checkpoint.
         * @param {number} checkpointMetadataTrialId The ID of the trial associated with the checkpoint.
         * @param {V1CheckpointMetadata} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialCheckpointMetadata(checkpointMetadataTrialId: number, body: V1CheckpointMetadata, options: any = {}): FetchArgs {
            // verify required parameter 'checkpointMetadataTrialId' is not null or undefined
            if (checkpointMetadataTrialId === null || checkpointMetadataTrialId === undefined) {
                throw new RequiredError('checkpointMetadataTrialId','Required parameter checkpointMetadataTrialId was null or undefined when calling determinedReportTrialCheckpointMetadata.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedReportTrialCheckpointMetadata.');
            }
            const localVarPath = `/api/v1/trials/{checkpointMetadata.trialId}/checkpoint_metadata`
                .replace(`{${"checkpointMetadata.trialId"}}`, encodeURIComponent(String(checkpointMetadataTrialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CheckpointMetadata" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary For bookkeeping, updates the progress towards to current requested searcher training length.
         * @param {number} trialId The id of the trial.
         * @param {number} body Total units completed by the trial, in terms of the unit used to configure the searcher.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialProgress(trialId: number, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling determinedReportTrialProgress.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedReportTrialProgress.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/progress`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports to the searcher that the trial has completed the current requested amount of training with the given searcher validation metric.
         * @param {number} trialId The id of the trial.
         * @param {V1TrialEarlyExit} body The exit reason.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialSearcherEarlyExit(trialId: number, body: V1TrialEarlyExit, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling determinedReportTrialSearcherEarlyExit.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedReportTrialSearcherEarlyExit.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/early_exit`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TrialEarlyExit" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record training metrics for specified training.
         * @param {number} trainingMetricsTrialId The trial associated with these metrics.
         * @param {V1TrialMetrics} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialTrainingMetrics(trainingMetricsTrialId: number, body: V1TrialMetrics, options: any = {}): FetchArgs {
            // verify required parameter 'trainingMetricsTrialId' is not null or undefined
            if (trainingMetricsTrialId === null || trainingMetricsTrialId === undefined) {
                throw new RequiredError('trainingMetricsTrialId','Required parameter trainingMetricsTrialId was null or undefined when calling determinedReportTrialTrainingMetrics.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedReportTrialTrainingMetrics.');
            }
            const localVarPath = `/api/v1/trials/{trainingMetrics.trialId}/training_metrics`
                .replace(`{${"trainingMetrics.trialId"}}`, encodeURIComponent(String(trainingMetricsTrialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TrialMetrics" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record validation metrics.
         * @param {number} validationMetricsTrialId The trial associated with these metrics.
         * @param {V1TrialMetrics} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialValidationMetrics(validationMetricsTrialId: number, body: V1TrialMetrics, options: any = {}): FetchArgs {
            // verify required parameter 'validationMetricsTrialId' is not null or undefined
            if (validationMetricsTrialId === null || validationMetricsTrialId === undefined) {
                throw new RequiredError('validationMetricsTrialId','Required parameter validationMetricsTrialId was null or undefined when calling determinedReportTrialValidationMetrics.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedReportTrialValidationMetrics.');
            }
            const localVarPath = `/api/v1/trials/{validationMetrics.trialId}/validation_metrics`
                .replace(`{${"validationMetrics.trialId"}}`, encodeURIComponent(String(validationMetricsTrialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TrialMetrics" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a sample of the metrics over time for a sample of the trials.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION'} metricType The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {number} [maxTrials] Maximum number of trials to fetch data for.
         * @param {number} [maxDatapoints] Maximum number of initial / historical data points.
         * @param {number} [startBatches] Beginning of window (inclusive) to fetch data for.
         * @param {number} [endBatches] Ending of window (inclusive) to fetch data for.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialsSample(experimentId: number, metricName: string, metricType: 'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION', maxTrials?: number, maxDatapoints?: number, startBatches?: number, endBatches?: number, periodSeconds?: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedTrialsSample.');
            }
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new RequiredError('metricName','Required parameter metricName was null or undefined when calling determinedTrialsSample.');
            }
            // verify required parameter 'metricType' is not null or undefined
            if (metricType === null || metricType === undefined) {
                throw new RequiredError('metricType','Required parameter metricType was null or undefined when calling determinedTrialsSample.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/metrics-stream/trials-sample`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (metricName !== undefined) {
                localVarQueryParameter['metricName'] = metricName;
            }

            if (metricType !== undefined) {
                localVarQueryParameter['metricType'] = metricType;
            }

            if (maxTrials !== undefined) {
                localVarQueryParameter['maxTrials'] = maxTrials;
            }

            if (maxDatapoints !== undefined) {
                localVarQueryParameter['maxDatapoints'] = maxDatapoints;
            }

            if (startBatches !== undefined) {
                localVarQueryParameter['startBatches'] = startBatches;
            }

            if (endBatches !== undefined) {
                localVarQueryParameter['endBatches'] = endBatches;
            }

            if (periodSeconds !== undefined) {
                localVarQueryParameter['periodSeconds'] = periodSeconds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a snapshot of a metric across all trials at a certain point of progress.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION'} metricType The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {number} batchesProcessed The point of progress at which to query metrics.
         * @param {number} [batchesMargin] A range either side of batches_processed to include near-misses.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialsSnapshot(experimentId: number, metricName: string, metricType: 'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION', batchesProcessed: number, batchesMargin?: number, periodSeconds?: number, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedTrialsSnapshot.');
            }
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new RequiredError('metricName','Required parameter metricName was null or undefined when calling determinedTrialsSnapshot.');
            }
            // verify required parameter 'metricType' is not null or undefined
            if (metricType === null || metricType === undefined) {
                throw new RequiredError('metricType','Required parameter metricType was null or undefined when calling determinedTrialsSnapshot.');
            }
            // verify required parameter 'batchesProcessed' is not null or undefined
            if (batchesProcessed === null || batchesProcessed === undefined) {
                throw new RequiredError('batchesProcessed','Required parameter batchesProcessed was null or undefined when calling determinedTrialsSnapshot.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/metrics-stream/trials-snapshot`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (metricName !== undefined) {
                localVarQueryParameter['metricName'] = metricName;
            }

            if (metricType !== undefined) {
                localVarQueryParameter['metricType'] = metricType;
            }

            if (batchesProcessed !== undefined) {
                localVarQueryParameter['batchesProcessed'] = batchesProcessed;
            }

            if (batchesMargin !== undefined) {
                localVarQueryParameter['batchesMargin'] = batchesMargin;
            }

            if (periodSeconds !== undefined) {
                localVarQueryParameter['periodSeconds'] = periodSeconds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Acknowledge the receipt of a signal to stop the given allocation early. This is used indicate and exit 0 isn't final; specifically, it is used for HP search directed early stops and preemption signals (not necessarily just scheduler preemption).
         * @param {string} allocationId The allocation that is acknowledging the request.
         * @param {V1AckAllocationPreemptionSignalRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedAckAllocationPreemptionSignal(allocationId: string, body: V1AckAllocationPreemptionSignalRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AckAllocationPreemptionSignalResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedAckAllocationPreemptionSignal(allocationId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Long poll preemption signals for the given allocation. If the allocation has been preempted when called, it will return so immediately. Otherwise, the connection will be kept open until the timeout is reached or the allocation is preempted.
         * @param {string} allocationId The id of the allocation.
         * @param {number} [timeoutSeconds] The timeout in seconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedAllocationPreemptionSignal(allocationId: string, timeoutSeconds?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AllocationPreemptionSignalResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedAllocationPreemptionSignal(allocationId, timeoutSeconds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gather an allocation's rendezvous info. Blocks until all trial containers connect to gather their rendezvous information and responds to them all at once.
         * @param {string} allocationId The id of the allocation.
         * @param {string} containerId The id of the allocation. Used to verify all allocations are connected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedAllocationRendezvousInfo(allocationId: string, containerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AllocationRendezvousInfoResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedAllocationRendezvousInfo(allocationId, containerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reports to the searcher that the trial has completed the given searcher operation.
         * @param {number} trialId The id of the trial.
         * @param {V1CompleteValidateAfterOperation} body The completed operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCompleteTrialSearcherValidation(trialId: number, body: V1CompleteValidateAfterOperation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CompleteTrialSearcherValidationResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedCompleteTrialSearcherValidation(trialId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Trigger the computation of hyperparameter importance on-demand for a specific metric on a specific experiment. The status and results can be retrieved with GetHPImportance.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedComputeHPImportance(experimentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ComputeHPImportanceResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedComputeHPImportance(experimentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create an experiment.
         * @param {V1CreateExperimentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCreateExperiment(body: V1CreateExperimentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreateExperimentResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedCreateExperiment(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the best searcher validation for an experiment by the given metric.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetBestSearcherValidationMetric(experimentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetBestSearcherValidationMetricResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedGetBestSearcherValidationMetric(experimentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the current searcher operation.
         * @param {number} trialId The id of the trial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetCurrentTrialSearcherOperation(trialId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetCurrentTrialSearcherOperationResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedGetCurrentTrialSearcherOperation(trialId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieve the latest computation of hyperparameter importance. Currently this is triggered for training loss (if emitted) and the searcher metric after 10% increments in an experiment's progress, but no more than every 10 minutes.
         * @param {number} experimentId The id of the experiment.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetHPImportance(experimentId: number, periodSeconds?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1GetHPImportanceResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedGetHPImportance(experimentId, periodSeconds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of all resource pools from the cluster.
         * @param {number} [offset] Skip the number of resource pools before returning results. Negative values denote number of resource pools to skip from the end before returning results.
         * @param {number} [limit] Limit the number of resource pools. A value of 0 denotes no limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetResourcePools(offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetResourcePoolsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedGetResourcePools(offset, limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get telemetry information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTelemetry(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTelemetryResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedGetTelemetry(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Send notebook idle data to master
         * @param {string} notebookId The id of the notebook.
         * @param {V1IdleNotebookRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedIdleNotebook(notebookId: string, body: V1IdleNotebookRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1IdleNotebookResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedIdleNotebook(notebookId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mark the given reservation (container, pod, etc) within an allocation as a daemon reservation. In the exit of a successful exit, Determined will wait for all reservations to exit - unless they are marked as daemon reservations, in which case Determined will clean them up regardless of exit status after all non-daemon reservations have exited.
         * @param {string} allocationId The allocation ID for the reservation.
         * @param {string} containerId The container ID for the reservation.
         * @param {V1MarkAllocationReservationDaemonRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedMarkAllocationReservationDaemon(allocationId: string, containerId: string, body: V1MarkAllocationReservationDaemonRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1MarkAllocationReservationDaemonResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedMarkAllocationReservationDaemon(allocationId, containerId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the milestones (in batches processed) at which a metric is recorded by an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION'} metricType The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedMetricBatches(experimentId: number, metricName: string, metricType: 'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION', periodSeconds?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1MetricBatchesResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedMetricBatches(experimentId, metricName, metricType, periodSeconds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the set of metric names recorded for an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedMetricNames(experimentId: number, periodSeconds?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1MetricNamesResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedMetricNames(experimentId, periodSeconds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Persist the given TrialProfilerMetricsBatch. The trial ID is in the labels.
         * @param {V1PostTrialProfilerMetricsBatchRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostTrialProfilerMetricsBatch(body: V1PostTrialProfilerMetricsBatchRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostTrialProfilerMetricsBatchResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedPostTrialProfilerMetricsBatch(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary For bookkeeping, update trial runner metadata (currently just state).
         * @param {number} trialId The id of the trial.
         * @param {V1TrialRunnerMetadata} body The state for the trial runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostTrialRunnerMetadata(trialId: number, body: V1TrialRunnerMetadata, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostTrialRunnerMetadataResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedPostTrialRunnerMetadata(trialId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Record a checkpoint.
         * @param {number} checkpointMetadataTrialId The ID of the trial associated with the checkpoint.
         * @param {V1CheckpointMetadata} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialCheckpointMetadata(checkpointMetadataTrialId: number, body: V1CheckpointMetadata, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ReportTrialCheckpointMetadataResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedReportTrialCheckpointMetadata(checkpointMetadataTrialId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary For bookkeeping, updates the progress towards to current requested searcher training length.
         * @param {number} trialId The id of the trial.
         * @param {number} body Total units completed by the trial, in terms of the unit used to configure the searcher.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialProgress(trialId: number, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ReportTrialProgressResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedReportTrialProgress(trialId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reports to the searcher that the trial has completed the current requested amount of training with the given searcher validation metric.
         * @param {number} trialId The id of the trial.
         * @param {V1TrialEarlyExit} body The exit reason.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialSearcherEarlyExit(trialId: number, body: V1TrialEarlyExit, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ReportTrialSearcherEarlyExitResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedReportTrialSearcherEarlyExit(trialId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Record training metrics for specified training.
         * @param {number} trainingMetricsTrialId The trial associated with these metrics.
         * @param {V1TrialMetrics} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialTrainingMetrics(trainingMetricsTrialId: number, body: V1TrialMetrics, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ReportTrialTrainingMetricsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedReportTrialTrainingMetrics(trainingMetricsTrialId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Record validation metrics.
         * @param {number} validationMetricsTrialId The trial associated with these metrics.
         * @param {V1TrialMetrics} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialValidationMetrics(validationMetricsTrialId: number, body: V1TrialMetrics, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ReportTrialValidationMetricsResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedReportTrialValidationMetrics(validationMetricsTrialId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a sample of the metrics over time for a sample of the trials.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION'} metricType The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {number} [maxTrials] Maximum number of trials to fetch data for.
         * @param {number} [maxDatapoints] Maximum number of initial / historical data points.
         * @param {number} [startBatches] Beginning of window (inclusive) to fetch data for.
         * @param {number} [endBatches] Ending of window (inclusive) to fetch data for.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialsSample(experimentId: number, metricName: string, metricType: 'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION', maxTrials?: number, maxDatapoints?: number, startBatches?: number, endBatches?: number, periodSeconds?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TrialsSampleResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedTrialsSample(experimentId, metricName, metricType, maxTrials, maxDatapoints, startBatches, endBatches, periodSeconds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a snapshot of a metric across all trials at a certain point of progress.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION'} metricType The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {number} batchesProcessed The point of progress at which to query metrics.
         * @param {number} [batchesMargin] A range either side of batches_processed to include near-misses.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialsSnapshot(experimentId: number, metricName: string, metricType: 'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION', batchesProcessed: number, batchesMargin?: number, periodSeconds?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TrialsSnapshotResponse> {
            const localVarFetchArgs = InternalApiFetchParamCreator(configuration).determinedTrialsSnapshot(experimentId, metricName, metricType, batchesProcessed, batchesMargin, periodSeconds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Acknowledge the receipt of a signal to stop the given allocation early. This is used indicate and exit 0 isn't final; specifically, it is used for HP search directed early stops and preemption signals (not necessarily just scheduler preemption).
         * @param {string} allocationId The allocation that is acknowledging the request.
         * @param {V1AckAllocationPreemptionSignalRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedAckAllocationPreemptionSignal(allocationId: string, body: V1AckAllocationPreemptionSignalRequest, options?: any) {
            return InternalApiFp(configuration).determinedAckAllocationPreemptionSignal(allocationId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Long poll preemption signals for the given allocation. If the allocation has been preempted when called, it will return so immediately. Otherwise, the connection will be kept open until the timeout is reached or the allocation is preempted.
         * @param {string} allocationId The id of the allocation.
         * @param {number} [timeoutSeconds] The timeout in seconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedAllocationPreemptionSignal(allocationId: string, timeoutSeconds?: number, options?: any) {
            return InternalApiFp(configuration).determinedAllocationPreemptionSignal(allocationId, timeoutSeconds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gather an allocation's rendezvous info. Blocks until all trial containers connect to gather their rendezvous information and responds to them all at once.
         * @param {string} allocationId The id of the allocation.
         * @param {string} containerId The id of the allocation. Used to verify all allocations are connected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedAllocationRendezvousInfo(allocationId: string, containerId: string, options?: any) {
            return InternalApiFp(configuration).determinedAllocationRendezvousInfo(allocationId, containerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reports to the searcher that the trial has completed the given searcher operation.
         * @param {number} trialId The id of the trial.
         * @param {V1CompleteValidateAfterOperation} body The completed operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCompleteTrialSearcherValidation(trialId: number, body: V1CompleteValidateAfterOperation, options?: any) {
            return InternalApiFp(configuration).determinedCompleteTrialSearcherValidation(trialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Trigger the computation of hyperparameter importance on-demand for a specific metric on a specific experiment. The status and results can be retrieved with GetHPImportance.
         * @param {number} experimentId The id of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedComputeHPImportance(experimentId: number, options?: any) {
            return InternalApiFp(configuration).determinedComputeHPImportance(experimentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create an experiment.
         * @param {V1CreateExperimentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCreateExperiment(body: V1CreateExperimentRequest, options?: any) {
            return InternalApiFp(configuration).determinedCreateExperiment(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the best searcher validation for an experiment by the given metric.
         * @param {number} experimentId The ID of the experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetBestSearcherValidationMetric(experimentId: number, options?: any) {
            return InternalApiFp(configuration).determinedGetBestSearcherValidationMetric(experimentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the current searcher operation.
         * @param {number} trialId The id of the trial.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetCurrentTrialSearcherOperation(trialId: number, options?: any) {
            return InternalApiFp(configuration).determinedGetCurrentTrialSearcherOperation(trialId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve the latest computation of hyperparameter importance. Currently this is triggered for training loss (if emitted) and the searcher metric after 10% increments in an experiment's progress, but no more than every 10 minutes.
         * @param {number} experimentId The id of the experiment.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetHPImportance(experimentId: number, periodSeconds?: number, options?: any) {
            return InternalApiFp(configuration).determinedGetHPImportance(experimentId, periodSeconds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of all resource pools from the cluster.
         * @param {number} [offset] Skip the number of resource pools before returning results. Negative values denote number of resource pools to skip from the end before returning results.
         * @param {number} [limit] Limit the number of resource pools. A value of 0 denotes no limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetResourcePools(offset?: number, limit?: number, options?: any) {
            return InternalApiFp(configuration).determinedGetResourcePools(offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get telemetry information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTelemetry(options?: any) {
            return InternalApiFp(configuration).determinedGetTelemetry(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send notebook idle data to master
         * @param {string} notebookId The id of the notebook.
         * @param {V1IdleNotebookRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedIdleNotebook(notebookId: string, body: V1IdleNotebookRequest, options?: any) {
            return InternalApiFp(configuration).determinedIdleNotebook(notebookId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mark the given reservation (container, pod, etc) within an allocation as a daemon reservation. In the exit of a successful exit, Determined will wait for all reservations to exit - unless they are marked as daemon reservations, in which case Determined will clean them up regardless of exit status after all non-daemon reservations have exited.
         * @param {string} allocationId The allocation ID for the reservation.
         * @param {string} containerId The container ID for the reservation.
         * @param {V1MarkAllocationReservationDaemonRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedMarkAllocationReservationDaemon(allocationId: string, containerId: string, body: V1MarkAllocationReservationDaemonRequest, options?: any) {
            return InternalApiFp(configuration).determinedMarkAllocationReservationDaemon(allocationId, containerId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the milestones (in batches processed) at which a metric is recorded by an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION'} metricType The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedMetricBatches(experimentId: number, metricName: string, metricType: 'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION', periodSeconds?: number, options?: any) {
            return InternalApiFp(configuration).determinedMetricBatches(experimentId, metricName, metricType, periodSeconds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the set of metric names recorded for an experiment.
         * @param {number} experimentId The id of the experiment.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedMetricNames(experimentId: number, periodSeconds?: number, options?: any) {
            return InternalApiFp(configuration).determinedMetricNames(experimentId, periodSeconds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Persist the given TrialProfilerMetricsBatch. The trial ID is in the labels.
         * @param {V1PostTrialProfilerMetricsBatchRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostTrialProfilerMetricsBatch(body: V1PostTrialProfilerMetricsBatchRequest, options?: any) {
            return InternalApiFp(configuration).determinedPostTrialProfilerMetricsBatch(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary For bookkeeping, update trial runner metadata (currently just state).
         * @param {number} trialId The id of the trial.
         * @param {V1TrialRunnerMetadata} body The state for the trial runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostTrialRunnerMetadata(trialId: number, body: V1TrialRunnerMetadata, options?: any) {
            return InternalApiFp(configuration).determinedPostTrialRunnerMetadata(trialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Record a checkpoint.
         * @param {number} checkpointMetadataTrialId The ID of the trial associated with the checkpoint.
         * @param {V1CheckpointMetadata} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialCheckpointMetadata(checkpointMetadataTrialId: number, body: V1CheckpointMetadata, options?: any) {
            return InternalApiFp(configuration).determinedReportTrialCheckpointMetadata(checkpointMetadataTrialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary For bookkeeping, updates the progress towards to current requested searcher training length.
         * @param {number} trialId The id of the trial.
         * @param {number} body Total units completed by the trial, in terms of the unit used to configure the searcher.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialProgress(trialId: number, body: number, options?: any) {
            return InternalApiFp(configuration).determinedReportTrialProgress(trialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reports to the searcher that the trial has completed the current requested amount of training with the given searcher validation metric.
         * @param {number} trialId The id of the trial.
         * @param {V1TrialEarlyExit} body The exit reason.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialSearcherEarlyExit(trialId: number, body: V1TrialEarlyExit, options?: any) {
            return InternalApiFp(configuration).determinedReportTrialSearcherEarlyExit(trialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Record training metrics for specified training.
         * @param {number} trainingMetricsTrialId The trial associated with these metrics.
         * @param {V1TrialMetrics} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialTrainingMetrics(trainingMetricsTrialId: number, body: V1TrialMetrics, options?: any) {
            return InternalApiFp(configuration).determinedReportTrialTrainingMetrics(trainingMetricsTrialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Record validation metrics.
         * @param {number} validationMetricsTrialId The trial associated with these metrics.
         * @param {V1TrialMetrics} body The training metrics to persist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedReportTrialValidationMetrics(validationMetricsTrialId: number, body: V1TrialMetrics, options?: any) {
            return InternalApiFp(configuration).determinedReportTrialValidationMetrics(validationMetricsTrialId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a sample of the metrics over time for a sample of the trials.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION'} metricType The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {number} [maxTrials] Maximum number of trials to fetch data for.
         * @param {number} [maxDatapoints] Maximum number of initial / historical data points.
         * @param {number} [startBatches] Beginning of window (inclusive) to fetch data for.
         * @param {number} [endBatches] Ending of window (inclusive) to fetch data for.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialsSample(experimentId: number, metricName: string, metricType: 'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION', maxTrials?: number, maxDatapoints?: number, startBatches?: number, endBatches?: number, periodSeconds?: number, options?: any) {
            return InternalApiFp(configuration).determinedTrialsSample(experimentId, metricName, metricType, maxTrials, maxDatapoints, startBatches, endBatches, periodSeconds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a snapshot of a metric across all trials at a certain point of progress.
         * @param {number} experimentId The id of the experiment.
         * @param {string} metricName A metric name.
         * @param {'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION'} metricType The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
         * @param {number} batchesProcessed The point of progress at which to query metrics.
         * @param {number} [batchesMargin] A range either side of batches_processed to include near-misses.
         * @param {number} [periodSeconds] Seconds to wait when polling for updates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialsSnapshot(experimentId: number, metricName: string, metricType: 'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION', batchesProcessed: number, batchesMargin?: number, periodSeconds?: number, options?: any) {
            return InternalApiFp(configuration).determinedTrialsSnapshot(experimentId, metricName, metricType, batchesProcessed, batchesMargin, periodSeconds, options)(fetch, basePath);
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * 
     * @summary Acknowledge the receipt of a signal to stop the given allocation early. This is used indicate and exit 0 isn't final; specifically, it is used for HP search directed early stops and preemption signals (not necessarily just scheduler preemption).
     * @param {string} allocationId The allocation that is acknowledging the request.
     * @param {V1AckAllocationPreemptionSignalRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedAckAllocationPreemptionSignal(allocationId: string, body: V1AckAllocationPreemptionSignalRequest, options?: any) {
        return InternalApiFp(this.configuration).determinedAckAllocationPreemptionSignal(allocationId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Long poll preemption signals for the given allocation. If the allocation has been preempted when called, it will return so immediately. Otherwise, the connection will be kept open until the timeout is reached or the allocation is preempted.
     * @param {string} allocationId The id of the allocation.
     * @param {number} [timeoutSeconds] The timeout in seconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedAllocationPreemptionSignal(allocationId: string, timeoutSeconds?: number, options?: any) {
        return InternalApiFp(this.configuration).determinedAllocationPreemptionSignal(allocationId, timeoutSeconds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gather an allocation's rendezvous info. Blocks until all trial containers connect to gather their rendezvous information and responds to them all at once.
     * @param {string} allocationId The id of the allocation.
     * @param {string} containerId The id of the allocation. Used to verify all allocations are connected.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedAllocationRendezvousInfo(allocationId: string, containerId: string, options?: any) {
        return InternalApiFp(this.configuration).determinedAllocationRendezvousInfo(allocationId, containerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Reports to the searcher that the trial has completed the given searcher operation.
     * @param {number} trialId The id of the trial.
     * @param {V1CompleteValidateAfterOperation} body The completed operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedCompleteTrialSearcherValidation(trialId: number, body: V1CompleteValidateAfterOperation, options?: any) {
        return InternalApiFp(this.configuration).determinedCompleteTrialSearcherValidation(trialId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Trigger the computation of hyperparameter importance on-demand for a specific metric on a specific experiment. The status and results can be retrieved with GetHPImportance.
     * @param {number} experimentId The id of the experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedComputeHPImportance(experimentId: number, options?: any) {
        return InternalApiFp(this.configuration).determinedComputeHPImportance(experimentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create an experiment.
     * @param {V1CreateExperimentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedCreateExperiment(body: V1CreateExperimentRequest, options?: any) {
        return InternalApiFp(this.configuration).determinedCreateExperiment(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the best searcher validation for an experiment by the given metric.
     * @param {number} experimentId The ID of the experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedGetBestSearcherValidationMetric(experimentId: number, options?: any) {
        return InternalApiFp(this.configuration).determinedGetBestSearcherValidationMetric(experimentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the current searcher operation.
     * @param {number} trialId The id of the trial.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedGetCurrentTrialSearcherOperation(trialId: number, options?: any) {
        return InternalApiFp(this.configuration).determinedGetCurrentTrialSearcherOperation(trialId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve the latest computation of hyperparameter importance. Currently this is triggered for training loss (if emitted) and the searcher metric after 10% increments in an experiment's progress, but no more than every 10 minutes.
     * @param {number} experimentId The id of the experiment.
     * @param {number} [periodSeconds] Seconds to wait when polling for updates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedGetHPImportance(experimentId: number, periodSeconds?: number, options?: any) {
        return InternalApiFp(this.configuration).determinedGetHPImportance(experimentId, periodSeconds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of all resource pools from the cluster.
     * @param {number} [offset] Skip the number of resource pools before returning results. Negative values denote number of resource pools to skip from the end before returning results.
     * @param {number} [limit] Limit the number of resource pools. A value of 0 denotes no limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedGetResourcePools(offset?: number, limit?: number, options?: any) {
        return InternalApiFp(this.configuration).determinedGetResourcePools(offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get telemetry information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedGetTelemetry(options?: any) {
        return InternalApiFp(this.configuration).determinedGetTelemetry(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Send notebook idle data to master
     * @param {string} notebookId The id of the notebook.
     * @param {V1IdleNotebookRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedIdleNotebook(notebookId: string, body: V1IdleNotebookRequest, options?: any) {
        return InternalApiFp(this.configuration).determinedIdleNotebook(notebookId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mark the given reservation (container, pod, etc) within an allocation as a daemon reservation. In the exit of a successful exit, Determined will wait for all reservations to exit - unless they are marked as daemon reservations, in which case Determined will clean them up regardless of exit status after all non-daemon reservations have exited.
     * @param {string} allocationId The allocation ID for the reservation.
     * @param {string} containerId The container ID for the reservation.
     * @param {V1MarkAllocationReservationDaemonRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedMarkAllocationReservationDaemon(allocationId: string, containerId: string, body: V1MarkAllocationReservationDaemonRequest, options?: any) {
        return InternalApiFp(this.configuration).determinedMarkAllocationReservationDaemon(allocationId, containerId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the milestones (in batches processed) at which a metric is recorded by an experiment.
     * @param {number} experimentId The id of the experiment.
     * @param {string} metricName A metric name.
     * @param {'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION'} metricType The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
     * @param {number} [periodSeconds] Seconds to wait when polling for updates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedMetricBatches(experimentId: number, metricName: string, metricType: 'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION', periodSeconds?: number, options?: any) {
        return InternalApiFp(this.configuration).determinedMetricBatches(experimentId, metricName, metricType, periodSeconds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the set of metric names recorded for an experiment.
     * @param {number} experimentId The id of the experiment.
     * @param {number} [periodSeconds] Seconds to wait when polling for updates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedMetricNames(experimentId: number, periodSeconds?: number, options?: any) {
        return InternalApiFp(this.configuration).determinedMetricNames(experimentId, periodSeconds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Persist the given TrialProfilerMetricsBatch. The trial ID is in the labels.
     * @param {V1PostTrialProfilerMetricsBatchRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedPostTrialProfilerMetricsBatch(body: V1PostTrialProfilerMetricsBatchRequest, options?: any) {
        return InternalApiFp(this.configuration).determinedPostTrialProfilerMetricsBatch(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary For bookkeeping, update trial runner metadata (currently just state).
     * @param {number} trialId The id of the trial.
     * @param {V1TrialRunnerMetadata} body The state for the trial runner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedPostTrialRunnerMetadata(trialId: number, body: V1TrialRunnerMetadata, options?: any) {
        return InternalApiFp(this.configuration).determinedPostTrialRunnerMetadata(trialId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Record a checkpoint.
     * @param {number} checkpointMetadataTrialId The ID of the trial associated with the checkpoint.
     * @param {V1CheckpointMetadata} body The training metrics to persist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedReportTrialCheckpointMetadata(checkpointMetadataTrialId: number, body: V1CheckpointMetadata, options?: any) {
        return InternalApiFp(this.configuration).determinedReportTrialCheckpointMetadata(checkpointMetadataTrialId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary For bookkeeping, updates the progress towards to current requested searcher training length.
     * @param {number} trialId The id of the trial.
     * @param {number} body Total units completed by the trial, in terms of the unit used to configure the searcher.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedReportTrialProgress(trialId: number, body: number, options?: any) {
        return InternalApiFp(this.configuration).determinedReportTrialProgress(trialId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Reports to the searcher that the trial has completed the current requested amount of training with the given searcher validation metric.
     * @param {number} trialId The id of the trial.
     * @param {V1TrialEarlyExit} body The exit reason.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedReportTrialSearcherEarlyExit(trialId: number, body: V1TrialEarlyExit, options?: any) {
        return InternalApiFp(this.configuration).determinedReportTrialSearcherEarlyExit(trialId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Record training metrics for specified training.
     * @param {number} trainingMetricsTrialId The trial associated with these metrics.
     * @param {V1TrialMetrics} body The training metrics to persist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedReportTrialTrainingMetrics(trainingMetricsTrialId: number, body: V1TrialMetrics, options?: any) {
        return InternalApiFp(this.configuration).determinedReportTrialTrainingMetrics(trainingMetricsTrialId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Record validation metrics.
     * @param {number} validationMetricsTrialId The trial associated with these metrics.
     * @param {V1TrialMetrics} body The training metrics to persist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedReportTrialValidationMetrics(validationMetricsTrialId: number, body: V1TrialMetrics, options?: any) {
        return InternalApiFp(this.configuration).determinedReportTrialValidationMetrics(validationMetricsTrialId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a sample of the metrics over time for a sample of the trials.
     * @param {number} experimentId The id of the experiment.
     * @param {string} metricName A metric name.
     * @param {'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION'} metricType The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
     * @param {number} [maxTrials] Maximum number of trials to fetch data for.
     * @param {number} [maxDatapoints] Maximum number of initial / historical data points.
     * @param {number} [startBatches] Beginning of window (inclusive) to fetch data for.
     * @param {number} [endBatches] Ending of window (inclusive) to fetch data for.
     * @param {number} [periodSeconds] Seconds to wait when polling for updates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedTrialsSample(experimentId: number, metricName: string, metricType: 'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION', maxTrials?: number, maxDatapoints?: number, startBatches?: number, endBatches?: number, periodSeconds?: number, options?: any) {
        return InternalApiFp(this.configuration).determinedTrialsSample(experimentId, metricName, metricType, maxTrials, maxDatapoints, startBatches, endBatches, periodSeconds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a snapshot of a metric across all trials at a certain point of progress.
     * @param {number} experimentId The id of the experiment.
     * @param {string} metricName A metric name.
     * @param {'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION'} metricType The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
     * @param {number} batchesProcessed The point of progress at which to query metrics.
     * @param {number} [batchesMargin] A range either side of batches_processed to include near-misses.
     * @param {number} [periodSeconds] Seconds to wait when polling for updates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public determinedTrialsSnapshot(experimentId: number, metricName: string, metricType: 'METRIC_TYPE_UNSPECIFIED' | 'METRIC_TYPE_TRAINING' | 'METRIC_TYPE_VALIDATION', batchesProcessed: number, batchesMargin?: number, periodSeconds?: number, options?: any) {
        return InternalApiFp(this.configuration).determinedTrialsSnapshot(experimentId, metricName, metricType, batchesProcessed, batchesMargin, periodSeconds, options)(this.fetch, this.basePath);
    }

}

/**
 * ModelsApi - fetch parameter creator
 * @export
 */
export const ModelsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested model.
         * @param {number} modelId The name of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModel(modelId: number, options: any = {}): FetchArgs {
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new RequiredError('modelId','Required parameter modelId was null or undefined when calling determinedGetModel.');
            }
            const localVarPath = `/api/v1/models/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested model version.
         * @param {string} modelId The name of the model.
         * @param {number} modelVersion The version number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModelVersion(modelId: string, modelVersion: number, options: any = {}): FetchArgs {
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new RequiredError('modelId','Required parameter modelId was null or undefined when calling determinedGetModelVersion.');
            }
            // verify required parameter 'modelVersion' is not null or undefined
            if (modelVersion === null || modelVersion === undefined) {
                throw new RequiredError('modelVersion','Required parameter modelVersion was null or undefined when calling determinedGetModelVersion.');
            }
            const localVarPath = `/api/v1/models/{modelId}/versions/{modelVersion}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)))
                .replace(`{${"modelVersion"}}`, encodeURIComponent(String(modelVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of versions for the requested model.
         * @param {number} modelId The id of the model.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_VERSION' | 'SORT_BY_CREATION_TIME'} [sortBy] Sort the model versions by the given field.   - SORT_BY_UNSPECIFIED: Returns model versions in an unsorted list.  - SORT_BY_VERSION: Returns model versions sorted by version number.  - SORT_BY_CREATION_TIME: Returns model versions sorted by creation_time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order model versions in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of model versions before returning results. Negative values denote number of models to skip from the end before returning results.
         * @param {number} [limit] Limit the number of model versions. A value of 0 denotes no limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModelVersions(modelId: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_VERSION' | 'SORT_BY_CREATION_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new RequiredError('modelId','Required parameter modelId was null or undefined when calling determinedGetModelVersions.');
            }
            const localVarPath = `/api/v1/models/{modelId}/versions`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of models.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_CREATION_TIME' | 'SORT_BY_LAST_UPDATED_TIME' | 'SORT_BY_NUM_VERSIONS'} [sortBy] Sort the models by the given field.   - SORT_BY_UNSPECIFIED: Returns models in an unsorted list.  - SORT_BY_NAME: Returns models sorted by name.  - SORT_BY_DESCRIPTION: Returns models sorted by description.  - SORT_BY_CREATION_TIME: Returns models sorted by creation time.  - SORT_BY_LAST_UPDATED_TIME: Returns models sorted by last updated time.  - SORT_BY_NUM_VERSIONS: Returns models sorted by number of version.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order models in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of models before returning results. Negative values denote number of models to skip from the end before returning results.
         * @param {number} [limit] Limit the number of models. A value of 0 denotes no limit.
         * @param {string} [name] Limit the models to those matching the name.
         * @param {string} [description] Limit the models to those matching the description.
         * @param {Array<string>} [labels] Limit the models to those with the following labels.
         * @param {boolean} [archived] Limit to unarchived models only.
         * @param {Array<string>} [users] Limit the models to those made by the following users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModels(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_CREATION_TIME' | 'SORT_BY_LAST_UPDATED_TIME' | 'SORT_BY_NUM_VERSIONS', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, name?: string, description?: string, labels?: Array<string>, archived?: boolean, users?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/models`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (labels) {
                localVarQueryParameter['labels'] = labels;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (users) {
                localVarQueryParameter['users'] = users;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a model's fields.
         * @param {number} modelId The id of this model.
         * @param {V1PatchModelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPatchModel(modelId: number, body: V1PatchModelRequest, options: any = {}): FetchArgs {
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new RequiredError('modelId','Required parameter modelId was null or undefined when calling determinedPatchModel.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedPatchModel.');
            }
            const localVarPath = `/api/v1/models/{model.id}`
                .replace(`{${"model.id"}}`, encodeURIComponent(String(modelId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1PatchModelRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a model in the registry.
         * @param {string} modelName The name of the model.
         * @param {V1Model} body The model to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostModel(modelName: string, body: V1Model, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling determinedPostModel.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedPostModel.');
            }
            const localVarPath = `/api/v1/models/{model.name}`
                .replace(`{${"model.name"}}`, encodeURIComponent(String(modelName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Model" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a model version.
         * @param {number} modelId The id of the model to add a version to.
         * @param {V1PostModelVersionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostModelVersion(modelId: number, body: V1PostModelVersionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new RequiredError('modelId','Required parameter modelId was null or undefined when calling determinedPostModelVersion.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedPostModelVersion.');
            }
            const localVarPath = `/api/v1/models/{modelId}/versions`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1PostModelVersionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelsApi - functional programming interface
 * @export
 */
export const ModelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested model.
         * @param {number} modelId The name of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModel(modelId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).determinedGetModel(modelId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested model version.
         * @param {string} modelId The name of the model.
         * @param {number} modelVersion The version number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModelVersion(modelId: string, modelVersion: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelVersionResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).determinedGetModelVersion(modelId, modelVersion, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of versions for the requested model.
         * @param {number} modelId The id of the model.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_VERSION' | 'SORT_BY_CREATION_TIME'} [sortBy] Sort the model versions by the given field.   - SORT_BY_UNSPECIFIED: Returns model versions in an unsorted list.  - SORT_BY_VERSION: Returns model versions sorted by version number.  - SORT_BY_CREATION_TIME: Returns model versions sorted by creation_time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order model versions in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of model versions before returning results. Negative values denote number of models to skip from the end before returning results.
         * @param {number} [limit] Limit the number of model versions. A value of 0 denotes no limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModelVersions(modelId: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_VERSION' | 'SORT_BY_CREATION_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelVersionsResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).determinedGetModelVersions(modelId, sortBy, orderBy, offset, limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of models.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_CREATION_TIME' | 'SORT_BY_LAST_UPDATED_TIME' | 'SORT_BY_NUM_VERSIONS'} [sortBy] Sort the models by the given field.   - SORT_BY_UNSPECIFIED: Returns models in an unsorted list.  - SORT_BY_NAME: Returns models sorted by name.  - SORT_BY_DESCRIPTION: Returns models sorted by description.  - SORT_BY_CREATION_TIME: Returns models sorted by creation time.  - SORT_BY_LAST_UPDATED_TIME: Returns models sorted by last updated time.  - SORT_BY_NUM_VERSIONS: Returns models sorted by number of version.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order models in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of models before returning results. Negative values denote number of models to skip from the end before returning results.
         * @param {number} [limit] Limit the number of models. A value of 0 denotes no limit.
         * @param {string} [name] Limit the models to those matching the name.
         * @param {string} [description] Limit the models to those matching the description.
         * @param {Array<string>} [labels] Limit the models to those with the following labels.
         * @param {boolean} [archived] Limit to unarchived models only.
         * @param {Array<string>} [users] Limit the models to those made by the following users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModels(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_CREATION_TIME' | 'SORT_BY_LAST_UPDATED_TIME' | 'SORT_BY_NUM_VERSIONS', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, name?: string, description?: string, labels?: Array<string>, archived?: boolean, users?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelsResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).determinedGetModels(sortBy, orderBy, offset, limit, name, description, labels, archived, users, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch a model's fields.
         * @param {number} modelId The id of this model.
         * @param {V1PatchModelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPatchModel(modelId: number, body: V1PatchModelRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PatchModelResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).determinedPatchModel(modelId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a model in the registry.
         * @param {string} modelName The name of the model.
         * @param {V1Model} body The model to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostModel(modelName: string, body: V1Model, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostModelResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).determinedPostModel(modelName, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a model version.
         * @param {number} modelId The id of the model to add a version to.
         * @param {V1PostModelVersionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostModelVersion(modelId: number, body: V1PostModelVersionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostModelVersionResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).determinedPostModelVersion(modelId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ModelsApi - factory interface
 * @export
 */
export const ModelsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the requested model.
         * @param {number} modelId The name of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModel(modelId: number, options?: any) {
            return ModelsApiFp(configuration).determinedGetModel(modelId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested model version.
         * @param {string} modelId The name of the model.
         * @param {number} modelVersion The version number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModelVersion(modelId: string, modelVersion: number, options?: any) {
            return ModelsApiFp(configuration).determinedGetModelVersion(modelId, modelVersion, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of versions for the requested model.
         * @param {number} modelId The id of the model.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_VERSION' | 'SORT_BY_CREATION_TIME'} [sortBy] Sort the model versions by the given field.   - SORT_BY_UNSPECIFIED: Returns model versions in an unsorted list.  - SORT_BY_VERSION: Returns model versions sorted by version number.  - SORT_BY_CREATION_TIME: Returns model versions sorted by creation_time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order model versions in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of model versions before returning results. Negative values denote number of models to skip from the end before returning results.
         * @param {number} [limit] Limit the number of model versions. A value of 0 denotes no limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModelVersions(modelId: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_VERSION' | 'SORT_BY_CREATION_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, options?: any) {
            return ModelsApiFp(configuration).determinedGetModelVersions(modelId, sortBy, orderBy, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of models.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_CREATION_TIME' | 'SORT_BY_LAST_UPDATED_TIME' | 'SORT_BY_NUM_VERSIONS'} [sortBy] Sort the models by the given field.   - SORT_BY_UNSPECIFIED: Returns models in an unsorted list.  - SORT_BY_NAME: Returns models sorted by name.  - SORT_BY_DESCRIPTION: Returns models sorted by description.  - SORT_BY_CREATION_TIME: Returns models sorted by creation time.  - SORT_BY_LAST_UPDATED_TIME: Returns models sorted by last updated time.  - SORT_BY_NUM_VERSIONS: Returns models sorted by number of version.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order models in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of models before returning results. Negative values denote number of models to skip from the end before returning results.
         * @param {number} [limit] Limit the number of models. A value of 0 denotes no limit.
         * @param {string} [name] Limit the models to those matching the name.
         * @param {string} [description] Limit the models to those matching the description.
         * @param {Array<string>} [labels] Limit the models to those with the following labels.
         * @param {boolean} [archived] Limit to unarchived models only.
         * @param {Array<string>} [users] Limit the models to those made by the following users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModels(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_CREATION_TIME' | 'SORT_BY_LAST_UPDATED_TIME' | 'SORT_BY_NUM_VERSIONS', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, name?: string, description?: string, labels?: Array<string>, archived?: boolean, users?: Array<string>, options?: any) {
            return ModelsApiFp(configuration).determinedGetModels(sortBy, orderBy, offset, limit, name, description, labels, archived, users, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch a model's fields.
         * @param {number} modelId The id of this model.
         * @param {V1PatchModelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPatchModel(modelId: number, body: V1PatchModelRequest, options?: any) {
            return ModelsApiFp(configuration).determinedPatchModel(modelId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a model in the registry.
         * @param {string} modelName The name of the model.
         * @param {V1Model} body The model to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostModel(modelName: string, body: V1Model, options?: any) {
            return ModelsApiFp(configuration).determinedPostModel(modelName, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a model version.
         * @param {number} modelId The id of the model to add a version to.
         * @param {V1PostModelVersionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostModelVersion(modelId: number, body: V1PostModelVersionRequest, options?: any) {
            return ModelsApiFp(configuration).determinedPostModelVersion(modelId, body, options)(fetch, basePath);
        },
    };
};

/**
 * ModelsApi - object-oriented interface
 * @export
 * @class ModelsApi
 * @extends {BaseAPI}
 */
export class ModelsApi extends BaseAPI {
    /**
     * 
     * @summary Get the requested model.
     * @param {number} modelId The name of the template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public determinedGetModel(modelId: number, options?: any) {
        return ModelsApiFp(this.configuration).determinedGetModel(modelId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the requested model version.
     * @param {string} modelId The name of the model.
     * @param {number} modelVersion The version number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public determinedGetModelVersion(modelId: string, modelVersion: number, options?: any) {
        return ModelsApiFp(this.configuration).determinedGetModelVersion(modelId, modelVersion, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of versions for the requested model.
     * @param {number} modelId The id of the model.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_VERSION' | 'SORT_BY_CREATION_TIME'} [sortBy] Sort the model versions by the given field.   - SORT_BY_UNSPECIFIED: Returns model versions in an unsorted list.  - SORT_BY_VERSION: Returns model versions sorted by version number.  - SORT_BY_CREATION_TIME: Returns model versions sorted by creation_time.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order model versions in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of model versions before returning results. Negative values denote number of models to skip from the end before returning results.
     * @param {number} [limit] Limit the number of model versions. A value of 0 denotes no limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public determinedGetModelVersions(modelId: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_VERSION' | 'SORT_BY_CREATION_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, options?: any) {
        return ModelsApiFp(this.configuration).determinedGetModelVersions(modelId, sortBy, orderBy, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of models.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_CREATION_TIME' | 'SORT_BY_LAST_UPDATED_TIME' | 'SORT_BY_NUM_VERSIONS'} [sortBy] Sort the models by the given field.   - SORT_BY_UNSPECIFIED: Returns models in an unsorted list.  - SORT_BY_NAME: Returns models sorted by name.  - SORT_BY_DESCRIPTION: Returns models sorted by description.  - SORT_BY_CREATION_TIME: Returns models sorted by creation time.  - SORT_BY_LAST_UPDATED_TIME: Returns models sorted by last updated time.  - SORT_BY_NUM_VERSIONS: Returns models sorted by number of version.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order models in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of models before returning results. Negative values denote number of models to skip from the end before returning results.
     * @param {number} [limit] Limit the number of models. A value of 0 denotes no limit.
     * @param {string} [name] Limit the models to those matching the name.
     * @param {string} [description] Limit the models to those matching the description.
     * @param {Array<string>} [labels] Limit the models to those with the following labels.
     * @param {boolean} [archived] Limit to unarchived models only.
     * @param {Array<string>} [users] Limit the models to those made by the following users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public determinedGetModels(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_CREATION_TIME' | 'SORT_BY_LAST_UPDATED_TIME' | 'SORT_BY_NUM_VERSIONS', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, name?: string, description?: string, labels?: Array<string>, archived?: boolean, users?: Array<string>, options?: any) {
        return ModelsApiFp(this.configuration).determinedGetModels(sortBy, orderBy, offset, limit, name, description, labels, archived, users, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch a model's fields.
     * @param {number} modelId The id of this model.
     * @param {V1PatchModelRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public determinedPatchModel(modelId: number, body: V1PatchModelRequest, options?: any) {
        return ModelsApiFp(this.configuration).determinedPatchModel(modelId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a model in the registry.
     * @param {string} modelName The name of the model.
     * @param {V1Model} body The model to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public determinedPostModel(modelName: string, body: V1Model, options?: any) {
        return ModelsApiFp(this.configuration).determinedPostModel(modelName, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a model version.
     * @param {number} modelId The id of the model to add a version to.
     * @param {V1PostModelVersionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public determinedPostModelVersion(modelId: number, body: V1PostModelVersionRequest, options?: any) {
        return ModelsApiFp(this.configuration).determinedPostModelVersion(modelId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * NotebooksApi - fetch parameter creator
 * @export
 */
export const NotebooksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetNotebook(notebookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'notebookId' is not null or undefined
            if (notebookId === null || notebookId === undefined) {
                throw new RequiredError('notebookId','Required parameter notebookId was null or undefined when calling determinedGetNotebook.');
            }
            const localVarPath = `/api/v1/notebooks/{notebookId}`
                .replace(`{${"notebookId"}}`, encodeURIComponent(String(notebookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of notebooks.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort notebooks by the given field.   - SORT_BY_UNSPECIFIED: Returns notebooks in an unsorted list.  - SORT_BY_ID: Returns notebooks sorted by id.  - SORT_BY_DESCRIPTION: Returns notebooks sorted by description.  - SORT_BY_START_TIME: Return notebooks sorted by start time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order notebooks in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of notebooks before returning results. Negative values denote number of notebooks to skip from the end before returning results.
         * @param {number} [limit] Limit the number of notebooks. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit notebooks to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetNotebooks(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/notebooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (users) {
                localVarQueryParameter['users'] = users;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillNotebook(notebookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'notebookId' is not null or undefined
            if (notebookId === null || notebookId === undefined) {
                throw new RequiredError('notebookId','Required parameter notebookId was null or undefined when calling determinedKillNotebook.');
            }
            const localVarPath = `/api/v1/notebooks/{notebookId}/kill`
                .replace(`{${"notebookId"}}`, encodeURIComponent(String(notebookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Launch a notebook.
         * @param {V1LaunchNotebookRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLaunchNotebook(body: V1LaunchNotebookRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedLaunchNotebook.');
            }
            const localVarPath = `/api/v1/notebooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1LaunchNotebookRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream notebook logs.
         * @param {string} notebookId Requested Notebook id.
         * @param {number} [offset] Skip the number of notebook logs before returning results. Negative values denote number of notebook logs to skip from the end before returning results.
         * @param {number} [limit] Limit the number of notebook logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the notebook stops or the limit is reached.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedNotebookLogs(notebookId: string, offset?: number, limit?: number, follow?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'notebookId' is not null or undefined
            if (notebookId === null || notebookId === undefined) {
                throw new RequiredError('notebookId','Required parameter notebookId was null or undefined when calling determinedNotebookLogs.');
            }
            const localVarPath = `/api/v1/notebooks/{notebookId}/logs`
                .replace(`{${"notebookId"}}`, encodeURIComponent(String(notebookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the priority of the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {V1SetNotebookPriorityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetNotebookPriority(notebookId: string, body: V1SetNotebookPriorityRequest, options: any = {}): FetchArgs {
            // verify required parameter 'notebookId' is not null or undefined
            if (notebookId === null || notebookId === undefined) {
                throw new RequiredError('notebookId','Required parameter notebookId was null or undefined when calling determinedSetNotebookPriority.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedSetNotebookPriority.');
            }
            const localVarPath = `/api/v1/notebooks/{notebookId}/set_priority`
                .replace(`{${"notebookId"}}`, encodeURIComponent(String(notebookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1SetNotebookPriorityRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotebooksApi - functional programming interface
 * @export
 */
export const NotebooksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetNotebook(notebookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetNotebookResponse> {
            const localVarFetchArgs = NotebooksApiFetchParamCreator(configuration).determinedGetNotebook(notebookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of notebooks.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort notebooks by the given field.   - SORT_BY_UNSPECIFIED: Returns notebooks in an unsorted list.  - SORT_BY_ID: Returns notebooks sorted by id.  - SORT_BY_DESCRIPTION: Returns notebooks sorted by description.  - SORT_BY_START_TIME: Return notebooks sorted by start time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order notebooks in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of notebooks before returning results. Negative values denote number of notebooks to skip from the end before returning results.
         * @param {number} [limit] Limit the number of notebooks. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit notebooks to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetNotebooks(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetNotebooksResponse> {
            const localVarFetchArgs = NotebooksApiFetchParamCreator(configuration).determinedGetNotebooks(sortBy, orderBy, offset, limit, users, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillNotebook(notebookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillNotebookResponse> {
            const localVarFetchArgs = NotebooksApiFetchParamCreator(configuration).determinedKillNotebook(notebookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Launch a notebook.
         * @param {V1LaunchNotebookRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLaunchNotebook(body: V1LaunchNotebookRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LaunchNotebookResponse> {
            const localVarFetchArgs = NotebooksApiFetchParamCreator(configuration).determinedLaunchNotebook(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream notebook logs.
         * @param {string} notebookId Requested Notebook id.
         * @param {number} [offset] Skip the number of notebook logs before returning results. Negative values denote number of notebook logs to skip from the end before returning results.
         * @param {number} [limit] Limit the number of notebook logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the notebook stops or the limit is reached.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedNotebookLogs(notebookId: string, offset?: number, limit?: number, follow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1NotebookLogsResponse> {
            const localVarFetchArgs = NotebooksApiFetchParamCreator(configuration).determinedNotebookLogs(notebookId, offset, limit, follow, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the priority of the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {V1SetNotebookPriorityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetNotebookPriority(notebookId: string, body: V1SetNotebookPriorityRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SetNotebookPriorityResponse> {
            const localVarFetchArgs = NotebooksApiFetchParamCreator(configuration).determinedSetNotebookPriority(notebookId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotebooksApi - factory interface
 * @export
 */
export const NotebooksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetNotebook(notebookId: string, options?: any) {
            return NotebooksApiFp(configuration).determinedGetNotebook(notebookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of notebooks.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort notebooks by the given field.   - SORT_BY_UNSPECIFIED: Returns notebooks in an unsorted list.  - SORT_BY_ID: Returns notebooks sorted by id.  - SORT_BY_DESCRIPTION: Returns notebooks sorted by description.  - SORT_BY_START_TIME: Return notebooks sorted by start time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order notebooks in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of notebooks before returning results. Negative values denote number of notebooks to skip from the end before returning results.
         * @param {number} [limit] Limit the number of notebooks. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit notebooks to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetNotebooks(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options?: any) {
            return NotebooksApiFp(configuration).determinedGetNotebooks(sortBy, orderBy, offset, limit, users, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillNotebook(notebookId: string, options?: any) {
            return NotebooksApiFp(configuration).determinedKillNotebook(notebookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Launch a notebook.
         * @param {V1LaunchNotebookRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLaunchNotebook(body: V1LaunchNotebookRequest, options?: any) {
            return NotebooksApiFp(configuration).determinedLaunchNotebook(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream notebook logs.
         * @param {string} notebookId Requested Notebook id.
         * @param {number} [offset] Skip the number of notebook logs before returning results. Negative values denote number of notebook logs to skip from the end before returning results.
         * @param {number} [limit] Limit the number of notebook logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the notebook stops or the limit is reached.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedNotebookLogs(notebookId: string, offset?: number, limit?: number, follow?: boolean, options?: any) {
            return NotebooksApiFp(configuration).determinedNotebookLogs(notebookId, offset, limit, follow, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the priority of the requested notebook.
         * @param {string} notebookId The id of the notebook.
         * @param {V1SetNotebookPriorityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetNotebookPriority(notebookId: string, body: V1SetNotebookPriorityRequest, options?: any) {
            return NotebooksApiFp(configuration).determinedSetNotebookPriority(notebookId, body, options)(fetch, basePath);
        },
    };
};

/**
 * NotebooksApi - object-oriented interface
 * @export
 * @class NotebooksApi
 * @extends {BaseAPI}
 */
export class NotebooksApi extends BaseAPI {
    /**
     * 
     * @summary Get the requested notebook.
     * @param {string} notebookId The id of the notebook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    public determinedGetNotebook(notebookId: string, options?: any) {
        return NotebooksApiFp(this.configuration).determinedGetNotebook(notebookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of notebooks.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort notebooks by the given field.   - SORT_BY_UNSPECIFIED: Returns notebooks in an unsorted list.  - SORT_BY_ID: Returns notebooks sorted by id.  - SORT_BY_DESCRIPTION: Returns notebooks sorted by description.  - SORT_BY_START_TIME: Return notebooks sorted by start time.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order notebooks in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of notebooks before returning results. Negative values denote number of notebooks to skip from the end before returning results.
     * @param {number} [limit] Limit the number of notebooks. A value of 0 denotes no limit.
     * @param {Array<string>} [users] Limit notebooks to those that are owned by the specified users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    public determinedGetNotebooks(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options?: any) {
        return NotebooksApiFp(this.configuration).determinedGetNotebooks(sortBy, orderBy, offset, limit, users, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Kill the requested notebook.
     * @param {string} notebookId The id of the notebook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    public determinedKillNotebook(notebookId: string, options?: any) {
        return NotebooksApiFp(this.configuration).determinedKillNotebook(notebookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Launch a notebook.
     * @param {V1LaunchNotebookRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    public determinedLaunchNotebook(body: V1LaunchNotebookRequest, options?: any) {
        return NotebooksApiFp(this.configuration).determinedLaunchNotebook(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stream notebook logs.
     * @param {string} notebookId Requested Notebook id.
     * @param {number} [offset] Skip the number of notebook logs before returning results. Negative values denote number of notebook logs to skip from the end before returning results.
     * @param {number} [limit] Limit the number of notebook logs. A value of 0 denotes no limit.
     * @param {boolean} [follow] Continue following logs until the notebook stops or the limit is reached.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    public determinedNotebookLogs(notebookId: string, offset?: number, limit?: number, follow?: boolean, options?: any) {
        return NotebooksApiFp(this.configuration).determinedNotebookLogs(notebookId, offset, limit, follow, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set the priority of the requested notebook.
     * @param {string} notebookId The id of the notebook.
     * @param {V1SetNotebookPriorityRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    public determinedSetNotebookPriority(notebookId: string, body: V1SetNotebookPriorityRequest, options?: any) {
        return NotebooksApiFp(this.configuration).determinedSetNotebookPriority(notebookId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProfilerApi - fetch parameter creator
 * @export
 */
export const ProfilerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stream the available series in a trial's profiler metrics.
         * @param {number} trialId The requested trial&#39;s id.
         * @param {boolean} [follow] Continue streaming labels until the trial stops. Defaults to False.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrialProfilerAvailableSeries(trialId: number, follow?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling determinedGetTrialProfilerAvailableSeries.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/profiler/available_series`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream trial profiler metrics.
         * @param {number} labelsTrialId The ID of the trial.
         * @param {string} [labelsName] The name of the metric.
         * @param {string} [labelsAgentId] The agent ID associated with the metric.
         * @param {string} [labelsGpuUuid] The GPU UUID associated with the metric.
         * @param {'PROFILER_METRIC_TYPE_UNSPECIFIED' | 'PROFILER_METRIC_TYPE_SYSTEM' | 'PROFILER_METRIC_TYPE_TIMING' | 'PROFILER_METRIC_TYPE_MISC'} [labelsMetricType] The type of the metric.   - PROFILER_METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - PROFILER_METRIC_TYPE_SYSTEM: For systems metrics, like GPU utilization or memory.  - PROFILER_METRIC_TYPE_TIMING: For timing metrics, like how long a backwards pass or getting a batch from the dataloader took.  - PROFILER_METRIC_TYPE_MISC: For other miscellaneous metrics.
         * @param {boolean} [follow] Continue streaming metrics until the trial stops. Defaults to False.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrialProfilerMetrics(labelsTrialId: number, labelsName?: string, labelsAgentId?: string, labelsGpuUuid?: string, labelsMetricType?: 'PROFILER_METRIC_TYPE_UNSPECIFIED' | 'PROFILER_METRIC_TYPE_SYSTEM' | 'PROFILER_METRIC_TYPE_TIMING' | 'PROFILER_METRIC_TYPE_MISC', follow?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'labelsTrialId' is not null or undefined
            if (labelsTrialId === null || labelsTrialId === undefined) {
                throw new RequiredError('labelsTrialId','Required parameter labelsTrialId was null or undefined when calling determinedGetTrialProfilerMetrics.');
            }
            const localVarPath = `/api/v1/trials/{labels.trialId}/profiler/metrics`
                .replace(`{${"labels.trialId"}}`, encodeURIComponent(String(labelsTrialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (labelsName !== undefined) {
                localVarQueryParameter['labels.name'] = labelsName;
            }

            if (labelsAgentId !== undefined) {
                localVarQueryParameter['labels.agentId'] = labelsAgentId;
            }

            if (labelsGpuUuid !== undefined) {
                localVarQueryParameter['labels.gpuUuid'] = labelsGpuUuid;
            }

            if (labelsMetricType !== undefined) {
                localVarQueryParameter['labels.metricType'] = labelsMetricType;
            }

            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilerApi - functional programming interface
 * @export
 */
export const ProfilerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stream the available series in a trial's profiler metrics.
         * @param {number} trialId The requested trial&#39;s id.
         * @param {boolean} [follow] Continue streaming labels until the trial stops. Defaults to False.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrialProfilerAvailableSeries(trialId: number, follow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1GetTrialProfilerAvailableSeriesResponse> {
            const localVarFetchArgs = ProfilerApiFetchParamCreator(configuration).determinedGetTrialProfilerAvailableSeries(trialId, follow, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream trial profiler metrics.
         * @param {number} labelsTrialId The ID of the trial.
         * @param {string} [labelsName] The name of the metric.
         * @param {string} [labelsAgentId] The agent ID associated with the metric.
         * @param {string} [labelsGpuUuid] The GPU UUID associated with the metric.
         * @param {'PROFILER_METRIC_TYPE_UNSPECIFIED' | 'PROFILER_METRIC_TYPE_SYSTEM' | 'PROFILER_METRIC_TYPE_TIMING' | 'PROFILER_METRIC_TYPE_MISC'} [labelsMetricType] The type of the metric.   - PROFILER_METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - PROFILER_METRIC_TYPE_SYSTEM: For systems metrics, like GPU utilization or memory.  - PROFILER_METRIC_TYPE_TIMING: For timing metrics, like how long a backwards pass or getting a batch from the dataloader took.  - PROFILER_METRIC_TYPE_MISC: For other miscellaneous metrics.
         * @param {boolean} [follow] Continue streaming metrics until the trial stops. Defaults to False.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrialProfilerMetrics(labelsTrialId: number, labelsName?: string, labelsAgentId?: string, labelsGpuUuid?: string, labelsMetricType?: 'PROFILER_METRIC_TYPE_UNSPECIFIED' | 'PROFILER_METRIC_TYPE_SYSTEM' | 'PROFILER_METRIC_TYPE_TIMING' | 'PROFILER_METRIC_TYPE_MISC', follow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1GetTrialProfilerMetricsResponse> {
            const localVarFetchArgs = ProfilerApiFetchParamCreator(configuration).determinedGetTrialProfilerMetrics(labelsTrialId, labelsName, labelsAgentId, labelsGpuUuid, labelsMetricType, follow, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProfilerApi - factory interface
 * @export
 */
export const ProfilerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Stream the available series in a trial's profiler metrics.
         * @param {number} trialId The requested trial&#39;s id.
         * @param {boolean} [follow] Continue streaming labels until the trial stops. Defaults to False.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrialProfilerAvailableSeries(trialId: number, follow?: boolean, options?: any) {
            return ProfilerApiFp(configuration).determinedGetTrialProfilerAvailableSeries(trialId, follow, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream trial profiler metrics.
         * @param {number} labelsTrialId The ID of the trial.
         * @param {string} [labelsName] The name of the metric.
         * @param {string} [labelsAgentId] The agent ID associated with the metric.
         * @param {string} [labelsGpuUuid] The GPU UUID associated with the metric.
         * @param {'PROFILER_METRIC_TYPE_UNSPECIFIED' | 'PROFILER_METRIC_TYPE_SYSTEM' | 'PROFILER_METRIC_TYPE_TIMING' | 'PROFILER_METRIC_TYPE_MISC'} [labelsMetricType] The type of the metric.   - PROFILER_METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - PROFILER_METRIC_TYPE_SYSTEM: For systems metrics, like GPU utilization or memory.  - PROFILER_METRIC_TYPE_TIMING: For timing metrics, like how long a backwards pass or getting a batch from the dataloader took.  - PROFILER_METRIC_TYPE_MISC: For other miscellaneous metrics.
         * @param {boolean} [follow] Continue streaming metrics until the trial stops. Defaults to False.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrialProfilerMetrics(labelsTrialId: number, labelsName?: string, labelsAgentId?: string, labelsGpuUuid?: string, labelsMetricType?: 'PROFILER_METRIC_TYPE_UNSPECIFIED' | 'PROFILER_METRIC_TYPE_SYSTEM' | 'PROFILER_METRIC_TYPE_TIMING' | 'PROFILER_METRIC_TYPE_MISC', follow?: boolean, options?: any) {
            return ProfilerApiFp(configuration).determinedGetTrialProfilerMetrics(labelsTrialId, labelsName, labelsAgentId, labelsGpuUuid, labelsMetricType, follow, options)(fetch, basePath);
        },
    };
};

/**
 * ProfilerApi - object-oriented interface
 * @export
 * @class ProfilerApi
 * @extends {BaseAPI}
 */
export class ProfilerApi extends BaseAPI {
    /**
     * 
     * @summary Stream the available series in a trial's profiler metrics.
     * @param {number} trialId The requested trial&#39;s id.
     * @param {boolean} [follow] Continue streaming labels until the trial stops. Defaults to False.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilerApi
     */
    public determinedGetTrialProfilerAvailableSeries(trialId: number, follow?: boolean, options?: any) {
        return ProfilerApiFp(this.configuration).determinedGetTrialProfilerAvailableSeries(trialId, follow, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stream trial profiler metrics.
     * @param {number} labelsTrialId The ID of the trial.
     * @param {string} [labelsName] The name of the metric.
     * @param {string} [labelsAgentId] The agent ID associated with the metric.
     * @param {string} [labelsGpuUuid] The GPU UUID associated with the metric.
     * @param {'PROFILER_METRIC_TYPE_UNSPECIFIED' | 'PROFILER_METRIC_TYPE_SYSTEM' | 'PROFILER_METRIC_TYPE_TIMING' | 'PROFILER_METRIC_TYPE_MISC'} [labelsMetricType] The type of the metric.   - PROFILER_METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - PROFILER_METRIC_TYPE_SYSTEM: For systems metrics, like GPU utilization or memory.  - PROFILER_METRIC_TYPE_TIMING: For timing metrics, like how long a backwards pass or getting a batch from the dataloader took.  - PROFILER_METRIC_TYPE_MISC: For other miscellaneous metrics.
     * @param {boolean} [follow] Continue streaming metrics until the trial stops. Defaults to False.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilerApi
     */
    public determinedGetTrialProfilerMetrics(labelsTrialId: number, labelsName?: string, labelsAgentId?: string, labelsGpuUuid?: string, labelsMetricType?: 'PROFILER_METRIC_TYPE_UNSPECIFIED' | 'PROFILER_METRIC_TYPE_SYSTEM' | 'PROFILER_METRIC_TYPE_TIMING' | 'PROFILER_METRIC_TYPE_MISC', follow?: boolean, options?: any) {
        return ProfilerApiFp(this.configuration).determinedGetTrialProfilerMetrics(labelsTrialId, labelsName, labelsAgentId, labelsGpuUuid, labelsMetricType, follow, options)(this.fetch, this.basePath);
    }

}

/**
 * ShellsApi - fetch parameter creator
 * @export
 */
export const ShellsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetShell(shellId: string, options: any = {}): FetchArgs {
            // verify required parameter 'shellId' is not null or undefined
            if (shellId === null || shellId === undefined) {
                throw new RequiredError('shellId','Required parameter shellId was null or undefined when calling determinedGetShell.');
            }
            const localVarPath = `/api/v1/shells/{shellId}`
                .replace(`{${"shellId"}}`, encodeURIComponent(String(shellId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of shells.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort shells by the given field.   - SORT_BY_UNSPECIFIED: Returns shells in an unsorted list.  - SORT_BY_ID: Returns shells sorted by id.  - SORT_BY_DESCRIPTION: Returns shells sorted by description.  - SORT_BY_START_TIME: Return shells sorted by start time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order shells in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of shells before returning results. Negative values denote number of shells to skip from the end before returning results.
         * @param {number} [limit] Limit the number of shells. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit shells to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetShells(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/shells`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (users) {
                localVarQueryParameter['users'] = users;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillShell(shellId: string, options: any = {}): FetchArgs {
            // verify required parameter 'shellId' is not null or undefined
            if (shellId === null || shellId === undefined) {
                throw new RequiredError('shellId','Required parameter shellId was null or undefined when calling determinedKillShell.');
            }
            const localVarPath = `/api/v1/shells/{shellId}/kill`
                .replace(`{${"shellId"}}`, encodeURIComponent(String(shellId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Launch a shell.
         * @param {V1LaunchShellRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLaunchShell(body: V1LaunchShellRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedLaunchShell.');
            }
            const localVarPath = `/api/v1/shells`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1LaunchShellRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the priority of the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {V1SetShellPriorityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetShellPriority(shellId: string, body: V1SetShellPriorityRequest, options: any = {}): FetchArgs {
            // verify required parameter 'shellId' is not null or undefined
            if (shellId === null || shellId === undefined) {
                throw new RequiredError('shellId','Required parameter shellId was null or undefined when calling determinedSetShellPriority.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedSetShellPriority.');
            }
            const localVarPath = `/api/v1/shells/{shellId}/set_priority`
                .replace(`{${"shellId"}}`, encodeURIComponent(String(shellId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1SetShellPriorityRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShellsApi - functional programming interface
 * @export
 */
export const ShellsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetShell(shellId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetShellResponse> {
            const localVarFetchArgs = ShellsApiFetchParamCreator(configuration).determinedGetShell(shellId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of shells.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort shells by the given field.   - SORT_BY_UNSPECIFIED: Returns shells in an unsorted list.  - SORT_BY_ID: Returns shells sorted by id.  - SORT_BY_DESCRIPTION: Returns shells sorted by description.  - SORT_BY_START_TIME: Return shells sorted by start time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order shells in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of shells before returning results. Negative values denote number of shells to skip from the end before returning results.
         * @param {number} [limit] Limit the number of shells. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit shells to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetShells(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetShellsResponse> {
            const localVarFetchArgs = ShellsApiFetchParamCreator(configuration).determinedGetShells(sortBy, orderBy, offset, limit, users, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillShell(shellId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillShellResponse> {
            const localVarFetchArgs = ShellsApiFetchParamCreator(configuration).determinedKillShell(shellId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Launch a shell.
         * @param {V1LaunchShellRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLaunchShell(body: V1LaunchShellRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LaunchShellResponse> {
            const localVarFetchArgs = ShellsApiFetchParamCreator(configuration).determinedLaunchShell(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the priority of the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {V1SetShellPriorityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetShellPriority(shellId: string, body: V1SetShellPriorityRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SetShellPriorityResponse> {
            const localVarFetchArgs = ShellsApiFetchParamCreator(configuration).determinedSetShellPriority(shellId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ShellsApi - factory interface
 * @export
 */
export const ShellsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetShell(shellId: string, options?: any) {
            return ShellsApiFp(configuration).determinedGetShell(shellId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of shells.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort shells by the given field.   - SORT_BY_UNSPECIFIED: Returns shells in an unsorted list.  - SORT_BY_ID: Returns shells sorted by id.  - SORT_BY_DESCRIPTION: Returns shells sorted by description.  - SORT_BY_START_TIME: Return shells sorted by start time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order shells in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of shells before returning results. Negative values denote number of shells to skip from the end before returning results.
         * @param {number} [limit] Limit the number of shells. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit shells to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetShells(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options?: any) {
            return ShellsApiFp(configuration).determinedGetShells(sortBy, orderBy, offset, limit, users, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillShell(shellId: string, options?: any) {
            return ShellsApiFp(configuration).determinedKillShell(shellId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Launch a shell.
         * @param {V1LaunchShellRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLaunchShell(body: V1LaunchShellRequest, options?: any) {
            return ShellsApiFp(configuration).determinedLaunchShell(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the priority of the requested shell.
         * @param {string} shellId The id of the shell.
         * @param {V1SetShellPriorityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetShellPriority(shellId: string, body: V1SetShellPriorityRequest, options?: any) {
            return ShellsApiFp(configuration).determinedSetShellPriority(shellId, body, options)(fetch, basePath);
        },
    };
};

/**
 * ShellsApi - object-oriented interface
 * @export
 * @class ShellsApi
 * @extends {BaseAPI}
 */
export class ShellsApi extends BaseAPI {
    /**
     * 
     * @summary Get the requested shell.
     * @param {string} shellId The id of the shell.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShellsApi
     */
    public determinedGetShell(shellId: string, options?: any) {
        return ShellsApiFp(this.configuration).determinedGetShell(shellId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of shells.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort shells by the given field.   - SORT_BY_UNSPECIFIED: Returns shells in an unsorted list.  - SORT_BY_ID: Returns shells sorted by id.  - SORT_BY_DESCRIPTION: Returns shells sorted by description.  - SORT_BY_START_TIME: Return shells sorted by start time.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order shells in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of shells before returning results. Negative values denote number of shells to skip from the end before returning results.
     * @param {number} [limit] Limit the number of shells. A value of 0 denotes no limit.
     * @param {Array<string>} [users] Limit shells to those that are owned by the specified users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShellsApi
     */
    public determinedGetShells(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options?: any) {
        return ShellsApiFp(this.configuration).determinedGetShells(sortBy, orderBy, offset, limit, users, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Kill the requested shell.
     * @param {string} shellId The id of the shell.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShellsApi
     */
    public determinedKillShell(shellId: string, options?: any) {
        return ShellsApiFp(this.configuration).determinedKillShell(shellId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Launch a shell.
     * @param {V1LaunchShellRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShellsApi
     */
    public determinedLaunchShell(body: V1LaunchShellRequest, options?: any) {
        return ShellsApiFp(this.configuration).determinedLaunchShell(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set the priority of the requested shell.
     * @param {string} shellId The id of the shell.
     * @param {V1SetShellPriorityRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShellsApi
     */
    public determinedSetShellPriority(shellId: string, body: V1SetShellPriorityRequest, options?: any) {
        return ShellsApiFp(this.configuration).determinedSetShellPriority(shellId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * TemplatesApi - fetch parameter creator
 * @export
 */
export const TemplatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDeleteTemplate(templateName: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling determinedDeleteTemplate.');
            }
            const localVarPath = `/api/v1/templates/{templateName}`
                .replace(`{${"templateName"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTemplate(templateName: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling determinedGetTemplate.');
            }
            const localVarPath = `/api/v1/templates/{templateName}`
                .replace(`{${"templateName"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of templates.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME'} [sortBy] Sort templates by the given field.   - SORT_BY_UNSPECIFIED: Returns templates in an unsorted list.  - SORT_BY_NAME: Returns templates sorted by name.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order templates in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of templates before returning results. Negative values denote number of templates to skip from the end before returning results.
         * @param {number} [limit] Limit the number of templates. A value of 0 denotes no limit.
         * @param {string} [name] Limit templates to those that match the name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTemplates(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, name?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update or create (upsert) the requested template.
         * @param {string} templateName The name of the template.
         * @param {V1Template} body The template to put.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPutTemplate(templateName: string, body: V1Template, options: any = {}): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling determinedPutTemplate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedPutTemplate.');
            }
            const localVarPath = `/api/v1/templates/{template.name}`
                .replace(`{${"template.name"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Template" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDeleteTemplate(templateName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeleteTemplateResponse> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).determinedDeleteTemplate(templateName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTemplate(templateName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTemplateResponse> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).determinedGetTemplate(templateName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of templates.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME'} [sortBy] Sort templates by the given field.   - SORT_BY_UNSPECIFIED: Returns templates in an unsorted list.  - SORT_BY_NAME: Returns templates sorted by name.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order templates in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of templates before returning results. Negative values denote number of templates to skip from the end before returning results.
         * @param {number} [limit] Limit the number of templates. A value of 0 denotes no limit.
         * @param {string} [name] Limit templates to those that match the name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTemplates(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTemplatesResponse> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).determinedGetTemplates(sortBy, orderBy, offset, limit, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update or create (upsert) the requested template.
         * @param {string} templateName The name of the template.
         * @param {V1Template} body The template to put.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPutTemplate(templateName: string, body: V1Template, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PutTemplateResponse> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).determinedPutTemplate(templateName, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete a template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDeleteTemplate(templateName: string, options?: any) {
            return TemplatesApiFp(configuration).determinedDeleteTemplate(templateName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTemplate(templateName: string, options?: any) {
            return TemplatesApiFp(configuration).determinedGetTemplate(templateName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of templates.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME'} [sortBy] Sort templates by the given field.   - SORT_BY_UNSPECIFIED: Returns templates in an unsorted list.  - SORT_BY_NAME: Returns templates sorted by name.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order templates in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of templates before returning results. Negative values denote number of templates to skip from the end before returning results.
         * @param {number} [limit] Limit the number of templates. A value of 0 denotes no limit.
         * @param {string} [name] Limit templates to those that match the name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTemplates(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, name?: string, options?: any) {
            return TemplatesApiFp(configuration).determinedGetTemplates(sortBy, orderBy, offset, limit, name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update or create (upsert) the requested template.
         * @param {string} templateName The name of the template.
         * @param {V1Template} body The template to put.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPutTemplate(templateName: string, body: V1Template, options?: any) {
            return TemplatesApiFp(configuration).determinedPutTemplate(templateName, body, options)(fetch, basePath);
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a template.
     * @param {string} templateName The id of the template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public determinedDeleteTemplate(templateName: string, options?: any) {
        return TemplatesApiFp(this.configuration).determinedDeleteTemplate(templateName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the requested template.
     * @param {string} templateName The id of the template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public determinedGetTemplate(templateName: string, options?: any) {
        return TemplatesApiFp(this.configuration).determinedGetTemplate(templateName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of templates.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME'} [sortBy] Sort templates by the given field.   - SORT_BY_UNSPECIFIED: Returns templates in an unsorted list.  - SORT_BY_NAME: Returns templates sorted by name.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order templates in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of templates before returning results. Negative values denote number of templates to skip from the end before returning results.
     * @param {number} [limit] Limit the number of templates. A value of 0 denotes no limit.
     * @param {string} [name] Limit templates to those that match the name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public determinedGetTemplates(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_NAME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, name?: string, options?: any) {
        return TemplatesApiFp(this.configuration).determinedGetTemplates(sortBy, orderBy, offset, limit, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update or create (upsert) the requested template.
     * @param {string} templateName The name of the template.
     * @param {V1Template} body The template to put.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public determinedPutTemplate(templateName: string, body: V1Template, options?: any) {
        return TemplatesApiFp(this.configuration).determinedPutTemplate(templateName, body, options)(this.fetch, this.basePath);
    }

}

/**
 * TensorboardsApi - fetch parameter creator
 * @export
 */
export const TensorboardsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested tensorboard.
         * @param {string} tensorboardId The id of the tensorboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTensorboard(tensorboardId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tensorboardId' is not null or undefined
            if (tensorboardId === null || tensorboardId === undefined) {
                throw new RequiredError('tensorboardId','Required parameter tensorboardId was null or undefined when calling determinedGetTensorboard.');
            }
            const localVarPath = `/api/v1/tensorboards/{tensorboardId}`
                .replace(`{${"tensorboardId"}}`, encodeURIComponent(String(tensorboardId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of tensorboards.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort tensorboards by the given field.   - SORT_BY_UNSPECIFIED: Returns tensorboards in an unsorted list.  - SORT_BY_ID: Returns tensorboards sorted by id.  - SORT_BY_DESCRIPTION: Returns tensorboards sorted by description.  - SORT_BY_START_TIME: Return tensorboards sorted by start time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order tensorboards in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of tensorboards before returning results. Negative values denote number of tensorboards to skip from the end before returning results.
         * @param {number} [limit] Limit the number of tensorboards. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit tensorboards to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTensorboards(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/tensorboards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (users) {
                localVarQueryParameter['users'] = users;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill the requested tensorboard.
         * @param {string} tensorboardId The id of the tensorboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillTensorboard(tensorboardId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tensorboardId' is not null or undefined
            if (tensorboardId === null || tensorboardId === undefined) {
                throw new RequiredError('tensorboardId','Required parameter tensorboardId was null or undefined when calling determinedKillTensorboard.');
            }
            const localVarPath = `/api/v1/tensorboards/{tensorboardId}/kill`
                .replace(`{${"tensorboardId"}}`, encodeURIComponent(String(tensorboardId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Launch a tensorboard.
         * @param {V1LaunchTensorboardRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLaunchTensorboard(body: V1LaunchTensorboardRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedLaunchTensorboard.');
            }
            const localVarPath = `/api/v1/tensorboards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1LaunchTensorboardRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the priority of the requested TensorBoard.
         * @param {string} tensorboardId The id of the TensorBoard.
         * @param {V1SetTensorboardPriorityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetTensorboardPriority(tensorboardId: string, body: V1SetTensorboardPriorityRequest, options: any = {}): FetchArgs {
            // verify required parameter 'tensorboardId' is not null or undefined
            if (tensorboardId === null || tensorboardId === undefined) {
                throw new RequiredError('tensorboardId','Required parameter tensorboardId was null or undefined when calling determinedSetTensorboardPriority.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedSetTensorboardPriority.');
            }
            const localVarPath = `/api/v1/tensorboards/{tensorboardId}/set_priority`
                .replace(`{${"tensorboardId"}}`, encodeURIComponent(String(tensorboardId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1SetTensorboardPriorityRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TensorboardsApi - functional programming interface
 * @export
 */
export const TensorboardsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested tensorboard.
         * @param {string} tensorboardId The id of the tensorboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTensorboard(tensorboardId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTensorboardResponse> {
            const localVarFetchArgs = TensorboardsApiFetchParamCreator(configuration).determinedGetTensorboard(tensorboardId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of tensorboards.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort tensorboards by the given field.   - SORT_BY_UNSPECIFIED: Returns tensorboards in an unsorted list.  - SORT_BY_ID: Returns tensorboards sorted by id.  - SORT_BY_DESCRIPTION: Returns tensorboards sorted by description.  - SORT_BY_START_TIME: Return tensorboards sorted by start time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order tensorboards in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of tensorboards before returning results. Negative values denote number of tensorboards to skip from the end before returning results.
         * @param {number} [limit] Limit the number of tensorboards. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit tensorboards to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTensorboards(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTensorboardsResponse> {
            const localVarFetchArgs = TensorboardsApiFetchParamCreator(configuration).determinedGetTensorboards(sortBy, orderBy, offset, limit, users, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill the requested tensorboard.
         * @param {string} tensorboardId The id of the tensorboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillTensorboard(tensorboardId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillTensorboardResponse> {
            const localVarFetchArgs = TensorboardsApiFetchParamCreator(configuration).determinedKillTensorboard(tensorboardId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Launch a tensorboard.
         * @param {V1LaunchTensorboardRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLaunchTensorboard(body: V1LaunchTensorboardRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LaunchTensorboardResponse> {
            const localVarFetchArgs = TensorboardsApiFetchParamCreator(configuration).determinedLaunchTensorboard(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the priority of the requested TensorBoard.
         * @param {string} tensorboardId The id of the TensorBoard.
         * @param {V1SetTensorboardPriorityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetTensorboardPriority(tensorboardId: string, body: V1SetTensorboardPriorityRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SetTensorboardPriorityResponse> {
            const localVarFetchArgs = TensorboardsApiFetchParamCreator(configuration).determinedSetTensorboardPriority(tensorboardId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TensorboardsApi - factory interface
 * @export
 */
export const TensorboardsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the requested tensorboard.
         * @param {string} tensorboardId The id of the tensorboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTensorboard(tensorboardId: string, options?: any) {
            return TensorboardsApiFp(configuration).determinedGetTensorboard(tensorboardId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of tensorboards.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort tensorboards by the given field.   - SORT_BY_UNSPECIFIED: Returns tensorboards in an unsorted list.  - SORT_BY_ID: Returns tensorboards sorted by id.  - SORT_BY_DESCRIPTION: Returns tensorboards sorted by description.  - SORT_BY_START_TIME: Return tensorboards sorted by start time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order tensorboards in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of tensorboards before returning results. Negative values denote number of tensorboards to skip from the end before returning results.
         * @param {number} [limit] Limit the number of tensorboards. A value of 0 denotes no limit.
         * @param {Array<string>} [users] Limit tensorboards to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTensorboards(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options?: any) {
            return TensorboardsApiFp(configuration).determinedGetTensorboards(sortBy, orderBy, offset, limit, users, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill the requested tensorboard.
         * @param {string} tensorboardId The id of the tensorboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillTensorboard(tensorboardId: string, options?: any) {
            return TensorboardsApiFp(configuration).determinedKillTensorboard(tensorboardId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Launch a tensorboard.
         * @param {V1LaunchTensorboardRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLaunchTensorboard(body: V1LaunchTensorboardRequest, options?: any) {
            return TensorboardsApiFp(configuration).determinedLaunchTensorboard(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the priority of the requested TensorBoard.
         * @param {string} tensorboardId The id of the TensorBoard.
         * @param {V1SetTensorboardPriorityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetTensorboardPriority(tensorboardId: string, body: V1SetTensorboardPriorityRequest, options?: any) {
            return TensorboardsApiFp(configuration).determinedSetTensorboardPriority(tensorboardId, body, options)(fetch, basePath);
        },
    };
};

/**
 * TensorboardsApi - object-oriented interface
 * @export
 * @class TensorboardsApi
 * @extends {BaseAPI}
 */
export class TensorboardsApi extends BaseAPI {
    /**
     * 
     * @summary Get the requested tensorboard.
     * @param {string} tensorboardId The id of the tensorboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TensorboardsApi
     */
    public determinedGetTensorboard(tensorboardId: string, options?: any) {
        return TensorboardsApiFp(this.configuration).determinedGetTensorboard(tensorboardId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of tensorboards.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME'} [sortBy] Sort tensorboards by the given field.   - SORT_BY_UNSPECIFIED: Returns tensorboards in an unsorted list.  - SORT_BY_ID: Returns tensorboards sorted by id.  - SORT_BY_DESCRIPTION: Returns tensorboards sorted by description.  - SORT_BY_START_TIME: Return tensorboards sorted by start time.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order tensorboards in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of tensorboards before returning results. Negative values denote number of tensorboards to skip from the end before returning results.
     * @param {number} [limit] Limit the number of tensorboards. A value of 0 denotes no limit.
     * @param {Array<string>} [users] Limit tensorboards to those that are owned by the specified users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TensorboardsApi
     */
    public determinedGetTensorboards(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, users?: Array<string>, options?: any) {
        return TensorboardsApiFp(this.configuration).determinedGetTensorboards(sortBy, orderBy, offset, limit, users, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Kill the requested tensorboard.
     * @param {string} tensorboardId The id of the tensorboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TensorboardsApi
     */
    public determinedKillTensorboard(tensorboardId: string, options?: any) {
        return TensorboardsApiFp(this.configuration).determinedKillTensorboard(tensorboardId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Launch a tensorboard.
     * @param {V1LaunchTensorboardRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TensorboardsApi
     */
    public determinedLaunchTensorboard(body: V1LaunchTensorboardRequest, options?: any) {
        return TensorboardsApiFp(this.configuration).determinedLaunchTensorboard(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set the priority of the requested TensorBoard.
     * @param {string} tensorboardId The id of the TensorBoard.
     * @param {V1SetTensorboardPriorityRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TensorboardsApi
     */
    public determinedSetTensorboardPriority(tensorboardId: string, body: V1SetTensorboardPriorityRequest, options?: any) {
        return TensorboardsApiFp(this.configuration).determinedSetTensorboardPriority(tensorboardId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * TrialsApi - fetch parameter creator
 * @export
 */
export const TrialsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the list of trials for an experiment.
         * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION'} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
         * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentTrials(experimentId: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>, options: any = {}): FetchArgs {
            // verify required parameter 'experimentId' is not null or undefined
            if (experimentId === null || experimentId === undefined) {
                throw new RequiredError('experimentId','Required parameter experimentId was null or undefined when calling determinedGetExperimentTrials.');
            }
            const localVarPath = `/api/v1/experiments/{experimentId}/trials`
                .replace(`{${"experimentId"}}`, encodeURIComponent(String(experimentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (states) {
                localVarQueryParameter['states'] = states;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single trial.
         * @param {number} trialId The requested trial&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrial(trialId: number, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling determinedGetTrial.');
            }
            const localVarPath = `/api/v1/trials/{trialId}`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kill a trial.
         * @param {number} id The trial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillTrial(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling determinedKillTrial.');
            }
            const localVarPath = `/api/v1/trials/{id}/kill`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream trial logs.
         * @param {number} trialId The id of the trial.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling determinedTrialLogs.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/logs`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow;
            }

            if (agentIds) {
                localVarQueryParameter['agentIds'] = agentIds;
            }

            if (containerIds) {
                localVarQueryParameter['containerIds'] = containerIds;
            }

            if (rankIds) {
                localVarQueryParameter['rankIds'] = rankIds;
            }

            if (levels) {
                localVarQueryParameter['levels'] = levels;
            }

            if (stdtypes) {
                localVarQueryParameter['stdtypes'] = stdtypes;
            }

            if (sources) {
                localVarQueryParameter['sources'] = sources;
            }

            if (timestampBefore !== undefined) {
                localVarQueryParameter['timestampBefore'] = (timestampBefore as any).toISOString();
            }

            if (timestampAfter !== undefined) {
                localVarQueryParameter['timestampAfter'] = (timestampAfter as any).toISOString();
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream trial log fields.
         * @param {number} trialId The ID of the trial.
         * @param {boolean} [follow] Continue following fields until the trial stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialLogsFields(trialId: number, follow?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'trialId' is not null or undefined
            if (trialId === null || trialId === undefined) {
                throw new RequiredError('trialId','Required parameter trialId was null or undefined when calling determinedTrialLogsFields.');
            }
            const localVarPath = `/api/v1/trials/{trialId}/logs/fields`
                .replace(`{${"trialId"}}`, encodeURIComponent(String(trialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrialsApi - functional programming interface
 * @export
 */
export const TrialsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the list of trials for an experiment.
         * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION'} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
         * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentTrials(experimentId: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentTrialsResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).determinedGetExperimentTrials(experimentId, sortBy, orderBy, offset, limit, states, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a single trial.
         * @param {number} trialId The requested trial&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrial(trialId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTrialResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).determinedGetTrial(trialId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Kill a trial.
         * @param {number} id The trial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillTrial(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1KillTrialResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).determinedKillTrial(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream trial logs.
         * @param {number} trialId The id of the trial.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TrialLogsResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).determinedTrialLogs(trialId, limit, follow, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stream trial log fields.
         * @param {number} trialId The ID of the trial.
         * @param {boolean} [follow] Continue following fields until the trial stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialLogsFields(trialId: number, follow?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfV1TrialLogsFieldsResponse> {
            const localVarFetchArgs = TrialsApiFetchParamCreator(configuration).determinedTrialLogsFields(trialId, follow, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TrialsApi - factory interface
 * @export
 */
export const TrialsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the list of trials for an experiment.
         * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION'} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
         * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperimentTrials(experimentId: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>, options?: any) {
            return TrialsApiFp(configuration).determinedGetExperimentTrials(experimentId, sortBy, orderBy, offset, limit, states, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single trial.
         * @param {number} trialId The requested trial&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTrial(trialId: number, options?: any) {
            return TrialsApiFp(configuration).determinedGetTrial(trialId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Kill a trial.
         * @param {number} id The trial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedKillTrial(id: number, options?: any) {
            return TrialsApiFp(configuration).determinedKillTrial(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream trial logs.
         * @param {number} trialId The id of the trial.
         * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
         * @param {boolean} [follow] Continue following logs until the trial stops.
         * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
         * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
         * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
         * @param {Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
         * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
         * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
         * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
         * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options?: any) {
            return TrialsApiFp(configuration).determinedTrialLogs(trialId, limit, follow, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stream trial log fields.
         * @param {number} trialId The ID of the trial.
         * @param {boolean} [follow] Continue following fields until the trial stops.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedTrialLogsFields(trialId: number, follow?: boolean, options?: any) {
            return TrialsApiFp(configuration).determinedTrialLogsFields(trialId, follow, options)(fetch, basePath);
        },
    };
};

/**
 * TrialsApi - object-oriented interface
 * @export
 * @class TrialsApi
 * @extends {BaseAPI}
 */
export class TrialsApi extends BaseAPI {
    /**
     * 
     * @summary Get the list of trials for an experiment.
     * @param {number} experimentId Limit trials to those that are owned by the specified experiments.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION'} [sortBy] Sort trials by the given field.   - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.  - SORT_BY_ID: Returns trials sorted by id.  - SORT_BY_START_TIME: Return trials sorted by start time.  - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are returned after trials that are.  - SORT_BY_STATE: Return trials sorted by state.  - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is specified by &#x60;searcher.metric&#x60; in the experiment configuration.  - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.  - SORT_BY_DURATION: Return the trials sorted by the total duration.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order trials in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of trials before returning results. Negative values denote number of trials to skip from the end before returning results.
     * @param {number} [limit] Limit the number of trials. A value of 0 denotes no limit.
     * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>} [states] Limit trials to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.  - STATE_DELETING: The experiment is deleting.  - STATE_DELETE_FAILED: The experiment failed to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public determinedGetExperimentTrials(experimentId: number, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_BEST_VALIDATION_METRIC' | 'SORT_BY_LATEST_VALIDATION_METRIC' | 'SORT_BY_BATCHES_PROCESSED' | 'SORT_BY_DURATION', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED' | 'STATE_DELETING' | 'STATE_DELETE_FAILED'>, options?: any) {
        return TrialsApiFp(this.configuration).determinedGetExperimentTrials(experimentId, sortBy, orderBy, offset, limit, states, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a single trial.
     * @param {number} trialId The requested trial&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public determinedGetTrial(trialId: number, options?: any) {
        return TrialsApiFp(this.configuration).determinedGetTrial(trialId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Kill a trial.
     * @param {number} id The trial id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public determinedKillTrial(id: number, options?: any) {
        return TrialsApiFp(this.configuration).determinedKillTrial(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stream trial logs.
     * @param {number} trialId The id of the trial.
     * @param {number} [limit] Limit the number of trial logs. A value of 0 denotes no limit.
     * @param {boolean} [follow] Continue following logs until the trial stops.
     * @param {Array<string>} [agentIds] Limit the trial logs to a subset of agents.
     * @param {Array<string>} [containerIds] Limit the trial logs to a subset of containers.
     * @param {Array<number>} [rankIds] Limit the trial logs to a subset of ranks.
     * @param {Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>} [levels] Limit the trial logs to a subset of agents.   - LOG_LEVEL_UNSPECIFIED: Unspecified log level.  - LOG_LEVEL_TRACE: A log level of TRACE.  - LOG_LEVEL_DEBUG: A log level of DEBUG.  - LOG_LEVEL_INFO: A log level of INFO.  - LOG_LEVEL_WARNING: A log level of WARNING.  - LOG_LEVEL_ERROR: A log level of ERROR.  - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
     * @param {Array<string>} [stdtypes] Limit the trial logs to a subset of output streams.
     * @param {Array<string>} [sources] Limit the trial logs to a subset of sources.
     * @param {Date} [timestampBefore] Limit the trial logs to ones with a timestamp before a given time.
     * @param {Date} [timestampAfter] Limit the trial logs to ones with a timestamp after a given time.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order logs in either ascending or descending order by timestamp.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public determinedTrialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARNING' | 'LOG_LEVEL_ERROR' | 'LOG_LEVEL_CRITICAL'>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options?: any) {
        return TrialsApiFp(this.configuration).determinedTrialLogs(trialId, limit, follow, agentIds, containerIds, rankIds, levels, stdtypes, sources, timestampBefore, timestampAfter, orderBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stream trial log fields.
     * @param {number} trialId The ID of the trial.
     * @param {boolean} [follow] Continue following fields until the trial stops.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrialsApi
     */
    public determinedTrialLogsFields(trialId: number, follow?: boolean, options?: any) {
        return TrialsApiFp(this.configuration).determinedTrialLogsFields(trialId, follow, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested user.
         * @param {string} username The username of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetUser(username: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling determinedGetUser.');
            }
            const localVarPath = `/api/v1/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetUsers(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user.
         * @param {V1PostUserRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostUser(body: V1PostUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedPostUser.');
            }
            const localVarPath = `/api/v1/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1PostUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the requested user's password.
         * @param {string} username The username of the user.
         * @param {string} body The password of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetUserPassword(username: string, body: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling determinedSetUserPassword.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedSetUserPassword.');
            }
            const localVarPath = `/api/v1/users/{username}/password`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the requested user.
         * @param {string} username The username of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetUser(username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetUserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).determinedGetUser(username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetUsersResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).determinedGetUsers(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new user.
         * @param {V1PostUserRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostUser(body: V1PostUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostUserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).determinedPostUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the requested user's password.
         * @param {string} username The username of the user.
         * @param {string} body The password of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetUserPassword(username: string, body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SetUserPasswordResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).determinedSetUserPassword(username, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the requested user.
         * @param {string} username The username of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetUser(username: string, options?: any) {
            return UsersApiFp(configuration).determinedGetUser(username, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetUsers(options?: any) {
            return UsersApiFp(configuration).determinedGetUsers(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new user.
         * @param {V1PostUserRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostUser(body: V1PostUserRequest, options?: any) {
            return UsersApiFp(configuration).determinedPostUser(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the requested user's password.
         * @param {string} username The username of the user.
         * @param {string} body The password of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetUserPassword(username: string, body: string, options?: any) {
            return UsersApiFp(configuration).determinedSetUserPassword(username, body, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Get the requested user.
     * @param {string} username The username of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public determinedGetUser(username: string, options?: any) {
        return UsersApiFp(this.configuration).determinedGetUser(username, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public determinedGetUsers(options?: any) {
        return UsersApiFp(this.configuration).determinedGetUsers(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new user.
     * @param {V1PostUserRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public determinedPostUser(body: V1PostUserRequest, options?: any) {
        return UsersApiFp(this.configuration).determinedPostUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set the requested user's password.
     * @param {string} username The username of the user.
     * @param {string} body The password of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public determinedSetUserPassword(username: string, body: string, options?: any) {
        return UsersApiFp(this.configuration).determinedSetUserPassword(username, body, options)(this.fetch, this.basePath);
    }

}

