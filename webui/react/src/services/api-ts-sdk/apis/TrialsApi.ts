/* tslint:disable */
/* eslint-disable */
/**
 * Determined API (Beta)
 * Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.  You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.
 *
 * The version of the OpenAPI document: 0.1
 * Contact: community@determined.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  RuntimeError,
  StreamResultOfV1TrialLogsFieldsResponse,
  StreamResultOfV1TrialLogsResponse,
  V1GetExperimentTrialsResponse,
  V1GetTrialResponse,
  V1GetTrialWorkloadsResponse,
  V1SummarizeTrialResponse,
} from '../models';
import {
    RuntimeErrorFromJSON,
    RuntimeErrorToJSON,
    StreamResultOfV1TrialLogsFieldsResponseFromJSON,
    StreamResultOfV1TrialLogsFieldsResponseToJSON,
    StreamResultOfV1TrialLogsResponseFromJSON,
    StreamResultOfV1TrialLogsResponseToJSON,
    V1GetExperimentTrialsResponseFromJSON,
    V1GetExperimentTrialsResponseToJSON,
    V1GetTrialResponseFromJSON,
    V1GetTrialResponseToJSON,
    V1GetTrialWorkloadsResponseFromJSON,
    V1GetTrialWorkloadsResponseToJSON,
    V1SummarizeTrialResponseFromJSON,
    V1SummarizeTrialResponseToJSON,
} from '../models';

export interface GetExperimentTrialsRequest {
    experimentId: number;
    sortBy?: GetExperimentTrialsSortByEnum;
    orderBy?: GetExperimentTrialsOrderByEnum;
    offset?: number;
    limit?: number;
    states?: Array<GetExperimentTrialsStatesEnum>;
}

export interface GetTrialRequest {
    trialId: number;
}

export interface GetTrialWorkloadsRequest {
    trialId: number;
    orderBy?: GetTrialWorkloadsOrderByEnum;
    offset?: number;
    limit?: number;
    sortKey?: string;
    filter?: GetTrialWorkloadsFilterEnum;
    includeBatchMetrics?: boolean;
    metricType?: GetTrialWorkloadsMetricTypeEnum;
}

export interface KillTrialRequest {
    id: number;
}

export interface SummarizeTrialRequest {
    trialId: number;
    maxDatapoints?: number;
    metricNames?: Array<string>;
    startBatches?: number;
    endBatches?: number;
    metricType?: SummarizeTrialMetricTypeEnum;
    scale?: SummarizeTrialScaleEnum;
}

export interface TrialLogsRequest {
    trialId: number;
    limit?: number;
    follow?: boolean;
    agentIds?: Array<string>;
    containerIds?: Array<string>;
    rankIds?: Array<number>;
    levels?: Array<TrialLogsLevelsEnum>;
    stdtypes?: Array<string>;
    sources?: Array<string>;
    timestampBefore?: Date;
    timestampAfter?: Date;
    orderBy?: TrialLogsOrderByEnum;
    searchText?: string;
}

export interface TrialLogsFieldsRequest {
    trialId: number;
    follow?: boolean;
}

/**
 * 
 */
export class TrialsApi extends runtime.BaseAPI {

    /**
     * Get the list of trials for an experiment.
     */
    async getExperimentTrialsRaw(requestParameters: GetExperimentTrialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetExperimentTrialsResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling getExperimentTrials.');
        }

        const queryParameters: any = {};

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.states) {
            queryParameters['states'] = requestParameters.states;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/trials`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetExperimentTrialsResponseFromJSON(jsonValue));
    }

    /**
     * Get the list of trials for an experiment.
     */
    async getExperimentTrials(experimentId: number, sortBy?: GetExperimentTrialsSortByEnum, orderBy?: GetExperimentTrialsOrderByEnum, offset?: number, limit?: number, states?: Array<GetExperimentTrialsStatesEnum>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetExperimentTrialsResponse> {
        const response = await this.getExperimentTrialsRaw({ experimentId: experimentId, sortBy: sortBy, orderBy: orderBy, offset: offset, limit: limit, states: states }, initOverrides);
        return await response.value();
    }

    /**
     * Get a single trial.
     */
    async getTrialRaw(requestParameters: GetTrialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetTrialResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling getTrial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetTrialResponseFromJSON(jsonValue));
    }

    /**
     * Get a single trial.
     */
    async getTrial(trialId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetTrialResponse> {
        const response = await this.getTrialRaw({ trialId: trialId }, initOverrides);
        return await response.value();
    }

    /**
     * Get the list of workloads for a trial.
     */
    async getTrialWorkloadsRaw(requestParameters: GetTrialWorkloadsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetTrialWorkloadsResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling getTrialWorkloads.');
        }

        const queryParameters: any = {};

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.sortKey !== undefined) {
            queryParameters['sortKey'] = requestParameters.sortKey;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.includeBatchMetrics !== undefined) {
            queryParameters['includeBatchMetrics'] = requestParameters.includeBatchMetrics;
        }

        if (requestParameters.metricType !== undefined) {
            queryParameters['metricType'] = requestParameters.metricType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/workloads`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetTrialWorkloadsResponseFromJSON(jsonValue));
    }

    /**
     * Get the list of workloads for a trial.
     */
    async getTrialWorkloads(trialId: number, orderBy?: GetTrialWorkloadsOrderByEnum, offset?: number, limit?: number, sortKey?: string, filter?: GetTrialWorkloadsFilterEnum, includeBatchMetrics?: boolean, metricType?: GetTrialWorkloadsMetricTypeEnum, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetTrialWorkloadsResponse> {
        const response = await this.getTrialWorkloadsRaw({ trialId: trialId, orderBy: orderBy, offset: offset, limit: limit, sortKey: sortKey, filter: filter, includeBatchMetrics: includeBatchMetrics, metricType: metricType }, initOverrides);
        return await response.value();
    }

    /**
     * Kill a trial.
     */
    async killTrialRaw(requestParameters: KillTrialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling killTrial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{id}/kill`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Kill a trial.
     */
    async killTrial(id: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.killTrialRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Downsample metrics collected during a trial.
     */
    async summarizeTrialRaw(requestParameters: SummarizeTrialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1SummarizeTrialResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling summarizeTrial.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxDatapoints !== undefined) {
            queryParameters['maxDatapoints'] = requestParameters.maxDatapoints;
        }

        if (requestParameters.metricNames) {
            queryParameters['metricNames'] = requestParameters.metricNames;
        }

        if (requestParameters.startBatches !== undefined) {
            queryParameters['startBatches'] = requestParameters.startBatches;
        }

        if (requestParameters.endBatches !== undefined) {
            queryParameters['endBatches'] = requestParameters.endBatches;
        }

        if (requestParameters.metricType !== undefined) {
            queryParameters['metricType'] = requestParameters.metricType;
        }

        if (requestParameters.scale !== undefined) {
            queryParameters['scale'] = requestParameters.scale;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/summarize`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SummarizeTrialResponseFromJSON(jsonValue));
    }

    /**
     * Downsample metrics collected during a trial.
     */
    async summarizeTrial(trialId: number, maxDatapoints?: number, metricNames?: Array<string>, startBatches?: number, endBatches?: number, metricType?: SummarizeTrialMetricTypeEnum, scale?: SummarizeTrialScaleEnum, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1SummarizeTrialResponse> {
        const response = await this.summarizeTrialRaw({ trialId: trialId, maxDatapoints: maxDatapoints, metricNames: metricNames, startBatches: startBatches, endBatches: endBatches, metricType: metricType, scale: scale }, initOverrides);
        return await response.value();
    }

    /**
     * Stream trial logs.
     */
    async trialLogsRaw(requestParameters: TrialLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1TrialLogsResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling trialLogs.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.follow !== undefined) {
            queryParameters['follow'] = requestParameters.follow;
        }

        if (requestParameters.agentIds) {
            queryParameters['agentIds'] = requestParameters.agentIds;
        }

        if (requestParameters.containerIds) {
            queryParameters['containerIds'] = requestParameters.containerIds;
        }

        if (requestParameters.rankIds) {
            queryParameters['rankIds'] = requestParameters.rankIds;
        }

        if (requestParameters.levels) {
            queryParameters['levels'] = requestParameters.levels;
        }

        if (requestParameters.stdtypes) {
            queryParameters['stdtypes'] = requestParameters.stdtypes;
        }

        if (requestParameters.sources) {
            queryParameters['sources'] = requestParameters.sources;
        }

        if (requestParameters.timestampBefore !== undefined) {
            queryParameters['timestampBefore'] = (requestParameters.timestampBefore as any).toISOString();
        }

        if (requestParameters.timestampAfter !== undefined) {
            queryParameters['timestampAfter'] = (requestParameters.timestampAfter as any).toISOString();
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.searchText !== undefined) {
            queryParameters['searchText'] = requestParameters.searchText;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/logs`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1TrialLogsResponseFromJSON(jsonValue));
    }

    /**
     * Stream trial logs.
     */
    async trialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<TrialLogsLevelsEnum>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: TrialLogsOrderByEnum, searchText?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1TrialLogsResponse> {
        const response = await this.trialLogsRaw({ trialId: trialId, limit: limit, follow: follow, agentIds: agentIds, containerIds: containerIds, rankIds: rankIds, levels: levels, stdtypes: stdtypes, sources: sources, timestampBefore: timestampBefore, timestampAfter: timestampAfter, orderBy: orderBy, searchText: searchText }, initOverrides);
        return await response.value();
    }

    /**
     * Stream trial log fields.
     */
    async trialLogsFieldsRaw(requestParameters: TrialLogsFieldsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1TrialLogsFieldsResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling trialLogsFields.');
        }

        const queryParameters: any = {};

        if (requestParameters.follow !== undefined) {
            queryParameters['follow'] = requestParameters.follow;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/logs/fields`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1TrialLogsFieldsResponseFromJSON(jsonValue));
    }

    /**
     * Stream trial log fields.
     */
    async trialLogsFields(trialId: number, follow?: boolean, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1TrialLogsFieldsResponse> {
        const response = await this.trialLogsFieldsRaw({ trialId: trialId, follow: follow }, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetExperimentTrialsSortByEnum = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    ID: 'SORT_BY_ID',
    START_TIME: 'SORT_BY_START_TIME',
    END_TIME: 'SORT_BY_END_TIME',
    STATE: 'SORT_BY_STATE',
    BEST_VALIDATION_METRIC: 'SORT_BY_BEST_VALIDATION_METRIC',
    LATEST_VALIDATION_METRIC: 'SORT_BY_LATEST_VALIDATION_METRIC',
    BATCHES_PROCESSED: 'SORT_BY_BATCHES_PROCESSED',
    DURATION: 'SORT_BY_DURATION',
    RESTARTS: 'SORT_BY_RESTARTS'
} as const;
export type GetExperimentTrialsSortByEnum = typeof GetExperimentTrialsSortByEnum[keyof typeof GetExperimentTrialsSortByEnum];
/**
 * @export
 */
export const GetExperimentTrialsOrderByEnum = {
    UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
    ASC: 'ORDER_BY_ASC',
    DESC: 'ORDER_BY_DESC'
} as const;
export type GetExperimentTrialsOrderByEnum = typeof GetExperimentTrialsOrderByEnum[keyof typeof GetExperimentTrialsOrderByEnum];
/**
 * @export
 */
export const GetExperimentTrialsStatesEnum = {
    UNSPECIFIED: 'STATE_UNSPECIFIED',
    ACTIVE: 'STATE_ACTIVE',
    PAUSED: 'STATE_PAUSED',
    STOPPING_COMPLETED: 'STATE_STOPPING_COMPLETED',
    STOPPING_CANCELED: 'STATE_STOPPING_CANCELED',
    STOPPING_ERROR: 'STATE_STOPPING_ERROR',
    COMPLETED: 'STATE_COMPLETED',
    CANCELED: 'STATE_CANCELED',
    ERROR: 'STATE_ERROR',
    DELETED: 'STATE_DELETED',
    DELETING: 'STATE_DELETING',
    DELETE_FAILED: 'STATE_DELETE_FAILED',
    STOPPING_KILLED: 'STATE_STOPPING_KILLED',
    QUEUED: 'STATE_QUEUED',
    PULLING: 'STATE_PULLING',
    STARTING: 'STATE_STARTING',
    RUNNING: 'STATE_RUNNING'
} as const;
export type GetExperimentTrialsStatesEnum = typeof GetExperimentTrialsStatesEnum[keyof typeof GetExperimentTrialsStatesEnum];
/**
 * @export
 */
export const GetTrialWorkloadsOrderByEnum = {
    UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
    ASC: 'ORDER_BY_ASC',
    DESC: 'ORDER_BY_DESC'
} as const;
export type GetTrialWorkloadsOrderByEnum = typeof GetTrialWorkloadsOrderByEnum[keyof typeof GetTrialWorkloadsOrderByEnum];
/**
 * @export
 */
export const GetTrialWorkloadsFilterEnum = {
    UNSPECIFIED: 'FILTER_OPTION_UNSPECIFIED',
    CHECKPOINT: 'FILTER_OPTION_CHECKPOINT',
    VALIDATION: 'FILTER_OPTION_VALIDATION',
    CHECKPOINT_OR_VALIDATION: 'FILTER_OPTION_CHECKPOINT_OR_VALIDATION'
} as const;
export type GetTrialWorkloadsFilterEnum = typeof GetTrialWorkloadsFilterEnum[keyof typeof GetTrialWorkloadsFilterEnum];
/**
 * @export
 */
export const GetTrialWorkloadsMetricTypeEnum = {
    UNSPECIFIED: 'METRIC_TYPE_UNSPECIFIED',
    TRAINING: 'METRIC_TYPE_TRAINING',
    VALIDATION: 'METRIC_TYPE_VALIDATION'
} as const;
export type GetTrialWorkloadsMetricTypeEnum = typeof GetTrialWorkloadsMetricTypeEnum[keyof typeof GetTrialWorkloadsMetricTypeEnum];
/**
 * @export
 */
export const SummarizeTrialMetricTypeEnum = {
    UNSPECIFIED: 'METRIC_TYPE_UNSPECIFIED',
    TRAINING: 'METRIC_TYPE_TRAINING',
    VALIDATION: 'METRIC_TYPE_VALIDATION'
} as const;
export type SummarizeTrialMetricTypeEnum = typeof SummarizeTrialMetricTypeEnum[keyof typeof SummarizeTrialMetricTypeEnum];
/**
 * @export
 */
export const SummarizeTrialScaleEnum = {
    UNSPECIFIED: 'SCALE_UNSPECIFIED',
    LINEAR: 'SCALE_LINEAR',
    LOG: 'SCALE_LOG'
} as const;
export type SummarizeTrialScaleEnum = typeof SummarizeTrialScaleEnum[keyof typeof SummarizeTrialScaleEnum];
/**
 * @export
 */
export const TrialLogsLevelsEnum = {
    UNSPECIFIED: 'LOG_LEVEL_UNSPECIFIED',
    TRACE: 'LOG_LEVEL_TRACE',
    DEBUG: 'LOG_LEVEL_DEBUG',
    INFO: 'LOG_LEVEL_INFO',
    WARNING: 'LOG_LEVEL_WARNING',
    ERROR: 'LOG_LEVEL_ERROR',
    CRITICAL: 'LOG_LEVEL_CRITICAL'
} as const;
export type TrialLogsLevelsEnum = typeof TrialLogsLevelsEnum[keyof typeof TrialLogsLevelsEnum];
/**
 * @export
 */
export const TrialLogsOrderByEnum = {
    UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
    ASC: 'ORDER_BY_ASC',
    DESC: 'ORDER_BY_DESC'
} as const;
export type TrialLogsOrderByEnum = typeof TrialLogsOrderByEnum[keyof typeof TrialLogsOrderByEnum];
