/* tslint:disable */
/* eslint-disable */
/**
 * Determined API (Beta)
 * Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.  You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.
 *
 * The version of the OpenAPI document: 0.1
 * Contact: community@determined.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  RuntimeError,
  StreamResultOfV1TrialLogsFieldsResponse,
  StreamResultOfV1TrialLogsResponse,
  V1GetExperimentTrialsResponse,
  V1GetTrialResponse,
  V1GetTrialWorkloadsResponse,
  V1SummarizeTrialResponse,
} from '../models';
import {
    RuntimeErrorFromJSON,
    RuntimeErrorToJSON,
    StreamResultOfV1TrialLogsFieldsResponseFromJSON,
    StreamResultOfV1TrialLogsFieldsResponseToJSON,
    StreamResultOfV1TrialLogsResponseFromJSON,
    StreamResultOfV1TrialLogsResponseToJSON,
    V1GetExperimentTrialsResponseFromJSON,
    V1GetExperimentTrialsResponseToJSON,
    V1GetTrialResponseFromJSON,
    V1GetTrialResponseToJSON,
    V1GetTrialWorkloadsResponseFromJSON,
    V1GetTrialWorkloadsResponseToJSON,
    V1SummarizeTrialResponseFromJSON,
    V1SummarizeTrialResponseToJSON,
} from '../models';

export interface GetExperimentTrialsRequest {
    experimentId: number;
    sortBy?: GetExperimentTrialsSortByEnum;
    orderBy?: GetExperimentTrialsOrderByEnum;
    offset?: number;
    limit?: number;
    states?: Array<GetExperimentTrialsStatesEnum>;
}

export interface GetTrialRequest {
    trialId: number;
}

export interface GetTrialWorkloadsRequest {
    trialId: number;
    orderBy?: GetTrialWorkloadsOrderByEnum;
    offset?: number;
    limit?: number;
    sortKey?: string;
    filter?: GetTrialWorkloadsFilterEnum;
    includeBatchMetrics?: boolean;
    metricType?: GetTrialWorkloadsMetricTypeEnum;
}

export interface KillTrialRequest {
    id: number;
}

export interface SummarizeTrialRequest {
    trialId: number;
    maxDatapoints?: number;
    metricNames?: Array<string>;
    startBatches?: number;
    endBatches?: number;
    metricType?: SummarizeTrialMetricTypeEnum;
    scale?: SummarizeTrialScaleEnum;
}

export interface TrialLogsRequest {
    trialId: number;
    limit?: number;
    follow?: boolean;
    agentIds?: Array<string>;
    containerIds?: Array<string>;
    levels?: Array<TrialLogsLevelsEnum>;
    stdtypes?: Array<string>;
    sources?: Array<string>;
    timestampBefore?: Date;
    timestampAfter?: Date;
    orderBy?: TrialLogsOrderByEnum;
    searchText?: string;
    rankIds?: Array<string>;
}

export interface TrialLogsFieldsRequest {
    trialId: number;
    follow?: boolean;
}

/**
 * 
 */
export class TrialsApi extends runtime.BaseAPI {

    /**
     * Get the list of trials for an experiment.
     */
    async getExperimentTrialsRaw(requestParameters: GetExperimentTrialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetExperimentTrialsResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling getExperimentTrials.');
        }

        const queryParameters: any = {};

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.states) {
            queryParameters['states'] = requestParameters.states;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/trials`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetExperimentTrialsResponseFromJSON(jsonValue));
    }

    /**
     * Get the list of trials for an experiment.
     */
    async getExperimentTrials(requestParameters: GetExperimentTrialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetExperimentTrialsResponse> {
        const response = await this.getExperimentTrialsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a single trial.
     */
    async getTrialRaw(requestParameters: GetTrialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetTrialResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling getTrial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetTrialResponseFromJSON(jsonValue));
    }

    /**
     * Get a single trial.
     */
    async getTrial(requestParameters: GetTrialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetTrialResponse> {
        const response = await this.getTrialRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the list of workloads for a trial.
     */
    async getTrialWorkloadsRaw(requestParameters: GetTrialWorkloadsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetTrialWorkloadsResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling getTrialWorkloads.');
        }

        const queryParameters: any = {};

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.sortKey !== undefined) {
            queryParameters['sortKey'] = requestParameters.sortKey;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.includeBatchMetrics !== undefined) {
            queryParameters['includeBatchMetrics'] = requestParameters.includeBatchMetrics;
        }

        if (requestParameters.metricType !== undefined) {
            queryParameters['metricType'] = requestParameters.metricType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/workloads`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetTrialWorkloadsResponseFromJSON(jsonValue));
    }

    /**
     * Get the list of workloads for a trial.
     */
    async getTrialWorkloads(requestParameters: GetTrialWorkloadsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetTrialWorkloadsResponse> {
        const response = await this.getTrialWorkloadsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Kill a trial.
     */
    async killTrialRaw(requestParameters: KillTrialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling killTrial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{id}/kill`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Kill a trial.
     */
    async killTrial(requestParameters: KillTrialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.killTrialRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Downsample metrics collected during a trial.
     */
    async summarizeTrialRaw(requestParameters: SummarizeTrialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1SummarizeTrialResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling summarizeTrial.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxDatapoints !== undefined) {
            queryParameters['maxDatapoints'] = requestParameters.maxDatapoints;
        }

        if (requestParameters.metricNames) {
            queryParameters['metricNames'] = requestParameters.metricNames;
        }

        if (requestParameters.startBatches !== undefined) {
            queryParameters['startBatches'] = requestParameters.startBatches;
        }

        if (requestParameters.endBatches !== undefined) {
            queryParameters['endBatches'] = requestParameters.endBatches;
        }

        if (requestParameters.metricType !== undefined) {
            queryParameters['metricType'] = requestParameters.metricType;
        }

        if (requestParameters.scale !== undefined) {
            queryParameters['scale'] = requestParameters.scale;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/summarize`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SummarizeTrialResponseFromJSON(jsonValue));
    }

    /**
     * Downsample metrics collected during a trial.
     */
    async summarizeTrial(requestParameters: SummarizeTrialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1SummarizeTrialResponse> {
        const response = await this.summarizeTrialRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stream trial logs.
     */
    async trialLogsRaw(requestParameters: TrialLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1TrialLogsResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling trialLogs.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.follow !== undefined) {
            queryParameters['follow'] = requestParameters.follow;
        }

        if (requestParameters.agentIds) {
            queryParameters['agentIds'] = requestParameters.agentIds;
        }

        if (requestParameters.containerIds) {
            queryParameters['containerIds'] = requestParameters.containerIds;
        }

        if (requestParameters.levels) {
            queryParameters['levels'] = requestParameters.levels;
        }

        if (requestParameters.stdtypes) {
            queryParameters['stdtypes'] = requestParameters.stdtypes;
        }

        if (requestParameters.sources) {
            queryParameters['sources'] = requestParameters.sources;
        }

        if (requestParameters.timestampBefore !== undefined) {
            queryParameters['timestampBefore'] = (requestParameters.timestampBefore as any).toISOString();
        }

        if (requestParameters.timestampAfter !== undefined) {
            queryParameters['timestampAfter'] = (requestParameters.timestampAfter as any).toISOString();
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.searchText !== undefined) {
            queryParameters['searchText'] = requestParameters.searchText;
        }

        if (requestParameters.rankIds) {
            queryParameters['rankIds'] = requestParameters.rankIds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/logs`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1TrialLogsResponseFromJSON(jsonValue));
    }

    /**
     * Stream trial logs.
     */
    async trialLogs(requestParameters: TrialLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1TrialLogsResponse> {
        const response = await this.trialLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stream trial log fields.
     */
    async trialLogsFieldsRaw(requestParameters: TrialLogsFieldsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1TrialLogsFieldsResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling trialLogsFields.');
        }

        const queryParameters: any = {};

        if (requestParameters.follow !== undefined) {
            queryParameters['follow'] = requestParameters.follow;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/logs/fields`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1TrialLogsFieldsResponseFromJSON(jsonValue));
    }

    /**
     * Stream trial log fields.
     */
    async trialLogsFields(requestParameters: TrialLogsFieldsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1TrialLogsFieldsResponse> {
        const response = await this.trialLogsFieldsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
  * @export
  * @enum {string}
  */
export enum GetExperimentTrialsSortByEnum {
    Unspecified = 'SORT_BY_UNSPECIFIED',
    Id = 'SORT_BY_ID',
    StartTime = 'SORT_BY_START_TIME',
    EndTime = 'SORT_BY_END_TIME',
    State = 'SORT_BY_STATE',
    BestValidationMetric = 'SORT_BY_BEST_VALIDATION_METRIC',
    LatestValidationMetric = 'SORT_BY_LATEST_VALIDATION_METRIC',
    BatchesProcessed = 'SORT_BY_BATCHES_PROCESSED',
    Duration = 'SORT_BY_DURATION',
    Restarts = 'SORT_BY_RESTARTS'
}
/**
  * @export
  * @enum {string}
  */
export enum GetExperimentTrialsOrderByEnum {
    Unspecified = 'ORDER_BY_UNSPECIFIED',
    Asc = 'ORDER_BY_ASC',
    Desc = 'ORDER_BY_DESC'
}
/**
  * @export
  * @enum {string}
  */
export enum GetExperimentTrialsStatesEnum {
    Unspecified = 'STATE_UNSPECIFIED',
    Active = 'STATE_ACTIVE',
    Paused = 'STATE_PAUSED',
    StoppingCompleted = 'STATE_STOPPING_COMPLETED',
    StoppingCanceled = 'STATE_STOPPING_CANCELED',
    StoppingError = 'STATE_STOPPING_ERROR',
    Completed = 'STATE_COMPLETED',
    Canceled = 'STATE_CANCELED',
    Error = 'STATE_ERROR',
    Deleted = 'STATE_DELETED',
    Deleting = 'STATE_DELETING',
    DeleteFailed = 'STATE_DELETE_FAILED',
    StoppingKilled = 'STATE_STOPPING_KILLED',
    Queued = 'STATE_QUEUED',
    Pulling = 'STATE_PULLING',
    Starting = 'STATE_STARTING',
    Running = 'STATE_RUNNING'
}
/**
  * @export
  * @enum {string}
  */
export enum GetTrialWorkloadsOrderByEnum {
    Unspecified = 'ORDER_BY_UNSPECIFIED',
    Asc = 'ORDER_BY_ASC',
    Desc = 'ORDER_BY_DESC'
}
/**
  * @export
  * @enum {string}
  */
export enum GetTrialWorkloadsFilterEnum {
    Unspecified = 'FILTER_OPTION_UNSPECIFIED',
    Checkpoint = 'FILTER_OPTION_CHECKPOINT',
    Validation = 'FILTER_OPTION_VALIDATION',
    CheckpointOrValidation = 'FILTER_OPTION_CHECKPOINT_OR_VALIDATION'
}
/**
  * @export
  * @enum {string}
  */
export enum GetTrialWorkloadsMetricTypeEnum {
    Unspecified = 'METRIC_TYPE_UNSPECIFIED',
    Training = 'METRIC_TYPE_TRAINING',
    Validation = 'METRIC_TYPE_VALIDATION'
}
/**
  * @export
  * @enum {string}
  */
export enum SummarizeTrialMetricTypeEnum {
    Unspecified = 'METRIC_TYPE_UNSPECIFIED',
    Training = 'METRIC_TYPE_TRAINING',
    Validation = 'METRIC_TYPE_VALIDATION'
}
/**
  * @export
  * @enum {string}
  */
export enum SummarizeTrialScaleEnum {
    Unspecified = 'SCALE_UNSPECIFIED',
    Linear = 'SCALE_LINEAR',
    Log = 'SCALE_LOG'
}
/**
  * @export
  * @enum {string}
  */
export enum TrialLogsLevelsEnum {
    Unspecified = 'LOG_LEVEL_UNSPECIFIED',
    Trace = 'LOG_LEVEL_TRACE',
    Debug = 'LOG_LEVEL_DEBUG',
    Info = 'LOG_LEVEL_INFO',
    Warning = 'LOG_LEVEL_WARNING',
    Error = 'LOG_LEVEL_ERROR',
    Critical = 'LOG_LEVEL_CRITICAL'
}
/**
  * @export
  * @enum {string}
  */
export enum TrialLogsOrderByEnum {
    Unspecified = 'ORDER_BY_UNSPECIFIED',
    Asc = 'ORDER_BY_ASC',
    Desc = 'ORDER_BY_DESC'
}
