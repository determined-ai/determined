/* tslint:disable */
/* eslint-disable */
/**
 * Determined API (Beta)
 * Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.  You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.
 *
 * The version of the OpenAPI document: 0.1
 * Contact: community@determined.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  RuntimeError,
  V1GetModelLabelsResponse,
  V1GetModelResponse,
  V1GetModelVersionResponse,
  V1GetModelVersionsResponse,
  V1GetModelsResponse,
  V1PatchModel,
  V1PatchModelResponse,
  V1PatchModelVersion,
  V1PatchModelVersionResponse,
  V1PostModelRequest,
  V1PostModelResponse,
  V1PostModelVersionRequest,
  V1PostModelVersionResponse,
} from '../models';
import {
    RuntimeErrorFromJSON,
    RuntimeErrorToJSON,
    V1GetModelLabelsResponseFromJSON,
    V1GetModelLabelsResponseToJSON,
    V1GetModelResponseFromJSON,
    V1GetModelResponseToJSON,
    V1GetModelVersionResponseFromJSON,
    V1GetModelVersionResponseToJSON,
    V1GetModelVersionsResponseFromJSON,
    V1GetModelVersionsResponseToJSON,
    V1GetModelsResponseFromJSON,
    V1GetModelsResponseToJSON,
    V1PatchModelFromJSON,
    V1PatchModelToJSON,
    V1PatchModelResponseFromJSON,
    V1PatchModelResponseToJSON,
    V1PatchModelVersionFromJSON,
    V1PatchModelVersionToJSON,
    V1PatchModelVersionResponseFromJSON,
    V1PatchModelVersionResponseToJSON,
    V1PostModelRequestFromJSON,
    V1PostModelRequestToJSON,
    V1PostModelResponseFromJSON,
    V1PostModelResponseToJSON,
    V1PostModelVersionRequestFromJSON,
    V1PostModelVersionRequestToJSON,
    V1PostModelVersionResponseFromJSON,
    V1PostModelVersionResponseToJSON,
} from '../models';

export interface ArchiveModelRequest {
    modelName: string;
}

export interface DeleteModelRequest {
    modelName: string;
}

export interface DeleteModelVersionRequest {
    modelName: string;
    modelVersionId: number;
}

export interface GetModelRequest {
    modelName: string;
}

export interface GetModelVersionRequest {
    modelName: string;
    modelVersion: number;
}

export interface GetModelVersionsRequest {
    modelName: string;
    sortBy?: GetModelVersionsSortByEnum;
    orderBy?: GetModelVersionsOrderByEnum;
    offset?: number;
    limit?: number;
}

export interface GetModelsRequest {
    sortBy?: GetModelsSortByEnum;
    orderBy?: GetModelsOrderByEnum;
    offset?: number;
    limit?: number;
    name?: string;
    description?: string;
    labels?: Array<string>;
    archived?: boolean;
    users?: Array<string>;
    userIds?: Array<number>;
    id?: number;
}

export interface PatchModelRequest {
    modelName: string;
    body: V1PatchModel;
}

export interface PatchModelVersionRequest {
    modelName: string;
    modelVersionId: number;
    body: V1PatchModelVersion;
}

export interface PostModelRequest {
    body: V1PostModelRequest;
}

export interface PostModelVersionRequest {
    modelName: string;
    body: V1PostModelVersionRequest;
}

export interface UnarchiveModelRequest {
    modelName: string;
}

/**
 * 
 */
export class ModelsApi extends runtime.BaseAPI {

    /**
     * Archive a model
     */
    async archiveModelRaw(requestParameters: ArchiveModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.modelName === null || requestParameters.modelName === undefined) {
            throw new runtime.RequiredError('modelName','Required parameter requestParameters.modelName was null or undefined when calling archiveModel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/models/{modelName}/archive`.replace(`{${"modelName"}}`, encodeURIComponent(String(requestParameters.modelName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Archive a model
     */
    async archiveModel(modelName: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.archiveModelRaw({ modelName: modelName }, initOverrides);
        return await response.value();
    }

    /**
     * Delete a model
     */
    async deleteModelRaw(requestParameters: DeleteModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.modelName === null || requestParameters.modelName === undefined) {
            throw new runtime.RequiredError('modelName','Required parameter requestParameters.modelName was null or undefined when calling deleteModel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/models/{modelName}`.replace(`{${"modelName"}}`, encodeURIComponent(String(requestParameters.modelName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete a model
     */
    async deleteModel(modelName: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteModelRaw({ modelName: modelName }, initOverrides);
        return await response.value();
    }

    /**
     * Delete a model version
     */
    async deleteModelVersionRaw(requestParameters: DeleteModelVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.modelName === null || requestParameters.modelName === undefined) {
            throw new runtime.RequiredError('modelName','Required parameter requestParameters.modelName was null or undefined when calling deleteModelVersion.');
        }

        if (requestParameters.modelVersionId === null || requestParameters.modelVersionId === undefined) {
            throw new runtime.RequiredError('modelVersionId','Required parameter requestParameters.modelVersionId was null or undefined when calling deleteModelVersion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/models/{modelName}/versions/{modelVersionId}`.replace(`{${"modelName"}}`, encodeURIComponent(String(requestParameters.modelName))).replace(`{${"modelVersionId"}}`, encodeURIComponent(String(requestParameters.modelVersionId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete a model version
     */
    async deleteModelVersion(modelName: string, modelVersionId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteModelVersionRaw({ modelName: modelName, modelVersionId: modelVersionId }, initOverrides);
        return await response.value();
    }

    /**
     * Get the requested model.
     */
    async getModelRaw(requestParameters: GetModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetModelResponse>> {
        if (requestParameters.modelName === null || requestParameters.modelName === undefined) {
            throw new runtime.RequiredError('modelName','Required parameter requestParameters.modelName was null or undefined when calling getModel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/models/{modelName}`.replace(`{${"modelName"}}`, encodeURIComponent(String(requestParameters.modelName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetModelResponseFromJSON(jsonValue));
    }

    /**
     * Get the requested model.
     */
    async getModel(modelName: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetModelResponse> {
        const response = await this.getModelRaw({ modelName: modelName }, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of unique model labels (sorted by popularity).
     */
    async getModelLabelsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetModelLabelsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/model/labels`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetModelLabelsResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of unique model labels (sorted by popularity).
     */
    async getModelLabels(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetModelLabelsResponse> {
        const response = await this.getModelLabelsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the requested model version.
     */
    async getModelVersionRaw(requestParameters: GetModelVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetModelVersionResponse>> {
        if (requestParameters.modelName === null || requestParameters.modelName === undefined) {
            throw new runtime.RequiredError('modelName','Required parameter requestParameters.modelName was null or undefined when calling getModelVersion.');
        }

        if (requestParameters.modelVersion === null || requestParameters.modelVersion === undefined) {
            throw new runtime.RequiredError('modelVersion','Required parameter requestParameters.modelVersion was null or undefined when calling getModelVersion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/models/{modelName}/versions/{modelVersion}`.replace(`{${"modelName"}}`, encodeURIComponent(String(requestParameters.modelName))).replace(`{${"modelVersion"}}`, encodeURIComponent(String(requestParameters.modelVersion))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetModelVersionResponseFromJSON(jsonValue));
    }

    /**
     * Get the requested model version.
     */
    async getModelVersion(modelName: string, modelVersion: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetModelVersionResponse> {
        const response = await this.getModelVersionRaw({ modelName: modelName, modelVersion: modelVersion }, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of versions for the requested model.
     */
    async getModelVersionsRaw(requestParameters: GetModelVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetModelVersionsResponse>> {
        if (requestParameters.modelName === null || requestParameters.modelName === undefined) {
            throw new runtime.RequiredError('modelName','Required parameter requestParameters.modelName was null or undefined when calling getModelVersions.');
        }

        const queryParameters: any = {};

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/models/{modelName}/versions`.replace(`{${"modelName"}}`, encodeURIComponent(String(requestParameters.modelName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetModelVersionsResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of versions for the requested model.
     */
    async getModelVersions(modelName: string, sortBy?: GetModelVersionsSortByEnum, orderBy?: GetModelVersionsOrderByEnum, offset?: number, limit?: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetModelVersionsResponse> {
        const response = await this.getModelVersionsRaw({ modelName: modelName, sortBy: sortBy, orderBy: orderBy, offset: offset, limit: limit }, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of models.
     */
    async getModelsRaw(requestParameters: GetModelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetModelsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.description !== undefined) {
            queryParameters['description'] = requestParameters.description;
        }

        if (requestParameters.labels) {
            queryParameters['labels'] = requestParameters.labels;
        }

        if (requestParameters.archived !== undefined) {
            queryParameters['archived'] = requestParameters.archived;
        }

        if (requestParameters.users) {
            queryParameters['users'] = requestParameters.users;
        }

        if (requestParameters.userIds) {
            queryParameters['userIds'] = requestParameters.userIds;
        }

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/models`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetModelsResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of models.
     */
    async getModels(sortBy?: GetModelsSortByEnum, orderBy?: GetModelsOrderByEnum, offset?: number, limit?: number, name?: string, description?: string, labels?: Array<string>, archived?: boolean, users?: Array<string>, userIds?: Array<number>, id?: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetModelsResponse> {
        const response = await this.getModelsRaw({ sortBy: sortBy, orderBy: orderBy, offset: offset, limit: limit, name: name, description: description, labels: labels, archived: archived, users: users, userIds: userIds, id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Patch a model\'s fields.
     */
    async patchModelRaw(requestParameters: PatchModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PatchModelResponse>> {
        if (requestParameters.modelName === null || requestParameters.modelName === undefined) {
            throw new runtime.RequiredError('modelName','Required parameter requestParameters.modelName was null or undefined when calling patchModel.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchModel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/models/{modelName}`.replace(`{${"modelName"}}`, encodeURIComponent(String(requestParameters.modelName))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: V1PatchModelToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PatchModelResponseFromJSON(jsonValue));
    }

    /**
     * Patch a model\'s fields.
     */
    async patchModel(modelName: string, body: V1PatchModel, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PatchModelResponse> {
        const response = await this.patchModelRaw({ modelName: modelName, body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Patch a model version\'s fields.
     */
    async patchModelVersionRaw(requestParameters: PatchModelVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PatchModelVersionResponse>> {
        if (requestParameters.modelName === null || requestParameters.modelName === undefined) {
            throw new runtime.RequiredError('modelName','Required parameter requestParameters.modelName was null or undefined when calling patchModelVersion.');
        }

        if (requestParameters.modelVersionId === null || requestParameters.modelVersionId === undefined) {
            throw new runtime.RequiredError('modelVersionId','Required parameter requestParameters.modelVersionId was null or undefined when calling patchModelVersion.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchModelVersion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/models/{modelName}/versions/{modelVersionId}`.replace(`{${"modelName"}}`, encodeURIComponent(String(requestParameters.modelName))).replace(`{${"modelVersionId"}}`, encodeURIComponent(String(requestParameters.modelVersionId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: V1PatchModelVersionToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PatchModelVersionResponseFromJSON(jsonValue));
    }

    /**
     * Patch a model version\'s fields.
     */
    async patchModelVersion(modelName: string, modelVersionId: number, body: V1PatchModelVersion, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PatchModelVersionResponse> {
        const response = await this.patchModelVersionRaw({ modelName: modelName, modelVersionId: modelVersionId, body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Create a model in the registry.
     */
    async postModelRaw(requestParameters: PostModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PostModelResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling postModel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/models`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PostModelRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PostModelResponseFromJSON(jsonValue));
    }

    /**
     * Create a model in the registry.
     */
    async postModel(body: V1PostModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PostModelResponse> {
        const response = await this.postModelRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Create a model version.
     */
    async postModelVersionRaw(requestParameters: PostModelVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PostModelVersionResponse>> {
        if (requestParameters.modelName === null || requestParameters.modelName === undefined) {
            throw new runtime.RequiredError('modelName','Required parameter requestParameters.modelName was null or undefined when calling postModelVersion.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling postModelVersion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/models/{modelName}/versions`.replace(`{${"modelName"}}`, encodeURIComponent(String(requestParameters.modelName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PostModelVersionRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PostModelVersionResponseFromJSON(jsonValue));
    }

    /**
     * Create a model version.
     */
    async postModelVersion(modelName: string, body: V1PostModelVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PostModelVersionResponse> {
        const response = await this.postModelVersionRaw({ modelName: modelName, body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Unarchive a model
     */
    async unarchiveModelRaw(requestParameters: UnarchiveModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.modelName === null || requestParameters.modelName === undefined) {
            throw new runtime.RequiredError('modelName','Required parameter requestParameters.modelName was null or undefined when calling unarchiveModel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/models/{modelName}/unarchive`.replace(`{${"modelName"}}`, encodeURIComponent(String(requestParameters.modelName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Unarchive a model
     */
    async unarchiveModel(modelName: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.unarchiveModelRaw({ modelName: modelName }, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetModelVersionsSortByEnum = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    VERSION: 'SORT_BY_VERSION',
    CREATION_TIME: 'SORT_BY_CREATION_TIME'
} as const;
export type GetModelVersionsSortByEnum = typeof GetModelVersionsSortByEnum[keyof typeof GetModelVersionsSortByEnum];
/**
 * @export
 */
export const GetModelVersionsOrderByEnum = {
    UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
    ASC: 'ORDER_BY_ASC',
    DESC: 'ORDER_BY_DESC'
} as const;
export type GetModelVersionsOrderByEnum = typeof GetModelVersionsOrderByEnum[keyof typeof GetModelVersionsOrderByEnum];
/**
 * @export
 */
export const GetModelsSortByEnum = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    NAME: 'SORT_BY_NAME',
    DESCRIPTION: 'SORT_BY_DESCRIPTION',
    CREATION_TIME: 'SORT_BY_CREATION_TIME',
    LAST_UPDATED_TIME: 'SORT_BY_LAST_UPDATED_TIME',
    NUM_VERSIONS: 'SORT_BY_NUM_VERSIONS'
} as const;
export type GetModelsSortByEnum = typeof GetModelsSortByEnum[keyof typeof GetModelsSortByEnum];
/**
 * @export
 */
export const GetModelsOrderByEnum = {
    UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
    ASC: 'ORDER_BY_ASC',
    DESC: 'ORDER_BY_DESC'
} as const;
export type GetModelsOrderByEnum = typeof GetModelsOrderByEnum[keyof typeof GetModelsOrderByEnum];
