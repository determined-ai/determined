/* tslint:disable */
/* eslint-disable */
/**
 * Determined API (Beta)
 * Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.  You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.
 *
 * The version of the OpenAPI document: 0.1
 * Contact: community@determined.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  RuntimeError,
  V1GetTemplateResponse,
  V1GetTemplatesResponse,
  V1PutTemplateResponse,
  V1Template,
} from '../models';
import {
    RuntimeErrorFromJSON,
    RuntimeErrorToJSON,
    V1GetTemplateResponseFromJSON,
    V1GetTemplateResponseToJSON,
    V1GetTemplatesResponseFromJSON,
    V1GetTemplatesResponseToJSON,
    V1PutTemplateResponseFromJSON,
    V1PutTemplateResponseToJSON,
    V1TemplateFromJSON,
    V1TemplateToJSON,
} from '../models';

export interface DeleteTemplateRequest {
    templateName: string;
}

export interface GetTemplateRequest {
    templateName: string;
}

export interface GetTemplatesRequest {
    sortBy?: GetTemplatesSortByEnum;
    orderBy?: GetTemplatesOrderByEnum;
    offset?: number;
    limit?: number;
    name?: string;
}

export interface PutTemplateRequest {
    templateName: string;
    body: V1Template;
}

/**
 * 
 */
export class TemplatesApi extends runtime.BaseAPI {

    /**
     * Delete a template.
     */
    async deleteTemplateRaw(requestParameters: DeleteTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.templateName === null || requestParameters.templateName === undefined) {
            throw new runtime.RequiredError('templateName','Required parameter requestParameters.templateName was null or undefined when calling deleteTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/templates/{templateName}`.replace(`{${"templateName"}}`, encodeURIComponent(String(requestParameters.templateName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete a template.
     */
    async deleteTemplate(templateName: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteTemplateRaw({ templateName: templateName }, initOverrides);
        return await response.value();
    }

    /**
     * Get the requested template.
     */
    async getTemplateRaw(requestParameters: GetTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetTemplateResponse>> {
        if (requestParameters.templateName === null || requestParameters.templateName === undefined) {
            throw new runtime.RequiredError('templateName','Required parameter requestParameters.templateName was null or undefined when calling getTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/templates/{templateName}`.replace(`{${"templateName"}}`, encodeURIComponent(String(requestParameters.templateName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetTemplateResponseFromJSON(jsonValue));
    }

    /**
     * Get the requested template.
     */
    async getTemplate(templateName: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetTemplateResponse> {
        const response = await this.getTemplateRaw({ templateName: templateName }, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of templates.
     */
    async getTemplatesRaw(requestParameters: GetTemplatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetTemplatesResponse>> {
        const queryParameters: any = {};

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/templates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetTemplatesResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of templates.
     */
    async getTemplates(sortBy?: GetTemplatesSortByEnum, orderBy?: GetTemplatesOrderByEnum, offset?: number, limit?: number, name?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetTemplatesResponse> {
        const response = await this.getTemplatesRaw({ sortBy: sortBy, orderBy: orderBy, offset: offset, limit: limit, name: name }, initOverrides);
        return await response.value();
    }

    /**
     * Update or create (upsert) the requested template.
     */
    async putTemplateRaw(requestParameters: PutTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PutTemplateResponse>> {
        if (requestParameters.templateName === null || requestParameters.templateName === undefined) {
            throw new runtime.RequiredError('templateName','Required parameter requestParameters.templateName was null or undefined when calling putTemplate.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling putTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/templates/{template.name}`.replace(`{${"template.name"}}`, encodeURIComponent(String(requestParameters.templateName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1TemplateToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PutTemplateResponseFromJSON(jsonValue));
    }

    /**
     * Update or create (upsert) the requested template.
     */
    async putTemplate(templateName: string, body: V1Template, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PutTemplateResponse> {
        const response = await this.putTemplateRaw({ templateName: templateName, body: body }, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetTemplatesSortByEnum = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    NAME: 'SORT_BY_NAME'
} as const;
export type GetTemplatesSortByEnum = typeof GetTemplatesSortByEnum[keyof typeof GetTemplatesSortByEnum];
/**
 * @export
 */
export const GetTemplatesOrderByEnum = {
    UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
    ASC: 'ORDER_BY_ASC',
    DESC: 'ORDER_BY_DESC'
} as const;
export type GetTemplatesOrderByEnum = typeof GetTemplatesOrderByEnum[keyof typeof GetTemplatesOrderByEnum];
