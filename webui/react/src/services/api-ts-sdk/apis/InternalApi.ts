/* tslint:disable */
/* eslint-disable */
/**
 * Determined API (Beta)
 * Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.  You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.
 *
 * The version of the OpenAPI document: 0.1
 * Contact: community@determined.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  RuntimeError,
  StreamResultOfV1ExpCompareMetricNamesResponse,
  StreamResultOfV1ExpCompareTrialsSampleResponse,
  StreamResultOfV1GetHPImportanceResponse,
  StreamResultOfV1MetricBatchesResponse,
  StreamResultOfV1MetricNamesResponse,
  StreamResultOfV1TrialsSampleResponse,
  StreamResultOfV1TrialsSnapshotResponse,
  V1AckAllocationPreemptionSignalRequest,
  V1AllocationAllGatherRequest,
  V1AllocationAllGatherResponse,
  V1AllocationPendingPreemptionSignalRequest,
  V1AllocationPreemptionSignalResponse,
  V1AllocationReadyRequest,
  V1AllocationRendezvousInfoResponse,
  V1AllocationWaitingRequest,
  V1Checkpoint,
  V1CompleteValidateAfterOperation,
  V1CreateExperimentRequest,
  V1CreateExperimentResponse,
  V1CreateGroupRequest,
  V1CreateGroupResponse,
  V1GetBestSearcherValidationMetricResponse,
  V1GetCurrentTrialSearcherOperationResponse,
  V1GetGroupResponse,
  V1GetGroupsRequest,
  V1GetGroupsResponse,
  V1GetJobQueueStatsResponse,
  V1GetJobsResponse,
  V1GetResourcePoolsResponse,
  V1GetTelemetryResponse,
  V1GetTrialWorkloadsResponse,
  V1IdleNotebookRequest,
  V1MarkAllocationResourcesDaemonRequest,
  V1PostAllocationProxyAddressRequest,
  V1PostTrialProfilerMetricsBatchRequest,
  V1TrialEarlyExit,
  V1TrialMetrics,
  V1TrialRunnerMetadata,
  V1UpdateGroupRequest,
  V1UpdateGroupResponse,
  V1UpdateJobQueueRequest,
} from '../models';
import {
    RuntimeErrorFromJSON,
    RuntimeErrorToJSON,
    StreamResultOfV1ExpCompareMetricNamesResponseFromJSON,
    StreamResultOfV1ExpCompareMetricNamesResponseToJSON,
    StreamResultOfV1ExpCompareTrialsSampleResponseFromJSON,
    StreamResultOfV1ExpCompareTrialsSampleResponseToJSON,
    StreamResultOfV1GetHPImportanceResponseFromJSON,
    StreamResultOfV1GetHPImportanceResponseToJSON,
    StreamResultOfV1MetricBatchesResponseFromJSON,
    StreamResultOfV1MetricBatchesResponseToJSON,
    StreamResultOfV1MetricNamesResponseFromJSON,
    StreamResultOfV1MetricNamesResponseToJSON,
    StreamResultOfV1TrialsSampleResponseFromJSON,
    StreamResultOfV1TrialsSampleResponseToJSON,
    StreamResultOfV1TrialsSnapshotResponseFromJSON,
    StreamResultOfV1TrialsSnapshotResponseToJSON,
    V1AckAllocationPreemptionSignalRequestFromJSON,
    V1AckAllocationPreemptionSignalRequestToJSON,
    V1AllocationAllGatherRequestFromJSON,
    V1AllocationAllGatherRequestToJSON,
    V1AllocationAllGatherResponseFromJSON,
    V1AllocationAllGatherResponseToJSON,
    V1AllocationPendingPreemptionSignalRequestFromJSON,
    V1AllocationPendingPreemptionSignalRequestToJSON,
    V1AllocationPreemptionSignalResponseFromJSON,
    V1AllocationPreemptionSignalResponseToJSON,
    V1AllocationReadyRequestFromJSON,
    V1AllocationReadyRequestToJSON,
    V1AllocationRendezvousInfoResponseFromJSON,
    V1AllocationRendezvousInfoResponseToJSON,
    V1AllocationWaitingRequestFromJSON,
    V1AllocationWaitingRequestToJSON,
    V1CheckpointFromJSON,
    V1CheckpointToJSON,
    V1CompleteValidateAfterOperationFromJSON,
    V1CompleteValidateAfterOperationToJSON,
    V1CreateExperimentRequestFromJSON,
    V1CreateExperimentRequestToJSON,
    V1CreateExperimentResponseFromJSON,
    V1CreateExperimentResponseToJSON,
    V1CreateGroupRequestFromJSON,
    V1CreateGroupRequestToJSON,
    V1CreateGroupResponseFromJSON,
    V1CreateGroupResponseToJSON,
    V1GetBestSearcherValidationMetricResponseFromJSON,
    V1GetBestSearcherValidationMetricResponseToJSON,
    V1GetCurrentTrialSearcherOperationResponseFromJSON,
    V1GetCurrentTrialSearcherOperationResponseToJSON,
    V1GetGroupResponseFromJSON,
    V1GetGroupResponseToJSON,
    V1GetGroupsRequestFromJSON,
    V1GetGroupsRequestToJSON,
    V1GetGroupsResponseFromJSON,
    V1GetGroupsResponseToJSON,
    V1GetJobQueueStatsResponseFromJSON,
    V1GetJobQueueStatsResponseToJSON,
    V1GetJobsResponseFromJSON,
    V1GetJobsResponseToJSON,
    V1GetResourcePoolsResponseFromJSON,
    V1GetResourcePoolsResponseToJSON,
    V1GetTelemetryResponseFromJSON,
    V1GetTelemetryResponseToJSON,
    V1GetTrialWorkloadsResponseFromJSON,
    V1GetTrialWorkloadsResponseToJSON,
    V1IdleNotebookRequestFromJSON,
    V1IdleNotebookRequestToJSON,
    V1MarkAllocationResourcesDaemonRequestFromJSON,
    V1MarkAllocationResourcesDaemonRequestToJSON,
    V1PostAllocationProxyAddressRequestFromJSON,
    V1PostAllocationProxyAddressRequestToJSON,
    V1PostTrialProfilerMetricsBatchRequestFromJSON,
    V1PostTrialProfilerMetricsBatchRequestToJSON,
    V1TrialEarlyExitFromJSON,
    V1TrialEarlyExitToJSON,
    V1TrialMetricsFromJSON,
    V1TrialMetricsToJSON,
    V1TrialRunnerMetadataFromJSON,
    V1TrialRunnerMetadataToJSON,
    V1UpdateGroupRequestFromJSON,
    V1UpdateGroupRequestToJSON,
    V1UpdateGroupResponseFromJSON,
    V1UpdateGroupResponseToJSON,
    V1UpdateJobQueueRequestFromJSON,
    V1UpdateJobQueueRequestToJSON,
} from '../models';

export interface AckAllocationPreemptionSignalRequest {
    allocationId: string;
    body: V1AckAllocationPreemptionSignalRequest;
}

export interface AllocationAllGatherRequest {
    allocationId: string;
    body: V1AllocationAllGatherRequest;
}

export interface AllocationPendingPreemptionSignalRequest {
    allocationId: string;
    body: V1AllocationPendingPreemptionSignalRequest;
}

export interface AllocationPreemptionSignalRequest {
    allocationId: string;
    timeoutSeconds?: number;
}

export interface AllocationReadyRequest {
    allocationId: string;
    body: V1AllocationReadyRequest;
}

export interface AllocationRendezvousInfoRequest {
    allocationId: string;
    resourcesId: string;
}

export interface AllocationWaitingRequest {
    allocationId: string;
    body: V1AllocationWaitingRequest;
}

export interface CompleteTrialSearcherValidationRequest {
    trialId: number;
    body: V1CompleteValidateAfterOperation;
}

export interface ComputeHPImportanceRequest {
    experimentId: number;
}

export interface CreateExperimentRequest {
    body: V1CreateExperimentRequest;
}

export interface CreateGroupRequest {
    body: V1CreateGroupRequest;
}

export interface DeleteGroupRequest {
    groupId: number;
}

export interface ExpCompareMetricNamesRequest {
    trialId: Array<number>;
    periodSeconds?: number;
}

export interface ExpCompareTrialsSampleRequest {
    experimentIds: Array<number>;
    metricName: string;
    metricType: ExpCompareTrialsSampleMetricTypeEnum;
    maxTrials?: number;
    maxDatapoints?: number;
    startBatches?: number;
    endBatches?: number;
    periodSeconds?: number;
}

export interface GetBestSearcherValidationMetricRequest {
    experimentId: number;
}

export interface GetCurrentTrialSearcherOperationRequest {
    trialId: number;
}

export interface GetGroupRequest {
    groupId: number;
}

export interface GetGroupsRequest {
    body: V1GetGroupsRequest;
}

export interface GetHPImportanceRequest {
    experimentId: number;
    periodSeconds?: number;
}

export interface GetJobQueueStatsRequest {
    resourcePools?: Array<string>;
}

export interface GetJobsRequest {
    offset?: number;
    limit?: number;
    resourcePool?: string;
    orderBy?: GetJobsOrderByEnum;
    states?: Array<GetJobsStatesEnum>;
}

export interface GetResourcePoolsRequest {
    offset?: number;
    limit?: number;
}

export interface GetTrialWorkloadsRequest {
    trialId: number;
    orderBy?: GetTrialWorkloadsOrderByEnum;
    offset?: number;
    limit?: number;
    sortKey?: string;
    filter?: GetTrialWorkloadsFilterEnum;
    includeBatchMetrics?: boolean;
    metricType?: GetTrialWorkloadsMetricTypeEnum;
}

export interface IdleNotebookRequest {
    notebookId: string;
    body: V1IdleNotebookRequest;
}

export interface MarkAllocationResourcesDaemonRequest {
    allocationId: string;
    resourcesId: string;
    body: V1MarkAllocationResourcesDaemonRequest;
}

export interface MetricBatchesRequest {
    experimentId: number;
    metricName: string;
    metricType: MetricBatchesMetricTypeEnum;
    periodSeconds?: number;
}

export interface MetricNamesRequest {
    experimentId: number;
    periodSeconds?: number;
}

export interface PostAllocationProxyAddressRequest {
    allocationId: string;
    body: V1PostAllocationProxyAddressRequest;
}

export interface PostTrialProfilerMetricsBatchRequest {
    body: V1PostTrialProfilerMetricsBatchRequest;
}

export interface PostTrialRunnerMetadataRequest {
    trialId: number;
    body: V1TrialRunnerMetadata;
}

export interface ReportCheckpointRequest {
    body: V1Checkpoint;
}

export interface ReportTrialProgressRequest {
    trialId: number;
    body: number;
}

export interface ReportTrialSearcherEarlyExitRequest {
    trialId: number;
    body: V1TrialEarlyExit;
}

export interface ReportTrialTrainingMetricsRequest {
    trainingMetricsTrialId: number;
    body: V1TrialMetrics;
}

export interface ReportTrialValidationMetricsRequest {
    validationMetricsTrialId: number;
    body: V1TrialMetrics;
}

export interface TrialsSampleRequest {
    experimentId: number;
    metricName: string;
    metricType: TrialsSampleMetricTypeEnum;
    maxTrials?: number;
    maxDatapoints?: number;
    startBatches?: number;
    endBatches?: number;
    periodSeconds?: number;
}

export interface TrialsSnapshotRequest {
    experimentId: number;
    metricName: string;
    metricType: TrialsSnapshotMetricTypeEnum;
    batchesProcessed: number;
    batchesMargin?: number;
    periodSeconds?: number;
}

export interface UpdateGroupRequest {
    groupId: number;
    body: V1UpdateGroupRequest;
}

export interface UpdateJobQueueRequest {
    body: V1UpdateJobQueueRequest;
}

/**
 * 
 */
export class InternalApi extends runtime.BaseAPI {

    /**
     * Acknowledge the receipt of a signal to stop the given allocation early. This is used indicate and exit 0 isn\'t final; specifically, it is used for HP search directed early stops and preemption signals (not necessarily just scheduler preemption).
     */
    async ackAllocationPreemptionSignalRaw(requestParameters: AckAllocationPreemptionSignalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.allocationId === null || requestParameters.allocationId === undefined) {
            throw new runtime.RequiredError('allocationId','Required parameter requestParameters.allocationId was null or undefined when calling ackAllocationPreemptionSignal.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling ackAllocationPreemptionSignal.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/allocations/{allocationId}/signals/ack_preemption`.replace(`{${"allocationId"}}`, encodeURIComponent(String(requestParameters.allocationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1AckAllocationPreemptionSignalRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Acknowledge the receipt of a signal to stop the given allocation early. This is used indicate and exit 0 isn\'t final; specifically, it is used for HP search directed early stops and preemption signals (not necessarily just scheduler preemption).
     */
    async ackAllocationPreemptionSignal(requestParameters: AckAllocationPreemptionSignalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.ackAllocationPreemptionSignalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * AllocationAllGather performs an all gather through the master. An allocation can only perform once all gather at a time.
     */
    async allocationAllGatherRaw(requestParameters: AllocationAllGatherRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1AllocationAllGatherResponse>> {
        if (requestParameters.allocationId === null || requestParameters.allocationId === undefined) {
            throw new runtime.RequiredError('allocationId','Required parameter requestParameters.allocationId was null or undefined when calling allocationAllGather.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling allocationAllGather.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/allocations/{allocationId}/all_gather`.replace(`{${"allocationId"}}`, encodeURIComponent(String(requestParameters.allocationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1AllocationAllGatherRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1AllocationAllGatherResponseFromJSON(jsonValue));
    }

    /**
     * AllocationAllGather performs an all gather through the master. An allocation can only perform once all gather at a time.
     */
    async allocationAllGather(requestParameters: AllocationAllGatherRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1AllocationAllGatherResponse> {
        const response = await this.allocationAllGatherRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Report the receipt of a signal to stop the given allocation early. This is used to communicate back from a SLURM job that it has been notified of a pending preememption. Upon a call to this API the RM should then trigger a checkpoint and immediate exit.
     */
    async allocationPendingPreemptionSignalRaw(requestParameters: AllocationPendingPreemptionSignalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.allocationId === null || requestParameters.allocationId === undefined) {
            throw new runtime.RequiredError('allocationId','Required parameter requestParameters.allocationId was null or undefined when calling allocationPendingPreemptionSignal.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling allocationPendingPreemptionSignal.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/allocations/{allocationId}/signals/pending_preemption`.replace(`{${"allocationId"}}`, encodeURIComponent(String(requestParameters.allocationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1AllocationPendingPreemptionSignalRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Report the receipt of a signal to stop the given allocation early. This is used to communicate back from a SLURM job that it has been notified of a pending preememption. Upon a call to this API the RM should then trigger a checkpoint and immediate exit.
     */
    async allocationPendingPreemptionSignal(requestParameters: AllocationPendingPreemptionSignalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.allocationPendingPreemptionSignalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Long poll preemption signals for the given allocation. If the allocation has been preempted when called, it will return so immediately. Otherwise, the connection will be kept open until the timeout is reached or the allocation is preempted.
     */
    async allocationPreemptionSignalRaw(requestParameters: AllocationPreemptionSignalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1AllocationPreemptionSignalResponse>> {
        if (requestParameters.allocationId === null || requestParameters.allocationId === undefined) {
            throw new runtime.RequiredError('allocationId','Required parameter requestParameters.allocationId was null or undefined when calling allocationPreemptionSignal.');
        }

        const queryParameters: any = {};

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/allocations/{allocationId}/signals/preemption`.replace(`{${"allocationId"}}`, encodeURIComponent(String(requestParameters.allocationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1AllocationPreemptionSignalResponseFromJSON(jsonValue));
    }

    /**
     * Long poll preemption signals for the given allocation. If the allocation has been preempted when called, it will return so immediately. Otherwise, the connection will be kept open until the timeout is reached or the allocation is preempted.
     */
    async allocationPreemptionSignal(requestParameters: AllocationPreemptionSignalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1AllocationPreemptionSignalResponse> {
        const response = await this.allocationPreemptionSignalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set allocation to ready state.
     */
    async allocationReadyRaw(requestParameters: AllocationReadyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.allocationId === null || requestParameters.allocationId === undefined) {
            throw new runtime.RequiredError('allocationId','Required parameter requestParameters.allocationId was null or undefined when calling allocationReady.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling allocationReady.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/allocations/{allocationId}/ready`.replace(`{${"allocationId"}}`, encodeURIComponent(String(requestParameters.allocationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1AllocationReadyRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Set allocation to ready state.
     */
    async allocationReady(requestParameters: AllocationReadyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.allocationReadyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gather an allocation\'s rendezvous info. Blocks until all trial containers connect to gather their rendezvous information and responds to them all at once.
     */
    async allocationRendezvousInfoRaw(requestParameters: AllocationRendezvousInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1AllocationRendezvousInfoResponse>> {
        if (requestParameters.allocationId === null || requestParameters.allocationId === undefined) {
            throw new runtime.RequiredError('allocationId','Required parameter requestParameters.allocationId was null or undefined when calling allocationRendezvousInfo.');
        }

        if (requestParameters.resourcesId === null || requestParameters.resourcesId === undefined) {
            throw new runtime.RequiredError('resourcesId','Required parameter requestParameters.resourcesId was null or undefined when calling allocationRendezvousInfo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/allocations/{allocationId}/resources/{resourcesId}/rendezvous`.replace(`{${"allocationId"}}`, encodeURIComponent(String(requestParameters.allocationId))).replace(`{${"resourcesId"}}`, encodeURIComponent(String(requestParameters.resourcesId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1AllocationRendezvousInfoResponseFromJSON(jsonValue));
    }

    /**
     * Gather an allocation\'s rendezvous info. Blocks until all trial containers connect to gather their rendezvous information and responds to them all at once.
     */
    async allocationRendezvousInfo(requestParameters: AllocationRendezvousInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1AllocationRendezvousInfoResponse> {
        const response = await this.allocationRendezvousInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set allocation to waiting state.
     */
    async allocationWaitingRaw(requestParameters: AllocationWaitingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.allocationId === null || requestParameters.allocationId === undefined) {
            throw new runtime.RequiredError('allocationId','Required parameter requestParameters.allocationId was null or undefined when calling allocationWaiting.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling allocationWaiting.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/allocations/{allocationId}/waiting`.replace(`{${"allocationId"}}`, encodeURIComponent(String(requestParameters.allocationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1AllocationWaitingRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Set allocation to waiting state.
     */
    async allocationWaiting(requestParameters: AllocationWaitingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.allocationWaitingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reports to the searcher that the trial has completed the given searcher operation.
     */
    async completeTrialSearcherValidationRaw(requestParameters: CompleteTrialSearcherValidationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling completeTrialSearcherValidation.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling completeTrialSearcherValidation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/searcher/completed_operation`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1CompleteValidateAfterOperationToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Reports to the searcher that the trial has completed the given searcher operation.
     */
    async completeTrialSearcherValidation(requestParameters: CompleteTrialSearcherValidationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.completeTrialSearcherValidationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Trigger the computation of hyperparameter importance on-demand for a specific metric on a specific experiment. The status and results can be retrieved with GetHPImportance.
     */
    async computeHPImportanceRaw(requestParameters: ComputeHPImportanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling computeHPImportance.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/hyperparameter-importance`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Trigger the computation of hyperparameter importance on-demand for a specific metric on a specific experiment. The status and results can be retrieved with GetHPImportance.
     */
    async computeHPImportance(requestParameters: ComputeHPImportanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.computeHPImportanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an experiment.
     */
    async createExperimentRaw(requestParameters: CreateExperimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1CreateExperimentResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createExperiment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1CreateExperimentRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1CreateExperimentResponseFromJSON(jsonValue));
    }

    /**
     * Create an experiment.
     */
    async createExperiment(requestParameters: CreateExperimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1CreateExperimentResponse> {
        const response = await this.createExperimentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a group with optional members on creation.
     */
    async createGroupRaw(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1CreateGroupResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/groups`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1CreateGroupRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1CreateGroupResponseFromJSON(jsonValue));
    }

    /**
     * Create a group with optional members on creation.
     */
    async createGroup(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1CreateGroupResponse> {
        const response = await this.createGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a group.
     */
    async deleteGroupRaw(requestParameters: DeleteGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling deleteGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/groups/{groupId}`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Remove a group.
     */
    async deleteGroup(requestParameters: DeleteGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the set of metric names recorded for a trial.
     */
    async expCompareMetricNamesRaw(requestParameters: ExpCompareMetricNamesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1ExpCompareMetricNamesResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling expCompareMetricNames.');
        }

        const queryParameters: any = {};

        if (requestParameters.trialId) {
            queryParameters['trialId'] = requestParameters.trialId;
        }

        if (requestParameters.periodSeconds !== undefined) {
            queryParameters['periodSeconds'] = requestParameters.periodSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/metrics-stream/metric-names`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1ExpCompareMetricNamesResponseFromJSON(jsonValue));
    }

    /**
     * Get the set of metric names recorded for a trial.
     */
    async expCompareMetricNames(requestParameters: ExpCompareMetricNamesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1ExpCompareMetricNamesResponse> {
        const response = await this.expCompareMetricNamesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a sample of the metrics over time for a sample of the trials.
     */
    async expCompareTrialsSampleRaw(requestParameters: ExpCompareTrialsSampleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1ExpCompareTrialsSampleResponse>> {
        if (requestParameters.experimentIds === null || requestParameters.experimentIds === undefined) {
            throw new runtime.RequiredError('experimentIds','Required parameter requestParameters.experimentIds was null or undefined when calling expCompareTrialsSample.');
        }

        if (requestParameters.metricName === null || requestParameters.metricName === undefined) {
            throw new runtime.RequiredError('metricName','Required parameter requestParameters.metricName was null or undefined when calling expCompareTrialsSample.');
        }

        if (requestParameters.metricType === null || requestParameters.metricType === undefined) {
            throw new runtime.RequiredError('metricType','Required parameter requestParameters.metricType was null or undefined when calling expCompareTrialsSample.');
        }

        const queryParameters: any = {};

        if (requestParameters.experimentIds) {
            queryParameters['experimentIds'] = requestParameters.experimentIds;
        }

        if (requestParameters.metricName !== undefined) {
            queryParameters['metricName'] = requestParameters.metricName;
        }

        if (requestParameters.metricType !== undefined) {
            queryParameters['metricType'] = requestParameters.metricType;
        }

        if (requestParameters.maxTrials !== undefined) {
            queryParameters['maxTrials'] = requestParameters.maxTrials;
        }

        if (requestParameters.maxDatapoints !== undefined) {
            queryParameters['maxDatapoints'] = requestParameters.maxDatapoints;
        }

        if (requestParameters.startBatches !== undefined) {
            queryParameters['startBatches'] = requestParameters.startBatches;
        }

        if (requestParameters.endBatches !== undefined) {
            queryParameters['endBatches'] = requestParameters.endBatches;
        }

        if (requestParameters.periodSeconds !== undefined) {
            queryParameters['periodSeconds'] = requestParameters.periodSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments-compare`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1ExpCompareTrialsSampleResponseFromJSON(jsonValue));
    }

    /**
     * Get a sample of the metrics over time for a sample of the trials.
     */
    async expCompareTrialsSample(requestParameters: ExpCompareTrialsSampleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1ExpCompareTrialsSampleResponse> {
        const response = await this.expCompareTrialsSampleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the best searcher validation for an experiment by the given metric.
     */
    async getBestSearcherValidationMetricRaw(requestParameters: GetBestSearcherValidationMetricRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetBestSearcherValidationMetricResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling getBestSearcherValidationMetric.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/searcher/best_searcher_validation_metric`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetBestSearcherValidationMetricResponseFromJSON(jsonValue));
    }

    /**
     * Get the best searcher validation for an experiment by the given metric.
     */
    async getBestSearcherValidationMetric(requestParameters: GetBestSearcherValidationMetricRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetBestSearcherValidationMetricResponse> {
        const response = await this.getBestSearcherValidationMetricRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the current searcher operation.
     */
    async getCurrentTrialSearcherOperationRaw(requestParameters: GetCurrentTrialSearcherOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetCurrentTrialSearcherOperationResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling getCurrentTrialSearcherOperation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/searcher/operation`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetCurrentTrialSearcherOperationResponseFromJSON(jsonValue));
    }

    /**
     * Get the current searcher operation.
     */
    async getCurrentTrialSearcherOperation(requestParameters: GetCurrentTrialSearcherOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetCurrentTrialSearcherOperationResponse> {
        const response = await this.getCurrentTrialSearcherOperationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a group by id.
     */
    async getGroupRaw(requestParameters: GetGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetGroupResponse>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling getGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/groups/{groupId}`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetGroupResponseFromJSON(jsonValue));
    }

    /**
     * Get a group by id.
     */
    async getGroup(requestParameters: GetGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetGroupResponse> {
        const response = await this.getGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for groups with optional filters.
     */
    async getGroupsRaw(requestParameters: GetGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetGroupsResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling getGroups.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/groups/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1GetGroupsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetGroupsResponseFromJSON(jsonValue));
    }

    /**
     * Search for groups with optional filters.
     */
    async getGroups(requestParameters: GetGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetGroupsResponse> {
        const response = await this.getGroupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the latest computation of hyperparameter importance. Currently this is triggered for training loss (if emitted) and the searcher metric after 10% increments in an experiment\'s progress, but no more than every 10 minutes.
     */
    async getHPImportanceRaw(requestParameters: GetHPImportanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1GetHPImportanceResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling getHPImportance.');
        }

        const queryParameters: any = {};

        if (requestParameters.periodSeconds !== undefined) {
            queryParameters['periodSeconds'] = requestParameters.periodSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/hyperparameter-importance`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1GetHPImportanceResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the latest computation of hyperparameter importance. Currently this is triggered for training loss (if emitted) and the searcher metric after 10% increments in an experiment\'s progress, but no more than every 10 minutes.
     */
    async getHPImportance(requestParameters: GetHPImportanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1GetHPImportanceResponse> {
        const response = await this.getHPImportanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get job queue stats for a resource pool.
     */
    async getJobQueueStatsRaw(requestParameters: GetJobQueueStatsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetJobQueueStatsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.resourcePools) {
            queryParameters['resourcePools'] = requestParameters.resourcePools;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/job-queues/stats`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetJobQueueStatsResponseFromJSON(jsonValue));
    }

    /**
     * Get job queue stats for a resource pool.
     */
    async getJobQueueStats(requestParameters: GetJobQueueStatsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetJobQueueStatsResponse> {
        const response = await this.getJobQueueStatsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of jobs in queue.
     */
    async getJobsRaw(requestParameters: GetJobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetJobsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourcePool !== undefined) {
            queryParameters['resourcePool'] = requestParameters.resourcePool;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.states) {
            queryParameters['states'] = requestParameters.states;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/job-queues`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetJobsResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of jobs in queue.
     */
    async getJobs(requestParameters: GetJobsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetJobsResponse> {
        const response = await this.getJobsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all resource pools from the cluster.
     */
    async getResourcePoolsRaw(requestParameters: GetResourcePoolsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetResourcePoolsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/resource-pools`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetResourcePoolsResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of all resource pools from the cluster.
     */
    async getResourcePools(requestParameters: GetResourcePoolsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetResourcePoolsResponse> {
        const response = await this.getResourcePoolsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get telemetry information.
     */
    async getTelemetryRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetTelemetryResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/master/telemetry`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetTelemetryResponseFromJSON(jsonValue));
    }

    /**
     * Get telemetry information.
     */
    async getTelemetry(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetTelemetryResponse> {
        const response = await this.getTelemetryRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the list of workloads for a trial.
     */
    async getTrialWorkloadsRaw(requestParameters: GetTrialWorkloadsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetTrialWorkloadsResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling getTrialWorkloads.');
        }

        const queryParameters: any = {};

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.sortKey !== undefined) {
            queryParameters['sortKey'] = requestParameters.sortKey;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.includeBatchMetrics !== undefined) {
            queryParameters['includeBatchMetrics'] = requestParameters.includeBatchMetrics;
        }

        if (requestParameters.metricType !== undefined) {
            queryParameters['metricType'] = requestParameters.metricType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/workloads`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetTrialWorkloadsResponseFromJSON(jsonValue));
    }

    /**
     * Get the list of workloads for a trial.
     */
    async getTrialWorkloads(requestParameters: GetTrialWorkloadsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetTrialWorkloadsResponse> {
        const response = await this.getTrialWorkloadsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Send notebook idle data to master
     */
    async idleNotebookRaw(requestParameters: IdleNotebookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.notebookId === null || requestParameters.notebookId === undefined) {
            throw new runtime.RequiredError('notebookId','Required parameter requestParameters.notebookId was null or undefined when calling idleNotebook.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling idleNotebook.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/notebooks/{notebookId}/report_idle`.replace(`{${"notebookId"}}`, encodeURIComponent(String(requestParameters.notebookId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1IdleNotebookRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Send notebook idle data to master
     */
    async idleNotebook(requestParameters: IdleNotebookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.idleNotebookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark the given reservation (container, pod, etc) within an allocation as a daemon reservation. In the exit of a successful exit, Determined will wait for all resources to exit - unless they are marked as daemon resources, in which case Determined will clean them up regardless of exit status after all non-daemon resources have exited.
     */
    async markAllocationResourcesDaemonRaw(requestParameters: MarkAllocationResourcesDaemonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.allocationId === null || requestParameters.allocationId === undefined) {
            throw new runtime.RequiredError('allocationId','Required parameter requestParameters.allocationId was null or undefined when calling markAllocationResourcesDaemon.');
        }

        if (requestParameters.resourcesId === null || requestParameters.resourcesId === undefined) {
            throw new runtime.RequiredError('resourcesId','Required parameter requestParameters.resourcesId was null or undefined when calling markAllocationResourcesDaemon.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling markAllocationResourcesDaemon.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/allocations/{allocationId}/resources/{resourcesId}/daemon`.replace(`{${"allocationId"}}`, encodeURIComponent(String(requestParameters.allocationId))).replace(`{${"resourcesId"}}`, encodeURIComponent(String(requestParameters.resourcesId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1MarkAllocationResourcesDaemonRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Mark the given reservation (container, pod, etc) within an allocation as a daemon reservation. In the exit of a successful exit, Determined will wait for all resources to exit - unless they are marked as daemon resources, in which case Determined will clean them up regardless of exit status after all non-daemon resources have exited.
     */
    async markAllocationResourcesDaemon(requestParameters: MarkAllocationResourcesDaemonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.markAllocationResourcesDaemonRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the milestones (in batches processed) at which a metric is recorded by an experiment.
     */
    async metricBatchesRaw(requestParameters: MetricBatchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1MetricBatchesResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling metricBatches.');
        }

        if (requestParameters.metricName === null || requestParameters.metricName === undefined) {
            throw new runtime.RequiredError('metricName','Required parameter requestParameters.metricName was null or undefined when calling metricBatches.');
        }

        if (requestParameters.metricType === null || requestParameters.metricType === undefined) {
            throw new runtime.RequiredError('metricType','Required parameter requestParameters.metricType was null or undefined when calling metricBatches.');
        }

        const queryParameters: any = {};

        if (requestParameters.metricName !== undefined) {
            queryParameters['metricName'] = requestParameters.metricName;
        }

        if (requestParameters.metricType !== undefined) {
            queryParameters['metricType'] = requestParameters.metricType;
        }

        if (requestParameters.periodSeconds !== undefined) {
            queryParameters['periodSeconds'] = requestParameters.periodSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/metrics-stream/batches`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1MetricBatchesResponseFromJSON(jsonValue));
    }

    /**
     * Get the milestones (in batches processed) at which a metric is recorded by an experiment.
     */
    async metricBatches(requestParameters: MetricBatchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1MetricBatchesResponse> {
        const response = await this.metricBatchesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the set of metric names recorded for an experiment.
     */
    async metricNamesRaw(requestParameters: MetricNamesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1MetricNamesResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling metricNames.');
        }

        const queryParameters: any = {};

        if (requestParameters.periodSeconds !== undefined) {
            queryParameters['periodSeconds'] = requestParameters.periodSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/metrics-stream/metric-names`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1MetricNamesResponseFromJSON(jsonValue));
    }

    /**
     * Get the set of metric names recorded for an experiment.
     */
    async metricNames(requestParameters: MetricNamesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1MetricNamesResponse> {
        const response = await this.metricNamesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * PostAllocationProxyAddress sets the proxy address to use when proxying to services provided by an allocation. Upon receipt, the master will also register any proxies specified by the task.
     */
    async postAllocationProxyAddressRaw(requestParameters: PostAllocationProxyAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.allocationId === null || requestParameters.allocationId === undefined) {
            throw new runtime.RequiredError('allocationId','Required parameter requestParameters.allocationId was null or undefined when calling postAllocationProxyAddress.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling postAllocationProxyAddress.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/allocations/{allocationId}/proxy_address`.replace(`{${"allocationId"}}`, encodeURIComponent(String(requestParameters.allocationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PostAllocationProxyAddressRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * PostAllocationProxyAddress sets the proxy address to use when proxying to services provided by an allocation. Upon receipt, the master will also register any proxies specified by the task.
     */
    async postAllocationProxyAddress(requestParameters: PostAllocationProxyAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.postAllocationProxyAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Persist the given TrialProfilerMetricsBatch. The trial ID is in the labels.
     */
    async postTrialProfilerMetricsBatchRaw(requestParameters: PostTrialProfilerMetricsBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling postTrialProfilerMetricsBatch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/profiler/metrics`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PostTrialProfilerMetricsBatchRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Persist the given TrialProfilerMetricsBatch. The trial ID is in the labels.
     */
    async postTrialProfilerMetricsBatch(requestParameters: PostTrialProfilerMetricsBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.postTrialProfilerMetricsBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * For bookkeeping, update trial runner metadata (currently just state).
     */
    async postTrialRunnerMetadataRaw(requestParameters: PostTrialRunnerMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling postTrialRunnerMetadata.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling postTrialRunnerMetadata.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/runner/metadata`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1TrialRunnerMetadataToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * For bookkeeping, update trial runner metadata (currently just state).
     */
    async postTrialRunnerMetadata(requestParameters: PostTrialRunnerMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.postTrialRunnerMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Record a checkpoint.
     */
    async reportCheckpointRaw(requestParameters: ReportCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling reportCheckpoint.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/checkpoints`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1CheckpointToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Record a checkpoint.
     */
    async reportCheckpoint(requestParameters: ReportCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.reportCheckpointRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * For bookkeeping, updates the progress towards to current requested searcher training length.
     */
    async reportTrialProgressRaw(requestParameters: ReportTrialProgressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling reportTrialProgress.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling reportTrialProgress.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/progress`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * For bookkeeping, updates the progress towards to current requested searcher training length.
     */
    async reportTrialProgress(requestParameters: ReportTrialProgressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.reportTrialProgressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reports to the searcher that the trial has completed the current requested amount of training with the given searcher validation metric.
     */
    async reportTrialSearcherEarlyExitRaw(requestParameters: ReportTrialSearcherEarlyExitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling reportTrialSearcherEarlyExit.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling reportTrialSearcherEarlyExit.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/early_exit`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1TrialEarlyExitToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Reports to the searcher that the trial has completed the current requested amount of training with the given searcher validation metric.
     */
    async reportTrialSearcherEarlyExit(requestParameters: ReportTrialSearcherEarlyExitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.reportTrialSearcherEarlyExitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Record training metrics for specified training.
     */
    async reportTrialTrainingMetricsRaw(requestParameters: ReportTrialTrainingMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.trainingMetricsTrialId === null || requestParameters.trainingMetricsTrialId === undefined) {
            throw new runtime.RequiredError('trainingMetricsTrialId','Required parameter requestParameters.trainingMetricsTrialId was null or undefined when calling reportTrialTrainingMetrics.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling reportTrialTrainingMetrics.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trainingMetrics.trialId}/training_metrics`.replace(`{${"trainingMetrics.trialId"}}`, encodeURIComponent(String(requestParameters.trainingMetricsTrialId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1TrialMetricsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Record training metrics for specified training.
     */
    async reportTrialTrainingMetrics(requestParameters: ReportTrialTrainingMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.reportTrialTrainingMetricsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Record validation metrics.
     */
    async reportTrialValidationMetricsRaw(requestParameters: ReportTrialValidationMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.validationMetricsTrialId === null || requestParameters.validationMetricsTrialId === undefined) {
            throw new runtime.RequiredError('validationMetricsTrialId','Required parameter requestParameters.validationMetricsTrialId was null or undefined when calling reportTrialValidationMetrics.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling reportTrialValidationMetrics.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{validationMetrics.trialId}/validation_metrics`.replace(`{${"validationMetrics.trialId"}}`, encodeURIComponent(String(requestParameters.validationMetricsTrialId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1TrialMetricsToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Record validation metrics.
     */
    async reportTrialValidationMetrics(requestParameters: ReportTrialValidationMetricsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.reportTrialValidationMetricsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a sample of the metrics over time for a sample of the trials.
     */
    async trialsSampleRaw(requestParameters: TrialsSampleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1TrialsSampleResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling trialsSample.');
        }

        if (requestParameters.metricName === null || requestParameters.metricName === undefined) {
            throw new runtime.RequiredError('metricName','Required parameter requestParameters.metricName was null or undefined when calling trialsSample.');
        }

        if (requestParameters.metricType === null || requestParameters.metricType === undefined) {
            throw new runtime.RequiredError('metricType','Required parameter requestParameters.metricType was null or undefined when calling trialsSample.');
        }

        const queryParameters: any = {};

        if (requestParameters.metricName !== undefined) {
            queryParameters['metricName'] = requestParameters.metricName;
        }

        if (requestParameters.metricType !== undefined) {
            queryParameters['metricType'] = requestParameters.metricType;
        }

        if (requestParameters.maxTrials !== undefined) {
            queryParameters['maxTrials'] = requestParameters.maxTrials;
        }

        if (requestParameters.maxDatapoints !== undefined) {
            queryParameters['maxDatapoints'] = requestParameters.maxDatapoints;
        }

        if (requestParameters.startBatches !== undefined) {
            queryParameters['startBatches'] = requestParameters.startBatches;
        }

        if (requestParameters.endBatches !== undefined) {
            queryParameters['endBatches'] = requestParameters.endBatches;
        }

        if (requestParameters.periodSeconds !== undefined) {
            queryParameters['periodSeconds'] = requestParameters.periodSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/metrics-stream/trials-sample`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1TrialsSampleResponseFromJSON(jsonValue));
    }

    /**
     * Get a sample of the metrics over time for a sample of the trials.
     */
    async trialsSample(requestParameters: TrialsSampleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1TrialsSampleResponse> {
        const response = await this.trialsSampleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a snapshot of a metric across all trials at a certain point of progress.
     */
    async trialsSnapshotRaw(requestParameters: TrialsSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1TrialsSnapshotResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling trialsSnapshot.');
        }

        if (requestParameters.metricName === null || requestParameters.metricName === undefined) {
            throw new runtime.RequiredError('metricName','Required parameter requestParameters.metricName was null or undefined when calling trialsSnapshot.');
        }

        if (requestParameters.metricType === null || requestParameters.metricType === undefined) {
            throw new runtime.RequiredError('metricType','Required parameter requestParameters.metricType was null or undefined when calling trialsSnapshot.');
        }

        if (requestParameters.batchesProcessed === null || requestParameters.batchesProcessed === undefined) {
            throw new runtime.RequiredError('batchesProcessed','Required parameter requestParameters.batchesProcessed was null or undefined when calling trialsSnapshot.');
        }

        const queryParameters: any = {};

        if (requestParameters.metricName !== undefined) {
            queryParameters['metricName'] = requestParameters.metricName;
        }

        if (requestParameters.metricType !== undefined) {
            queryParameters['metricType'] = requestParameters.metricType;
        }

        if (requestParameters.batchesProcessed !== undefined) {
            queryParameters['batchesProcessed'] = requestParameters.batchesProcessed;
        }

        if (requestParameters.batchesMargin !== undefined) {
            queryParameters['batchesMargin'] = requestParameters.batchesMargin;
        }

        if (requestParameters.periodSeconds !== undefined) {
            queryParameters['periodSeconds'] = requestParameters.periodSeconds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/metrics-stream/trials-snapshot`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1TrialsSnapshotResponseFromJSON(jsonValue));
    }

    /**
     * Get a snapshot of a metric across all trials at a certain point of progress.
     */
    async trialsSnapshot(requestParameters: TrialsSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1TrialsSnapshotResponse> {
        const response = await this.trialsSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update group info.
     */
    async updateGroupRaw(requestParameters: UpdateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1UpdateGroupResponse>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling updateGroup.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/groups/{groupId}`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1UpdateGroupRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1UpdateGroupResponseFromJSON(jsonValue));
    }

    /**
     * Update group info.
     */
    async updateGroup(requestParameters: UpdateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1UpdateGroupResponse> {
        const response = await this.updateGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Control the job queues.
     */
    async updateJobQueueRaw(requestParameters: UpdateJobQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateJobQueue.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/job-queues`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1UpdateJobQueueRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Control the job queues.
     */
    async updateJobQueue(requestParameters: UpdateJobQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.updateJobQueueRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
  * @export
  * @enum {string}
  */
export enum ExpCompareTrialsSampleMetricTypeEnum {
    Unspecified = 'METRIC_TYPE_UNSPECIFIED',
    Training = 'METRIC_TYPE_TRAINING',
    Validation = 'METRIC_TYPE_VALIDATION'
}
/**
  * @export
  * @enum {string}
  */
export enum GetJobsOrderByEnum {
    Unspecified = 'ORDER_BY_UNSPECIFIED',
    Asc = 'ORDER_BY_ASC',
    Desc = 'ORDER_BY_DESC'
}
/**
  * @export
  * @enum {string}
  */
export enum GetJobsStatesEnum {
    Unspecified = 'STATE_UNSPECIFIED',
    Queued = 'STATE_QUEUED',
    Scheduled = 'STATE_SCHEDULED',
    ScheduledBackfilled = 'STATE_SCHEDULED_BACKFILLED'
}
/**
  * @export
  * @enum {string}
  */
export enum GetTrialWorkloadsOrderByEnum {
    Unspecified = 'ORDER_BY_UNSPECIFIED',
    Asc = 'ORDER_BY_ASC',
    Desc = 'ORDER_BY_DESC'
}
/**
  * @export
  * @enum {string}
  */
export enum GetTrialWorkloadsFilterEnum {
    Unspecified = 'FILTER_OPTION_UNSPECIFIED',
    Checkpoint = 'FILTER_OPTION_CHECKPOINT',
    Validation = 'FILTER_OPTION_VALIDATION',
    CheckpointOrValidation = 'FILTER_OPTION_CHECKPOINT_OR_VALIDATION'
}
/**
  * @export
  * @enum {string}
  */
export enum GetTrialWorkloadsMetricTypeEnum {
    Unspecified = 'METRIC_TYPE_UNSPECIFIED',
    Training = 'METRIC_TYPE_TRAINING',
    Validation = 'METRIC_TYPE_VALIDATION'
}
/**
  * @export
  * @enum {string}
  */
export enum MetricBatchesMetricTypeEnum {
    Unspecified = 'METRIC_TYPE_UNSPECIFIED',
    Training = 'METRIC_TYPE_TRAINING',
    Validation = 'METRIC_TYPE_VALIDATION'
}
/**
  * @export
  * @enum {string}
  */
export enum TrialsSampleMetricTypeEnum {
    Unspecified = 'METRIC_TYPE_UNSPECIFIED',
    Training = 'METRIC_TYPE_TRAINING',
    Validation = 'METRIC_TYPE_VALIDATION'
}
/**
  * @export
  * @enum {string}
  */
export enum TrialsSnapshotMetricTypeEnum {
    Unspecified = 'METRIC_TYPE_UNSPECIFIED',
    Training = 'METRIC_TYPE_TRAINING',
    Validation = 'METRIC_TYPE_VALIDATION'
}
