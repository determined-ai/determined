/* tslint:disable */
/* eslint-disable */
/**
 * Determined API (Beta)
 * Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.  You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.
 *
 * The version of the OpenAPI document: 0.1
 * Contact: community@determined.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  RuntimeError,
  StreamResultOfV1MasterLogsResponse,
  V1DisableAgentRequest,
  V1DisableAgentResponse,
  V1DisableSlotResponse,
  V1EnableAgentResponse,
  V1EnableSlotResponse,
  V1GetAgentResponse,
  V1GetAgentsResponse,
  V1GetMasterConfigResponse,
  V1GetMasterResponse,
  V1GetSlotResponse,
  V1GetSlotsResponse,
  V1ResourceAllocationAggregatedResponse,
  V1ResourceAllocationRawResponse,
} from '../models';
import {
    RuntimeErrorFromJSON,
    RuntimeErrorToJSON,
    StreamResultOfV1MasterLogsResponseFromJSON,
    StreamResultOfV1MasterLogsResponseToJSON,
    V1DisableAgentRequestFromJSON,
    V1DisableAgentRequestToJSON,
    V1DisableAgentResponseFromJSON,
    V1DisableAgentResponseToJSON,
    V1DisableSlotResponseFromJSON,
    V1DisableSlotResponseToJSON,
    V1EnableAgentResponseFromJSON,
    V1EnableAgentResponseToJSON,
    V1EnableSlotResponseFromJSON,
    V1EnableSlotResponseToJSON,
    V1GetAgentResponseFromJSON,
    V1GetAgentResponseToJSON,
    V1GetAgentsResponseFromJSON,
    V1GetAgentsResponseToJSON,
    V1GetMasterConfigResponseFromJSON,
    V1GetMasterConfigResponseToJSON,
    V1GetMasterResponseFromJSON,
    V1GetMasterResponseToJSON,
    V1GetSlotResponseFromJSON,
    V1GetSlotResponseToJSON,
    V1GetSlotsResponseFromJSON,
    V1GetSlotsResponseToJSON,
    V1ResourceAllocationAggregatedResponseFromJSON,
    V1ResourceAllocationAggregatedResponseToJSON,
    V1ResourceAllocationRawResponseFromJSON,
    V1ResourceAllocationRawResponseToJSON,
} from '../models';

export interface DisableAgentRequest {
    agentId: string;
    body: V1DisableAgentRequest;
}

export interface DisableSlotRequest {
    agentId: string;
    slotId: string;
}

export interface EnableAgentRequest {
    agentId: string;
}

export interface EnableSlotRequest {
    agentId: string;
    slotId: string;
}

export interface GetAgentRequest {
    agentId: string;
}

export interface GetAgentsRequest {
    sortBy?: GetAgentsSortByEnum;
    orderBy?: GetAgentsOrderByEnum;
    offset?: number;
    limit?: number;
    label?: string;
}

export interface GetAggregatedResourceAllocationCsvRequest {
    startDate: string;
    endDate: string;
    period: string;
}

export interface GetRawResourceAllocationCsvRequest {
    timestampAfter: string;
    timestampBefore: string;
}

export interface GetSlotRequest {
    agentId: string;
    slotId: string;
}

export interface GetSlotsRequest {
    agentId: string;
}

export interface MasterLogsRequest {
    offset?: number;
    limit?: number;
    follow?: boolean;
}

export interface ResourceAllocationAggregatedRequest {
    startDate?: string;
    endDate?: string;
    period?: ResourceAllocationAggregatedPeriodEnum;
}

export interface ResourceAllocationRawRequest {
    timestampAfter?: Date;
    timestampBefore?: Date;
}

/**
 * 
 */
export class ClusterApi extends runtime.BaseAPI {

    /**
     * Disable the agent.
     */
    async disableAgentRaw(requestParameters: DisableAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1DisableAgentResponse>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling disableAgent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling disableAgent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/agents/{agentId}/disable`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1DisableAgentRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1DisableAgentResponseFromJSON(jsonValue));
    }

    /**
     * Disable the agent.
     */
    async disableAgent(requestParameters: DisableAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1DisableAgentResponse> {
        const response = await this.disableAgentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Disable the slot.
     */
    async disableSlotRaw(requestParameters: DisableSlotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1DisableSlotResponse>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling disableSlot.');
        }

        if (requestParameters.slotId === null || requestParameters.slotId === undefined) {
            throw new runtime.RequiredError('slotId','Required parameter requestParameters.slotId was null or undefined when calling disableSlot.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/agents/{agentId}/slots/{slotId}/disable`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))).replace(`{${"slotId"}}`, encodeURIComponent(String(requestParameters.slotId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1DisableSlotResponseFromJSON(jsonValue));
    }

    /**
     * Disable the slot.
     */
    async disableSlot(requestParameters: DisableSlotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1DisableSlotResponse> {
        const response = await this.disableSlotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enable the agent.
     */
    async enableAgentRaw(requestParameters: EnableAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1EnableAgentResponse>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling enableAgent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/agents/{agentId}/enable`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EnableAgentResponseFromJSON(jsonValue));
    }

    /**
     * Enable the agent.
     */
    async enableAgent(requestParameters: EnableAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1EnableAgentResponse> {
        const response = await this.enableAgentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enable the slot.
     */
    async enableSlotRaw(requestParameters: EnableSlotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1EnableSlotResponse>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling enableSlot.');
        }

        if (requestParameters.slotId === null || requestParameters.slotId === undefined) {
            throw new runtime.RequiredError('slotId','Required parameter requestParameters.slotId was null or undefined when calling enableSlot.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/agents/{agentId}/slots/{slotId}/enable`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))).replace(`{${"slotId"}}`, encodeURIComponent(String(requestParameters.slotId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EnableSlotResponseFromJSON(jsonValue));
    }

    /**
     * Enable the slot.
     */
    async enableSlot(requestParameters: EnableSlotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1EnableSlotResponse> {
        const response = await this.enableSlotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the requested agent.
     */
    async getAgentRaw(requestParameters: GetAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetAgentResponse>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling getAgent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/agents/{agentId}`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetAgentResponseFromJSON(jsonValue));
    }

    /**
     * Get the requested agent.
     */
    async getAgent(requestParameters: GetAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetAgentResponse> {
        const response = await this.getAgentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a set of agents from the cluster.
     */
    async getAgentsRaw(requestParameters: GetAgentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetAgentsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.label !== undefined) {
            queryParameters['label'] = requestParameters.label;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/agents`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetAgentsResponseFromJSON(jsonValue));
    }

    /**
     * Get a set of agents from the cluster.
     */
    async getAgents(requestParameters: GetAgentsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetAgentsResponse> {
        const response = await this.getAgentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get an aggregated view of resource allocation during the given time period (CSV).
     */
    async getAggregatedResourceAllocationCsvRaw(requestParameters: GetAggregatedResourceAllocationCsvRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.startDate === null || requestParameters.startDate === undefined) {
            throw new runtime.RequiredError('startDate','Required parameter requestParameters.startDate was null or undefined when calling getAggregatedResourceAllocationCsv.');
        }

        if (requestParameters.endDate === null || requestParameters.endDate === undefined) {
            throw new runtime.RequiredError('endDate','Required parameter requestParameters.endDate was null or undefined when calling getAggregatedResourceAllocationCsv.');
        }

        if (requestParameters.period === null || requestParameters.period === undefined) {
            throw new runtime.RequiredError('period','Required parameter requestParameters.period was null or undefined when calling getAggregatedResourceAllocationCsv.');
        }

        const queryParameters: any = {};

        if (requestParameters.startDate !== undefined) {
            queryParameters['start_date'] = requestParameters.startDate;
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['end_date'] = requestParameters.endDate;
        }

        if (requestParameters.period !== undefined) {
            queryParameters['period'] = requestParameters.period;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/allocation/aggregated`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get an aggregated view of resource allocation during the given time period (CSV).
     */
    async getAggregatedResourceAllocationCsv(requestParameters: GetAggregatedResourceAllocationCsvRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getAggregatedResourceAllocationCsvRaw(requestParameters, initOverrides);
    }

    /**
     * Get master information.
     */
    async getMasterRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetMasterResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/master`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetMasterResponseFromJSON(jsonValue));
    }

    /**
     * Get master information.
     */
    async getMaster(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetMasterResponse> {
        const response = await this.getMasterRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get master config.
     */
    async getMasterConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetMasterConfigResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/master/config`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetMasterConfigResponseFromJSON(jsonValue));
    }

    /**
     * Get master config.
     */
    async getMasterConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetMasterConfigResponse> {
        const response = await this.getMasterConfigRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a detailed view of resource allocation during the given time period (CSV).
     */
    async getRawResourceAllocationCsvRaw(requestParameters: GetRawResourceAllocationCsvRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.timestampAfter === null || requestParameters.timestampAfter === undefined) {
            throw new runtime.RequiredError('timestampAfter','Required parameter requestParameters.timestampAfter was null or undefined when calling getRawResourceAllocationCsv.');
        }

        if (requestParameters.timestampBefore === null || requestParameters.timestampBefore === undefined) {
            throw new runtime.RequiredError('timestampBefore','Required parameter requestParameters.timestampBefore was null or undefined when calling getRawResourceAllocationCsv.');
        }

        const queryParameters: any = {};

        if (requestParameters.timestampAfter !== undefined) {
            queryParameters['timestamp_after'] = requestParameters.timestampAfter;
        }

        if (requestParameters.timestampBefore !== undefined) {
            queryParameters['timestamp_before'] = requestParameters.timestampBefore;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/allocation/raw`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get a detailed view of resource allocation during the given time period (CSV).
     */
    async getRawResourceAllocationCsv(requestParameters: GetRawResourceAllocationCsvRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getRawResourceAllocationCsvRaw(requestParameters, initOverrides);
    }

    /**
     * Get the requested slot for an agent.
     */
    async getSlotRaw(requestParameters: GetSlotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetSlotResponse>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling getSlot.');
        }

        if (requestParameters.slotId === null || requestParameters.slotId === undefined) {
            throw new runtime.RequiredError('slotId','Required parameter requestParameters.slotId was null or undefined when calling getSlot.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/agents/{agentId}/slots/{slotId}`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))).replace(`{${"slotId"}}`, encodeURIComponent(String(requestParameters.slotId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetSlotResponseFromJSON(jsonValue));
    }

    /**
     * Get the requested slot for an agent.
     */
    async getSlot(requestParameters: GetSlotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetSlotResponse> {
        const response = await this.getSlotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all the slots for an agent.
     */
    async getSlotsRaw(requestParameters: GetSlotsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetSlotsResponse>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling getSlots.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/agents/{agentId}/slots`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetSlotsResponseFromJSON(jsonValue));
    }

    /**
     * Get all the slots for an agent.
     */
    async getSlots(requestParameters: GetSlotsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetSlotsResponse> {
        const response = await this.getSlotsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stream master logs.
     */
    async masterLogsRaw(requestParameters: MasterLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1MasterLogsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.follow !== undefined) {
            queryParameters['follow'] = requestParameters.follow;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/master/logs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1MasterLogsResponseFromJSON(jsonValue));
    }

    /**
     * Stream master logs.
     */
    async masterLogs(requestParameters: MasterLogsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1MasterLogsResponse> {
        const response = await this.masterLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get an aggregated view of resource allocation during the given time period.
     */
    async resourceAllocationAggregatedRaw(requestParameters: ResourceAllocationAggregatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ResourceAllocationAggregatedResponse>> {
        const queryParameters: any = {};

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = requestParameters.startDate;
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = requestParameters.endDate;
        }

        if (requestParameters.period !== undefined) {
            queryParameters['period'] = requestParameters.period;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/resources/allocation/aggregated`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceAllocationAggregatedResponseFromJSON(jsonValue));
    }

    /**
     * Get an aggregated view of resource allocation during the given time period.
     */
    async resourceAllocationAggregated(requestParameters: ResourceAllocationAggregatedRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ResourceAllocationAggregatedResponse> {
        const response = await this.resourceAllocationAggregatedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a detailed view of resource allocation during the given time period.
     */
    async resourceAllocationRawRaw(requestParameters: ResourceAllocationRawRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ResourceAllocationRawResponse>> {
        const queryParameters: any = {};

        if (requestParameters.timestampAfter !== undefined) {
            queryParameters['timestampAfter'] = (requestParameters.timestampAfter as any).toISOString();
        }

        if (requestParameters.timestampBefore !== undefined) {
            queryParameters['timestampBefore'] = (requestParameters.timestampBefore as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/resources/allocation/raw`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceAllocationRawResponseFromJSON(jsonValue));
    }

    /**
     * Get a detailed view of resource allocation during the given time period.
     */
    async resourceAllocationRaw(requestParameters: ResourceAllocationRawRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ResourceAllocationRawResponse> {
        const response = await this.resourceAllocationRawRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
  * @export
  * @enum {string}
  */
export enum GetAgentsSortByEnum {
    Unspecified = 'SORT_BY_UNSPECIFIED',
    Id = 'SORT_BY_ID',
    Time = 'SORT_BY_TIME'
}
/**
  * @export
  * @enum {string}
  */
export enum GetAgentsOrderByEnum {
    Unspecified = 'ORDER_BY_UNSPECIFIED',
    Asc = 'ORDER_BY_ASC',
    Desc = 'ORDER_BY_DESC'
}
/**
  * @export
  * @enum {string}
  */
export enum ResourceAllocationAggregatedPeriodEnum {
    Unspecified = 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED',
    Daily = 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY',
    Monthly = 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY'
}
