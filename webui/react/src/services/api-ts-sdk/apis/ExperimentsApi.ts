/* tslint:disable */
/* eslint-disable */
/**
 * Determined API (Beta)
 * Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.  You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.
 *
 * The version of the OpenAPI document: 0.1
 * Contact: community@determined.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  RuntimeError,
  StreamResultOfV1TrialLogsFieldsResponse,
  StreamResultOfV1TrialLogsResponse,
  V1CompareTrialsResponse,
  V1GetExperimentCheckpointsResponse,
  V1GetExperimentLabelsResponse,
  V1GetExperimentResponse,
  V1GetExperimentTrialsResponse,
  V1GetExperimentValidationHistoryResponse,
  V1GetExperimentsResponse,
  V1GetModelDefFileRequest,
  V1GetModelDefFileResponse,
  V1GetModelDefResponse,
  V1GetModelDefTreeResponse,
  V1GetSearcherEventsResponse,
  V1GetTrialCheckpointsResponse,
  V1GetTrialResponse,
  V1MoveExperimentRequest,
  V1PatchExperiment,
  V1PatchExperimentResponse,
  V1PostSearcherOperationsRequest,
  V1PreviewHPSearchRequest,
  V1PreviewHPSearchResponse,
  V1SummarizeTrialResponse,
} from '../models';
import {
    RuntimeErrorFromJSON,
    RuntimeErrorToJSON,
    StreamResultOfV1TrialLogsFieldsResponseFromJSON,
    StreamResultOfV1TrialLogsFieldsResponseToJSON,
    StreamResultOfV1TrialLogsResponseFromJSON,
    StreamResultOfV1TrialLogsResponseToJSON,
    V1CompareTrialsResponseFromJSON,
    V1CompareTrialsResponseToJSON,
    V1GetExperimentCheckpointsResponseFromJSON,
    V1GetExperimentCheckpointsResponseToJSON,
    V1GetExperimentLabelsResponseFromJSON,
    V1GetExperimentLabelsResponseToJSON,
    V1GetExperimentResponseFromJSON,
    V1GetExperimentResponseToJSON,
    V1GetExperimentTrialsResponseFromJSON,
    V1GetExperimentTrialsResponseToJSON,
    V1GetExperimentValidationHistoryResponseFromJSON,
    V1GetExperimentValidationHistoryResponseToJSON,
    V1GetExperimentsResponseFromJSON,
    V1GetExperimentsResponseToJSON,
    V1GetModelDefFileRequestFromJSON,
    V1GetModelDefFileRequestToJSON,
    V1GetModelDefFileResponseFromJSON,
    V1GetModelDefFileResponseToJSON,
    V1GetModelDefResponseFromJSON,
    V1GetModelDefResponseToJSON,
    V1GetModelDefTreeResponseFromJSON,
    V1GetModelDefTreeResponseToJSON,
    V1GetSearcherEventsResponseFromJSON,
    V1GetSearcherEventsResponseToJSON,
    V1GetTrialCheckpointsResponseFromJSON,
    V1GetTrialCheckpointsResponseToJSON,
    V1GetTrialResponseFromJSON,
    V1GetTrialResponseToJSON,
    V1MoveExperimentRequestFromJSON,
    V1MoveExperimentRequestToJSON,
    V1PatchExperimentFromJSON,
    V1PatchExperimentToJSON,
    V1PatchExperimentResponseFromJSON,
    V1PatchExperimentResponseToJSON,
    V1PostSearcherOperationsRequestFromJSON,
    V1PostSearcherOperationsRequestToJSON,
    V1PreviewHPSearchRequestFromJSON,
    V1PreviewHPSearchRequestToJSON,
    V1PreviewHPSearchResponseFromJSON,
    V1PreviewHPSearchResponseToJSON,
    V1SummarizeTrialResponseFromJSON,
    V1SummarizeTrialResponseToJSON,
} from '../models';

export interface ActivateExperimentRequest {
    id: number;
}

export interface ArchiveExperimentRequest {
    id: number;
}

export interface CancelExperimentRequest {
    id: number;
}

export interface CompareTrialsRequest {
    trialIds?: Array<number>;
    maxDatapoints?: number;
    metricNames?: Array<string>;
    startBatches?: number;
    endBatches?: number;
    metricType?: CompareTrialsMetricTypeEnum;
    scale?: CompareTrialsScaleEnum;
}

export interface DeleteExperimentRequest {
    experimentId: number;
}

export interface GetExperimentRequest {
    experimentId: number;
}

export interface GetExperimentCheckpointsRequest {
    id: number;
    sortBy?: GetExperimentCheckpointsSortByEnum;
    orderBy?: GetExperimentCheckpointsOrderByEnum;
    offset?: number;
    limit?: number;
    states?: Array<GetExperimentCheckpointsStatesEnum>;
}

export interface GetExperimentLabelsRequest {
    projectId?: number;
}

export interface GetExperimentModelFileRequest {
    experimentId: number;
    path: string;
}

export interface GetExperimentTrialsRequest {
    experimentId: number;
    sortBy?: GetExperimentTrialsSortByEnum;
    orderBy?: GetExperimentTrialsOrderByEnum;
    offset?: number;
    limit?: number;
    states?: Array<GetExperimentTrialsStatesEnum>;
}

export interface GetExperimentValidationHistoryRequest {
    experimentId: number;
}

export interface GetExperimentsRequest {
    sortBy?: GetExperimentsSortByEnum;
    orderBy?: GetExperimentsOrderByEnum;
    offset?: number;
    limit?: number;
    description?: string;
    name?: string;
    labels?: Array<string>;
    archived?: boolean;
    states?: Array<GetExperimentsStatesEnum>;
    users?: Array<string>;
    userIds?: Array<number>;
    projectId?: number;
    experimentIdFilterLt?: number;
    experimentIdFilterLte?: number;
    experimentIdFilterGt?: number;
    experimentIdFilterGte?: number;
    experimentIdFilterIncl?: Array<number>;
    experimentIdFilterNotIn?: Array<number>;
}

export interface GetModelDefRequest {
    experimentId: number;
}

export interface GetModelDefFileRequest {
    experimentId: number;
    body: V1GetModelDefFileRequest;
}

export interface GetModelDefTreeRequest {
    experimentId: number;
}

export interface GetSearcherEventsRequest {
    experimentId: number;
}

export interface GetTrialRequest {
    trialId: number;
}

export interface GetTrialCheckpointsRequest {
    id: number;
    sortBy?: GetTrialCheckpointsSortByEnum;
    orderBy?: GetTrialCheckpointsOrderByEnum;
    offset?: number;
    limit?: number;
    states?: Array<GetTrialCheckpointsStatesEnum>;
}

export interface KillExperimentRequest {
    id: number;
}

export interface KillTrialRequest {
    id: number;
}

export interface MoveExperimentRequest {
    experimentId: number;
    body: V1MoveExperimentRequest;
}

export interface PatchExperimentRequest {
    experimentId: number;
    body: V1PatchExperiment;
}

export interface PauseExperimentRequest {
    id: number;
}

export interface PostSearcherOperationsRequest {
    experimentId: number;
    body: V1PostSearcherOperationsRequest;
}

export interface PreviewHPSearchRequest {
    body: V1PreviewHPSearchRequest;
}

export interface SummarizeTrialRequest {
    trialId: number;
    maxDatapoints?: number;
    metricNames?: Array<string>;
    startBatches?: number;
    endBatches?: number;
    metricType?: SummarizeTrialMetricTypeEnum;
    scale?: SummarizeTrialScaleEnum;
}

export interface TrialLogsRequest {
    trialId: number;
    limit?: number;
    follow?: boolean;
    agentIds?: Array<string>;
    containerIds?: Array<string>;
    rankIds?: Array<number>;
    levels?: Array<TrialLogsLevelsEnum>;
    stdtypes?: Array<string>;
    sources?: Array<string>;
    timestampBefore?: Date;
    timestampAfter?: Date;
    orderBy?: TrialLogsOrderByEnum;
    searchText?: string;
}

export interface TrialLogsFieldsRequest {
    trialId: number;
    follow?: boolean;
}

export interface UnarchiveExperimentRequest {
    id: number;
}

/**
 * 
 */
export class ExperimentsApi extends runtime.BaseAPI {

    /**
     * Activate an experiment.
     */
    async activateExperimentRaw(requestParameters: ActivateExperimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling activateExperiment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{id}/activate`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Activate an experiment.
     */
    async activateExperiment(id: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.activateExperimentRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Archive an experiment.
     */
    async archiveExperimentRaw(requestParameters: ArchiveExperimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling archiveExperiment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{id}/archive`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Archive an experiment.
     */
    async archiveExperiment(id: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.archiveExperimentRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Cancel an experiment.
     */
    async cancelExperimentRaw(requestParameters: CancelExperimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling cancelExperiment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{id}/cancel`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Cancel an experiment.
     */
    async cancelExperiment(id: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.cancelExperimentRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Return downsampled metrics from multiple trials to compare them side-by-side.
     */
    async compareTrialsRaw(requestParameters: CompareTrialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1CompareTrialsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.trialIds) {
            queryParameters['trialIds'] = requestParameters.trialIds;
        }

        if (requestParameters.maxDatapoints !== undefined) {
            queryParameters['maxDatapoints'] = requestParameters.maxDatapoints;
        }

        if (requestParameters.metricNames) {
            queryParameters['metricNames'] = requestParameters.metricNames;
        }

        if (requestParameters.startBatches !== undefined) {
            queryParameters['startBatches'] = requestParameters.startBatches;
        }

        if (requestParameters.endBatches !== undefined) {
            queryParameters['endBatches'] = requestParameters.endBatches;
        }

        if (requestParameters.metricType !== undefined) {
            queryParameters['metricType'] = requestParameters.metricType;
        }

        if (requestParameters.scale !== undefined) {
            queryParameters['scale'] = requestParameters.scale;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/compare`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1CompareTrialsResponseFromJSON(jsonValue));
    }

    /**
     * Return downsampled metrics from multiple trials to compare them side-by-side.
     */
    async compareTrials(trialIds?: Array<number>, maxDatapoints?: number, metricNames?: Array<string>, startBatches?: number, endBatches?: number, metricType?: CompareTrialsMetricTypeEnum, scale?: CompareTrialsScaleEnum, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1CompareTrialsResponse> {
        const response = await this.compareTrialsRaw({ trialIds: trialIds, maxDatapoints: maxDatapoints, metricNames: metricNames, startBatches: startBatches, endBatches: endBatches, metricType: metricType, scale: scale }, initOverrides);
        return await response.value();
    }

    /**
     * Delete the requested experiment.
     */
    async deleteExperimentRaw(requestParameters: DeleteExperimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling deleteExperiment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete the requested experiment.
     */
    async deleteExperiment(experimentId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteExperimentRaw({ experimentId: experimentId }, initOverrides);
        return await response.value();
    }

    /**
     * Get the requested experiment.
     */
    async getExperimentRaw(requestParameters: GetExperimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetExperimentResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling getExperiment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetExperimentResponseFromJSON(jsonValue));
    }

    /**
     * Get the requested experiment.
     */
    async getExperiment(experimentId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetExperimentResponse> {
        const response = await this.getExperimentRaw({ experimentId: experimentId }, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of checkpoints for an experiment.
     */
    async getExperimentCheckpointsRaw(requestParameters: GetExperimentCheckpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetExperimentCheckpointsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getExperimentCheckpoints.');
        }

        const queryParameters: any = {};

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.states) {
            queryParameters['states'] = requestParameters.states;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{id}/checkpoints`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetExperimentCheckpointsResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of checkpoints for an experiment.
     */
    async getExperimentCheckpoints(id: number, sortBy?: GetExperimentCheckpointsSortByEnum, orderBy?: GetExperimentCheckpointsOrderByEnum, offset?: number, limit?: number, states?: Array<GetExperimentCheckpointsStatesEnum>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetExperimentCheckpointsResponse> {
        const response = await this.getExperimentCheckpointsRaw({ id: id, sortBy: sortBy, orderBy: orderBy, offset: offset, limit: limit, states: states }, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of unique experiment labels (sorted by popularity).
     */
    async getExperimentLabelsRaw(requestParameters: GetExperimentLabelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetExperimentLabelsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.projectId !== undefined) {
            queryParameters['projectId'] = requestParameters.projectId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiment/labels`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetExperimentLabelsResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of unique experiment labels (sorted by popularity).
     */
    async getExperimentLabels(projectId?: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetExperimentLabelsResponse> {
        const response = await this.getExperimentLabelsRaw({ projectId: projectId }, initOverrides);
        return await response.value();
    }

    /**
     * Get individual file from modal definitions for download.
     */
    async getExperimentModelFileRaw(requestParameters: GetExperimentModelFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling getExperimentModelFile.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling getExperimentModelFile.');
        }

        const queryParameters: any = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/experiments/{experiment_id}/file/download`.replace(`{${"experiment_id"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get individual file from modal definitions for download.
     */
    async getExperimentModelFile(experimentId: number, path: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getExperimentModelFileRaw({ experimentId: experimentId, path: path }, initOverrides);
    }

    /**
     * Get the list of trials for an experiment.
     */
    async getExperimentTrialsRaw(requestParameters: GetExperimentTrialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetExperimentTrialsResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling getExperimentTrials.');
        }

        const queryParameters: any = {};

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.states) {
            queryParameters['states'] = requestParameters.states;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/trials`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetExperimentTrialsResponseFromJSON(jsonValue));
    }

    /**
     * Get the list of trials for an experiment.
     */
    async getExperimentTrials(experimentId: number, sortBy?: GetExperimentTrialsSortByEnum, orderBy?: GetExperimentTrialsOrderByEnum, offset?: number, limit?: number, states?: Array<GetExperimentTrialsStatesEnum>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetExperimentTrialsResponse> {
        const response = await this.getExperimentTrialsRaw({ experimentId: experimentId, sortBy: sortBy, orderBy: orderBy, offset: offset, limit: limit, states: states }, initOverrides);
        return await response.value();
    }

    /**
     * Get the validation history for an experiment.
     */
    async getExperimentValidationHistoryRaw(requestParameters: GetExperimentValidationHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetExperimentValidationHistoryResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling getExperimentValidationHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/validation-history`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetExperimentValidationHistoryResponseFromJSON(jsonValue));
    }

    /**
     * Get the validation history for an experiment.
     */
    async getExperimentValidationHistory(experimentId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetExperimentValidationHistoryResponse> {
        const response = await this.getExperimentValidationHistoryRaw({ experimentId: experimentId }, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of experiments.
     */
    async getExperimentsRaw(requestParameters: GetExperimentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetExperimentsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.description !== undefined) {
            queryParameters['description'] = requestParameters.description;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.labels) {
            queryParameters['labels'] = requestParameters.labels;
        }

        if (requestParameters.archived !== undefined) {
            queryParameters['archived'] = requestParameters.archived;
        }

        if (requestParameters.states) {
            queryParameters['states'] = requestParameters.states;
        }

        if (requestParameters.users) {
            queryParameters['users'] = requestParameters.users;
        }

        if (requestParameters.userIds) {
            queryParameters['userIds'] = requestParameters.userIds;
        }

        if (requestParameters.projectId !== undefined) {
            queryParameters['projectId'] = requestParameters.projectId;
        }

        if (requestParameters.experimentIdFilterLt !== undefined) {
            queryParameters['experimentIdFilter.lt'] = requestParameters.experimentIdFilterLt;
        }

        if (requestParameters.experimentIdFilterLte !== undefined) {
            queryParameters['experimentIdFilter.lte'] = requestParameters.experimentIdFilterLte;
        }

        if (requestParameters.experimentIdFilterGt !== undefined) {
            queryParameters['experimentIdFilter.gt'] = requestParameters.experimentIdFilterGt;
        }

        if (requestParameters.experimentIdFilterGte !== undefined) {
            queryParameters['experimentIdFilter.gte'] = requestParameters.experimentIdFilterGte;
        }

        if (requestParameters.experimentIdFilterIncl) {
            queryParameters['experimentIdFilter.incl'] = requestParameters.experimentIdFilterIncl;
        }

        if (requestParameters.experimentIdFilterNotIn) {
            queryParameters['experimentIdFilter.notIn'] = requestParameters.experimentIdFilterNotIn;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetExperimentsResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of experiments.
     */
    async getExperiments(sortBy?: GetExperimentsSortByEnum, orderBy?: GetExperimentsOrderByEnum, offset?: number, limit?: number, description?: string, name?: string, labels?: Array<string>, archived?: boolean, states?: Array<GetExperimentsStatesEnum>, users?: Array<string>, userIds?: Array<number>, projectId?: number, experimentIdFilterLt?: number, experimentIdFilterLte?: number, experimentIdFilterGt?: number, experimentIdFilterGte?: number, experimentIdFilterIncl?: Array<number>, experimentIdFilterNotIn?: Array<number>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetExperimentsResponse> {
        const response = await this.getExperimentsRaw({ sortBy: sortBy, orderBy: orderBy, offset: offset, limit: limit, description: description, name: name, labels: labels, archived: archived, states: states, users: users, userIds: userIds, projectId: projectId, experimentIdFilterLt: experimentIdFilterLt, experimentIdFilterLte: experimentIdFilterLte, experimentIdFilterGt: experimentIdFilterGt, experimentIdFilterGte: experimentIdFilterGte, experimentIdFilterIncl: experimentIdFilterIncl, experimentIdFilterNotIn: experimentIdFilterNotIn }, initOverrides);
        return await response.value();
    }

    /**
     * Get the model definition of an experiment.
     */
    async getModelDefRaw(requestParameters: GetModelDefRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetModelDefResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling getModelDef.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/model_def`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetModelDefResponseFromJSON(jsonValue));
    }

    /**
     * Get the model definition of an experiment.
     */
    async getModelDef(experimentId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetModelDefResponse> {
        const response = await this.getModelDefRaw({ experimentId: experimentId }, initOverrides);
        return await response.value();
    }

    /**
     * Get one file content of model definition of an experiment.
     */
    async getModelDefFileRaw(requestParameters: GetModelDefFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetModelDefFileResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling getModelDefFile.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling getModelDefFile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/file`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1GetModelDefFileRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetModelDefFileResponseFromJSON(jsonValue));
    }

    /**
     * Get one file content of model definition of an experiment.
     */
    async getModelDefFile(experimentId: number, body: V1GetModelDefFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetModelDefFileResponse> {
        const response = await this.getModelDefFileRaw({ experimentId: experimentId, body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Get the model definition file tree of an experiment.
     */
    async getModelDefTreeRaw(requestParameters: GetModelDefTreeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetModelDefTreeResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling getModelDefTree.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/file_tree`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetModelDefTreeResponseFromJSON(jsonValue));
    }

    /**
     * Get the model definition file tree of an experiment.
     */
    async getModelDefTree(experimentId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetModelDefTreeResponse> {
        const response = await this.getModelDefTreeRaw({ experimentId: experimentId }, initOverrides);
        return await response.value();
    }

    /**
     * Get the list of custom searcher events with long polling.
     */
    async getSearcherEventsRaw(requestParameters: GetSearcherEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetSearcherEventsResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling getSearcherEvents.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/searcher_events`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetSearcherEventsResponseFromJSON(jsonValue));
    }

    /**
     * Get the list of custom searcher events with long polling.
     */
    async getSearcherEvents(experimentId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetSearcherEventsResponse> {
        const response = await this.getSearcherEventsRaw({ experimentId: experimentId }, initOverrides);
        return await response.value();
    }

    /**
     * Get a single trial.
     */
    async getTrialRaw(requestParameters: GetTrialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetTrialResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling getTrial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetTrialResponseFromJSON(jsonValue));
    }

    /**
     * Get a single trial.
     */
    async getTrial(trialId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetTrialResponse> {
        const response = await this.getTrialRaw({ trialId: trialId }, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of checkpoints for a trial.
     */
    async getTrialCheckpointsRaw(requestParameters: GetTrialCheckpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetTrialCheckpointsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTrialCheckpoints.');
        }

        const queryParameters: any = {};

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.states) {
            queryParameters['states'] = requestParameters.states;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{id}/checkpoints`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetTrialCheckpointsResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of checkpoints for a trial.
     */
    async getTrialCheckpoints(id: number, sortBy?: GetTrialCheckpointsSortByEnum, orderBy?: GetTrialCheckpointsOrderByEnum, offset?: number, limit?: number, states?: Array<GetTrialCheckpointsStatesEnum>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetTrialCheckpointsResponse> {
        const response = await this.getTrialCheckpointsRaw({ id: id, sortBy: sortBy, orderBy: orderBy, offset: offset, limit: limit, states: states }, initOverrides);
        return await response.value();
    }

    /**
     * Kill an experiment.
     */
    async killExperimentRaw(requestParameters: KillExperimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling killExperiment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{id}/kill`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Kill an experiment.
     */
    async killExperiment(id: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.killExperimentRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Kill a trial.
     */
    async killTrialRaw(requestParameters: KillTrialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling killTrial.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{id}/kill`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Kill a trial.
     */
    async killTrial(id: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.killTrialRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Move an experiment into a project.
     */
    async moveExperimentRaw(requestParameters: MoveExperimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling moveExperiment.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling moveExperiment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/move`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1MoveExperimentRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Move an experiment into a project.
     */
    async moveExperiment(experimentId: number, body: V1MoveExperimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.moveExperimentRaw({ experimentId: experimentId, body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Patch an experiment\'s fields.
     */
    async patchExperimentRaw(requestParameters: PatchExperimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PatchExperimentResponse>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling patchExperiment.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchExperiment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experiment.id}`.replace(`{${"experiment.id"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: V1PatchExperimentToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PatchExperimentResponseFromJSON(jsonValue));
    }

    /**
     * Patch an experiment\'s fields.
     */
    async patchExperiment(experimentId: number, body: V1PatchExperiment, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PatchExperimentResponse> {
        const response = await this.patchExperimentRaw({ experimentId: experimentId, body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Pause an experiment.
     */
    async pauseExperimentRaw(requestParameters: PauseExperimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling pauseExperiment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{id}/pause`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Pause an experiment.
     */
    async pauseExperiment(id: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.pauseExperimentRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Submit operations to a custom searcher.
     */
    async postSearcherOperationsRaw(requestParameters: PostSearcherOperationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.experimentId === null || requestParameters.experimentId === undefined) {
            throw new runtime.RequiredError('experimentId','Required parameter requestParameters.experimentId was null or undefined when calling postSearcherOperations.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling postSearcherOperations.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{experimentId}/searcher_operations`.replace(`{${"experimentId"}}`, encodeURIComponent(String(requestParameters.experimentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PostSearcherOperationsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Submit operations to a custom searcher.
     */
    async postSearcherOperations(experimentId: number, body: V1PostSearcherOperationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.postSearcherOperationsRaw({ experimentId: experimentId, body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Preview hyperparameter search.
     */
    async previewHPSearchRaw(requestParameters: PreviewHPSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PreviewHPSearchResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling previewHPSearch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/preview-hp-search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PreviewHPSearchRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PreviewHPSearchResponseFromJSON(jsonValue));
    }

    /**
     * Preview hyperparameter search.
     */
    async previewHPSearch(body: V1PreviewHPSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PreviewHPSearchResponse> {
        const response = await this.previewHPSearchRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Downsample metrics collected during a trial.
     */
    async summarizeTrialRaw(requestParameters: SummarizeTrialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1SummarizeTrialResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling summarizeTrial.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxDatapoints !== undefined) {
            queryParameters['maxDatapoints'] = requestParameters.maxDatapoints;
        }

        if (requestParameters.metricNames) {
            queryParameters['metricNames'] = requestParameters.metricNames;
        }

        if (requestParameters.startBatches !== undefined) {
            queryParameters['startBatches'] = requestParameters.startBatches;
        }

        if (requestParameters.endBatches !== undefined) {
            queryParameters['endBatches'] = requestParameters.endBatches;
        }

        if (requestParameters.metricType !== undefined) {
            queryParameters['metricType'] = requestParameters.metricType;
        }

        if (requestParameters.scale !== undefined) {
            queryParameters['scale'] = requestParameters.scale;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/summarize`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SummarizeTrialResponseFromJSON(jsonValue));
    }

    /**
     * Downsample metrics collected during a trial.
     */
    async summarizeTrial(trialId: number, maxDatapoints?: number, metricNames?: Array<string>, startBatches?: number, endBatches?: number, metricType?: SummarizeTrialMetricTypeEnum, scale?: SummarizeTrialScaleEnum, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1SummarizeTrialResponse> {
        const response = await this.summarizeTrialRaw({ trialId: trialId, maxDatapoints: maxDatapoints, metricNames: metricNames, startBatches: startBatches, endBatches: endBatches, metricType: metricType, scale: scale }, initOverrides);
        return await response.value();
    }

    /**
     * Stream trial logs.
     */
    async trialLogsRaw(requestParameters: TrialLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1TrialLogsResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling trialLogs.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.follow !== undefined) {
            queryParameters['follow'] = requestParameters.follow;
        }

        if (requestParameters.agentIds) {
            queryParameters['agentIds'] = requestParameters.agentIds;
        }

        if (requestParameters.containerIds) {
            queryParameters['containerIds'] = requestParameters.containerIds;
        }

        if (requestParameters.rankIds) {
            queryParameters['rankIds'] = requestParameters.rankIds;
        }

        if (requestParameters.levels) {
            queryParameters['levels'] = requestParameters.levels;
        }

        if (requestParameters.stdtypes) {
            queryParameters['stdtypes'] = requestParameters.stdtypes;
        }

        if (requestParameters.sources) {
            queryParameters['sources'] = requestParameters.sources;
        }

        if (requestParameters.timestampBefore !== undefined) {
            queryParameters['timestampBefore'] = (requestParameters.timestampBefore as any).toISOString();
        }

        if (requestParameters.timestampAfter !== undefined) {
            queryParameters['timestampAfter'] = (requestParameters.timestampAfter as any).toISOString();
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.searchText !== undefined) {
            queryParameters['searchText'] = requestParameters.searchText;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/logs`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1TrialLogsResponseFromJSON(jsonValue));
    }

    /**
     * Stream trial logs.
     */
    async trialLogs(trialId: number, limit?: number, follow?: boolean, agentIds?: Array<string>, containerIds?: Array<string>, rankIds?: Array<number>, levels?: Array<TrialLogsLevelsEnum>, stdtypes?: Array<string>, sources?: Array<string>, timestampBefore?: Date, timestampAfter?: Date, orderBy?: TrialLogsOrderByEnum, searchText?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1TrialLogsResponse> {
        const response = await this.trialLogsRaw({ trialId: trialId, limit: limit, follow: follow, agentIds: agentIds, containerIds: containerIds, rankIds: rankIds, levels: levels, stdtypes: stdtypes, sources: sources, timestampBefore: timestampBefore, timestampAfter: timestampAfter, orderBy: orderBy, searchText: searchText }, initOverrides);
        return await response.value();
    }

    /**
     * Stream trial log fields.
     */
    async trialLogsFieldsRaw(requestParameters: TrialLogsFieldsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamResultOfV1TrialLogsFieldsResponse>> {
        if (requestParameters.trialId === null || requestParameters.trialId === undefined) {
            throw new runtime.RequiredError('trialId','Required parameter requestParameters.trialId was null or undefined when calling trialLogsFields.');
        }

        const queryParameters: any = {};

        if (requestParameters.follow !== undefined) {
            queryParameters['follow'] = requestParameters.follow;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trials/{trialId}/logs/fields`.replace(`{${"trialId"}}`, encodeURIComponent(String(requestParameters.trialId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfV1TrialLogsFieldsResponseFromJSON(jsonValue));
    }

    /**
     * Stream trial log fields.
     */
    async trialLogsFields(trialId: number, follow?: boolean, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamResultOfV1TrialLogsFieldsResponse> {
        const response = await this.trialLogsFieldsRaw({ trialId: trialId, follow: follow }, initOverrides);
        return await response.value();
    }

    /**
     * Unarchive an experiment.
     */
    async unarchiveExperimentRaw(requestParameters: UnarchiveExperimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling unarchiveExperiment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/experiments/{id}/unarchive`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Unarchive an experiment.
     */
    async unarchiveExperiment(id: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.unarchiveExperimentRaw({ id: id }, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CompareTrialsMetricTypeEnum = {
    UNSPECIFIED: 'METRIC_TYPE_UNSPECIFIED',
    TRAINING: 'METRIC_TYPE_TRAINING',
    VALIDATION: 'METRIC_TYPE_VALIDATION'
} as const;
export type CompareTrialsMetricTypeEnum = typeof CompareTrialsMetricTypeEnum[keyof typeof CompareTrialsMetricTypeEnum];
/**
 * @export
 */
export const CompareTrialsScaleEnum = {
    UNSPECIFIED: 'SCALE_UNSPECIFIED',
    LINEAR: 'SCALE_LINEAR',
    LOG: 'SCALE_LOG'
} as const;
export type CompareTrialsScaleEnum = typeof CompareTrialsScaleEnum[keyof typeof CompareTrialsScaleEnum];
/**
 * @export
 */
export const GetExperimentCheckpointsSortByEnum = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    UUID: 'SORT_BY_UUID',
    TRIAL_ID: 'SORT_BY_TRIAL_ID',
    BATCH_NUMBER: 'SORT_BY_BATCH_NUMBER',
    END_TIME: 'SORT_BY_END_TIME',
    STATE: 'SORT_BY_STATE',
    SEARCHER_METRIC: 'SORT_BY_SEARCHER_METRIC'
} as const;
export type GetExperimentCheckpointsSortByEnum = typeof GetExperimentCheckpointsSortByEnum[keyof typeof GetExperimentCheckpointsSortByEnum];
/**
 * @export
 */
export const GetExperimentCheckpointsOrderByEnum = {
    UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
    ASC: 'ORDER_BY_ASC',
    DESC: 'ORDER_BY_DESC'
} as const;
export type GetExperimentCheckpointsOrderByEnum = typeof GetExperimentCheckpointsOrderByEnum[keyof typeof GetExperimentCheckpointsOrderByEnum];
/**
 * @export
 */
export const GetExperimentCheckpointsStatesEnum = {
    UNSPECIFIED: 'STATE_UNSPECIFIED',
    ACTIVE: 'STATE_ACTIVE',
    COMPLETED: 'STATE_COMPLETED',
    ERROR: 'STATE_ERROR',
    DELETED: 'STATE_DELETED'
} as const;
export type GetExperimentCheckpointsStatesEnum = typeof GetExperimentCheckpointsStatesEnum[keyof typeof GetExperimentCheckpointsStatesEnum];
/**
 * @export
 */
export const GetExperimentTrialsSortByEnum = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    ID: 'SORT_BY_ID',
    START_TIME: 'SORT_BY_START_TIME',
    END_TIME: 'SORT_BY_END_TIME',
    STATE: 'SORT_BY_STATE',
    BEST_VALIDATION_METRIC: 'SORT_BY_BEST_VALIDATION_METRIC',
    LATEST_VALIDATION_METRIC: 'SORT_BY_LATEST_VALIDATION_METRIC',
    BATCHES_PROCESSED: 'SORT_BY_BATCHES_PROCESSED',
    DURATION: 'SORT_BY_DURATION',
    RESTARTS: 'SORT_BY_RESTARTS'
} as const;
export type GetExperimentTrialsSortByEnum = typeof GetExperimentTrialsSortByEnum[keyof typeof GetExperimentTrialsSortByEnum];
/**
 * @export
 */
export const GetExperimentTrialsOrderByEnum = {
    UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
    ASC: 'ORDER_BY_ASC',
    DESC: 'ORDER_BY_DESC'
} as const;
export type GetExperimentTrialsOrderByEnum = typeof GetExperimentTrialsOrderByEnum[keyof typeof GetExperimentTrialsOrderByEnum];
/**
 * @export
 */
export const GetExperimentTrialsStatesEnum = {
    UNSPECIFIED: 'STATE_UNSPECIFIED',
    ACTIVE: 'STATE_ACTIVE',
    PAUSED: 'STATE_PAUSED',
    STOPPING_COMPLETED: 'STATE_STOPPING_COMPLETED',
    STOPPING_CANCELED: 'STATE_STOPPING_CANCELED',
    STOPPING_ERROR: 'STATE_STOPPING_ERROR',
    COMPLETED: 'STATE_COMPLETED',
    CANCELED: 'STATE_CANCELED',
    ERROR: 'STATE_ERROR',
    DELETED: 'STATE_DELETED',
    DELETING: 'STATE_DELETING',
    DELETE_FAILED: 'STATE_DELETE_FAILED',
    STOPPING_KILLED: 'STATE_STOPPING_KILLED',
    QUEUED: 'STATE_QUEUED',
    PULLING: 'STATE_PULLING',
    STARTING: 'STATE_STARTING',
    RUNNING: 'STATE_RUNNING'
} as const;
export type GetExperimentTrialsStatesEnum = typeof GetExperimentTrialsStatesEnum[keyof typeof GetExperimentTrialsStatesEnum];
/**
 * @export
 */
export const GetExperimentsSortByEnum = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    ID: 'SORT_BY_ID',
    DESCRIPTION: 'SORT_BY_DESCRIPTION',
    START_TIME: 'SORT_BY_START_TIME',
    END_TIME: 'SORT_BY_END_TIME',
    STATE: 'SORT_BY_STATE',
    NUM_TRIALS: 'SORT_BY_NUM_TRIALS',
    PROGRESS: 'SORT_BY_PROGRESS',
    USER: 'SORT_BY_USER',
    NAME: 'SORT_BY_NAME',
    FORKED_FROM: 'SORT_BY_FORKED_FROM',
    RESOURCE_POOL: 'SORT_BY_RESOURCE_POOL',
    PROJECT_ID: 'SORT_BY_PROJECT_ID'
} as const;
export type GetExperimentsSortByEnum = typeof GetExperimentsSortByEnum[keyof typeof GetExperimentsSortByEnum];
/**
 * @export
 */
export const GetExperimentsOrderByEnum = {
    UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
    ASC: 'ORDER_BY_ASC',
    DESC: 'ORDER_BY_DESC'
} as const;
export type GetExperimentsOrderByEnum = typeof GetExperimentsOrderByEnum[keyof typeof GetExperimentsOrderByEnum];
/**
 * @export
 */
export const GetExperimentsStatesEnum = {
    UNSPECIFIED: 'STATE_UNSPECIFIED',
    ACTIVE: 'STATE_ACTIVE',
    PAUSED: 'STATE_PAUSED',
    STOPPING_COMPLETED: 'STATE_STOPPING_COMPLETED',
    STOPPING_CANCELED: 'STATE_STOPPING_CANCELED',
    STOPPING_ERROR: 'STATE_STOPPING_ERROR',
    COMPLETED: 'STATE_COMPLETED',
    CANCELED: 'STATE_CANCELED',
    ERROR: 'STATE_ERROR',
    DELETED: 'STATE_DELETED',
    DELETING: 'STATE_DELETING',
    DELETE_FAILED: 'STATE_DELETE_FAILED',
    STOPPING_KILLED: 'STATE_STOPPING_KILLED',
    QUEUED: 'STATE_QUEUED',
    PULLING: 'STATE_PULLING',
    STARTING: 'STATE_STARTING',
    RUNNING: 'STATE_RUNNING'
} as const;
export type GetExperimentsStatesEnum = typeof GetExperimentsStatesEnum[keyof typeof GetExperimentsStatesEnum];
/**
 * @export
 */
export const GetTrialCheckpointsSortByEnum = {
    UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
    UUID: 'SORT_BY_UUID',
    BATCH_NUMBER: 'SORT_BY_BATCH_NUMBER',
    END_TIME: 'SORT_BY_END_TIME',
    STATE: 'SORT_BY_STATE'
} as const;
export type GetTrialCheckpointsSortByEnum = typeof GetTrialCheckpointsSortByEnum[keyof typeof GetTrialCheckpointsSortByEnum];
/**
 * @export
 */
export const GetTrialCheckpointsOrderByEnum = {
    UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
    ASC: 'ORDER_BY_ASC',
    DESC: 'ORDER_BY_DESC'
} as const;
export type GetTrialCheckpointsOrderByEnum = typeof GetTrialCheckpointsOrderByEnum[keyof typeof GetTrialCheckpointsOrderByEnum];
/**
 * @export
 */
export const GetTrialCheckpointsStatesEnum = {
    UNSPECIFIED: 'STATE_UNSPECIFIED',
    ACTIVE: 'STATE_ACTIVE',
    COMPLETED: 'STATE_COMPLETED',
    ERROR: 'STATE_ERROR',
    DELETED: 'STATE_DELETED'
} as const;
export type GetTrialCheckpointsStatesEnum = typeof GetTrialCheckpointsStatesEnum[keyof typeof GetTrialCheckpointsStatesEnum];
/**
 * @export
 */
export const SummarizeTrialMetricTypeEnum = {
    UNSPECIFIED: 'METRIC_TYPE_UNSPECIFIED',
    TRAINING: 'METRIC_TYPE_TRAINING',
    VALIDATION: 'METRIC_TYPE_VALIDATION'
} as const;
export type SummarizeTrialMetricTypeEnum = typeof SummarizeTrialMetricTypeEnum[keyof typeof SummarizeTrialMetricTypeEnum];
/**
 * @export
 */
export const SummarizeTrialScaleEnum = {
    UNSPECIFIED: 'SCALE_UNSPECIFIED',
    LINEAR: 'SCALE_LINEAR',
    LOG: 'SCALE_LOG'
} as const;
export type SummarizeTrialScaleEnum = typeof SummarizeTrialScaleEnum[keyof typeof SummarizeTrialScaleEnum];
/**
 * @export
 */
export const TrialLogsLevelsEnum = {
    UNSPECIFIED: 'LOG_LEVEL_UNSPECIFIED',
    TRACE: 'LOG_LEVEL_TRACE',
    DEBUG: 'LOG_LEVEL_DEBUG',
    INFO: 'LOG_LEVEL_INFO',
    WARNING: 'LOG_LEVEL_WARNING',
    ERROR: 'LOG_LEVEL_ERROR',
    CRITICAL: 'LOG_LEVEL_CRITICAL'
} as const;
export type TrialLogsLevelsEnum = typeof TrialLogsLevelsEnum[keyof typeof TrialLogsLevelsEnum];
/**
 * @export
 */
export const TrialLogsOrderByEnum = {
    UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
    ASC: 'ORDER_BY_ASC',
    DESC: 'ORDER_BY_DESC'
} as const;
export type TrialLogsOrderByEnum = typeof TrialLogsOrderByEnum[keyof typeof TrialLogsOrderByEnum];
