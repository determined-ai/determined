/* tslint:disable */
/* eslint-disable */
/**
 * Determined API (Beta)
 * Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.  You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.
 *
 * The version of the OpenAPI document: 0.1
 * Contact: community@determined.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  RuntimeError,
  V1CreateTrialsCollectionRequest,
  V1CreateTrialsCollectionResponse,
  V1GetTrialsCollectionsResponse,
  V1PatchTrialsCollectionRequest,
  V1PatchTrialsCollectionResponse,
  V1QueryTrialsRequest,
  V1QueryTrialsResponse,
  V1UpdateTrialTagsRequest,
  V1UpdateTrialTagsResponse,
} from '../models';
import {
    RuntimeErrorFromJSON,
    RuntimeErrorToJSON,
    V1CreateTrialsCollectionRequestFromJSON,
    V1CreateTrialsCollectionRequestToJSON,
    V1CreateTrialsCollectionResponseFromJSON,
    V1CreateTrialsCollectionResponseToJSON,
    V1GetTrialsCollectionsResponseFromJSON,
    V1GetTrialsCollectionsResponseToJSON,
    V1PatchTrialsCollectionRequestFromJSON,
    V1PatchTrialsCollectionRequestToJSON,
    V1PatchTrialsCollectionResponseFromJSON,
    V1PatchTrialsCollectionResponseToJSON,
    V1QueryTrialsRequestFromJSON,
    V1QueryTrialsRequestToJSON,
    V1QueryTrialsResponseFromJSON,
    V1QueryTrialsResponseToJSON,
    V1UpdateTrialTagsRequestFromJSON,
    V1UpdateTrialTagsRequestToJSON,
    V1UpdateTrialTagsResponseFromJSON,
    V1UpdateTrialTagsResponseToJSON,
} from '../models';

export interface CreateTrialsCollectionRequest {
    body: V1CreateTrialsCollectionRequest;
}

export interface DeleteTrialsCollectionRequest {
    id?: number;
}

export interface GetTrialsCollectionsRequest {
    projectId?: number;
}

export interface PatchTrialsCollectionRequest {
    body: V1PatchTrialsCollectionRequest;
}

export interface QueryTrialsRequest {
    body: V1QueryTrialsRequest;
}

export interface UpdateTrialTagsRequest {
    body: V1UpdateTrialTagsRequest;
}

/**
 * 
 */
export class TrialComparisonApi extends runtime.BaseAPI {

    /**
     * Create a Trial Collection for a set of TrialFilters.
     */
    async createTrialsCollectionRaw(requestParameters: CreateTrialsCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1CreateTrialsCollectionResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createTrialsCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trial-comparison/collections`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1CreateTrialsCollectionRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1CreateTrialsCollectionResponseFromJSON(jsonValue));
    }

    /**
     * Create a Trial Collection for a set of TrialFilters.
     */
    async createTrialsCollection(body: V1CreateTrialsCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1CreateTrialsCollectionResponse> {
        const response = await this.createTrialsCollectionRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Removes a TrialCollection.
     */
    async deleteTrialsCollectionRaw(requestParameters: DeleteTrialsCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trial-comparison/collections`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Removes a TrialCollection.
     */
    async deleteTrialsCollection(id?: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteTrialsCollectionRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Return all collectiions for a specific project.
     */
    async getTrialsCollectionsRaw(requestParameters: GetTrialsCollectionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1GetTrialsCollectionsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.projectId !== undefined) {
            queryParameters['projectId'] = requestParameters.projectId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trial-comparison/collections`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1GetTrialsCollectionsResponseFromJSON(jsonValue));
    }

    /**
     * Return all collectiions for a specific project.
     */
    async getTrialsCollections(projectId?: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1GetTrialsCollectionsResponse> {
        const response = await this.getTrialsCollectionsRaw({ projectId: projectId }, initOverrides);
        return await response.value();
    }

    /**
     * Modify collection attributes: name, filters, etc.
     */
    async patchTrialsCollectionRaw(requestParameters: PatchTrialsCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PatchTrialsCollectionResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchTrialsCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trial-comparison/collections`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: V1PatchTrialsCollectionRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PatchTrialsCollectionResponseFromJSON(jsonValue));
    }

    /**
     * Modify collection attributes: name, filters, etc.
     */
    async patchTrialsCollection(body: V1PatchTrialsCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PatchTrialsCollectionResponse> {
        const response = await this.patchTrialsCollectionRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Return trials matching a set of TrialFilters.
     */
    async queryTrialsRaw(requestParameters: QueryTrialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1QueryTrialsResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling queryTrials.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trial-comparison/query`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1QueryTrialsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1QueryTrialsResponseFromJSON(jsonValue));
    }

    /**
     * Return trials matching a set of TrialFilters.
     */
    async queryTrials(body: V1QueryTrialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1QueryTrialsResponse> {
        const response = await this.queryTrialsRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Update tags for trials by IDs or filters.
     */
    async updateTrialTagsRaw(requestParameters: UpdateTrialTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1UpdateTrialTagsResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateTrialTags.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/trial-comparison/update-trial-tags`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1UpdateTrialTagsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1UpdateTrialTagsResponseFromJSON(jsonValue));
    }

    /**
     * Update tags for trials by IDs or filters.
     */
    async updateTrialTags(body: V1UpdateTrialTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1UpdateTrialTagsResponse> {
        const response = await this.updateTrialTagsRaw({ body: body }, initOverrides);
        return await response.value();
    }

}
