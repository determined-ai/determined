/**
 * Generated by orval v7.2.0 üç∫
 * Do not edit manually.
 * Determined API (Beta)
 * Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.

You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.
 * OpenAPI spec version: 0.1
 */
import axios from 'axios'
import type {
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
export type GetRawResourceAllocationCsvParams = {
/**
 * Start time to get allocations for (YYYY-MM-DDTHH:MM:SSZ format)
 */
timestamp_after: string;
/**
 * End time to get allocations for (YYYY-MM-DDTHH:MM:SSZ format)
 */
timestamp_before: string;
};

export type GetResourceAllocationCsvParams = {
/**
 * Start time to get allocations for (YYYY-MM-DDTHH:MM:SSZ format)
 */
timestamp_after: string;
/**
 * End time to get allocations for (YYYY-MM-DDTHH:MM:SSZ format)
 */
timestamp_before: string;
};

export type GetAggregatedResourceAllocationCsvParams = {
/**
 * Start time to get allocations for (YYYY-MM-DD format for daily, YYYY-MM format for monthly)
 */
start_date: string;
/**
 * End time to get allocations for (YYYY-MM-DD format for daily, YYYY-MM format for monthly)
 */
end_date: string;
/**
 * Period to aggregate over (RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY or RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY)
 */
period: string;
};

export type GetExperimentModelFileParams = {
/**
 * Path to the target file
 */
path: string;
};

export type DeleteWorkspaceNamespaceBindingsParams = {
/**
 * The names of the clusters to delete the bindings for.
 */
clusterNames?: string[];
};

export type ListRPsBoundToWorkspaceParams = {
/**
 * The offset to use with pagination.
 */
offset?: number;
/**
 * The maximum number of results to return.
 */
limit?: number;
};

export type GetWorkspaceProjectsOrderBy = typeof GetWorkspaceProjectsOrderBy[keyof typeof GetWorkspaceProjectsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetWorkspaceProjectsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetWorkspaceProjectsSortBy = typeof GetWorkspaceProjectsSortBy[keyof typeof GetWorkspaceProjectsSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetWorkspaceProjectsSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_CREATION_TIME: 'SORT_BY_CREATION_TIME',
  SORT_BY_LAST_EXPERIMENT_START_TIME: 'SORT_BY_LAST_EXPERIMENT_START_TIME',
  SORT_BY_NAME: 'SORT_BY_NAME',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_ID: 'SORT_BY_ID',
} as const;

export type GetWorkspaceProjectsParams = {
/**
 * Sort the projects by the given field.

 - SORT_BY_UNSPECIFIED: Returns projects in an unsorted list.
 - SORT_BY_CREATION_TIME: Returns projects sorted by time that they were created.
 - SORT_BY_LAST_EXPERIMENT_START_TIME: Returns projects sorted by most recent start of an experiment.
 - SORT_BY_NAME: Returns projects sorted by name.
 - SORT_BY_DESCRIPTION: Returns projects sorted by description.
 - SORT_BY_ID: Returns projects sorted by ID.
 */
sortBy?: GetWorkspaceProjectsSortBy;
/**
 * Order projects in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetWorkspaceProjectsOrderBy;
/**
 * Skip the number of projects before returning results. Negative values
denote number of projects to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of projects. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Limit the projects to those matching the name.
 */
name?: string;
/**
 * Limit the projects to those with an archived status.
 */
archived?: boolean;
/**
 * Limit the projects to those from particular users, by usernames.
 */
users?: string[];
/**
 * Limit the projects to those from particular users, by userIds.
 */
userIds?: number[];
};

export type GetWorkspacesOrderBy = typeof GetWorkspacesOrderBy[keyof typeof GetWorkspacesOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetWorkspacesOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetWorkspacesSortBy = typeof GetWorkspacesSortBy[keyof typeof GetWorkspacesSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetWorkspacesSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_NAME: 'SORT_BY_NAME',
} as const;

export type GetWorkspacesParams = {
/**
 * Sort the workspaces by the given field.

 - SORT_BY_UNSPECIFIED: Returns workspaces in an unsorted list.
 - SORT_BY_ID: Returns workspaces sorted by id.
 - SORT_BY_NAME: Returns workspaces sorted by name.
 */
sortBy?: GetWorkspacesSortBy;
/**
 * Order workspaces in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetWorkspacesOrderBy;
/**
 * Skip the number of workspaces before returning results. Negative values
denote number of workspaces to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of workspaces. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Limit the workspaces to those matching the name (case insensitive).
 */
name?: string;
/**
 * Limit the workspaces to those with an archived status.
 */
archived?: boolean;
/**
 * Limit the workspaces to those from particular users, by usernames.
 */
users?: string[];
/**
 * Limit the workspaces to those from particular users, by userIds.
 */
userIds?: number[];
/**
 * Limit the workspaces to those with pinned status by the current user.
 */
pinned?: boolean;
/**
 * Limit the workspaces to those matching the name (case sensitive).
 */
nameCaseSensitive?: string;
};

export type GetUsersOrderBy = typeof GetUsersOrderBy[keyof typeof GetUsersOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUsersOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetUsersSortBy = typeof GetUsersSortBy[keyof typeof GetUsersSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetUsersSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_DISPLAY_NAME: 'SORT_BY_DISPLAY_NAME',
  SORT_BY_USER_NAME: 'SORT_BY_USER_NAME',
  SORT_BY_ADMIN: 'SORT_BY_ADMIN',
  SORT_BY_ACTIVE: 'SORT_BY_ACTIVE',
  SORT_BY_MODIFIED_TIME: 'SORT_BY_MODIFIED_TIME',
  SORT_BY_NAME: 'SORT_BY_NAME',
  SORT_BY_LAST_AUTH_TIME: 'SORT_BY_LAST_AUTH_TIME',
  SORT_BY_REMOTE: 'SORT_BY_REMOTE',
} as const;

export type GetUsersParams = {
/**
 * Sort users by the given field.

 - SORT_BY_UNSPECIFIED: Returns users in an unsorted list.
 - SORT_BY_DISPLAY_NAME: Returns users sorted by display name.
 - SORT_BY_USER_NAME: Returns users sorted by user name.
 - SORT_BY_ADMIN: Returns users sorted by if they are admin.
 - SORT_BY_ACTIVE: Returns users sorted by if they are active.
 - SORT_BY_MODIFIED_TIME: Returns users sorted by modified time.
 - SORT_BY_NAME: Returns users sorted by username unless display name exist.
 - SORT_BY_LAST_AUTH_TIME: Returns users sorted by last authenticated time.
 - SORT_BY_REMOTE: Returns users sorted by local or remote auth.
 */
sortBy?: GetUsersSortBy;
/**
 * Order users in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetUsersOrderBy;
/**
 * Skip the number of projects before returning results. Negative values
denote number of projects to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of projects. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Filter by username or display name.
 */
name?: string;
/**
 * Filter by status.
 */
active?: boolean;
/**
 * Filter by roles.
 */
admin?: boolean;
/**
 * Filter by roles id assigned directly to user for EE.
 */
roleIdAssignedDirectlyToUser?: number[];
};

export type GetProjectsByUserActivityParams = {
/**
 * Limit number of project entries.
 */
limit?: number;
};

export type GetTrialWorkloadsMetricType = typeof GetTrialWorkloadsMetricType[keyof typeof GetTrialWorkloadsMetricType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTrialWorkloadsMetricType = {
  METRIC_TYPE_UNSPECIFIED: 'METRIC_TYPE_UNSPECIFIED',
  METRIC_TYPE_TRAINING: 'METRIC_TYPE_TRAINING',
  METRIC_TYPE_VALIDATION: 'METRIC_TYPE_VALIDATION',
  METRIC_TYPE_PROFILING: 'METRIC_TYPE_PROFILING',
} as const;

export type GetTrialWorkloadsFilter = typeof GetTrialWorkloadsFilter[keyof typeof GetTrialWorkloadsFilter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTrialWorkloadsFilter = {
  FILTER_OPTION_UNSPECIFIED: 'FILTER_OPTION_UNSPECIFIED',
  FILTER_OPTION_CHECKPOINT: 'FILTER_OPTION_CHECKPOINT',
  FILTER_OPTION_VALIDATION: 'FILTER_OPTION_VALIDATION',
  FILTER_OPTION_CHECKPOINT_OR_VALIDATION: 'FILTER_OPTION_CHECKPOINT_OR_VALIDATION',
} as const;

export type GetTrialWorkloadsOrderBy = typeof GetTrialWorkloadsOrderBy[keyof typeof GetTrialWorkloadsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTrialWorkloadsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetTrialWorkloadsParams = {
/**
 * Order workloads in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetTrialWorkloadsOrderBy;
/**
 * Skip the number of workloads before returning results. Negative values
denote number of workloads to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of workloads. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Sort workloads by batches, a training metric, or a validation metric.
 */
sortKey?: string;
/**
 * Filter workloads with validation and/or checkpoint information.

 - FILTER_OPTION_UNSPECIFIED: Any workload.
 - FILTER_OPTION_CHECKPOINT: Only workloads with an associated checkpoint.
 - FILTER_OPTION_VALIDATION: Only validation workloads.
 - FILTER_OPTION_CHECKPOINT_OR_VALIDATION: Only validation workloads or ones with an associated checkpoint.
 */
filter?: GetTrialWorkloadsFilter;
/**
 * Include per-batch metrics.
 */
includeBatchMetrics?: boolean;
/**
 * When sorting workloads by sort_key, specify training or validation form of
a metric.

 - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).
 - METRIC_TYPE_TRAINING: For metrics emitted during training.
 - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
 - METRIC_TYPE_PROFILING: For metrics emitted during profiling.
 */
metricType?: GetTrialWorkloadsMetricType;
/**
 * Metric group (training, validation, etc).
 */
group?: string;
/**
 * Remove deleted checkpoints.
 */
removeDeletedCheckpoints?: boolean;
};

export type GetTrialProfilerAvailableSeries200 = {
  error?: RuntimeStreamError;
  result?: V1GetTrialProfilerAvailableSeriesResponse;
};

export type GetTrialProfilerAvailableSeriesParams = {
/**
 * Continue streaming labels until the trial stops. Defaults to False.
 */
follow?: boolean;
};

export type TrialLogsFields200 = {
  error?: RuntimeStreamError;
  result?: V1TrialLogsFieldsResponse;
};

export type TrialLogsFieldsParams = {
/**
 * Continue following fields until the trial stops.
 */
follow?: boolean;
};

export type TrialLogs200 = {
  error?: RuntimeStreamError;
  result?: V1TrialLogsResponse;
};

export type TrialLogsOrderBy = typeof TrialLogsOrderBy[keyof typeof TrialLogsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TrialLogsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type TrialLogsLevelsItem = typeof TrialLogsLevelsItem[keyof typeof TrialLogsLevelsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TrialLogsLevelsItem = {
  LOG_LEVEL_UNSPECIFIED: 'LOG_LEVEL_UNSPECIFIED',
  LOG_LEVEL_TRACE: 'LOG_LEVEL_TRACE',
  LOG_LEVEL_DEBUG: 'LOG_LEVEL_DEBUG',
  LOG_LEVEL_INFO: 'LOG_LEVEL_INFO',
  LOG_LEVEL_WARNING: 'LOG_LEVEL_WARNING',
  LOG_LEVEL_ERROR: 'LOG_LEVEL_ERROR',
  LOG_LEVEL_CRITICAL: 'LOG_LEVEL_CRITICAL',
} as const;

export type TrialLogsParams = {
/**
 * Limit the number of trial logs. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Continue following logs until the trial stops.
 */
follow?: boolean;
/**
 * Limit the trial logs to a subset of agents.
 */
agentIds?: string[];
/**
 * Limit the trial logs to a subset of containers.
 */
containerIds?: string[];
/**
 * Limit the trial logs to a subset of ranks.
 */
rankIds?: number[];
/**
 * Limit the trial logs to a subset of agents.

 - LOG_LEVEL_UNSPECIFIED: Unspecified log level.
 - LOG_LEVEL_TRACE: A log level of TRACE.
 - LOG_LEVEL_DEBUG: A log level of DEBUG.
 - LOG_LEVEL_INFO: A log level of INFO.
 - LOG_LEVEL_WARNING: A log level of WARNING.
 - LOG_LEVEL_ERROR: A log level of ERROR.
 - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
 */
levels?: TrialLogsLevelsItem[];
/**
 * Limit the trial logs to a subset of output streams.
 */
stdtypes?: string[];
/**
 * Limit the trial logs to a subset of sources.
 */
sources?: string[];
/**
 * Limit the trial logs to ones with a timestamp before a given time.
 */
timestampBefore?: string;
/**
 * Limit the trial logs to ones with a timestamp after a given time.
 */
timestampAfter?: string;
/**
 * Order logs in either ascending or descending order by timestamp.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: TrialLogsOrderBy;
/**
 * Search the logs by whether the text contains a substring.
 */
searchText?: string;
/**
 * Search text is regex. Default to false.
 */
enableRegex?: boolean;
};

export type GetTrialProfilerMetrics200 = {
  error?: RuntimeStreamError;
  result?: V1GetTrialProfilerMetricsResponse;
};

export type GetTrialProfilerMetricsLabelsMetricType = typeof GetTrialProfilerMetricsLabelsMetricType[keyof typeof GetTrialProfilerMetricsLabelsMetricType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTrialProfilerMetricsLabelsMetricType = {
  PROFILER_METRIC_TYPE_UNSPECIFIED: 'PROFILER_METRIC_TYPE_UNSPECIFIED',
  PROFILER_METRIC_TYPE_SYSTEM: 'PROFILER_METRIC_TYPE_SYSTEM',
  PROFILER_METRIC_TYPE_TIMING: 'PROFILER_METRIC_TYPE_TIMING',
  PROFILER_METRIC_TYPE_MISC: 'PROFILER_METRIC_TYPE_MISC',
} as const;

export type GetTrialProfilerMetricsParams = {
/**
 * The name of the metric.
 */
'labels.name'?: string;
/**
 * The agent ID associated with the metric.
 */
'labels.agentId'?: string;
/**
 * The GPU UUID associated with the metric.
 */
'labels.gpuUuid'?: string;
/**
 * The type of the metric.

 - PROFILER_METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).
 - PROFILER_METRIC_TYPE_SYSTEM: For systems metrics, like GPU utilization or memory.
 - PROFILER_METRIC_TYPE_TIMING: For timing metrics, like how long a backwards pass or getting a batch
from the dataloader took.
 - PROFILER_METRIC_TYPE_MISC: For other miscellaneous metrics.
 */
'labels.metricType'?: GetTrialProfilerMetricsLabelsMetricType;
/**
 * Continue streaming metrics until the trial stops. Defaults to False.
 */
follow?: boolean;
};

export type GetTrialCheckpointsStatesItem = typeof GetTrialCheckpointsStatesItem[keyof typeof GetTrialCheckpointsStatesItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTrialCheckpointsStatesItem = {
  STATE_UNSPECIFIED: 'STATE_UNSPECIFIED',
  STATE_ACTIVE: 'STATE_ACTIVE',
  STATE_COMPLETED: 'STATE_COMPLETED',
  STATE_ERROR: 'STATE_ERROR',
  STATE_DELETED: 'STATE_DELETED',
  STATE_PARTIALLY_DELETED: 'STATE_PARTIALLY_DELETED',
} as const;

export type GetTrialCheckpointsOrderBy = typeof GetTrialCheckpointsOrderBy[keyof typeof GetTrialCheckpointsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTrialCheckpointsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetTrialCheckpointsSortByAttr = typeof GetTrialCheckpointsSortByAttr[keyof typeof GetTrialCheckpointsSortByAttr];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTrialCheckpointsSortByAttr = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_UUID: 'SORT_BY_UUID',
  SORT_BY_TRIAL_ID: 'SORT_BY_TRIAL_ID',
  SORT_BY_BATCH_NUMBER: 'SORT_BY_BATCH_NUMBER',
  SORT_BY_END_TIME: 'SORT_BY_END_TIME',
  SORT_BY_STATE: 'SORT_BY_STATE',
  SORT_BY_SEARCHER_METRIC: 'SORT_BY_SEARCHER_METRIC',
} as const;

export type GetTrialCheckpointsParams = {
/**
 * Sort by preset checkpoint attribute.

 - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.
 - SORT_BY_UUID: Returns checkpoints sorted by UUID.
 - SORT_BY_TRIAL_ID: Returns checkpoints sorted by trial id.
 - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.
 - SORT_BY_END_TIME: Returns checkpoints sorted by end time.
 - SORT_BY_STATE: Returns checkpoints sorted by state.
 - SORT_BY_SEARCHER_METRIC: Returns checkpoints sorted by the experiment's `searcher.metric`
configuration setting.
 */
sortByAttr?: GetTrialCheckpointsSortByAttr;
/**
 * Sort by custom validation metric name.
 */
sortByMetric?: string;
/**
 * Order checkpoints in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetTrialCheckpointsOrderBy;
/**
 * Skip the number of checkpoints before returning results. Negative values
denote number of checkpoints to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of checkpoints. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Limit the checkpoints to those that match the states.

 - STATE_UNSPECIFIED: The state of the checkpoint is unknown.
 - STATE_ACTIVE: The checkpoint is in an active state.
 - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.
 - STATE_ERROR: The checkpoint errored.
 - STATE_DELETED: The checkpoint has been deleted.
 - STATE_PARTIALLY_DELETED: The checkpoint has been partially deleted.
 */
states?: GetTrialCheckpointsStatesItem[];
};

export type CompareTrialsMetricType = typeof CompareTrialsMetricType[keyof typeof CompareTrialsMetricType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CompareTrialsMetricType = {
  METRIC_TYPE_UNSPECIFIED: 'METRIC_TYPE_UNSPECIFIED',
  METRIC_TYPE_TRAINING: 'METRIC_TYPE_TRAINING',
  METRIC_TYPE_VALIDATION: 'METRIC_TYPE_VALIDATION',
  METRIC_TYPE_PROFILING: 'METRIC_TYPE_PROFILING',
} as const;

export type CompareTrialsParams = {
/**
 * The requested trial ids.
 */
trialIds?: number[];
/**
 * The maximum number of data points to return after downsampling.
 */
maxDatapoints?: number;
/**
 * The names of selected metrics.
 */
metricNames?: string[];
/**
 * Sample from metrics after this batch number.
 */
startBatches?: number;
/**
 * Sample from metrics before this batch number.
 */
endBatches?: number;
/**
 * Metric group.

 - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).
 - METRIC_TYPE_TRAINING: For metrics emitted during training.
 - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
 - METRIC_TYPE_PROFILING: For metrics emitted during profiling.
 */
metricType?: CompareTrialsMetricType;
/**
 * Metric group (training, validation, etc).
 */
group?: string;
/**
 * metric ids for the query. must be in the form group.metric_name.
 */
metricIds?: string[];
/**
 * metric or column name for the filter.
 */
'timeSeriesFilter.name'?: string;
/**
 * Less than.
 */
'timeSeriesFilter.doubleRange.lt'?: number;
/**
 * Less than or equal.
 */
'timeSeriesFilter.doubleRange.lte'?: number;
/**
 * Greater than.
 */
'timeSeriesFilter.doubleRange.gt'?: number;
/**
 * Greater than or equal.
 */
'timeSeriesFilter.doubleRange.gte'?: number;
/**
 * Less than.
 */
'timeSeriesFilter.integerRange.lt'?: number;
/**
 * Less than or equal.
 */
'timeSeriesFilter.integerRange.lte'?: number;
/**
 * Greater than.
 */
'timeSeriesFilter.integerRange.gt'?: number;
/**
 * Greater than or equal.
 */
'timeSeriesFilter.integerRange.gte'?: number;
/**
 * In a set. `in` is a reserved word in python.
 */
'timeSeriesFilter.integerRange.incl'?: number[];
/**
 * Not in a set.
 */
'timeSeriesFilter.integerRange.notIn'?: number[];
/**
 * Less than.
 */
'timeSeriesFilter.timeRange.lt'?: string;
/**
 * Less than or equal.
 */
'timeSeriesFilter.timeRange.lte'?: string;
/**
 * Greater than.
 */
'timeSeriesFilter.timeRange.gt'?: string;
/**
 * Greater than or equal.
 */
'timeSeriesFilter.timeRange.gte'?: string;
};

export type GetValidationMetrics200 = {
  error?: RuntimeStreamError;
  result?: V1GetValidationMetricsResponse;
};

export type GetValidationMetricsParams = {
/**
 * Trial IDs to get metrics for.
 */
trialIds?: number[];
};

export type GetMetrics200 = {
  error?: RuntimeStreamError;
  result?: V1GetMetricsResponse;
};

export type GetMetricsParams = {
/**
 * Trial IDs to get metrics for.
 */
trialIds: number[];
/**
 * The group of metrics to get eg 'training', 'validation', etc.
 */
group: string;
};

export type GetTrainingMetrics200 = {
  error?: RuntimeStreamError;
  result?: V1GetTrainingMetricsResponse;
};

export type GetTrainingMetricsParams = {
/**
 * Trial IDs to get metrics for.
 */
trialIds?: number[];
};

export type GetAccessTokensOrderBy = typeof GetAccessTokensOrderBy[keyof typeof GetAccessTokensOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetAccessTokensOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetAccessTokensSortBy = typeof GetAccessTokensSortBy[keyof typeof GetAccessTokensSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetAccessTokensSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_USER_ID: 'SORT_BY_USER_ID',
  SORT_BY_EXPIRY: 'SORT_BY_EXPIRY',
  SORT_BY_CREATED_AT: 'SORT_BY_CREATED_AT',
  SORT_BY_TOKEN_TYPE: 'SORT_BY_TOKEN_TYPE',
  SORT_BY_REVOKED: 'SORT_BY_REVOKED',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
} as const;

export type GetAccessTokensParams = {
/**
 * Sort token info by the given field.

 - SORT_BY_UNSPECIFIED: Returns token info in an unsorted list.
 - SORT_BY_USER_ID: Returns token info sorted by user id.
 - SORT_BY_EXPIRY: Returns token info sorted by expiry.
 - SORT_BY_CREATED_AT: Returns token info sorted by created at.
 - SORT_BY_TOKEN_TYPE: Returns token info sorted by token type.
 - SORT_BY_REVOKED: Returns token info sorted by if it is revoked.
 - SORT_BY_DESCRIPTION: Returns token info sorted by description of token.
 */
sortBy?: GetAccessTokensSortBy;
/**
 * Order token info in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetAccessTokensOrderBy;
/**
 * Skip the number of projects before returning results. Negative values
denote number of projects to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of projects. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Filter on token_ids.
 */
tokenIds?: number[];
/**
 * Filter by username.
 */
username?: string;
/**
 * Filter by active status.
 */
showInactive?: boolean;
};

export type GetTensorboardsOrderBy = typeof GetTensorboardsOrderBy[keyof typeof GetTensorboardsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTensorboardsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetTensorboardsSortBy = typeof GetTensorboardsSortBy[keyof typeof GetTensorboardsSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTensorboardsSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_START_TIME: 'SORT_BY_START_TIME',
  SORT_BY_WORKSPACE_ID: 'SORT_BY_WORKSPACE_ID',
} as const;

export type GetTensorboardsParams = {
/**
 * Sort tensorboards by the given field.

 - SORT_BY_UNSPECIFIED: Returns tensorboards in an unsorted list.
 - SORT_BY_ID: Returns tensorboards sorted by id.
 - SORT_BY_DESCRIPTION: Returns tensorboards sorted by description.
 - SORT_BY_START_TIME: Return tensorboards sorted by start time.
 - SORT_BY_WORKSPACE_ID: Return tensorboards sorted by workspace_id.
 */
sortBy?: GetTensorboardsSortBy;
/**
 * Order tensorboards in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetTensorboardsOrderBy;
/**
 * Skip the number of tensorboards before returning results. Negative values
denote number of tensorboards to skip from the end before returning
results.
 */
offset?: number;
/**
 * Limit the number of tensorboards. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Limit tensorboards to those that are owned by users with the specified
usernames.
 */
users?: string[];
/**
 * Limit tensorboards to those that are owned by users with the specified
userIds.
 */
userIds?: number[];
/**
 * Limit tensorboards to those that are in a specific workspace, or 0 for
all accessible workspaces.
 */
workspaceId?: number;
};

export type PatchTemplateConfigBody = { [key: string]: unknown };

export type GetTemplatesOrderBy = typeof GetTemplatesOrderBy[keyof typeof GetTemplatesOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTemplatesOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetTemplatesSortBy = typeof GetTemplatesSortBy[keyof typeof GetTemplatesSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTemplatesSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_NAME: 'SORT_BY_NAME',
} as const;

export type GetTemplatesParams = {
/**
 * Sort templates by the given field.

 - SORT_BY_UNSPECIFIED: Returns templates in an unsorted list.
 - SORT_BY_NAME: Returns templates sorted by name.
 */
sortBy?: GetTemplatesSortBy;
/**
 * Order templates in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetTemplatesOrderBy;
/**
 * Skip the number of templates before returning results. Negative values
denote number of templates to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of templates. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Limit templates to those that match the name.
 */
name?: string;
/**
 * Limit templates to those that match the workspace id.
 */
workspaceIds?: number[];
};

export type TaskLogsFields200 = {
  error?: RuntimeStreamError;
  result?: V1TaskLogsFieldsResponse;
};

export type TaskLogsFieldsParams = {
/**
 * Continue following fields until the task stops.
 */
follow?: boolean;
};

export type TaskLogs200 = {
  error?: RuntimeStreamError;
  result?: V1TaskLogsResponse;
};

export type TaskLogsOrderBy = typeof TaskLogsOrderBy[keyof typeof TaskLogsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TaskLogsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type TaskLogsLevelsItem = typeof TaskLogsLevelsItem[keyof typeof TaskLogsLevelsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TaskLogsLevelsItem = {
  LOG_LEVEL_UNSPECIFIED: 'LOG_LEVEL_UNSPECIFIED',
  LOG_LEVEL_TRACE: 'LOG_LEVEL_TRACE',
  LOG_LEVEL_DEBUG: 'LOG_LEVEL_DEBUG',
  LOG_LEVEL_INFO: 'LOG_LEVEL_INFO',
  LOG_LEVEL_WARNING: 'LOG_LEVEL_WARNING',
  LOG_LEVEL_ERROR: 'LOG_LEVEL_ERROR',
  LOG_LEVEL_CRITICAL: 'LOG_LEVEL_CRITICAL',
} as const;

export type TaskLogsParams = {
/**
 * Limit the number of trial logs. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Continue following logs until the trial stops.
 */
follow?: boolean;
/**
 * Limit the task logs to particular allocations.
 */
allocationIds?: string[];
/**
 * Limit the trial logs to a subset of agents.
 */
agentIds?: string[];
/**
 * Limit the trial logs to a subset of containers.
 */
containerIds?: string[];
/**
 * Limit the trial logs to a subset of ranks.
 */
rankIds?: number[];
/**
 * Limit the trial logs to a subset of agents.

 - LOG_LEVEL_UNSPECIFIED: Unspecified log level.
 - LOG_LEVEL_TRACE: A log level of TRACE.
 - LOG_LEVEL_DEBUG: A log level of DEBUG.
 - LOG_LEVEL_INFO: A log level of INFO.
 - LOG_LEVEL_WARNING: A log level of WARNING.
 - LOG_LEVEL_ERROR: A log level of ERROR.
 - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
 */
levels?: TaskLogsLevelsItem[];
/**
 * Limit the trial logs to a subset of output streams.
 */
stdtypes?: string[];
/**
 * Limit the trial logs to a subset of sources.
 */
sources?: string[];
/**
 * Limit the trial logs to ones with a timestamp before a given time.
 */
timestampBefore?: string;
/**
 * Limit the trial logs to ones with a timestamp after a given time.
 */
timestampAfter?: string;
/**
 * Order logs in either ascending or descending order by timestamp.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: TaskLogsOrderBy;
/**
 * Search the logs by whether the text contains a substring.
 */
searchText?: string;
/**
 * Search text is regex. Default to false.
 */
enableRegex?: boolean;
};

export type GetShellsOrderBy = typeof GetShellsOrderBy[keyof typeof GetShellsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetShellsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetShellsSortBy = typeof GetShellsSortBy[keyof typeof GetShellsSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetShellsSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_START_TIME: 'SORT_BY_START_TIME',
  SORT_BY_WORKSPACE_ID: 'SORT_BY_WORKSPACE_ID',
} as const;

export type GetShellsParams = {
/**
 * Sort shells by the given field.

 - SORT_BY_UNSPECIFIED: Returns shells in an unsorted list.
 - SORT_BY_ID: Returns shells sorted by id.
 - SORT_BY_DESCRIPTION: Returns shells sorted by description.
 - SORT_BY_START_TIME: Return shells sorted by start time.
 - SORT_BY_WORKSPACE_ID: Return shells sorted by workspace_id.
 */
sortBy?: GetShellsSortBy;
/**
 * Order shells in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetShellsOrderBy;
/**
 * Skip the number of shells before returning results. Negative values
denote number of shells to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of shells. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Limit shells to those that are owned by users with the specified usernames.
 */
users?: string[];
/**
 * Limit shells to those that are owned by users with the specified userIds.
 */
userIds?: number[];
/**
 * Limit to those within a specified workspace, or 0 for all
accessible workspaces.
 */
workspaceId?: number;
};

export type GetGroupsAndUsersAssignedToWorkspaceParams = {
/**
 * Name of groups and users to search by. Name filters by group name for
groups. Name filters by display name then username if display name is null
for users.
 */
name?: string;
};

export type ResourceAllocationRawParams = {
/**
 * The start of the period to consider.
 */
timestampAfter: string;
/**
 * The end of the period to consider.
 */
timestampBefore: string;
};

export type ResourceAllocationAggregatedPeriod = typeof ResourceAllocationAggregatedPeriod[keyof typeof ResourceAllocationAggregatedPeriod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResourceAllocationAggregatedPeriod = {
  RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED',
  RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY',
  RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY',
} as const;

export type ResourceAllocationAggregatedParams = {
/**
 * The first day to consider (the exact time is midnight UTC at the beginning
of the day).
 */
startDate: string;
/**
 * The last day to consider (the exact time is midnight UTC at the end of the
day).
 */
endDate: string;
/**
 * The period over which to perform aggregation.

 - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is
just an artifact of using protobuf.
 - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.
 - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
 */
period?: ResourceAllocationAggregatedPeriod;
};

export type ListWorkspacesBoundToRPParams = {
/**
 * The offset to use with pagination.
 */
offset?: number;
/**
 * The maximum number of results to return.
 */
limit?: number;
};

export type GetResourcePoolsParams = {
/**
 * Skip the number of resource pools before returning results. Negative values
denote number of resource pools to skip from the end before returning
results.
 */
offset?: number;
/**
 * Limit the number of resource pools. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Indicate whether or not to return unbound pools only.
 */
unbound?: boolean;
};

export type GetProjectColumnsTableType = typeof GetProjectColumnsTableType[keyof typeof GetProjectColumnsTableType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetProjectColumnsTableType = {
  TABLE_TYPE_UNSPECIFIED: 'TABLE_TYPE_UNSPECIFIED',
  TABLE_TYPE_EXPERIMENT: 'TABLE_TYPE_EXPERIMENT',
  TABLE_TYPE_RUN: 'TABLE_TYPE_RUN',
} as const;

export type GetProjectColumnsParams = {
/**
 * type of table for project columns.

 - TABLE_TYPE_UNSPECIFIED: Unspecified table type.
 - TABLE_TYPE_EXPERIMENT: experiment table.
 - TABLE_TYPE_RUN: run table.
 */
tableType?: GetProjectColumnsTableType;
};

export type GetNotebooksOrderBy = typeof GetNotebooksOrderBy[keyof typeof GetNotebooksOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetNotebooksOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetNotebooksSortBy = typeof GetNotebooksSortBy[keyof typeof GetNotebooksSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetNotebooksSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_START_TIME: 'SORT_BY_START_TIME',
  SORT_BY_WORKSPACE_ID: 'SORT_BY_WORKSPACE_ID',
} as const;

export type GetNotebooksParams = {
/**
 * Sort notebooks by the given field.

 - SORT_BY_UNSPECIFIED: Returns notebooks in an unsorted list.
 - SORT_BY_ID: Returns notebooks sorted by id.
 - SORT_BY_DESCRIPTION: Returns notebooks sorted by description.
 - SORT_BY_START_TIME: Return notebooks sorted by start time.
 - SORT_BY_WORKSPACE_ID: Return notebooks sorted by workspace_id
 */
sortBy?: GetNotebooksSortBy;
/**
 * Order notebooks in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetNotebooksOrderBy;
/**
 * Skip the number of notebooks before returning results. Negative values
denote number of notebooks to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of notebooks. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Limit notebooks to those that are owned by users with the specified
usernames.
 */
users?: string[];
/**
 * Limit notebooks to those that are owned by users with the specified
userIds.
 */
userIds?: number[];
/**
 * Limit to those within a specified workspace, or 0 for all
accessible workspaces.
 */
workspaceId?: number;
};

export type GetTrialMetricsByModelVersionTrialSourceInfoType = typeof GetTrialMetricsByModelVersionTrialSourceInfoType[keyof typeof GetTrialMetricsByModelVersionTrialSourceInfoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTrialMetricsByModelVersionTrialSourceInfoType = {
  TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: 'TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED',
  TRIAL_SOURCE_INFO_TYPE_INFERENCE: 'TRIAL_SOURCE_INFO_TYPE_INFERENCE',
  TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: 'TRIAL_SOURCE_INFO_TYPE_FINE_TUNING',
} as const;

export type GetTrialMetricsByModelVersionParams = {
/**
 * Type of the TrialSourceInfo.

 - TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: The type is unspecified
 - TRIAL_SOURCE_INFO_TYPE_INFERENCE: "Inference" Trial Source Info Type, used for batch inference
 - TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: "Fine Tuning" Trial Source Info Type, used in model hub
 */
trialSourceInfoType?: GetTrialMetricsByModelVersionTrialSourceInfoType;
/**
 * Metric Group string ("training", "validation", or anything else) (nil means
all groups).
 */
metricGroup?: string;
};

export type GetModelVersionsOrderBy = typeof GetModelVersionsOrderBy[keyof typeof GetModelVersionsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetModelVersionsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetModelVersionsSortBy = typeof GetModelVersionsSortBy[keyof typeof GetModelVersionsSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetModelVersionsSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_VERSION: 'SORT_BY_VERSION',
  SORT_BY_CREATION_TIME: 'SORT_BY_CREATION_TIME',
} as const;

export type GetModelVersionsParams = {
/**
 * Sort the model versions by the given field.

 - SORT_BY_UNSPECIFIED: Returns model versions in an unsorted list.
 - SORT_BY_VERSION: Returns model versions sorted by version number.
 - SORT_BY_CREATION_TIME: Returns model versions sorted by creation_time.
 */
sortBy?: GetModelVersionsSortBy;
/**
 * Order model versions in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetModelVersionsOrderBy;
/**
 * Skip the number of model versions before returning results. Negative values
denote number of models to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of model versions. A value of 0 denotes no limit.
 */
limit?: number;
};

export type GetModelsOrderBy = typeof GetModelsOrderBy[keyof typeof GetModelsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetModelsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetModelsSortBy = typeof GetModelsSortBy[keyof typeof GetModelsSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetModelsSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_NAME: 'SORT_BY_NAME',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_CREATION_TIME: 'SORT_BY_CREATION_TIME',
  SORT_BY_LAST_UPDATED_TIME: 'SORT_BY_LAST_UPDATED_TIME',
  SORT_BY_NUM_VERSIONS: 'SORT_BY_NUM_VERSIONS',
  SORT_BY_WORKSPACE: 'SORT_BY_WORKSPACE',
} as const;

export type GetModelsParams = {
/**
 * Sort the models by the given field.

 - SORT_BY_UNSPECIFIED: Returns models in an unsorted list.
 - SORT_BY_NAME: Returns models sorted by name.
 - SORT_BY_DESCRIPTION: Returns models sorted by description.
 - SORT_BY_CREATION_TIME: Returns models sorted by creation time.
 - SORT_BY_LAST_UPDATED_TIME: Returns models sorted by last updated time.
 - SORT_BY_NUM_VERSIONS: Returns models sorted by number of version.
 - SORT_BY_WORKSPACE: Returns models sorted by workspace name.
 */
sortBy?: GetModelsSortBy;
/**
 * Order models in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetModelsOrderBy;
/**
 * Skip the number of models before returning results. Negative values
denote number of models to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of models. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Limit the models to those matching or partially-matching the name.
 */
name?: string;
/**
 * Limit the models to those matching or partially-matching the description.
 */
description?: string;
/**
 * Limit the models to those with the following labels.
 */
labels?: string[];
/**
 * Limit to unarchived models only.
 */
archived?: boolean;
/**
 * Limit the models to those made by the users with the following usernames.
 */
users?: string[];
/**
 * Limit models to those that belong to the following workspace names.
 */
workspaceNames?: string[];
/**
 * Limit the models to those made by the users with the following userIds.
 */
userIds?: number[];
/**
 * Limit the models to this model id.
 */
id?: number;
/**
 * Limit models to those that belong to the following workspace ids.
 */
workspaceIds?: number[];
};

export type GetModelLabelsParams = {
/**
 * Optional workspace ID to limit query for model tags.
 */
workspaceId?: number;
};

export type MasterLogs200 = {
  error?: RuntimeStreamError;
  result?: V1MasterLogsResponse;
};

export type MasterLogsParams = {
/**
 * Skip the number of master logs before returning results. Negative values
denote number of master logs to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of master logs. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Continue following logs until the master stops or the limit is reached.
 */
follow?: boolean;
};

export type GetJobQueueStatsParams = {
/**
 * Filter the results based on a set of resource pools.
 */
resourcePools?: string[];
};

export type GetJobsV2StatesItem = typeof GetJobsV2StatesItem[keyof typeof GetJobsV2StatesItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetJobsV2StatesItem = {
  STATE_UNSPECIFIED: 'STATE_UNSPECIFIED',
  STATE_QUEUED: 'STATE_QUEUED',
  STATE_SCHEDULED: 'STATE_SCHEDULED',
  STATE_SCHEDULED_BACKFILLED: 'STATE_SCHEDULED_BACKFILLED',
} as const;

export type GetJobsV2OrderBy = typeof GetJobsV2OrderBy[keyof typeof GetJobsV2OrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetJobsV2OrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetJobsV2Params = {
/**
 * Pagination offset.
 */
offset?: number;
/**
 * Pagination limit.
 */
limit?: number;
/**
 * The target resource-pool for agent resource manager.
 */
resourcePool?: string;
/**
 * Order results in either ascending or descending order by the number of
jobs ahead.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetJobsV2OrderBy;
/**
 * Filter to jobs with states among those given.

 - STATE_UNSPECIFIED: Unspecified state.
 - STATE_QUEUED: Job is queued and waiting to be schedlued.
 - STATE_SCHEDULED: Job is scheduled.
 - STATE_SCHEDULED_BACKFILLED: Job is scheduled as a backfill.
 */
states?: GetJobsV2StatesItem[];
};

export type GetJobsStatesItem = typeof GetJobsStatesItem[keyof typeof GetJobsStatesItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetJobsStatesItem = {
  STATE_UNSPECIFIED: 'STATE_UNSPECIFIED',
  STATE_QUEUED: 'STATE_QUEUED',
  STATE_SCHEDULED: 'STATE_SCHEDULED',
  STATE_SCHEDULED_BACKFILLED: 'STATE_SCHEDULED_BACKFILLED',
} as const;

export type GetJobsOrderBy = typeof GetJobsOrderBy[keyof typeof GetJobsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetJobsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetJobsParams = {
/**
 * Pagination offset.
 */
offset?: number;
/**
 * Pagination limit.
 */
limit?: number;
/**
 * The target resource-pool for agent resource manager.
 */
resourcePool?: string;
/**
 * Order results in either ascending or descending order by the number of
jobs ahead.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetJobsOrderBy;
/**
 * Filter to jobs with states among those given.

 - STATE_UNSPECIFIED: Unspecified state.
 - STATE_QUEUED: Job is queued and waiting to be schedlued.
 - STATE_SCHEDULED: Job is scheduled.
 - STATE_SCHEDULED_BACKFILLED: Job is scheduled as a backfill.
 */
states?: GetJobsStatesItem[];
};

export type GetExperimentCheckpointsStatesItem = typeof GetExperimentCheckpointsStatesItem[keyof typeof GetExperimentCheckpointsStatesItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetExperimentCheckpointsStatesItem = {
  STATE_UNSPECIFIED: 'STATE_UNSPECIFIED',
  STATE_ACTIVE: 'STATE_ACTIVE',
  STATE_COMPLETED: 'STATE_COMPLETED',
  STATE_ERROR: 'STATE_ERROR',
  STATE_DELETED: 'STATE_DELETED',
  STATE_PARTIALLY_DELETED: 'STATE_PARTIALLY_DELETED',
} as const;

export type GetExperimentCheckpointsOrderBy = typeof GetExperimentCheckpointsOrderBy[keyof typeof GetExperimentCheckpointsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetExperimentCheckpointsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetExperimentCheckpointsSortByAttr = typeof GetExperimentCheckpointsSortByAttr[keyof typeof GetExperimentCheckpointsSortByAttr];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetExperimentCheckpointsSortByAttr = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_UUID: 'SORT_BY_UUID',
  SORT_BY_TRIAL_ID: 'SORT_BY_TRIAL_ID',
  SORT_BY_BATCH_NUMBER: 'SORT_BY_BATCH_NUMBER',
  SORT_BY_END_TIME: 'SORT_BY_END_TIME',
  SORT_BY_STATE: 'SORT_BY_STATE',
  SORT_BY_SEARCHER_METRIC: 'SORT_BY_SEARCHER_METRIC',
} as const;

export type GetExperimentCheckpointsParams = {
/**
 * Sort by preset checkpoint attribute.

 - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.
 - SORT_BY_UUID: Returns checkpoints sorted by UUID.
 - SORT_BY_TRIAL_ID: Returns checkpoints sorted by trial id.
 - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.
 - SORT_BY_END_TIME: Returns checkpoints sorted by end time.
 - SORT_BY_STATE: Returns checkpoints sorted by state.
 - SORT_BY_SEARCHER_METRIC: Returns checkpoints sorted by the experiment's `searcher.metric`
configuration setting.
 */
sortByAttr?: GetExperimentCheckpointsSortByAttr;
/**
 * Sort by custom validation metric name.
 */
sortByMetric?: string;
/**
 * Order checkpoints in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetExperimentCheckpointsOrderBy;
/**
 * Skip the number of checkpoints before returning results. Negative values
denote number of checkpoints to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of checkpoints. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Limit the checkpoints to those that match the states.

 - STATE_UNSPECIFIED: The state of the checkpoint is unknown.
 - STATE_ACTIVE: The checkpoint is in an active state.
 - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.
 - STATE_ERROR: The checkpoint errored.
 - STATE_DELETED: The checkpoint has been deleted.
 - STATE_PARTIALLY_DELETED: The checkpoint has been partially deleted.
 */
states?: GetExperimentCheckpointsStatesItem[];
};

export type GetExperimentTrialsStatesItem = typeof GetExperimentTrialsStatesItem[keyof typeof GetExperimentTrialsStatesItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetExperimentTrialsStatesItem = {
  STATE_UNSPECIFIED: 'STATE_UNSPECIFIED',
  STATE_ACTIVE: 'STATE_ACTIVE',
  STATE_PAUSED: 'STATE_PAUSED',
  STATE_STOPPING_COMPLETED: 'STATE_STOPPING_COMPLETED',
  STATE_STOPPING_CANCELED: 'STATE_STOPPING_CANCELED',
  STATE_STOPPING_ERROR: 'STATE_STOPPING_ERROR',
  STATE_COMPLETED: 'STATE_COMPLETED',
  STATE_CANCELED: 'STATE_CANCELED',
  STATE_ERROR: 'STATE_ERROR',
  STATE_DELETED: 'STATE_DELETED',
  STATE_DELETING: 'STATE_DELETING',
  STATE_DELETE_FAILED: 'STATE_DELETE_FAILED',
  STATE_STOPPING_KILLED: 'STATE_STOPPING_KILLED',
  STATE_QUEUED: 'STATE_QUEUED',
  STATE_PULLING: 'STATE_PULLING',
  STATE_STARTING: 'STATE_STARTING',
  STATE_RUNNING: 'STATE_RUNNING',
} as const;

export type GetExperimentTrialsOrderBy = typeof GetExperimentTrialsOrderBy[keyof typeof GetExperimentTrialsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetExperimentTrialsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetExperimentTrialsSortBy = typeof GetExperimentTrialsSortBy[keyof typeof GetExperimentTrialsSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetExperimentTrialsSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_START_TIME: 'SORT_BY_START_TIME',
  SORT_BY_END_TIME: 'SORT_BY_END_TIME',
  SORT_BY_STATE: 'SORT_BY_STATE',
  SORT_BY_BEST_VALIDATION_METRIC: 'SORT_BY_BEST_VALIDATION_METRIC',
  SORT_BY_LATEST_VALIDATION_METRIC: 'SORT_BY_LATEST_VALIDATION_METRIC',
  SORT_BY_BATCHES_PROCESSED: 'SORT_BY_BATCHES_PROCESSED',
  SORT_BY_DURATION: 'SORT_BY_DURATION',
  SORT_BY_RESTARTS: 'SORT_BY_RESTARTS',
  SORT_BY_CHECKPOINT_SIZE: 'SORT_BY_CHECKPOINT_SIZE',
  SORT_BY_LOG_RETENTION_DAYS: 'SORT_BY_LOG_RETENTION_DAYS',
} as const;

export type GetExperimentTrialsParams = {
/**
 * Sort trials by the given field.

 - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.
 - SORT_BY_ID: Returns trials sorted by id.
 - SORT_BY_START_TIME: Return trials sorted by start time.
 - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are
returned after trials that are.
 - SORT_BY_STATE: Return trials sorted by state.
 - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is
specified by `searcher.metric` in the experiment configuration.
 - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is
specified by `searcher.metric` in the experiment configuration.
 - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.
 - SORT_BY_DURATION: Return the trials sorted by the total duration.
 - SORT_BY_RESTARTS: Return the trials sorted by the number of restarts.
 - SORT_BY_CHECKPOINT_SIZE: Return the trials sorted by checkpoint size.
 - SORT_BY_LOG_RETENTION_DAYS: Return the trials sorted by number of log retention days.
 */
sortBy?: GetExperimentTrialsSortBy;
/**
 * Order trials in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetExperimentTrialsOrderBy;
/**
 * Skip the number of trials before returning results. Negative values
denote number of trials to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of trials. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Limit trials to those that match the provided state.

 - STATE_UNSPECIFIED: The state of the experiment is unknown.
 - STATE_ACTIVE: The experiment is in an active state.
 - STATE_PAUSED: The experiment is in a paused state
 - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.
 - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.
 - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.
 - STATE_COMPLETED: The experiment is completed and is shut down.
 - STATE_CANCELED: The experiment is canceled and is shut down.
 - STATE_ERROR: The experiment is errored and is shut down.
 - STATE_DELETED: The experiment has been deleted.
 - STATE_DELETING: The experiment is deleting.
 - STATE_DELETE_FAILED: The experiment failed to delete.
 - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.
 - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued).
Queued is a substate of the Active state.
 - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active
state.
 - STATE_STARTING: The experiment is preparing the environment after finishing pulling the
image. Starting is a substate of the Active state.
 - STATE_RUNNING: The experiment has an allocation actively running.
Running is a substate of the Active state.
 */
states?: GetExperimentTrialsStatesItem[];
};

export type TrialsSnapshot200 = {
  error?: RuntimeStreamError;
  result?: V1TrialsSnapshotResponse;
};

export type TrialsSnapshotMetricType = typeof TrialsSnapshotMetricType[keyof typeof TrialsSnapshotMetricType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TrialsSnapshotMetricType = {
  METRIC_TYPE_UNSPECIFIED: 'METRIC_TYPE_UNSPECIFIED',
  METRIC_TYPE_TRAINING: 'METRIC_TYPE_TRAINING',
  METRIC_TYPE_VALIDATION: 'METRIC_TYPE_VALIDATION',
  METRIC_TYPE_PROFILING: 'METRIC_TYPE_PROFILING',
} as const;

export type TrialsSnapshotParams = {
/**
 * A metric name.
 */
metricName: string;
/**
 * The type of metric.

 - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).
 - METRIC_TYPE_TRAINING: For metrics emitted during training.
 - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
 - METRIC_TYPE_PROFILING: For metrics emitted during profiling.
 */
metricType?: TrialsSnapshotMetricType;
/**
 * Metric group (training, validation, etc).
 */
group?: string;
/**
 * The point of progress at which to query metrics.
 */
batchesProcessed: number;
/**
 * A range either side of batches_processed to include near-misses.
 */
batchesMargin?: number;
/**
 * Seconds to wait when polling for updates.
 */
periodSeconds?: number;
};

export type TrialsSample200 = {
  error?: RuntimeStreamError;
  result?: V1TrialsSampleResponse;
};

export type TrialsSampleMetricType = typeof TrialsSampleMetricType[keyof typeof TrialsSampleMetricType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TrialsSampleMetricType = {
  METRIC_TYPE_UNSPECIFIED: 'METRIC_TYPE_UNSPECIFIED',
  METRIC_TYPE_TRAINING: 'METRIC_TYPE_TRAINING',
  METRIC_TYPE_VALIDATION: 'METRIC_TYPE_VALIDATION',
  METRIC_TYPE_PROFILING: 'METRIC_TYPE_PROFILING',
} as const;

export type TrialsSampleParams = {
/**
 * A metric name.
 */
metricName: string;
/**
 * The type of metric.

 - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).
 - METRIC_TYPE_TRAINING: For metrics emitted during training.
 - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
 - METRIC_TYPE_PROFILING: For metrics emitted during profiling.
 */
metricType?: TrialsSampleMetricType;
/**
 * Metric group (training, validation, etc).
 */
group?: string;
/**
 * Maximum number of trials to fetch data for.
 */
maxTrials?: number;
/**
 * Maximum number of initial / historical data points.
 */
maxDatapoints?: number;
/**
 * Beginning of window (inclusive) to fetch data for.
 */
startBatches?: number;
/**
 * Ending of window (inclusive) to fetch data for.
 */
endBatches?: number;
/**
 * Seconds to wait when polling for updates.
 */
periodSeconds?: number;
};

export type MetricBatches200 = {
  error?: RuntimeStreamError;
  result?: V1MetricBatchesResponse;
};

export type MetricBatchesMetricType = typeof MetricBatchesMetricType[keyof typeof MetricBatchesMetricType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MetricBatchesMetricType = {
  METRIC_TYPE_UNSPECIFIED: 'METRIC_TYPE_UNSPECIFIED',
  METRIC_TYPE_TRAINING: 'METRIC_TYPE_TRAINING',
  METRIC_TYPE_VALIDATION: 'METRIC_TYPE_VALIDATION',
  METRIC_TYPE_PROFILING: 'METRIC_TYPE_PROFILING',
} as const;

export type MetricBatchesParams = {
/**
 * A metric name.
 */
metricName: string;
/**
 * The type of metric.

 - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).
 - METRIC_TYPE_TRAINING: For metrics emitted during training.
 - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
 - METRIC_TYPE_PROFILING: For metrics emitted during profiling.
 */
metricType?: MetricBatchesMetricType;
/**
 * Metric group (training, validation, etc).
 */
group?: string;
/**
 * Seconds to wait when polling for updates.
 */
periodSeconds?: number;
};

export type ExpMetricNames200 = {
  error?: RuntimeStreamError;
  result?: V1ExpMetricNamesResponse;
};

export type ExpMetricNamesParams = {
/**
 * The ids for the experiments.
 */
ids: number[];
/**
 * Seconds to wait when polling for updates.
 */
periodSeconds?: number;
};

export type GetExperimentsStatesItem = typeof GetExperimentsStatesItem[keyof typeof GetExperimentsStatesItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetExperimentsStatesItem = {
  STATE_UNSPECIFIED: 'STATE_UNSPECIFIED',
  STATE_ACTIVE: 'STATE_ACTIVE',
  STATE_PAUSED: 'STATE_PAUSED',
  STATE_STOPPING_COMPLETED: 'STATE_STOPPING_COMPLETED',
  STATE_STOPPING_CANCELED: 'STATE_STOPPING_CANCELED',
  STATE_STOPPING_ERROR: 'STATE_STOPPING_ERROR',
  STATE_COMPLETED: 'STATE_COMPLETED',
  STATE_CANCELED: 'STATE_CANCELED',
  STATE_ERROR: 'STATE_ERROR',
  STATE_DELETED: 'STATE_DELETED',
  STATE_DELETING: 'STATE_DELETING',
  STATE_DELETE_FAILED: 'STATE_DELETE_FAILED',
  STATE_STOPPING_KILLED: 'STATE_STOPPING_KILLED',
  STATE_QUEUED: 'STATE_QUEUED',
  STATE_PULLING: 'STATE_PULLING',
  STATE_STARTING: 'STATE_STARTING',
  STATE_RUNNING: 'STATE_RUNNING',
} as const;

export type GetExperimentsOrderBy = typeof GetExperimentsOrderBy[keyof typeof GetExperimentsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetExperimentsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetExperimentsSortBy = typeof GetExperimentsSortBy[keyof typeof GetExperimentsSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetExperimentsSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_START_TIME: 'SORT_BY_START_TIME',
  SORT_BY_END_TIME: 'SORT_BY_END_TIME',
  SORT_BY_STATE: 'SORT_BY_STATE',
  SORT_BY_NUM_TRIALS: 'SORT_BY_NUM_TRIALS',
  SORT_BY_PROGRESS: 'SORT_BY_PROGRESS',
  SORT_BY_USER: 'SORT_BY_USER',
  SORT_BY_NAME: 'SORT_BY_NAME',
  SORT_BY_FORKED_FROM: 'SORT_BY_FORKED_FROM',
  SORT_BY_RESOURCE_POOL: 'SORT_BY_RESOURCE_POOL',
  SORT_BY_PROJECT_ID: 'SORT_BY_PROJECT_ID',
  SORT_BY_CHECKPOINT_SIZE: 'SORT_BY_CHECKPOINT_SIZE',
  SORT_BY_CHECKPOINT_COUNT: 'SORT_BY_CHECKPOINT_COUNT',
  SORT_BY_SEARCHER_METRIC_VAL: 'SORT_BY_SEARCHER_METRIC_VAL',
} as const;

export type GetExperimentsParams = {
/**
 * Sort experiments by the given field.

 - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.
 - SORT_BY_ID: Returns experiments sorted by id.
 - SORT_BY_DESCRIPTION: Returns experiments sorted by description.
 - SORT_BY_START_TIME: Return experiments sorted by start time.
 - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end_time are
returned after the ones with end_time.
 - SORT_BY_STATE: Return experiments sorted by state.
 - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.
 - SORT_BY_PROGRESS: Return experiments sorted by progress.
 - SORT_BY_USER: Return experiments sorted by user.
 - SORT_BY_NAME: Returns experiments sorted by name.
 - SORT_BY_FORKED_FROM: Returns experiments sorted by originating model.
 - SORT_BY_RESOURCE_POOL: Returns experiments sorted by resource pool.
 - SORT_BY_PROJECT_ID: Returns experiments sorted by project.
 - SORT_BY_CHECKPOINT_SIZE: Returns experiments sorted by checkpoint size.
 - SORT_BY_CHECKPOINT_COUNT: Returns experiments sorted by checkpoint count.
 - SORT_BY_SEARCHER_METRIC_VAL: Returns experiments sorted by searcher metric value..
 */
sortBy?: GetExperimentsSortBy;
/**
 * Order experiments in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetExperimentsOrderBy;
/**
 * Skip the number of experiments before returning results. Negative values
denote number of experiments to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of experiments.
0 or Unspecified - returns a default of 100.
-1               - returns everything.
-2               - returns pagination info but no experiments.
 */
limit?: number;
/**
 * Limit experiments to those that match the description.
 */
description?: string;
/**
 * Limit experiments to those that match the name.
 */
name?: string;
/**
 * Limit experiments to those that match the provided labels.
 */
labels?: string[];
/**
 * Limit experiments to those that are archived.
 */
archived?: boolean;
/**
 * Limit experiments to those that match the provided state.

 - STATE_UNSPECIFIED: The state of the experiment is unknown.
 - STATE_ACTIVE: The experiment is in an active state.
 - STATE_PAUSED: The experiment is in a paused state
 - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.
 - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.
 - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.
 - STATE_COMPLETED: The experiment is completed and is shut down.
 - STATE_CANCELED: The experiment is canceled and is shut down.
 - STATE_ERROR: The experiment is errored and is shut down.
 - STATE_DELETED: The experiment has been deleted.
 - STATE_DELETING: The experiment is deleting.
 - STATE_DELETE_FAILED: The experiment failed to delete.
 - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.
 - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued).
Queued is a substate of the Active state.
 - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active
state.
 - STATE_STARTING: The experiment is preparing the environment after finishing pulling the
image. Starting is a substate of the Active state.
 - STATE_RUNNING: The experiment has an allocation actively running.
Running is a substate of the Active state.
 */
states?: GetExperimentsStatesItem[];
/**
 * Limit experiments to those that are owned by users with the specified
usernames.
 */
users?: string[];
/**
 * Limit experiments to those that are owned by users with the specified
userIds.
 */
userIds?: number[];
/**
 * Limit experiments to those within a specified project, or 0 for all
projects.
 */
projectId?: number;
/**
 * Less than.
 */
'experimentIdFilter.lt'?: number;
/**
 * Less than or equal.
 */
'experimentIdFilter.lte'?: number;
/**
 * Greater than.
 */
'experimentIdFilter.gt'?: number;
/**
 * Greater than or equal.
 */
'experimentIdFilter.gte'?: number;
/**
 * In a set. `in` is a reserved word in python.
 */
'experimentIdFilter.incl'?: number[];
/**
 * Not in a set.
 */
'experimentIdFilter.notIn'?: number[];
/**
 * whether to surface trial specific data from the best trial.
 */
showTrialData?: boolean;
};

export type GetExperimentLabelsParams = {
/**
 * Filter experiments by project.
 */
projectId?: number;
};

export type GetCommandsOrderBy = typeof GetCommandsOrderBy[keyof typeof GetCommandsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCommandsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetCommandsSortBy = typeof GetCommandsSortBy[keyof typeof GetCommandsSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCommandsSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_START_TIME: 'SORT_BY_START_TIME',
  SORT_BY_WORKSPACE_ID: 'SORT_BY_WORKSPACE_ID',
} as const;

export type GetCommandsParams = {
/**
 * Sort commands by the given field.

 - SORT_BY_UNSPECIFIED: Returns commands in an unsorted list.
 - SORT_BY_ID: Returns commands sorted by id.
 - SORT_BY_DESCRIPTION: Returns commands sorted by description.
 - SORT_BY_START_TIME: Return commands sorted by start time.
 - SORT_BY_WORKSPACE_ID: Return commands sorted by workspace_id.
 */
sortBy?: GetCommandsSortBy;
/**
 * Order commands in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetCommandsOrderBy;
/**
 * Skip the number of commands before returning results. Negative values
denote number of commands to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of commands. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * Limit commands to those that are owned by users with the specified
usernames.
 */
users?: string[];
/**
 * Limit commands to those that are owned by users with the specified userIds.
 */
userIds?: number[];
/**
 * Limit commands to those within a specific workspace, or 0 for all
accessible workspaces.
 */
workspaceId?: number;
};

export type GetTrialMetricsByCheckpointTrialSourceInfoType = typeof GetTrialMetricsByCheckpointTrialSourceInfoType[keyof typeof GetTrialMetricsByCheckpointTrialSourceInfoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTrialMetricsByCheckpointTrialSourceInfoType = {
  TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: 'TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED',
  TRIAL_SOURCE_INFO_TYPE_INFERENCE: 'TRIAL_SOURCE_INFO_TYPE_INFERENCE',
  TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: 'TRIAL_SOURCE_INFO_TYPE_FINE_TUNING',
} as const;

export type GetTrialMetricsByCheckpointParams = {
/**
 * Type of the TrialSourceInfo.

 - TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: The type is unspecified
 - TRIAL_SOURCE_INFO_TYPE_INFERENCE: "Inference" Trial Source Info Type, used for batch inference
 - TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: "Fine Tuning" Trial Source Info Type, used in model hub
 */
trialSourceInfoType?: GetTrialMetricsByCheckpointTrialSourceInfoType;
/**
 * Metric Group string ("training", "validation", or anything else) (nil means
all groups).
 */
metricGroup?: string;
};

export type AllocationPreemptionSignalParams = {
/**
 * The timeout in seconds.
 */
timeoutSeconds?: number;
};

export type GetAgentsOrderBy = typeof GetAgentsOrderBy[keyof typeof GetAgentsOrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetAgentsOrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type GetAgentsSortBy = typeof GetAgentsSortBy[keyof typeof GetAgentsSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetAgentsSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_TIME: 'SORT_BY_TIME',
} as const;

export type GetAgentsParams = {
/**
 * Sort agents by the given field.

 - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.
 - SORT_BY_ID: Returns agents sorted by id.
 - SORT_BY_TIME: Returns agents sorted by time.
 */
sortBy?: GetAgentsSortBy;
/**
 * Order agents in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
orderBy?: GetAgentsOrderBy;
/**
 * Skip the number of agents before returning results. Negative values
denote number of agents to skip from the end before returning results.
 */
offset?: number;
/**
 * Limit the number of agents. A value of 0 denotes no limit.
 */
limit?: number;
/**
 * exclude slots.
 */
excludeSlots?: boolean;
/**
 * exclude containers.
 */
excludeContainers?: boolean;
};

/**
 * The training metrics to persist.
 */
export type V1TrialMetricsBody = V1TrialMetrics;

/**
 * The template to put.
 */
export type V1TemplateBody = V1Template;

export type HealthStatus = typeof HealthStatus[keyof typeof HealthStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HealthStatus = {
  up: 'up',
  down: 'down',
} as const;

export interface ResourceManagerHealth {
  cluster_name?: string;
  status?: HealthStatus;
}

export interface HealthCheck {
  database?: HealthStatus;
  resource_managers?: ResourceManagerHealth[];
  status?: HealthStatus;
}

/**
 * - STATE_UNSPECIFIED: The trial is in an unspecified state.
 - STATE_ACTIVE: The trial is in an active state.
 - STATE_PAUSED: The trial is in a paused state
 - STATE_STOPPING_CANCELED: The trial is canceled and is shutting down.
 - STATE_STOPPING_KILLED: The trial is killed and is shutting down.
 - STATE_STOPPING_COMPLETED: The trial is completed and is shutting down.
 - STATE_STOPPING_ERROR: The trial is errored and is shutting down.
 - STATE_CANCELED: The trial is canceled and is shut down.
 - STATE_COMPLETED: The trial is completed and is shut down.
 - STATE_ERROR: The trial is errored and is shut down.
 - STATE_QUEUED: The trial is queued (waiting to be run, or job state is still queued).
Queued is a substate of the Active state.
 - STATE_PULLING: The trial is pulling the image. Pulling is a substate of the Active
state.
 - STATE_STARTING: The trial is preparing the environment after finishing pulling the
image. Starting is a substate of the Active state.
 - STATE_RUNNING: The trial's allocation is actively running.
Running is a substate of the Active state.
 */
export type Trialv1State = typeof Trialv1State[keyof typeof Trialv1State];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Trialv1State = {
  STATE_UNSPECIFIED: 'STATE_UNSPECIFIED',
  STATE_ACTIVE: 'STATE_ACTIVE',
  STATE_PAUSED: 'STATE_PAUSED',
  STATE_STOPPING_CANCELED: 'STATE_STOPPING_CANCELED',
  STATE_STOPPING_KILLED: 'STATE_STOPPING_KILLED',
  STATE_STOPPING_COMPLETED: 'STATE_STOPPING_COMPLETED',
  STATE_STOPPING_ERROR: 'STATE_STOPPING_ERROR',
  STATE_CANCELED: 'STATE_CANCELED',
  STATE_COMPLETED: 'STATE_COMPLETED',
  STATE_ERROR: 'STATE_ERROR',
  STATE_QUEUED: 'STATE_QUEUED',
  STATE_PULLING: 'STATE_PULLING',
  STATE_STARTING: 'STATE_STARTING',
  STATE_RUNNING: 'STATE_RUNNING',
} as const;

/**
 * The current state of the task.

 - STATE_UNSPECIFIED: The task state is unknown.
 - STATE_PULLING: The task's base image is being pulled from the Docker registry.
 - STATE_STARTING: The image has been pulled and the task is being started, but the task is
not ready yet.
 - STATE_RUNNING: The service in the task is running.
 - STATE_TERMINATED: The task has exited or has been aborted.
 - STATE_TERMINATING: The task has begun to exit.
 - STATE_WAITING: The task is waiting on something to complete.
 - STATE_QUEUED: Additional state to cover queueing operations.
 */
export type Taskv1State = typeof Taskv1State[keyof typeof Taskv1State];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Taskv1State = {
  STATE_UNSPECIFIED: 'STATE_UNSPECIFIED',
  STATE_PULLING: 'STATE_PULLING',
  STATE_STARTING: 'STATE_STARTING',
  STATE_RUNNING: 'STATE_RUNNING',
  STATE_TERMINATED: 'STATE_TERMINATED',
  STATE_TERMINATING: 'STATE_TERMINATING',
  STATE_WAITING: 'STATE_WAITING',
  STATE_QUEUED: 'STATE_QUEUED',
} as const;

/**
 * Job type.

 - TYPE_UNSPECIFIED: Unspecified state.
 - TYPE_EXPERIMENT: Experiement Job.
 - TYPE_NOTEBOOK: Jupyter Notebook Job.
 - TYPE_TENSORBOARD: TensorBoard Job.
 - TYPE_SHELL: Shell Job.
 - TYPE_COMMAND: Command Job.
 - TYPE_CHECKPOINT_GC: CheckpointGC Job.
 - TYPE_EXTERNAL: External Job.
 - TYPE_GENERIC: Generic Job.
 */
export type Jobv1Type = typeof Jobv1Type[keyof typeof Jobv1Type];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Jobv1Type = {
  TYPE_UNSPECIFIED: 'TYPE_UNSPECIFIED',
  TYPE_EXPERIMENT: 'TYPE_EXPERIMENT',
  TYPE_NOTEBOOK: 'TYPE_NOTEBOOK',
  TYPE_TENSORBOARD: 'TYPE_TENSORBOARD',
  TYPE_SHELL: 'TYPE_SHELL',
  TYPE_COMMAND: 'TYPE_COMMAND',
  TYPE_CHECKPOINT_GC: 'TYPE_CHECKPOINT_GC',
  TYPE_EXTERNAL: 'TYPE_EXTERNAL',
  TYPE_GENERIC: 'TYPE_GENERIC',
} as const;

/**
 * Job state.

 - STATE_UNSPECIFIED: Unspecified state.
 - STATE_QUEUED: Job is queued and waiting to be schedlued.
 - STATE_SCHEDULED: Job is scheduled.
 - STATE_SCHEDULED_BACKFILLED: Job is scheduled as a backfill.
 */
export type Jobv1State = typeof Jobv1State[keyof typeof Jobv1State];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Jobv1State = {
  STATE_UNSPECIFIED: 'STATE_UNSPECIFIED',
  STATE_QUEUED: 'STATE_QUEUED',
  STATE_SCHEDULED: 'STATE_SCHEDULED',
  STATE_SCHEDULED_BACKFILLED: 'STATE_SCHEDULED_BACKFILLED',
} as const;

/**
 * The current state of the experiment.

 - STATE_UNSPECIFIED: The state of the experiment is unknown.
 - STATE_ACTIVE: The experiment is in an active state.
 - STATE_PAUSED: The experiment is in a paused state
 - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.
 - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.
 - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.
 - STATE_COMPLETED: The experiment is completed and is shut down.
 - STATE_CANCELED: The experiment is canceled and is shut down.
 - STATE_ERROR: The experiment is errored and is shut down.
 - STATE_DELETED: The experiment has been deleted.
 - STATE_DELETING: The experiment is deleting.
 - STATE_DELETE_FAILED: The experiment failed to delete.
 - STATE_STOPPING_KILLED: The experiment is killed and is shutting down.
 - STATE_QUEUED: The experiment is queued (waiting to be run, or job state is still queued).
Queued is a substate of the Active state.
 - STATE_PULLING: The experiment is pulling the image. Pulling is a substate of the Active
state.
 - STATE_STARTING: The experiment is preparing the environment after finishing pulling the
image. Starting is a substate of the Active state.
 - STATE_RUNNING: The experiment has an allocation actively running.
Running is a substate of the Active state.
 */
export type Experimentv1State = typeof Experimentv1State[keyof typeof Experimentv1State];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Experimentv1State = {
  STATE_UNSPECIFIED: 'STATE_UNSPECIFIED',
  STATE_ACTIVE: 'STATE_ACTIVE',
  STATE_PAUSED: 'STATE_PAUSED',
  STATE_STOPPING_COMPLETED: 'STATE_STOPPING_COMPLETED',
  STATE_STOPPING_CANCELED: 'STATE_STOPPING_CANCELED',
  STATE_STOPPING_ERROR: 'STATE_STOPPING_ERROR',
  STATE_COMPLETED: 'STATE_COMPLETED',
  STATE_CANCELED: 'STATE_CANCELED',
  STATE_ERROR: 'STATE_ERROR',
  STATE_DELETED: 'STATE_DELETED',
  STATE_DELETING: 'STATE_DELETING',
  STATE_DELETE_FAILED: 'STATE_DELETE_FAILED',
  STATE_STOPPING_KILLED: 'STATE_STOPPING_KILLED',
  STATE_QUEUED: 'STATE_QUEUED',
  STATE_PULLING: 'STATE_PULLING',
  STATE_STARTING: 'STATE_STARTING',
  STATE_RUNNING: 'STATE_RUNNING',
} as const;

/**
 * The type of the Device.

 - TYPE_UNSPECIFIED: An unspecified device type.
 - TYPE_CPU: A CPU device.
 - TYPE_CUDA: CUDA device.
 - TYPE_ROCM: ROCM.
 */
export type Devicev1Type = typeof Devicev1Type[keyof typeof Devicev1Type];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Devicev1Type = {
  TYPE_UNSPECIFIED: 'TYPE_UNSPECIFIED',
  TYPE_CPU: 'TYPE_CPU',
  TYPE_CUDA: 'TYPE_CUDA',
  TYPE_ROCM: 'TYPE_ROCM',
} as const;

/**
 * The current state of the container.

 - STATE_UNSPECIFIED: The container state is unknown.
 - STATE_ASSIGNED: The container has been assigned to an agent but has not started yet.
 - STATE_PULLING: The container's base image is being pulled from the Docker registry.
 - STATE_STARTING: The image has been built and the container is being started, but the
service in the container is not ready yet.
 - STATE_RUNNING: The service in the container is able to accept requests.
 - STATE_TERMINATED: The container has completely exited or the container has been aborted prior
to getting assigned.
 */
export type Containerv1State = typeof Containerv1State[keyof typeof Containerv1State];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Containerv1State = {
  STATE_UNSPECIFIED: 'STATE_UNSPECIFIED',
  STATE_ASSIGNED: 'STATE_ASSIGNED',
  STATE_PULLING: 'STATE_PULLING',
  STATE_STARTING: 'STATE_STARTING',
  STATE_RUNNING: 'STATE_RUNNING',
  STATE_TERMINATED: 'STATE_TERMINATED',
} as const;

/**
 * The current state of the checkpoint.

 - STATE_UNSPECIFIED: The state of the checkpoint is unknown.
 - STATE_ACTIVE: The checkpoint is in an active state.
 - STATE_COMPLETED: The checkpoint is persisted to checkpoint storage.
 - STATE_ERROR: The checkpoint errored.
 - STATE_DELETED: The checkpoint has been deleted.
 - STATE_PARTIALLY_DELETED: The checkpoint has been partially deleted.
 */
export type Checkpointv1State = typeof Checkpointv1State[keyof typeof Checkpointv1State];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Checkpointv1State = {
  STATE_UNSPECIFIED: 'STATE_UNSPECIFIED',
  STATE_ACTIVE: 'STATE_ACTIVE',
  STATE_COMPLETED: 'STATE_COMPLETED',
  STATE_ERROR: 'STATE_ERROR',
  STATE_DELETED: 'STATE_DELETED',
  STATE_PARTIALLY_DELETED: 'STATE_PARTIALLY_DELETED',
} as const;

/**
 * WorkspaceState is used to track progress during a deletion.

 - WORKSPACE_STATE_UNSPECIFIED: Object deletion is not in progress.
 - WORKSPACE_STATE_DELETING: The object is being deleted.
 - WORKSPACE_STATE_DELETE_FAILED: The object failed to delete.
 - WORKSPACE_STATE_DELETED: The object finished deleting.
 */
export type V1WorkspaceState = typeof V1WorkspaceState[keyof typeof V1WorkspaceState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1WorkspaceState = {
  WORKSPACE_STATE_UNSPECIFIED: 'WORKSPACE_STATE_UNSPECIFIED',
  WORKSPACE_STATE_DELETING: 'WORKSPACE_STATE_DELETING',
  WORKSPACE_STATE_DELETE_FAILED: 'WORKSPACE_STATE_DELETE_FAILED',
  WORKSPACE_STATE_DELETED: 'WORKSPACE_STATE_DELETED',
} as const;

/**
 * WorkspaceNamespaceMeta is the metadata associated with a workspace-namespace
binding.
 */
export interface V1WorkspaceNamespaceMeta {
  /** Whether we want to auto-create a namespace for a workspace-namespace
binding. */
  autoCreateNamespace?: boolean;
  /** Whether we want to auto-create a namespace for each cluster's
workspace-namespace binding. */
  autoCreateNamespaceAllClusters?: boolean;
  /** The cluster to which we apply the workspace-namespace binding or resource
quota. */
  clusterName?: string;
  /** The optional namespace of the workspace-namespace binding. */
  namespace?: string;
  /** The optional resource quota placed on the namespace (and consequentially,
the workspace).
TODO (CM-495): Remove this field and use GetKubernetesResourceQuotasRequest
instead. */
  resourceQuota?: number;
}

/**
 * WorkspaceNamespace represents a workspace-namespace binding for a given
workspace and cluster.
 */
export interface V1WorkspaceNamespaceBinding {
  /** Whether the namespace was auto-created for a workspace-namespace
binding. */
  autoCreateNamespace?: boolean;
  /** User cluster name. */
  clusterName?: string;
  /** The Kubernetes namespace. */
  namespace?: string;
  /** The id of the workspace. */
  workspaceId?: number;
}

/**
 * Optional checkpoint storage config.
Expects same format as experiment config's checkpoint storage.
 */
export type V1WorkspaceCheckpointStorageConfig = { [key: string]: unknown };

/**
 * Workspace is a named collection of projects.
 */
export interface V1Workspace {
  agentUserGroup?: V1AgentUserGroup;
  /** Whether this workspace is archived or not. */
  archived: boolean;
  /** Optional auto-created namespace bound to the workspace. */
  autoCreatedNamespace?: string;
  /** Optional checkpoint storage config.
Expects same format as experiment config's checkpoint storage. */
  checkpointStorageConfig?: V1WorkspaceCheckpointStorageConfig;
  /** Name of the default aux pool. */
  defaultAuxPool?: string;
  /** Name of the default compute pool. */
  defaultComputePool?: string;
  /** Message stored from errors on async-deleting a workspace. */
  errorMessage: string;
  /** The unique id of the workspace. */
  id: number;
  /** Whether this workspace is immutable (default uncategorized workspace). */
  immutable: boolean;
  /**
   * The unique name of the workspace.
   * @minLength 1
   */
  name: string;
  /** Number of experiments associated with this workspace. */
  numExperiments: number;
  /** Number of projects associated with this workspace. */
  numProjects: number;
  /** Pin status of this workspace for the current user. */
  pinned: boolean;
  /** Optional date when workspace was pinned. */
  pinnedAt?: string;
  state: V1WorkspaceState;
  /** ID of the user who created this project. */
  userId: number;
  /** User who created this workspace. */
  username: string;
}

/**
 * WorkloadContainer is a wrapper for Determined workloads to allow repeated
oneof types.
 */
export interface V1WorkloadContainer {
  checkpoint?: V1CheckpointWorkload;
  training?: V1MetricsWorkload;
  validation?: V1MetricsWorkload;
}

/**
 * Enum values for expected webhook types.

 - WEBHOOK_TYPE_UNSPECIFIED: Default value
 - WEBHOOK_TYPE_DEFAULT: For a default webhook
 - WEBHOOK_TYPE_SLACK: For a slack webhook.
 */
export type V1WebhookType = typeof V1WebhookType[keyof typeof V1WebhookType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1WebhookType = {
  WEBHOOK_TYPE_UNSPECIFIED: 'WEBHOOK_TYPE_UNSPECIFIED',
  WEBHOOK_TYPE_DEFAULT: 'WEBHOOK_TYPE_DEFAULT',
  WEBHOOK_TYPE_SLACK: 'WEBHOOK_TYPE_SLACK',
} as const;

/**
 * Enum values for webhook mode.

 - WEBHOOK_MODE_UNSPECIFIED: Default value
 - WEBHOOK_MODE_WORKSPACE: Webhook will be triggered by all experiment in the workspace
 - WEBHOOK_MODE_SPECIFIC: Webhook will only be triggered by experiment with matching configuration in
the same workspace as the web hook
 */
export type V1WebhookMode = typeof V1WebhookMode[keyof typeof V1WebhookMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1WebhookMode = {
  WEBHOOK_MODE_UNSPECIFIED: 'WEBHOOK_MODE_UNSPECIFIED',
  WEBHOOK_MODE_WORKSPACE: 'WEBHOOK_MODE_WORKSPACE',
  WEBHOOK_MODE_SPECIFIC: 'WEBHOOK_MODE_SPECIFIC',
} as const;

export interface V1Webhook {
  /** The id of the webhook. */
  id?: number;
  mode: V1WebhookMode;
  /** The name of the webhook. */
  name: string;
  /** The triggers of the webhook. */
  triggers?: V1Trigger[];
  /** The url of the webhook. */
  url: string;
  webhookType: V1WebhookType;
  /** The workspace of the webhook. */
  workspaceId?: number;
}

/**
 * ValidationHistoryEntry is a single entry for a validation history for an
experiment.
 */
export interface V1ValidationHistoryEntry {
  /** The time at which the completed validation was reported. */
  endTime: string;
  /** The value of the `searcher.metric`, indicated by the experiment config, for
the validation. */
  searcherMetric: number;
  /** The id for the trial associated with this validation entry. */
  trialId: number;
}

/**
 * UserWebSetting represents user web setting.
 */
export interface V1UserWebSetting {
  /** The key of setting. */
  key: string;
  /** The storage path of setting. */
  storagePath?: string;
  /** The value of setting. */
  value?: string;
}

/**
 * UserRoleAssignment contains information about the users
belonging to a role.
 */
export interface V1UserRoleAssignment {
  roleAssignment: V1RoleAssignment;
  userId: number;
}

/**
 * Options to filter a subset of users.
 */
export interface V1UserFilters {
  /** Matches users with or without an admin flag. */
  admin?: boolean;
  /** Case-insensitive partial match of string to username or display name. */
  name?: string;
}

/**
 * Message for results of individual users in a multi-user action.
 */
export interface V1UserActionResult {
  /** Optional error message. */
  error: string;
  /** User ID. */
  id: number;
}

/**
 * User is an account in the determined cluster.
 */
export interface V1User {
  /** Bool denoting whether the account is active. */
  active: boolean;
  /** Bool denoting whether the account is an admin account. */
  admin: boolean;
  agentUserGroup?: V1AgentUserGroup;
  /** Name to display in the web UI. */
  displayName?: string;
  /** The user ID. */
  id?: number;
  lastAuthAt?: string;
  /** The version of the user object for caching purposes. */
  modifiedAt?: string;
  /** Bool denoting whether the user should be able to login with or change a
password. */
  remote?: boolean;
  /** The user login name of the user. */
  username: string;
}

/**
 * Response to UpdateJobQueueRequest.
 */
export interface V1UpdateJobQueueResponse { [key: string]: unknown }

/**
 * Request to update the job queue.
 */
export interface V1UpdateJobQueueRequest {
  /** List of job queue control requests. */
  updates: V1QueueControl[];
}

/**
 * UpdateGroupResponse is the body of the response for the call
to update a group and its members.
 */
export interface V1UpdateGroupResponse {
  group: V1GroupDetails;
}

/**
 * UpdateGroupRequest is the body of the request for the call
to update a group and its members.
 */
export interface V1UpdateGroupRequest {
  addUsers?: number[];
  groupId: number;
  name?: string;
  removeUsers?: number[];
}

/**
 * Response to UnpinWorkspaceRequest.
 */
export interface V1UnpinWorkspaceResponse { [key: string]: unknown }

export interface V1UnpauseGenericTaskResponse { [key: string]: unknown }

/**
 * Unbind a resource pool to workspaces response.
 */
export interface V1UnbindRPFromWorkspaceResponse { [key: string]: unknown }

/**
 * Unbind a resource pool to workspaces.
 */
export interface V1UnbindRPFromWorkspaceRequest {
  /** The resource pool name. */
  resourcePoolName: string;
  /** The workspace IDs to be unbound. */
  workspaceIds?: number[];
  /** The workspace names to be unbound. */
  workspaceNames?: string[];
}

/**
 * Response to UnarchiveWorkspaceRequest.
 */
export interface V1UnarchiveWorkspaceResponse { [key: string]: unknown }

/**
 * Response to UnarchiveSearchesRequest.
 */
export interface V1UnarchiveSearchesResponse {
  /** Details on success or error for each search. */
  results: V1SearchActionResult[];
}

export interface V1UnarchiveSearchesRequest {
  filter?: string;
  /** The id of the current parent project. */
  projectId: number;
  /** The ids of the searches being unarchived. Leave empty if using filter. */
  searchIds?: number[];
}

/**
 * Response to UnarchiveRunsRequest.
 */
export interface V1UnarchiveRunsResponse {
  /** Details on success or error for each run. */
  results: V1RunActionResult[];
}

export interface V1UnarchiveRunsRequest {
  filter?: string;
  /** The id of the current parent project. */
  projectId: number;
  /** The ids of the runs being unarchived. Leave empty if using filter. */
  runIds?: number[];
}

/**
 * Response to UnarchiveProjectRequest.
 */
export interface V1UnarchiveProjectResponse { [key: string]: unknown }

export interface V1UnarchiveModelResponse { [key: string]: unknown }

/**
 * Response to UnarchiveExperimentsRequest.
 */
export interface V1UnarchiveExperimentsResponse {
  /** Details on success or error for each experiment. */
  results: V1ExperimentActionResult[];
}

/**
 * Unarchive multiple experiments.
 */
export interface V1UnarchiveExperimentsRequest {
  /** Selecting experiments by id. */
  experimentIds: number[];
  filters?: V1BulkExperimentFilters;
  /** Project id that the experiments belong to. */
  projectId: number;
}

/**
 * Response to UnarchiveExperimentRequest.
 */
export interface V1UnarchiveExperimentResponse { [key: string]: unknown }

/**
 * Enum values for expected trigger types.

 - TRIGGER_TYPE_UNSPECIFIED: Default value
 - TRIGGER_TYPE_EXPERIMENT_STATE_CHANGE: For an experiment changing state
 - TRIGGER_TYPE_METRIC_THRESHOLD_EXCEEDED: For metrics emitted during training.
 - TRIGGER_TYPE_TASK_LOG: For task logs.
 - TRIGGER_TYPE_CUSTOM: For custom alert.
 */
export type V1TriggerType = typeof V1TriggerType[keyof typeof V1TriggerType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1TriggerType = {
  TRIGGER_TYPE_UNSPECIFIED: 'TRIGGER_TYPE_UNSPECIFIED',
  TRIGGER_TYPE_EXPERIMENT_STATE_CHANGE: 'TRIGGER_TYPE_EXPERIMENT_STATE_CHANGE',
  TRIGGER_TYPE_METRIC_THRESHOLD_EXCEEDED: 'TRIGGER_TYPE_METRIC_THRESHOLD_EXCEEDED',
  TRIGGER_TYPE_TASK_LOG: 'TRIGGER_TYPE_TASK_LOG',
  TRIGGER_TYPE_CUSTOM: 'TRIGGER_TYPE_CUSTOM',
} as const;

export type V1TriggerCondition = { [key: string]: unknown };

export interface V1Trigger {
  condition?: V1TriggerCondition;
  /** The id of the trigger. */
  id?: number;
  triggerType?: V1TriggerType;
  /** The parent webhook of the trigger. */
  webhookId?: number;
}

/**
 * A dictionary of hyperparameter values for this trial.
 */
export type V1TrialsSnapshotResponseTrialHparams = { [key: string]: unknown };

/**
 * Metric value and metadata for a trial that has progress this far.
 */
export interface V1TrialsSnapshotResponseTrial {
  /** The number of batches processed for this particular datapoint. */
  batchesProcessed: number;
  /** A dictionary of hyperparameter values for this trial. */
  hparams: V1TrialsSnapshotResponseTrialHparams;
  /** The value of the metric in this trial at this point. */
  metric: number;
  /** The id of the trial. */
  trialId: number;
}

export interface V1TrialsSnapshotResponse {
  /** A list of trials. */
  trials: V1TrialsSnapshotResponseTrial[];
}

/**
 * Hyperparamters values for this specific trial.
 */
export type V1TrialsSampleResponseTrialHparams = { [key: string]: unknown };

/**
 * Metadata and metrics stream from a trial.
 */
export interface V1TrialsSampleResponseTrial {
  /** A possibly down-sampled series of metric readings through the progress of
the trial. */
  data: V1DataPoint[];
  /** Hyperparamters values for this specific trial. */
  hparams: V1TrialsSampleResponseTrialHparams;
  /** The id of the trial. */
  trialId: number;
}

export interface V1TrialsSampleResponse {
  /** IDs of trials that are no longer included in the top N trials. */
  demotedTrials: number[];
  /** IDs of trials that are newly included in the data. */
  promotedTrials: number[];
  /** A historical or incremental series of data points for the trials. */
  trials: V1TrialsSampleResponseTrial[];
}

/**
 * TrialSummary describes the runs that are estimated to train for a certain
length.
 */
export interface V1TrialSummary {
  /** Number of trials. */
  count: number;
  unit: V1SearchUnit;
}

/**
 * - TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: The type is unspecified
 - TRIAL_SOURCE_INFO_TYPE_INFERENCE: "Inference" Trial Source Info Type, used for batch inference
 - TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: "Fine Tuning" Trial Source Info Type, used in model hub
 */
export type V1TrialSourceInfoType = typeof V1TrialSourceInfoType[keyof typeof V1TrialSourceInfoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1TrialSourceInfoType = {
  TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED: 'TRIAL_SOURCE_INFO_TYPE_UNSPECIFIED',
  TRIAL_SOURCE_INFO_TYPE_INFERENCE: 'TRIAL_SOURCE_INFO_TYPE_INFERENCE',
  TRIAL_SOURCE_INFO_TYPE_FINE_TUNING: 'TRIAL_SOURCE_INFO_TYPE_FINE_TUNING',
} as const;

export interface V1TrialSourceInfo {
  /** UUID of the checkpoint. */
  checkpointUuid: string;
  modelId?: number;
  modelVersion?: number;
  /** ID of the trial. */
  trialId: number;
  trialSourceInfoType: V1TrialSourceInfoType;
}

/**
 * The metadata pertaining to the current running task for a trial.
 */
export interface V1TrialRunnerMetadata {
  /** The state of the trial runner. */
  state: string;
}

export interface V1TrialProfilerMetricLabels {
  /** The agent ID associated with the metric. */
  agentId?: string;
  /** The GPU UUID associated with the metric. */
  gpuUuid?: string;
  metricType?: TrialProfilerMetricLabelsProfilerMetricType;
  /** The name of the metric. */
  name: string;
  /** The ID of the trial. */
  trialId: number;
}

/**
 * TrialProfilerMetricsBatch is a batch of trial profiler metrics. A batch will
contain metrics pertaining to a single series. The fields values, batches and
timestamps will be equal length arrays with each index corresponding to a
reading.
 */
export interface V1TrialProfilerMetricsBatch {
  /** The batch at which a reading occurred, repeated for the batch of metrics. */
  batches: number[];
  labels: V1TrialProfilerMetricLabels;
  /** The timestamp at which a reading occurred, repeated for the batch of
metrics. */
  timestamps: string[];
  /** The measurement for a reading, repeated for the batch of metrics. */
  values: number[];
}

/**
 * Metrics from the trial some duration of training.
 */
export interface V1TrialMetrics {
  metrics: V1Metrics;
  /** The client-reported time associated with these metrics. */
  reportTime?: string;
  /** The number of batches trained on when these metrics were reported. */
  stepsCompleted?: number;
  /** The trial associated with these metrics. */
  trialId: number;
  /** The trial run associated with these metrics. */
  trialRunId: number;
}

/**
 * Response to TrialLogsRequest.
 */
export interface V1TrialLogsResponse {
  /** The ID of the agent that logged this. */
  agentId?: string;
  /** The ID of the container or, in the case of k8s, the pod name. */
  containerId?: string;
  /** The ID of the trial log. */
  id: string;
  level: V1LogLevel;
  /** The text of the log entry. */
  log?: string;
  /** The flat version of the log that UIs have shown historically. */
  message: string;
  /** The rank ID. */
  rankId?: number;
  /** The source of the log entry. */
  source?: string;
  /** The output stream (e.g. stdout, stderr). */
  stdtype?: string;
  /** The timestamp of the log. */
  timestamp: string;
  /** The ID of the trial associated with this log entry. */
  trialId: number;
}

/**
 * Response to TrialLogFieldsRequest.
 */
export interface V1TrialLogsFieldsResponse {
  /** The distinct agent IDs present in the logs. */
  agentIds?: string[];
  /** The distinct container IDs present in the logs. */
  containerIds?: string[];
  /** The distinct rank IDs present in the logs. */
  rankIds?: number[];
  /** The distinct sources present in the logs. */
  sources?: string[];
  /** The distinct stdtypes present in the logs. */
  stdtypes?: string[];
}

/**
 * The reason for an early exit.

 - EXITED_REASON_UNSPECIFIED: Zero-value (not allowed).
 - EXITED_REASON_INVALID_HP: Indicates the trial exited due to an invalid hyperparameter.
 - EXITED_REASON_INIT_INVALID_HP: Indicates the trial exited due to an invalid hyperparameter
in the trial init.
 */
export type V1TrialEarlyExitExitedReason = typeof V1TrialEarlyExitExitedReason[keyof typeof V1TrialEarlyExitExitedReason];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1TrialEarlyExitExitedReason = {
  EXITED_REASON_UNSPECIFIED: 'EXITED_REASON_UNSPECIFIED',
  EXITED_REASON_INVALID_HP: 'EXITED_REASON_INVALID_HP',
  EXITED_REASON_INIT_INVALID_HP: 'EXITED_REASON_INIT_INVALID_HP',
} as const;

/**
 * Signals to the experiment the trial early exited.
 */
export interface V1TrialEarlyExit {
  reason: V1TrialEarlyExitExitedReason;
}

/**
 * Token type.

 - TOKEN_TYPE_UNSPECIFIED: Default token type.
 - TOKEN_TYPE_USER_SESSION: User Session token.
 - TOKEN_TYPE_ACCESS_TOKEN: Access token.
 */
export type V1TokenType = typeof V1TokenType[keyof typeof V1TokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1TokenType = {
  TOKEN_TYPE_UNSPECIFIED: 'TOKEN_TYPE_UNSPECIFIED',
  TOKEN_TYPE_USER_SESSION: 'TOKEN_TYPE_USER_SESSION',
  TOKEN_TYPE_ACCESS_TOKEN: 'TOKEN_TYPE_ACCESS_TOKEN',
} as const;

/**
 * TokenInfo represents a token entry in the database.
 */
export interface V1TokenInfo {
  /** Tiemstamp of when the token was created. */
  createdAt?: string;
  /** Description of the token. */
  description?: string;
  /** Timestamp of when the token expires. */
  expiry?: string;
  /** The token ID. */
  id: number;
  /** Flag denoting if this token is revoked. */
  revoked?: boolean;
  tokenType?: V1TokenType;
  /** The id of the user the token belongs to. */
  userId: number;
}

/**
 * Timestamp filters.
 */
export interface V1TimestampFieldFilter {
  /** Greater than. */
  gt?: string;
  /** Greater than or equal. */
  gte?: string;
  /** Less than. */
  lt?: string;
  /** Less than or equal. */
  lte?: string;
}

/**
 * Response to TestWebhookRequest.
 */
export interface V1TestWebhookResponse {
  /** Status of test. */
  completed: boolean;
}

/**
 * Tensorboard is a tensorboard instance in a containerized environment.
 */
export interface V1Tensorboard {
  container?: V1Container;
  /** The description of the tensorboard. */
  description: string;
  /** The display name of the user that created the tensorboard. */
  displayName?: string;
  exitStatus?: string;
  /** The experiment ids loaded into this tensorboard instance. */
  experimentIds?: number[];
  /** The id of the tensorboard. */
  id: string;
  /** The associated job id. */
  jobId: string;
  resourcePool: string;
  /** The service address. */
  serviceAddress?: string;
  /** The time the tensorboard was started. */
  startTime: string;
  state: Taskv1State;
  /** The trial ids loaded into this tensorboard instance. */
  trialIds?: number[];
  /** The id of the user that created the tensorboard. */
  userId?: number;
  /** The username of the user that created the tensorboard. */
  username: string;
  /** The workspace id. */
  workspaceId: number;
}

/**
 * The template value.
 */
export type V1TemplateConfig = { [key: string]: unknown };

/**
 * Templates move settings that are shared by many experiments into a single
YAML file.
 */
export interface V1Template {
  /** The template value. */
  config: V1TemplateConfig;
  /** The name of the template. */
  name: string;
  /** The id of the workspace associated with this model. */
  workspaceId: number;
}

/**
 * - TASK_TYPE_UNSPECIFIED: The task type is unknown
 - TASK_TYPE_TRIAL: "TRIAL" task type for the enum public.task_type in Postgres.
 - TASK_TYPE_NOTEBOOK: "NOTEBOOK" task type for the enum public.task_type in Postgres.
 - TASK_TYPE_SHELL: "SHELL" task type for the enum public.task_type in Postgres.
 - TASK_TYPE_COMMAND: "COMMAND" task type for the enum public.task_type in Postgres.
 - TASK_TYPE_TENSORBOARD: "TENSORBOARD" task type for the enum public.task_type in Postgres.
 - TASK_TYPE_CHECKPOINT_GC: "CHECKPOINT_GC" task type for the enum public.task_type in Postgres.
 - TASK_TYPE_GENERIC: "GENERIC" task type for the enum public.task_type in Postgres.
 */
export type V1TaskType = typeof V1TaskType[keyof typeof V1TaskType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1TaskType = {
  TASK_TYPE_UNSPECIFIED: 'TASK_TYPE_UNSPECIFIED',
  TASK_TYPE_TRIAL: 'TASK_TYPE_TRIAL',
  TASK_TYPE_NOTEBOOK: 'TASK_TYPE_NOTEBOOK',
  TASK_TYPE_SHELL: 'TASK_TYPE_SHELL',
  TASK_TYPE_COMMAND: 'TASK_TYPE_COMMAND',
  TASK_TYPE_TENSORBOARD: 'TASK_TYPE_TENSORBOARD',
  TASK_TYPE_CHECKPOINT_GC: 'TASK_TYPE_CHECKPOINT_GC',
  TASK_TYPE_GENERIC: 'TASK_TYPE_GENERIC',
} as const;

/**
 * Response to TaskLogsRequest.
 */
export interface V1TaskLogsResponse {
  /** The agent the logs came from. */
  agentId?: string;
  /** The ID of the allocation. */
  allocationId?: string;
  /** The ID of the container or, in the case of k8s, the pod name. */
  containerId?: string;
  /** The ID of the log. */
  id: string;
  level: V1LogLevel;
  /** The text of the log entry. */
  log: string;
  /** The flat version of the log that UIs have shown historically. */
  message: string;
  /** The rank ID. */
  rankId?: number;
  /** The source of the log entry. */
  source?: string;
  /** The output stream (e.g. stdout, stderr). */
  stdtype?: string;
  /** The ID of the task. */
  taskId: string;
  /** The timestamp of the log. */
  timestamp: string;
}

/**
 * Response to TaskLogsFieldsRequest.
 */
export interface V1TaskLogsFieldsResponse {
  /** The distinct agent IDs present in the logs. */
  agentIds?: string[];
  /** The distint allocation IDs present in the logs. */
  allocationIds?: string[];
  /** The distinct container IDs present in the logs. */
  containerIds?: string[];
  /** The distinct rank IDs present in the logs. */
  rankIds?: number[];
  /** The distinct sources present in the logs. */
  sources?: string[];
  /** The distinct stdtypes present in the logs. */
  stdtypes?: string[];
}

export interface V1TaskLog {
  /** The agent the logs came from. */
  agentId?: string;
  /** The ID of the allocation. */
  allocationId?: string;
  /** The ID of the container or, in the case of k8s, the pod name. */
  containerId?: string;
  /** The ID of the log. */
  id?: number;
  level?: V1LogLevel;
  /** The text of the log entry. */
  log: string;
  /** The rank ID. */
  rankId?: number;
  /** The source of the log entry. */
  source?: string;
  /** The output stream (e.g. stdout, stderr). */
  stdtype?: string;
  /** The ID of the task. */
  taskId: string;
  /** The timestamp of the log. */
  timestamp?: string;
}

/**
 * Task is the model for a task in the database.
 */
export interface V1Task {
  /** List of Allocations. */
  allocations: V1Allocation[];
  /** The configuration of the task. */
  config?: string;
  /** End timestamp if completed. */
  endTime?: string;
  forkedFrom?: string;
  /** Flag for whether task can be paused or not. */
  noPause?: boolean;
  /** ID of parent task (empty if root task). */
  parentId?: string;
  /** Start timestamp. */
  startTime: string;
  /** Unique ID of task. */
  taskId: string;
  taskState?: V1GenericTaskState;
  taskType: V1TaskType;
}

/**
 * Project Table type.

 - TABLE_TYPE_UNSPECIFIED: Unspecified table type.
 - TABLE_TYPE_EXPERIMENT: experiment table.
 - TABLE_TYPE_RUN: run table.
 */
export type V1TableType = typeof V1TableType[keyof typeof V1TableType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1TableType = {
  TABLE_TYPE_UNSPECIFIED: 'TABLE_TYPE_UNSPECIFIED',
  TABLE_TYPE_EXPERIMENT: 'TABLE_TYPE_EXPERIMENT',
  TABLE_TYPE_RUN: 'TABLE_TYPE_RUN',
} as const;

/**
 * Response to StartTrialRequest.
 */
export interface V1StartTrialResponse {
  /** Latest checkpoint. */
  latestCheckpoint?: string;
  /** Steps completed. */
  stepsCompleted: number;
  /** Trial run id. */
  trialRunId: number;
}

/**
 * Start a trial.
 */
export interface V1StartTrialRequest {
  /** Whether resume is allowed. */
  resume?: boolean;
  /** Trial id. */
  trialId: number;
}

/**
 * Map of device type to device stats.
 */
export type V1SlotStatsTypeStats = {[key: string]: V1DeviceStats};

/**
 * Map of device brands to device stats.
 */
export type V1SlotStatsBrandStats = {[key: string]: V1DeviceStats};

/**
 * SlotStats contains statistics about a set of slots.
 */
export interface V1SlotStats {
  /** Map of device brands to device stats. */
  brandStats: V1SlotStatsBrandStats;
  /** Map of device type to device stats. */
  typeStats: V1SlotStatsTypeStats;
}

/**
 * Slot wraps a single device on the agent.
 */
export interface V1Slot {
  container?: V1Container;
  device?: V1Device;
  /** Flag notifying if this slot is in the draining mode: current containers
will be allowed to finish but no new ones will be scheduled. */
  draining?: boolean;
  /** Flag notifying if containers can be scheduled on this slot. */
  enabled?: boolean;
  /** The unqiue id of the slot for a given agent. */
  id?: string;
}

export type V1ShellAgentUserGroup = { [key: string]: unknown };

export type V1ShellAddressesItem = { [key: string]: unknown };

/**
 * Shell is an ssh server in a containerized environment.
 */
export interface V1Shell {
  addresses?: V1ShellAddressesItem[];
  agentUserGroup?: V1ShellAgentUserGroup;
  container?: V1Container;
  /** The description of the shell. */
  description: string;
  /** The display name of the user that created the shell. */
  displayName?: string;
  exitStatus?: string;
  /** The id of the shell. */
  id: string;
  /** The associated job id. */
  jobId: string;
  /** The private key for this shell. */
  privateKey?: string;
  /** The public key for this shell. */
  publicKey?: string;
  resourcePool: string;
  /** The time the shell was started. */
  startTime: string;
  state: Taskv1State;
  /** The id of the user that created the shell. */
  userId?: number;
  /** The username of the user that created the shell. */
  username: string;
  /** The workspace id. */
  workspaceId: number;
}

/**
 * The added workspace-namespace bindings.
 */
export type V1SetWorkspaceNamespaceBindingsResponseNamespaceBindings = {[key: string]: V1WorkspaceNamespaceBinding};

/**
 * Response for setting workspace-namespace bindings.
 */
export interface V1SetWorkspaceNamespaceBindingsResponse {
  /** The added workspace-namespace bindings. */
  namespaceBindings: V1SetWorkspaceNamespaceBindingsResponseNamespaceBindings;
}

/**
 * The cluster-namespace pairs used to create workspace-namespace bindings.
 */
export type V1SetWorkspaceNamespaceBindingsRequestClusterNamespaceMeta = {[key: string]: V1WorkspaceNamespaceMeta};

/**
 * Request for setting workspace-namespace bindings.
 */
export interface V1SetWorkspaceNamespaceBindingsRequest {
  /** The cluster-namespace pairs used to create workspace-namespace bindings. */
  clusterNamespaceMeta?: V1SetWorkspaceNamespaceBindingsRequestClusterNamespaceMeta;
  /** The unique id of the workspace. */
  workspaceId: number;
}

/**
 * Response to SetUserPasswordRequest.
 */
export interface V1SetUserPasswordResponse {
  user?: V1User;
}

/**
 * Response to SetTensorboardPriorityRequest.
 */
export interface V1SetTensorboardPriorityResponse {
  tensorboard?: V1Tensorboard;
}

/**
 * Set the priority of the requested TensorBoard.
 */
export interface V1SetTensorboardPriorityRequest {
  /** The new priority. */
  priority?: number;
  /** The id of the TensorBoard. */
  tensorboardId?: string;
}

/**
 * Response to SetShellPriorityRequest.
 */
export interface V1SetShellPriorityResponse {
  shell?: V1Shell;
}

/**
 * Set the priority of the requested shell.
 */
export interface V1SetShellPriorityRequest {
  /** The new priority. */
  priority?: number;
  /** The id of the shell. */
  shellId?: string;
}

/**
 * Response for setting the resource quota for a workspace (for a specific
cluster).
 */
export interface V1SetResourceQuotasResponse { [key: string]: unknown }

/**
 * A map of cluster to resource-quota pairs used to set GPU request limits on
the workspace (for a specific cluster).
 */
export type V1SetResourceQuotasRequestClusterQuotaPairs = {[key: string]: number};

/**
 * Request to set a resource quota on a workspace (for a specific cluster).
 */
export interface V1SetResourceQuotasRequest {
  /** A map of cluster to resource-quota pairs used to set GPU request limits on
the workspace (for a specific cluster). */
  clusterQuotaPairs?: V1SetResourceQuotasRequestClusterQuotaPairs;
  /** The id of the workspace. */
  id: number;
}

/**
 * Response to SetNotebookPriorityRequest.
 */
export interface V1SetNotebookPriorityResponse {
  notebook?: V1Notebook;
}

/**
 * Set the priority of the requested notebook.
 */
export interface V1SetNotebookPriorityRequest {
  /** The id of the notebook. */
  notebookId?: string;
  /** The new priority. */
  priority?: number;
}

/**
 * Response to SetCommandPriorityRequest.
 */
export interface V1SetCommandPriorityResponse {
  command?: V1Command;
}

/**
 * Set the priority of the requested command.
 */
export interface V1SetCommandPriorityRequest {
  /** The id of the command. */
  commandId?: string;
  /** The new priority. */
  priority?: number;
}

/**
 * Response to SetClusterMessageRequest.
 */
export interface V1SetClusterMessageResponse { [key: string]: unknown }

/**
 * Set the cluster-wide message.
 */
export interface V1SetClusterMessageRequest {
  duration?: string;
  /** Time to stop showing message. */
  endTime?: string;
  /** Text content of message. */
  message: string;
  /** Time to begin showing message. */
  startTime: string;
}

/**
 * SearchUnit describes a length unit used by some searchers to manage training.
 */
export interface V1SearchUnit {
  /** Bool indicating whether the training length is defined in code. */
  maxLength: boolean;
  /** Name of the length unit (if max_length is false). */
  name?: string;
  /** Value of the length unit (if max_length is false). */
  value?: number;
}

/**
 * The searcher config from which the summary is generated.
 */
export type V1SearchSummaryConfig = { [key: string]: unknown };

/**
 * SearchSummary contains the estimated trials and training lengths that a
search plans to execute.
 */
export interface V1SearchSummary {
  /** The searcher config from which the summary is generated. */
  config: V1SearchSummaryConfig;
  /** A list of planned number of trials to their training lengths. */
  trials?: V1TrialSummary[];
}

/**
 * Response to SearchRunsResponse.
 */
export interface V1SearchRunsResponse {
  pagination: V1Pagination;
  /** The list of returned runs. */
  runs: V1FlatRun[];
}

/**
 * Get a list of runs.
 */
export interface V1SearchRunsRequest {
  filter?: string;
  limit?: number;
  offset?: number;
  projectId?: number;
  sort?: string;
}

export interface V1SearchRolesAssignableToScopeResponse {
  pagination?: V1Pagination;
  /** the set of roles and all assignments belonging to it. */
  roles?: V1Role[];
}

export interface V1SearchRolesAssignableToScopeRequest {
  limit: number;
  offset?: number;
  workspaceId?: number;
}

export interface V1SearchExperimentsRequest {
  filter?: string;
  limit?: number;
  offset?: number;
  projectId?: number;
  sort?: string;
}

export interface V1SearchExperimentExperiment {
  bestTrial?: Trialv1Trial;
  experiment: V1Experiment;
}

export interface V1SearchExperimentsResponse {
  /** The list of returned experiments. */
  experiments: V1SearchExperimentExperiment[];
  pagination: V1Pagination;
}

/**
 * Message for results of individual searches in a multi-search action.
 */
export interface V1SearchActionResult {
  /** Optional error message. */
  error: string;
  /** search ID. */
  id: number;
}

export interface V1ScopeTypeMask {
  /** Whether this permission or role can be assigned globally, i.e.
cluster-wide. Currently, all permissions can be assigned globally, so this
is always true. */
  cluster?: boolean;
  /** Whether this permission or role can be assigned on a particular workspace.
For example, `ADMINISTRATE_USER` permission will have this field set to
false, since user creation can only be done at a cluster level, and it
doesn't make sense for a single workspace. */
  workspace?: boolean;
}

/**
 * The type of the Scheduler.

 - SCHEDULER_TYPE_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is
just an artifact of using protobuf.
 - SCHEDULER_TYPE_PRIORITY: The priority scheduler.
 - SCHEDULER_TYPE_FAIR_SHARE: The fair share scheduler.
 - SCHEDULER_TYPE_ROUND_ROBIN: The round robin scheduler
 - SCHEDULER_TYPE_KUBERNETES: The kubernetes scheduler.
 - SCHEDULER_TYPE_SLURM: A slurm placeholder. When running on slurm, all scheduling behavior is
delegated.
 - SCHEDULER_TYPE_PBS: A PBS placeholder. When running on PBS, all scheduling behavior is
delegated.
 */
export type V1SchedulerType = typeof V1SchedulerType[keyof typeof V1SchedulerType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1SchedulerType = {
  SCHEDULER_TYPE_UNSPECIFIED: 'SCHEDULER_TYPE_UNSPECIFIED',
  SCHEDULER_TYPE_PRIORITY: 'SCHEDULER_TYPE_PRIORITY',
  SCHEDULER_TYPE_FAIR_SHARE: 'SCHEDULER_TYPE_FAIR_SHARE',
  SCHEDULER_TYPE_ROUND_ROBIN: 'SCHEDULER_TYPE_ROUND_ROBIN',
  SCHEDULER_TYPE_KUBERNETES: 'SCHEDULER_TYPE_KUBERNETES',
  SCHEDULER_TYPE_SLURM: 'SCHEDULER_TYPE_SLURM',
  SCHEDULER_TYPE_PBS: 'SCHEDULER_TYPE_PBS',
} as const;

/**
 * Describe one SSO provider.
 */
export interface V1SSOProvider {
  /** The flag to indicate if this provider should be always be redirected to,
instead of showing the standard sign-in page. */
  alwaysRedirect?: boolean;
  /** A descriptive name for this provider. */
  name: string;
  /** The URL to use for SSO with this provider. */
  ssoUrl: string;
  /** The type of SSO (such as SAML, OIDC). */
  type: string;
}

/**
 * Response to prepare to start reporting to a run.
 */
export interface V1RunPrepareForReportingResponse {
  /** The storage_id to be used when creating new checkpoints. This will be
returned always when checkpoint storage is set in the request. */
  storageId?: number;
}

/**
 * Checkpoint storage config.
 */
export type V1RunPrepareForReportingRequestCheckpointStorage = { [key: string]: unknown };

/**
 * Request to prepare to start reporting to a run.
 */
export interface V1RunPrepareForReportingRequest {
  /** Checkpoint storage config. */
  checkpointStorage?: V1RunPrepareForReportingRequestCheckpointStorage;
  /** RunID to sync to. */
  runId: number;
}

/**
 * Message for results of individual runs in a multi-run action.
 */
export interface V1RunActionResult {
  /** Optional error message. */
  error: string;
  /** run ID. */
  id: number;
}

/**
 * RoleAssignmentSummary is used to describe permissions a user has.
 */
export interface V1RoleAssignmentSummary {
  roleId: number;
  /** Whether the role is assigned cluster-wide. */
  scopeCluster?: boolean;
  /** List of workspace IDs to apply the role. */
  scopeWorkspaceIds?: number[];
}

export interface V1Role {
  name?: string;
  permissions?: V1Permission[];
  roleId: number;
  scopeTypeMask?: V1ScopeTypeMask;
}

/**
 * RoleWithAssignments contains a detailed description of
a role and the groups and users belonging to it.
 */
export interface V1RoleWithAssignments {
  /** The embedded GroupRoleAssignment. */
  groupRoleAssignments?: V1GroupRoleAssignment[];
  role?: V1Role;
  /** The embedded UserRoleAssignment. */
  userRoleAssignments?: V1UserRoleAssignment[];
}

/**
 * RoleAssignment contains information about the scope
of the role.
 */
export interface V1RoleAssignment {
  role: V1Role;
  /** Whether the role is assigned cluster-wide. */
  scopeCluster?: boolean;
  /** The id of the workspace the role belongs to. Empty for cluster-wide scope. */
  scopeWorkspaceId?: number;
}

/**
 * Response to ResumeSearchesRequest.
 */
export interface V1ResumeSearchesResponse {
  /** Details on success or error for each search. */
  results: V1SearchActionResult[];
}

/**
 * Request to unpause the experiment associated witha search.
 */
export interface V1ResumeSearchesRequest {
  filter?: string;
  /** The id of the project of the searches being unpaused. */
  projectId: number;
  /** The ids of the searches being moved. Leave empty if using filter. */
  searchIds?: number[];
}

/**
 * Response to ResumeRunsRequest.
 */
export interface V1ResumeRunsResponse {
  /** Details on success or error for each run. */
  results: V1RunActionResult[];
}

/**
 * Request to unpause the experiment associated witha run.
 */
export interface V1ResumeRunsRequest {
  filter?: string;
  /** The id of the project of the runs being unpaused. */
  projectId: number;
  /** The ids of the runs being moved. Leave empty if using filter. */
  runIds?: number[];
}

/**
 * ID, an identifier for an agent, maps to the associated devices.
 */
export type V1ResourcesSummaryAgentDevices = {[key: string]: ResourcesSummaryDevices};

/**
 * ResourcesStarted contains the information needed by tasks from container
started.
 */
export interface V1ResourcesStarted {
  /** Addresses represents the exposed ports on a container. */
  addresses?: V1Address[];
  /** NativeResourcesID is the native Docker hex container ID of the Determined
container. */
  nativeResourcesId?: string;
}

/**
 * ResourcesFailure contains information about restored resources' failure.
 */
export interface V1ResourcesFailure {
  /** The error message of the failure. */
  errMsg?: string;
  /** The exit code of the failure. */
  exitCode?: number;
  failureType?: V1FailureType;
}

/**
 * ResourcesStopped contains the information needed by tasks from container
stopped.
 */
export interface V1ResourcesStopped {
  failure?: V1ResourcesFailure;
}

/**
 * ResourcesSummary provides a summary of the resources comprising what we know
at the time the allocation is granted, but for k8s it is granted before being
scheduled so it isn't really much and `agent_devices` are missing for k8s.
 */
export interface V1ResourcesSummary {
  /** ID, an identifier for an agent, maps to the associated devices. */
  agentDevices?: V1ResourcesSummaryAgentDevices;
  /** AllocationID is the ID of an allocation of a task. */
  allocationId?: string;
  /** Available if the RM can give information on the container level. */
  containerId?: string;
  exited?: V1ResourcesStopped;
  /** ResourcesID is the ID of some set of resources. */
  resourcesId?: string;
  /** ResourcesType is the type of some set of resources. This should be purely
informational. */
  resourcesType?: string;
  started?: V1ResourcesStarted;
}

/**
 * The type of the ResourcePool.

 - RESOURCE_POOL_TYPE_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is
just an artifact of using protobuf.
 - RESOURCE_POOL_TYPE_AWS: An AWS resource pool.
 - RESOURCE_POOL_TYPE_GCP: A GCP resource pool.
 - RESOURCE_POOL_TYPE_STATIC: A static resource pool.
 - RESOURCE_POOL_TYPE_K8S: The kubernetes resource pool.
 */
export type V1ResourcePoolType = typeof V1ResourcePoolType[keyof typeof V1ResourcePoolType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1ResourcePoolType = {
  RESOURCE_POOL_TYPE_UNSPECIFIED: 'RESOURCE_POOL_TYPE_UNSPECIFIED',
  RESOURCE_POOL_TYPE_AWS: 'RESOURCE_POOL_TYPE_AWS',
  RESOURCE_POOL_TYPE_GCP: 'RESOURCE_POOL_TYPE_GCP',
  RESOURCE_POOL_TYPE_STATIC: 'RESOURCE_POOL_TYPE_STATIC',
  RESOURCE_POOL_TYPE_K8S: 'RESOURCE_POOL_TYPE_K8S',
} as const;

export interface V1ResourcePoolPrioritySchedulerDetail {
  /** The priority that is assigned to tasks that do not explicitly specify a
priority. */
  defaultPriority: number;
  /** List of available priorities for K8 (if applicable). */
  k8Priorities?: V1K8PriorityClass[];
  preemption: boolean;
}

export interface V1ResourcePoolGcpDetail {
  bootDiskSize: number;
  bootDiskSourceImage: string;
  externalIp: boolean;
  gpuNum: number;
  gpuType: string;
  /** Key for labeling the Determined agent instances. */
  labelKey: string;
  labelValue: string;
  machineType: string;
  namePrefix: string;
  network: string;
  networkTags?: string[];
  operationTimeoutPeriod: number;
  preemptible: boolean;
  project: string;
  /** Email of the service account for the Determined agent instances. */
  serviceAccountEmail: string;
  serviceAccountScopes: string[];
  subnetwork?: string;
  zone: string;
}

export interface V1ResourcePoolAwsDetail {
  customTags?: V1AwsCustomTag[];
  /** The Amazon Resource Name (ARN) of the IAM instance profile to attach to the
agent instances. */
  iamInstanceProfileArn: string;
  imageId: string;
  instanceName: string;
  instanceType?: string;
  logGroup?: string;
  logStream?: string;
  publicIp: boolean;
  region: string;
  rootVolumeSize: number;
  securityGroupId: string;
  spotEnabled: boolean;
  spotMaxPrice?: string;
  sshKeyName: string;
  subnetId?: string;
  tagKey: string;
  tagValue: string;
}

export interface V1ResourcePoolDetail {
  aws?: V1ResourcePoolAwsDetail;
  gcp?: V1ResourcePoolGcpDetail;
  priorityScheduler?: V1ResourcePoolPrioritySchedulerDetail;
}

/**
 * Resource manager's metadata.
 */
export type V1ResourcePoolResourceManagerMetadata = {[key: string]: string};

/**
 * A Resource Pool is a pool of resources where containers are run.
 */
export interface V1ResourcePool {
  accelerator?: string;
  agentDockerImage: string;
  /** The Docker network to use for the agent when using dynamic agents. */
  agentDockerNetwork: string;
  agentDockerRuntime: string;
  agentFluentImage: string;
  auxContainerCapacity: number;
  auxContainerCapacityPerAgent: number;
  auxContainersRunning: number;
  /** Resource manager's associated cluster name. */
  clusterName: string;
  /** The startup script for the agent's container. This runs in the container
determined-agent runs in. */
  containerStartupScript: string;
  defaultAuxPool: boolean;
  defaultComputePool: boolean;
  description: string;
  details: V1ResourcePoolDetail;
  /** The VM image used for the agents when using dynamic agents. */
  imageId: string;
  /** The instance type of the agents when using dynamic agents. For AWS this is
the Instance Type. For GCP this is the machine type combined with the
number and types of GPUs. To work with this data programattically, we
recommend working with the ResourcePool.details.aws.instanceType and
ResourcePool.details.gcp.machineType/gpuType/gpuNum. */
  instanceType: string;
  /** The location of the resource pool. For AWS this returns the region and for
GCP this return the zone. */
  location: string;
  masterCertName: string;
  masterUrl: string;
  /** When using dynamic agents, the maximum number of agents that can exist in
the resource pool. */
  maxAgents: number;
  /** The maximum starting period of agents in seconds. The master waits for this
period of time for starting agents before retrying. */
  maxAgentStartingPeriod: number;
  /** The maximum idle period of agents in seconds. The master waits for this
period of time before shutting down idle agents. */
  maxIdleAgentPeriod: number;
  /** When using dynamic agents, the minimum number of agents that can exist in
the resource pool. */
  minAgents: number;
  /** The unique name of the resource pool. */
  name: string;
  numAgents: number;
  /** Is this resource pool using preemptible/spot instances? Only meaningful in
an AWS or GCP resource pool. */
  preemptible: boolean;
  /** Resource manager's metadata. */
  resourceManagerMetadata: V1ResourcePoolResourceManagerMetadata;
  schedulerFittingPolicy: V1FittingPolicy;
  schedulerType: V1SchedulerType;
  slotsAvailable: number;
  /** The number of slots that exists on an dynamic agent. */
  slotsPerAgent?: number;
  slotsUsed: number;
  slotType: Devicev1Type;
  /** The startup script for the agent. This runs on the node the agent runs on. */
  startupScript: string;
  stats?: V1QueueStats;
  type: V1ResourcePoolType;
}

/**
 * One instance of slots in the cluster being allocated to a task.
 */
export interface V1ResourceAllocationRawEntry {
  /** The time at which the allocation ended. */
  endTime?: string;
  /** The ID of the experiment the allocation is a part of. */
  experimentId?: number;
  /** The kind of workload being run during this allocation (training,
checkpoint, or validation). */
  kind?: string;
  /** The labels assigned to the experiment. */
  labels?: string[];
  /** The number of seconds for which the allocation was active during the
requested period. */
  seconds?: number;
  /** The number of slots used by the allocation. */
  slots?: number;
  /** The time at which the allocation began. */
  startTime?: string;
  /** The username of the user who ran the experiment. */
  userId?: number;
  /** The username of the user who ran the experiment. */
  username?: string;
}

/**
 * Response to ResourceAllocationRawRequest.
 */
export interface V1ResourceAllocationRawResponse {
  /** An entry summarizing one workload. */
  resourceEntries?: V1ResourceAllocationRawEntry[];
}

/**
 * The period over which to perform aggregation.

 - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is
just an artifact of using protobuf.
 - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.
 - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
 */
export type V1ResourceAllocationAggregationPeriod = typeof V1ResourceAllocationAggregationPeriod[keyof typeof V1ResourceAllocationAggregationPeriod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1ResourceAllocationAggregationPeriod = {
  RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED',
  RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY',
  RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: 'RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY',
} as const;

/**
 * The seconds in the cluster used by experiments belonging to each user.
 */
export type V1ResourceAllocationAggregatedEntryByUsername = {[key: string]: number};

/**
 * The seconds in the cluster used by experiments assigned to each resource
pool.
 */
export type V1ResourceAllocationAggregatedEntryByResourcePool = {[key: string]: number};

/**
 * The seconds in the cluster used by experiments labeled with each label.
 */
export type V1ResourceAllocationAggregatedEntryByExperimentLabel = {[key: string]: number};

/**
 * One instance of slots in the cluster being allocated to a task during a
period (aggregated).
 */
export interface V1ResourceAllocationAggregatedEntry {
  /** The seconds in the cluster used by experiments labeled with each label. */
  byExperimentLabel: V1ResourceAllocationAggregatedEntryByExperimentLabel;
  /** The seconds in the cluster used by experiments assigned to each resource
pool. */
  byResourcePool: V1ResourceAllocationAggregatedEntryByResourcePool;
  /** The seconds in the cluster used by experiments belonging to each user. */
  byUsername: V1ResourceAllocationAggregatedEntryByUsername;
  period: V1ResourceAllocationAggregationPeriod;
  /** The date of this entry. */
  periodStart: string;
  /** The total number of seconds included in this allocation entry. */
  seconds: number;
}

/**
 * Response to ResourceAllocationAggregatedRequest.
 */
export interface V1ResourceAllocationAggregatedResponse {
  /** An entry summarizing one workload. */
  resourceEntries: V1ResourceAllocationAggregatedEntry[];
}

/**
 * Response to ResetUserSettingRequest.
 */
export interface V1ResetUserSettingResponse { [key: string]: unknown }

export interface V1ReportTrialValidationMetricsResponse { [key: string]: unknown }

export interface V1ReportTrialTrainingMetricsResponse { [key: string]: unknown }

export interface V1ReportTrialSourceInfoResponse {
  /** UUID of the checkpoint. */
  checkpointUuid: string;
  trialId: number;
}

export interface V1ReportTrialSourceInfoRequest {
  trialSourceInfo: V1TrialSourceInfo;
}

export interface V1ReportTrialSearcherEarlyExitResponse { [key: string]: unknown }

export interface V1ReportTrialProgressResponse { [key: string]: unknown }

/**
 * For bookkeeping, updates the progress of the trial as a percent torwards
the training length requested of it by the searcher.
 */
export interface V1ReportTrialProgressRequest {
  /** Indicator for if the passed progress is raw and we want to skip any
calculation by searcher. Default to false. */
  isRaw?: boolean;
  /** Total units completed by the trial, in terms of the unit used to configure
the searcher. */
  progress: number;
  /** The id of the trial. */
  trialId: number;
}

export interface V1ReportTrialMetricsResponse { [key: string]: unknown }

/**
 * Persist the given metrics for the trial.
 */
export interface V1ReportTrialMetricsRequest {
  /** The type of metrics to persist eg 'training', 'validation', etc. */
  group: string;
  metrics: V1TrialMetrics;
}

/**
 * Response to ReportCheckpointRequest.
 */
export interface V1ReportCheckpointResponse { [key: string]: unknown }

/**
 * The rendezvous info for the trial to rendezvous with sibling containers.
 */
export interface V1RendezvousInfo {
  /** The rendezvous addresses of the other containers. */
  addresses: string[];
  /** The container rank. */
  rank: number;
  /** The slots for each address, respectively. */
  slots: number[];
}

/**
 * RemoveAssignmentsResponse is the body of the response for teh call
to remove a user or group from a role.
 */
export interface V1RemoveAssignmentsResponse { [key: string]: unknown }

/**
 * RemoveAssignmentsRequest is the body of the request for the call
to remove a user or group from a role.
 */
export interface V1RemoveAssignmentsRequest {
  /** the set of groups being removed from a role. */
  groupRoleAssignments?: V1GroupRoleAssignment[];
  /** the set of users being removed from a role. */
  userRoleAssignments?: V1UserRoleAssignment[];
}

/**
 * RBACJob is a job that can have either a limited or a full
representation of a job.
 */
export interface V1RBACJob {
  full?: V1Job;
  limited?: V1LimitedJob;
}

/**
 * Statistics for a queue.
 */
export interface V1QueueStats {
  /** Number of queued jobs in the queue. */
  queuedCount: number;
  /** Number of scheduled jobs in the queue. */
  scheduledCount: number;
}

/**
 * Job stats for a resource pool.
 */
export interface V1RPQueueStat {
  /** Aggregate stats. */
  aggregates?: V1AggregateQueueStats[];
  /** Resource pool. */
  resourcePool: string;
  stats: V1QueueStats;
}

/**
 * Describes a message to control jobs in a queue.
 */
export interface V1QueueControl {
  /** Deprecated; do not use. */
  aheadOf?: string;
  /** Deprecated; do not use. */
  behindOf?: string;
  /** Job id. */
  jobId: string;
  /** The desired job priority in priority scheduler. */
  priority?: number;
  /** Name of the target resource_pool to move the job to. */
  resourcePool?: string;
  /** The desired job weight in fairshare scheduler. */
  weight?: number;
}

/**
 * The config policies saved. Contains both invariant configs and constraints
in yaml or json format.
 */
export type V1PutWorkspaceConfigPoliciesResponseConfigPolicies = { [key: string]: unknown };

/**
 * Response to PutWorkspaceConfigPoliciesRequest.
 */
export interface V1PutWorkspaceConfigPoliciesResponse {
  /** The config policies saved. Contains both invariant configs and constraints
in yaml or json format. */
  configPolicies?: V1PutWorkspaceConfigPoliciesResponseConfigPolicies;
}

/**
 * PutWorkspaceConfigPoliciesRequest sets config
policies for the workspace and workload type.
 */
export interface V1PutWorkspaceConfigPoliciesRequest {
  /** The config policies to use. Contains both invariant configs and constraints
in yaml or json format. */
  configPolicies: string;
  /** The workload type the config policies apply to: EXPERIMENT or NTSC. */
  workloadType: string;
  /** The workspace the config policies apply to. Use global API for
global config policies. */
  workspaceId: number;
}

/**
 * Response to PutExperimentRetainLogsRequest.
 */
export interface V1PutTrialRetainLogsResponse { [key: string]: unknown }

/**
 * Request for changing the log retention policy for the an experiment.
 */
export interface V1PutTrialRetainLogsRequest {
  /** The number of days to retain logs, starting from the end time of the task. */
  numDays: number;
  /** The ID of the trial. */
  trialId?: number;
}

/**
 * Response to PutTrialRequest.
 */
export interface V1PutTrialResponse {
  trial: Trialv1Trial;
}

/**
 * Put a trial.
 */
export interface V1PutTrialRequest {
  createTrialRequest?: V1CreateTrialRequest;
  /** External trial id. */
  externalTrialId?: string;
}

/**
 * Response to PutTemplateRequest.
 */
export interface V1PutTemplateResponse {
  template?: V1Template;
}

/**
 * Response to PutProjectNotesRequest.
 */
export interface V1PutProjectNotesResponse {
  /** The complete list of notes on a project. */
  notes: V1Note[];
}

/**
 * Request for setting project notes.
 */
export interface V1PutProjectNotesRequest {
  /** The complete list of notes. */
  notes: V1Note[];
  /** The id of the project. */
  projectId: number;
}

/**
 * The config policies saved. Contains both invariant configs and constraints
in yaml or json format.
 */
export type V1PutGlobalConfigPoliciesResponseConfigPolicies = { [key: string]: unknown };

/**
 * Response to PutGlobalConfigPoliciesRequest.
 */
export interface V1PutGlobalConfigPoliciesResponse {
  /** The config policies saved. Contains both invariant configs and constraints
in yaml or json format. */
  configPolicies?: V1PutGlobalConfigPoliciesResponseConfigPolicies;
}

/**
 * PutGlobalConfigPoliciesRequest sets global config
policies for the workload type.
 */
export interface V1PutGlobalConfigPoliciesRequest {
  /** The config policies to use. Contains both invariant configs and constraints
in yaml or json format. */
  configPolicies: string;
  /** The workload type the config policies apply to: EXPERIMENT or NTSC. */
  workloadType: string;
}

/**
 * Response to PutExperimentRetainLogsRequest.
 */
export interface V1PutExperimentsRetainLogsResponse {
  /** Details on success or error for each experiment. */
  results: V1ExperimentActionResult[];
}

/**
 * Request for changing the log retention policy for the an experiment.
 */
export interface V1PutExperimentsRetainLogsRequest {
  /** The ids of the experiments being moved. */
  experimentIds: number[];
  filters?: V1BulkExperimentFilters;
  /** The number of days to retain logs, starting from the end time of the task. */
  numDays: number;
  /** Project id that the experiments belong to. */
  projectId: number;
}

/**
 * Response to PutExperimentRetainLogsRequest.
 */
export interface V1PutExperimentRetainLogsResponse { [key: string]: unknown }

/**
 * Request for changing the log retention policy for the an experiment.
 */
export interface V1PutExperimentRetainLogsRequest {
  /** The ID of the experiment. */
  experimentId: number;
  /** The number of days to retain logs, starting from the end time of the task. */
  numDays: number;
}

/**
 * The created experiment config.
 */
export type V1PutExperimentResponseConfig = { [key: string]: unknown };

/**
 * Response to PutExperimentRequest.
 */
export interface V1PutExperimentResponse {
  /** The created experiment config. */
  config: V1PutExperimentResponseConfig;
  experiment: V1Experiment;
}

/**
 * Response to PutExperimentLabelRequest.
 */
export interface V1PutExperimentLabelResponse {
  /** The complete list of labels associated with the experiment. */
  labels: string[];
}

/**
 * ProxyPortConfig configures a proxy the allocation should start.
 */
export interface V1ProxyPortConfig {
  /** The port of the proxy port config. */
  port?: number;
  /** True if proxy uses TCP. */
  proxyTcp?: boolean;
  /** The service ID of the proxy port config. */
  serviceId?: string;
  /** True if the proxy is unauthenticated. */
  unauthenticated?: boolean;
}

/**
 * Project Column is a description of a column used on experiments in the
project.
 */
export interface V1ProjectColumn {
  /** Raw column name. */
  column: string;
  /** Human-friendly name. */
  displayName?: string;
  location: V1LocationType;
  type: V1ColumnType;
}

/**
 * Project is a named collection of experiments.
 */
export interface V1Project {
  /** Whether this project is archived or not. */
  archived: boolean;
  /** The description of the project. */
  description?: string;
  /** Message stored from errors on async-deleting a project. */
  errorMessage: string;
  /** The unique id of the project. */
  id: number;
  /** Whether this project is immutable (default uncategorized project). */
  immutable: boolean;
  /** The key of the project. */
  key: string;
  /** Time of most recently started experiment within this project. */
  lastExperimentStartedAt?: string;
  /**
   * The unique name of the project.
   * @minLength 1
   */
  name: string;
  /** Notes associated with this project. */
  notes: V1Note[];
  /** Count of active experiments associated with this project. */
  numActiveExperiments: number;
  /** Count of experiments associated with this project. */
  numExperiments: number;
  /** Count of runs associated with this project. */
  numRuns: number;
  state: V1WorkspaceState;
  /** ID of the user who created this project. */
  userId: number;
  /** User who created this project. */
  username: string;
  /** The id of the associated workspace. */
  workspaceId: number;
  /** The name of the associated workspace. */
  workspaceName?: string;
}

/**
 * Response to PreviewSearchRequest.
 */
export interface V1PreviewHPSearchResponse {
  summary?: V1SearchSummary;
}

/**
 * The experiment config to simulate.
 */
export type V1PreviewHPSearchRequestConfig = { [key: string]: unknown };

/**
 * Preview hyperparameter search.
 */
export interface V1PreviewHPSearchRequest {
  /** The experiment config to simulate. */
  config?: V1PreviewHPSearchRequestConfig;
  /** The searcher simulation seed. */
  seed?: number;
}

/**
 * The workspace-namespace bindings and resource quotas created.
 */
export type V1PostWorkspaceResponseNamespaceBindings = {[key: string]: V1WorkspaceNamespaceBinding};

/**
 * Response to PostWorkspaceRequest.
 */
export interface V1PostWorkspaceResponse {
  /** The workspace-namespace bindings and resource quotas created. */
  namespaceBindings?: V1PostWorkspaceResponseNamespaceBindings;
  workspace: V1Workspace;
}

/**
 * The map of clusters to the resource quota placed on the auto-generated
namespace within that cluster (inherently capping the slots available to a
workspace).
 */
export type V1PostWorkspaceRequestClusterQuotaPairs = {[key: string]: number};

/**
 * The map of clusters to workspace-namespace metadata (including the
workspace-namespace binding and the resource quota placed on the namespace
bound to the workspace for a given cluster).
 */
export type V1PostWorkspaceRequestClusterNamespaceMeta = {[key: string]: V1WorkspaceNamespaceMeta};

/**
 * Optional checkpoint storage config.
 */
export type V1PostWorkspaceRequestCheckpointStorageConfig = { [key: string]: unknown };

/**
 * Request for creating a workspace.
 */
export interface V1PostWorkspaceRequest {
  agentUserGroup?: V1AgentUserGroup;
  /** Optional checkpoint storage config. */
  checkpointStorageConfig?: V1PostWorkspaceRequestCheckpointStorageConfig;
  /** The map of clusters to workspace-namespace metadata (including the
workspace-namespace binding and the resource quota placed on the namespace
bound to the workspace for a given cluster). */
  clusterNamespaceMeta?: V1PostWorkspaceRequestClusterNamespaceMeta;
  /** The map of clusters to the resource quota placed on the auto-generated
namespace within that cluster (inherently capping the slots available to a
workspace). */
  clusterQuotaPairs?: V1PostWorkspaceRequestClusterQuotaPairs;
  /** The name of the default aux pool. */
  defaultAuxPool?: string;
  /** The name of the default compute pool. */
  defaultComputePool?: string;
  /** The name of the workspace. */
  name: string;
}

/**
 * Response to PostWebhookRequest.
 */
export interface V1PostWebhookResponse {
  webhook: V1Webhook;
}

/**
 * Response to PostWebhookEventDataRequest.
 */
export interface V1PostWebhookEventDataResponse { [key: string]: unknown }

/**
 * Request for triggering custom trigger.
 */
export interface V1PostWebhookEventDataRequest {
  data: V1CustomWebhookEventData;
  /** The id of the experiment. */
  experimentId: number;
  /** The id of the trial. */
  trialId?: number;
}

/**
 * Response to PostUserSettingRequest.
 */
export interface V1PostUserSettingResponse { [key: string]: unknown }

/**
 * Update user settings.
 */
export interface V1PostUserSettingRequest {
  /** Setting key value pair. */
  settings: V1UserWebSetting[];
}

/**
 * Response to PostUserRequest.
 */
export interface V1PostUserResponse {
  user?: V1User;
}

/**
 * Create a new user.
 */
export interface V1PostUserRequest {
  /** Indicate whether the provided password is pre-salted & hashed or not. */
  isHashed?: boolean;
  /** The password of the user. */
  password?: string;
  user?: V1User;
}

/**
 * Response to PostUserActivityRequest.
 */
export interface V1PostUserActivityResponse { [key: string]: unknown }

/**
 * Update user activity.
 */
export interface V1PostUserActivityRequest {
  activityType: V1ActivityType;
  entityId: number;
  entityType: V1EntityType;
}

export interface V1PostTrialRunnerMetadataResponse { [key: string]: unknown }

export interface V1PostTrialProfilerMetricsBatchResponse { [key: string]: unknown }

/**
 * Create a batch of trial profiler metrics.
 */
export interface V1PostTrialProfilerMetricsBatchRequest {
  /** The batches to create. */
  batches?: V1TrialProfilerMetricsBatch[];
}

/**
 * Response to PostTemplateRequest.
 */
export interface V1PostTemplateResponse {
  template: V1Template;
}

/**
 * Response to PostTaskLogs.
 */
export interface V1PostTaskLogsResponse { [key: string]: unknown }

/**
 * Request to PostTaskLogs.
 */
export interface V1PostTaskLogsRequest {
  /** The logs to persist. */
  logs: V1TaskLog[];
}

/**
 * The new metadata of the run.
 */
export type V1PostRunMetadataResponseMetadata = { [key: string]: unknown };

/**
 * Response to post metadata for a run.
 */
export interface V1PostRunMetadataResponse {
  /** The new metadata of the run. */
  metadata?: V1PostRunMetadataResponseMetadata;
}

/**
 * The arbitrary metadata to post.
 */
export type V1PostRunMetadataRequestMetadata = { [key: string]: unknown };

/**
 * Request to post metadata for a run.
 */
export interface V1PostRunMetadataRequest {
  /** The arbitrary metadata to post. */
  metadata: V1PostRunMetadataRequestMetadata;
  /** The ID of the run to post metadata for. */
  runId?: number;
}

/**
 * Response to PostProjectRequest.
 */
export interface V1PostProjectResponse {
  project: V1Project;
}

/**
 * Request for creating a project.
 */
export interface V1PostProjectRequest {
  /** Description of the project. */
  description?: string;
  /** Key for the project. */
  key?: string;
  /** The name of the project. */
  name: string;
  /** Id of the associated workspace. */
  workspaceId: number;
}

/**
 * Response for PostModelVersionRequest.
 */
export interface V1PostModelVersionResponse {
  modelVersion: V1ModelVersion;
}

/**
 * The user-defined metadata of the model version.
 */
export type V1PostModelVersionRequestMetadata = { [key: string]: unknown };

/**
 * Request for creating a model version.
 */
export interface V1PostModelVersionRequest {
  /** UUID of the checkpoint. */
  checkpointUuid: string;
  /** User-written comment for the model version. */
  comment?: string;
  /** Labels associated with this model version. */
  labels?: string[];
  /** The user-defined metadata of the model version. */
  metadata?: V1PostModelVersionRequestMetadata;
  /** The name of the model to add this version to. */
  modelName: string;
  /** User-friendly name for the model version. */
  name?: string;
  /** Notes associated with this model version. */
  notes?: string;
}

/**
 * Response to PostModelRequest.
 */
export interface V1PostModelResponse {
  model: V1Model;
}

/**
 * The user-defined metadata of the model.
 */
export type V1PostModelRequestMetadata = { [key: string]: unknown };

/**
 * Request for creating a model in the registry.
 */
export interface V1PostModelRequest {
  /** The description of the model. */
  description?: string;
  /** Labels associated with this model. */
  labels?: string[];
  /** The user-defined metadata of the model. */
  metadata?: V1PostModelRequestMetadata;
  /** The name of the model. */
  name: string;
  /** Notes associated with this model. */
  notes?: string;
  /** The id of the workspace associated with this model. */
  workspaceId?: number;
  /** The name of the workspace associated with this model. */
  workspaceName?: string;
}

/**
 * Response to PostCheckpointRequest.
 */
export interface V1PostCheckpointMetadataResponse {
  checkpoint?: V1Checkpoint;
}

/**
 * Request for updating a checkpoints metadata.
 */
export interface V1PostCheckpointMetadataRequest {
  checkpoint?: V1Checkpoint;
}

export interface V1PostAllocationProxyAddressResponse { [key: string]: unknown }

/**
 * Set the proxy address for some allocation.
 */
export interface V1PostAllocationProxyAddressRequest {
  /** The id of the allocation. */
  allocationId?: string;
  /** The address of the host where the service is, w.r.t. the master. */
  proxyAddress?: string;
}

export interface V1PostAllocationAcceleratorDataResponse { [key: string]: unknown }

/**
 * Set the accelerator data for some allocation.
 */
export interface V1PostAllocationAcceleratorDataRequest {
  acceleratorData: V1AcceleratorData;
  /** The id of the allocation. */
  allocationId: string;
}

/**
 * Response to PostAccessTokenRequest.
 */
export interface V1PostAccessTokenResponse {
  /** token value string. */
  token?: string;
  /** token id. */
  tokenId?: number;
}

/**
 * Create the requested user's accessToken.
 */
export interface V1PostAccessTokenRequest {
  /** Description of the token. */
  description?: string;
  lifespan?: string;
  /** The id of the user. */
  userId: number;
}

export interface V1PolymorphicFilter {
  doubleRange?: V1DoubleFieldFilter;
  integerRange?: V1Int32FieldFilter;
  name?: string;
  timeRange?: V1TimestampFieldFilter;
}

/**
 * Response to PinWorkspaceRequest.
 */
export interface V1PinWorkspaceResponse { [key: string]: unknown }

/**
 * List of permissions types.
Value of the enum has 9xxxx for global only permissions.
Permissions on the same object share the thousands place
value like 2001 and 2002.

 - PERMISSION_TYPE_UNSPECIFIED: The permission type is unknown.
 - PERMISSION_TYPE_ADMINISTRATE_USER: Can create and update other users.
Allows updating other users passwords making this
permission give all other permissions effectively.
 - PERMISSION_TYPE_ADMINISTRATE_OAUTH: Ability to manage OAuth clients and settings.
 - PERMISSION_TYPE_CREATE_EXPERIMENT: Ability to create experiments.
 - PERMISSION_TYPE_VIEW_EXPERIMENT_ARTIFACTS: Ability to view experiment's model code, checkpoints, trials.
 - PERMISSION_TYPE_VIEW_EXPERIMENT_METADATA: Ability to view experiment's metadata such as experiment config, progress.
 - PERMISSION_TYPE_UPDATE_EXPERIMENT: Ability to update experiment and experiment's lifecycle.
 - PERMISSION_TYPE_UPDATE_EXPERIMENT_METADATA: Ability to update experiment's metadata.
 - PERMISSION_TYPE_DELETE_EXPERIMENT: Ability to delete experiment.
 - PERMISSION_TYPE_CREATE_NSC: Ability to create Notebooks, Shells, and Commands.
 - PERMISSION_TYPE_VIEW_NSC: Ability to view Notebooks, Shells, and Commands.
 - PERMISSION_TYPE_UPDATE_NSC: Ability to terminate Notebooks, Shells, and Commands.
 - PERMISSION_TYPE_UPDATE_GROUP: Ability to create, update, and add / remove users from groups.
 - PERMISSION_TYPE_CREATE_WORKSPACE: Ability to create workspaces.
 - PERMISSION_TYPE_VIEW_WORKSPACE: Ability to view workspace.
 - PERMISSION_TYPE_UPDATE_WORKSPACE: Ability to update workspace.
 - PERMISSION_TYPE_DELETE_WORKSPACE: Ability to delete workspace.
 - PERMISSION_TYPE_SET_WORKSPACE_AGENT_USER_GROUP: Ability to set workspace agent user group config.
 - PERMISSION_TYPE_SET_WORKSPACE_CHECKPOINT_STORAGE_CONFIG: Ability to set workspace checkpoint storage config.
 - PERMISSION_TYPE_SET_WORKSPACE_DEFAULT_RESOURCE_POOL: Ability to set workspace default resource pool.
 - PERMISSION_TYPE_CREATE_PROJECT: Ability to create projects.
 - PERMISSION_TYPE_VIEW_PROJECT: Ability to view projects.
 - PERMISSION_TYPE_UPDATE_PROJECT: Ability to update projects.
 - PERMISSION_TYPE_DELETE_PROJECT: Ability to delete projects.
 - PERMISSION_TYPE_ASSIGN_ROLES: Ability to assign roles to groups / users.
If assigned at a workspace scope, can only assign roles to that workspace
scope.
 - PERMISSION_TYPE_VIEW_MODEL_REGISTRY: Ability to view model registry.
 - PERMISSION_TYPE_EDIT_MODEL_REGISTRY: Ability to edit model registry.
 - PERMISSION_TYPE_CREATE_MODEL_REGISTRY: Ability to create model registry.
 - PERMISSION_TYPE_DELETE_MODEL_REGISTRY: Ability to delete model registry.
 - PERMISSION_TYPE_DELETE_MODEL_VERSION: Ability to delete model version.
 - PERMISSION_TYPE_DELETE_OTHER_USER_MODEL_REGISTRY: Ability to delete another user's model registry.
 - PERMISSION_TYPE_DELETE_OTHER_USER_MODEL_VERSION: Ability to delete another user's model version.
 - PERMISSION_TYPE_VIEW_MASTER_LOGS: Ability to view master logs.
 - PERMISSION_TYPE_VIEW_CLUSTER_USAGE: Ability to view detailed cluster usage info.
 - PERMISSION_TYPE_UPDATE_AGENTS: Ability to update agents.
 - PERMISSION_TYPE_VIEW_SENSITIVE_AGENT_INFO: Ability to view sensitive subset of agent info.
 - PERMISSION_TYPE_VIEW_MASTER_CONFIG: Ability to view master configs.
 - PERMISSION_TYPE_UPDATE_MASTER_CONFIG: Ability to update master configs.
 - PERMISSION_TYPE_VIEW_EXTERNAL_JOBS: Ability to view external jobs.
 - PERMISSION_TYPE_CONTROL_STRICT_JOB_QUEUE: Ability to control strict job queue.
 - PERMISSION_TYPE_VIEW_TEMPLATES: Ability to view templates.
 - PERMISSION_TYPE_UPDATE_TEMPLATES: Ability to update templates.
 - PERMISSION_TYPE_CREATE_TEMPLATES: Ability to create templates.
 - PERMISSION_TYPE_DELETE_TEMPLATES: Ability to delete templates.
 - PERMISSION_TYPE_UPDATE_ROLES: Ability to create and update role definitions.
 - PERMISSION_TYPE_EDIT_WEBHOOKS: Ability to create and delete webhooks.
 - PERMISSION_TYPE_VIEW_WEBHOOKS: Ability to view webhooks.
 - PERMISSION_TYPE_MODIFY_RP_WORKSPACE_BINDINGS: Ability to bind, unbind or overwrite resource pool workspace bindings.
 - PERMISSION_TYPE_SET_WORKSPACE_NAMESPACE_BINDINGS: Ability to bind, unbind, or overwrite namespace workspace bindings.
 - PERMISSION_TYPE_SET_RESOURCE_QUOTAS: Ability to set resource quotas on workspaces.
 - PERMISSION_TYPE_VIEW_RESOURCE_QUOTAS: Ability to view resource quotas on workspaces.
 - PERMISSION_TYPE_MODIFY_GLOBAL_CONFIG_POLICIES: Ability to modify global config policies.
 - PERMISSION_TYPE_MODIFY_WORKSPACE_CONFIG_POLICIES: Ability to modify workspace config policies.
 - PERMISSION_TYPE_VIEW_GLOBAL_CONFIG_POLICIES: Ability to view global config policies.
 - PERMISSION_TYPE_VIEW_WORKSPACE_CONFIG_POLICIES: Ability to view workspace config policies.
 - PERMISSION_TYPE_ADMINISTRATE_TOKEN: Ability to administrate other users' tokens.
 - PERMISSION_TYPE_UPDATE_TOKEN: Ability to update one's own token.
 - PERMISSION_TYPE_CREATE_TOKEN: Ability to create one's own token
 - PERMISSION_TYPE_CREATE_OTHER_TOKEN: Ability to create another user's token
 - PERMISSION_TYPE_VIEW_OTHER_TOKEN: Ability to view another user's token
 - PERMISSION_TYPE_VIEW_TOKEN: Ability to view one's own token
 */
export type V1PermissionType = typeof V1PermissionType[keyof typeof V1PermissionType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1PermissionType = {
  PERMISSION_TYPE_UNSPECIFIED: 'PERMISSION_TYPE_UNSPECIFIED',
  PERMISSION_TYPE_ADMINISTRATE_USER: 'PERMISSION_TYPE_ADMINISTRATE_USER',
  PERMISSION_TYPE_ADMINISTRATE_OAUTH: 'PERMISSION_TYPE_ADMINISTRATE_OAUTH',
  PERMISSION_TYPE_CREATE_EXPERIMENT: 'PERMISSION_TYPE_CREATE_EXPERIMENT',
  PERMISSION_TYPE_VIEW_EXPERIMENT_ARTIFACTS: 'PERMISSION_TYPE_VIEW_EXPERIMENT_ARTIFACTS',
  PERMISSION_TYPE_VIEW_EXPERIMENT_METADATA: 'PERMISSION_TYPE_VIEW_EXPERIMENT_METADATA',
  PERMISSION_TYPE_UPDATE_EXPERIMENT: 'PERMISSION_TYPE_UPDATE_EXPERIMENT',
  PERMISSION_TYPE_UPDATE_EXPERIMENT_METADATA: 'PERMISSION_TYPE_UPDATE_EXPERIMENT_METADATA',
  PERMISSION_TYPE_DELETE_EXPERIMENT: 'PERMISSION_TYPE_DELETE_EXPERIMENT',
  PERMISSION_TYPE_CREATE_NSC: 'PERMISSION_TYPE_CREATE_NSC',
  PERMISSION_TYPE_VIEW_NSC: 'PERMISSION_TYPE_VIEW_NSC',
  PERMISSION_TYPE_UPDATE_NSC: 'PERMISSION_TYPE_UPDATE_NSC',
  PERMISSION_TYPE_UPDATE_GROUP: 'PERMISSION_TYPE_UPDATE_GROUP',
  PERMISSION_TYPE_CREATE_WORKSPACE: 'PERMISSION_TYPE_CREATE_WORKSPACE',
  PERMISSION_TYPE_VIEW_WORKSPACE: 'PERMISSION_TYPE_VIEW_WORKSPACE',
  PERMISSION_TYPE_UPDATE_WORKSPACE: 'PERMISSION_TYPE_UPDATE_WORKSPACE',
  PERMISSION_TYPE_DELETE_WORKSPACE: 'PERMISSION_TYPE_DELETE_WORKSPACE',
  PERMISSION_TYPE_SET_WORKSPACE_AGENT_USER_GROUP: 'PERMISSION_TYPE_SET_WORKSPACE_AGENT_USER_GROUP',
  PERMISSION_TYPE_SET_WORKSPACE_CHECKPOINT_STORAGE_CONFIG: 'PERMISSION_TYPE_SET_WORKSPACE_CHECKPOINT_STORAGE_CONFIG',
  PERMISSION_TYPE_SET_WORKSPACE_DEFAULT_RESOURCE_POOL: 'PERMISSION_TYPE_SET_WORKSPACE_DEFAULT_RESOURCE_POOL',
  PERMISSION_TYPE_CREATE_PROJECT: 'PERMISSION_TYPE_CREATE_PROJECT',
  PERMISSION_TYPE_VIEW_PROJECT: 'PERMISSION_TYPE_VIEW_PROJECT',
  PERMISSION_TYPE_UPDATE_PROJECT: 'PERMISSION_TYPE_UPDATE_PROJECT',
  PERMISSION_TYPE_DELETE_PROJECT: 'PERMISSION_TYPE_DELETE_PROJECT',
  PERMISSION_TYPE_ASSIGN_ROLES: 'PERMISSION_TYPE_ASSIGN_ROLES',
  PERMISSION_TYPE_VIEW_MODEL_REGISTRY: 'PERMISSION_TYPE_VIEW_MODEL_REGISTRY',
  PERMISSION_TYPE_EDIT_MODEL_REGISTRY: 'PERMISSION_TYPE_EDIT_MODEL_REGISTRY',
  PERMISSION_TYPE_CREATE_MODEL_REGISTRY: 'PERMISSION_TYPE_CREATE_MODEL_REGISTRY',
  PERMISSION_TYPE_DELETE_MODEL_REGISTRY: 'PERMISSION_TYPE_DELETE_MODEL_REGISTRY',
  PERMISSION_TYPE_DELETE_MODEL_VERSION: 'PERMISSION_TYPE_DELETE_MODEL_VERSION',
  PERMISSION_TYPE_DELETE_OTHER_USER_MODEL_REGISTRY: 'PERMISSION_TYPE_DELETE_OTHER_USER_MODEL_REGISTRY',
  PERMISSION_TYPE_DELETE_OTHER_USER_MODEL_VERSION: 'PERMISSION_TYPE_DELETE_OTHER_USER_MODEL_VERSION',
  PERMISSION_TYPE_VIEW_MASTER_LOGS: 'PERMISSION_TYPE_VIEW_MASTER_LOGS',
  PERMISSION_TYPE_VIEW_CLUSTER_USAGE: 'PERMISSION_TYPE_VIEW_CLUSTER_USAGE',
  PERMISSION_TYPE_UPDATE_AGENTS: 'PERMISSION_TYPE_UPDATE_AGENTS',
  PERMISSION_TYPE_VIEW_SENSITIVE_AGENT_INFO: 'PERMISSION_TYPE_VIEW_SENSITIVE_AGENT_INFO',
  PERMISSION_TYPE_VIEW_MASTER_CONFIG: 'PERMISSION_TYPE_VIEW_MASTER_CONFIG',
  PERMISSION_TYPE_UPDATE_MASTER_CONFIG: 'PERMISSION_TYPE_UPDATE_MASTER_CONFIG',
  PERMISSION_TYPE_VIEW_EXTERNAL_JOBS: 'PERMISSION_TYPE_VIEW_EXTERNAL_JOBS',
  PERMISSION_TYPE_CONTROL_STRICT_JOB_QUEUE: 'PERMISSION_TYPE_CONTROL_STRICT_JOB_QUEUE',
  PERMISSION_TYPE_VIEW_TEMPLATES: 'PERMISSION_TYPE_VIEW_TEMPLATES',
  PERMISSION_TYPE_UPDATE_TEMPLATES: 'PERMISSION_TYPE_UPDATE_TEMPLATES',
  PERMISSION_TYPE_CREATE_TEMPLATES: 'PERMISSION_TYPE_CREATE_TEMPLATES',
  PERMISSION_TYPE_DELETE_TEMPLATES: 'PERMISSION_TYPE_DELETE_TEMPLATES',
  PERMISSION_TYPE_UPDATE_ROLES: 'PERMISSION_TYPE_UPDATE_ROLES',
  PERMISSION_TYPE_EDIT_WEBHOOKS: 'PERMISSION_TYPE_EDIT_WEBHOOKS',
  PERMISSION_TYPE_VIEW_WEBHOOKS: 'PERMISSION_TYPE_VIEW_WEBHOOKS',
  PERMISSION_TYPE_MODIFY_RP_WORKSPACE_BINDINGS: 'PERMISSION_TYPE_MODIFY_RP_WORKSPACE_BINDINGS',
  PERMISSION_TYPE_SET_WORKSPACE_NAMESPACE_BINDINGS: 'PERMISSION_TYPE_SET_WORKSPACE_NAMESPACE_BINDINGS',
  PERMISSION_TYPE_SET_RESOURCE_QUOTAS: 'PERMISSION_TYPE_SET_RESOURCE_QUOTAS',
  PERMISSION_TYPE_VIEW_RESOURCE_QUOTAS: 'PERMISSION_TYPE_VIEW_RESOURCE_QUOTAS',
  PERMISSION_TYPE_MODIFY_GLOBAL_CONFIG_POLICIES: 'PERMISSION_TYPE_MODIFY_GLOBAL_CONFIG_POLICIES',
  PERMISSION_TYPE_MODIFY_WORKSPACE_CONFIG_POLICIES: 'PERMISSION_TYPE_MODIFY_WORKSPACE_CONFIG_POLICIES',
  PERMISSION_TYPE_VIEW_GLOBAL_CONFIG_POLICIES: 'PERMISSION_TYPE_VIEW_GLOBAL_CONFIG_POLICIES',
  PERMISSION_TYPE_VIEW_WORKSPACE_CONFIG_POLICIES: 'PERMISSION_TYPE_VIEW_WORKSPACE_CONFIG_POLICIES',
  PERMISSION_TYPE_ADMINISTRATE_TOKEN: 'PERMISSION_TYPE_ADMINISTRATE_TOKEN',
  PERMISSION_TYPE_UPDATE_TOKEN: 'PERMISSION_TYPE_UPDATE_TOKEN',
  PERMISSION_TYPE_CREATE_TOKEN: 'PERMISSION_TYPE_CREATE_TOKEN',
  PERMISSION_TYPE_CREATE_OTHER_TOKEN: 'PERMISSION_TYPE_CREATE_OTHER_TOKEN',
  PERMISSION_TYPE_VIEW_OTHER_TOKEN: 'PERMISSION_TYPE_VIEW_OTHER_TOKEN',
  PERMISSION_TYPE_VIEW_TOKEN: 'PERMISSION_TYPE_VIEW_TOKEN',
} as const;

export interface V1Permission {
  id: V1PermissionType;
  name?: string;
  scopeTypeMask?: V1ScopeTypeMask;
}

/**
 * Response to PauseSearchesRequest.
 */
export interface V1PauseSearchesResponse {
  /** Details on success or error for each search. */
  results: V1SearchActionResult[];
}

/**
 * Request to pause the experiment associated witha search.
 */
export interface V1PauseSearchesRequest {
  filter?: string;
  /** The id of the project of the searches being paused. */
  projectId: number;
  /** The ids of the searches being moved. Leave empty if using filter. */
  searchIds?: number[];
}

/**
 * Response to PauseRunsRequest.
 */
export interface V1PauseRunsResponse {
  /** Details on success or error for each run. */
  results: V1RunActionResult[];
}

/**
 * Request to pause the experiment associated witha run.
 */
export interface V1PauseRunsRequest {
  filter?: string;
  /** The id of the project of the runs being paused. */
  projectId: number;
  /** The ids of the runs being paused. Leave empty if using filter. */
  runIds?: number[];
}

export interface V1PauseGenericTaskResponse { [key: string]: unknown }

/**
 * Response to PauseExperimentsRequest.
 */
export interface V1PauseExperimentsResponse {
  /** Details on success or error for each experiment. */
  results: V1ExperimentActionResult[];
}

/**
 * Pause multiple experiments.
 */
export interface V1PauseExperimentsRequest {
  /** Selecting experiments by id. */
  experimentIds: number[];
  filters?: V1BulkExperimentFilters;
  /** Project id that the experiments belong to. */
  projectId: number;
}

/**
 * Response to PauseExperimentRequest.
 */
export interface V1PauseExperimentResponse { [key: string]: unknown }

/**
 * The workspace-namespace bindings and resource quotas created.
 */
export type V1PatchWorkspaceResponseNamespaceBindings = {[key: string]: V1WorkspaceNamespaceBinding};

/**
 * Response to PatchWorkspaceRequest.
 */
export interface V1PatchWorkspaceResponse {
  /** The workspace-namespace bindings and resource quotas created. */
  namespaceBindings?: V1PatchWorkspaceResponseNamespaceBindings;
  workspace: V1Workspace;
}

/**
 * The map of clusters to workspace-namespace metadata (including the
workspace-namespace binding and the resource quota placed on the namespace
bound to the workspace for a given cluster).
 */
export type V1PatchWorkspaceClusterNamespaceMeta = {[key: string]: V1WorkspaceNamespaceMeta};

/**
 * Optional checkpoint storage config.
Expects same format as experiment config's checkpoint storage.
 */
export type V1PatchWorkspaceCheckpointStorageConfig = { [key: string]: unknown };

/**
 * PatchWorkspace is a partial update to a workspace with all optional fields.
 */
export interface V1PatchWorkspace {
  agentUserGroup?: V1AgentUserGroup;
  /** Optional checkpoint storage config.
Expects same format as experiment config's checkpoint storage. */
  checkpointStorageConfig?: V1PatchWorkspaceCheckpointStorageConfig;
  /** The map of clusters to workspace-namespace metadata (including the
workspace-namespace binding and the resource quota placed on the namespace
bound to the workspace for a given cluster). */
  clusterNamespaceMeta?: V1PatchWorkspaceClusterNamespaceMeta;
  /** Name of the default aux pool. */
  defaultAuxPool?: string;
  /** Name of the default aux pool can be optional. */
  defaultAuxResourcePool?: string;
  /** Name of the default compute pool. */
  defaultComputePool?: string;
  /** Name of the default compute pool can be optional. */
  defaultComputeResourcePool?: string;
  /** The new name for the workspace. */
  name?: string;
}

/**
 * Response to PatchWebhookRequest.
 */
export interface V1PatchWebhookResponse { [key: string]: unknown }

export interface V1PatchWebhook {
  /** The new url of the webhook. */
  url: string;
}

/**
 * Response to PatchUsersRequest.
 */
export interface V1PatchUsersResponse {
  /** Details on success or error for each user. */
  results: V1UserActionResult[];
}

/**
 * Update activation status for multiple users.
 */
export interface V1PatchUsersRequest {
  /** Intended status (true to activate, false to deactivate). */
  activate: boolean;
  filters?: V1UserFilters;
  /** A list of user IDs to update. */
  userIds: number[];
}

/**
 * Response to PatchUserRequest.
 */
export interface V1PatchUserResponse {
  user: V1User;
}

/**
 * Request to edit fields for a user.
 */
export interface V1PatchUser {
  /** Bool denoting whether the account is active. */
  active?: boolean;
  /** Bool denoting whether the account is an admin account. */
  admin?: boolean;
  agentUserGroup?: V1AgentUserGroup;
  /** Name to display in the web UI. */
  displayName?: string;
  /** Indicate whether the provided password is pre-salted & hashed or not. */
  isHashed?: boolean;
  /** String denoting the password of the user. */
  password?: string;
  /** Bool denoting whether the user should be able to login with or change a
password. */
  remote?: boolean;
  /** String denoting the username of the user. */
  username?: string;
}

/**
 * Response to PatchTrialRequest.
 */
export interface V1PatchTrialResponse {
  trial: Trialv1Trial;
}

/**
 * Patch a trial.
 */
export interface V1PatchTrialRequest {
  state?: Trialv1State;
  /** Trial id. */
  trialId: number;
}

export interface V1PatchTemplateNameResponse {
  template: V1Template;
}

export interface V1PatchTemplateNameRequest {
  /** The updated name. */
  newName: string;
  /** The current name. */
  oldName: string;
}

/**
 * Response to PatchTemplateConfigRequest.
 */
export interface V1PatchTemplateConfigResponse {
  template: V1Template;
}

/**
 * Response to PatchProjectRequest.
 */
export interface V1PatchProjectResponse {
  project: V1Project;
}

/**
 * PatchProject is a partial update to a project with all optional fields.
 */
export interface V1PatchProject {
  /** The new description for the project. */
  description?: string;
  /** The new key for the project. */
  key?: string;
  /** The new name for the project. */
  name?: string;
}

/**
 * Response to PatchModelVersionRequest.
 */
export interface V1PatchModelVersionResponse {
  modelVersion: V1ModelVersion;
}

/**
 * An updated metadata object for the model version.
 */
export type V1PatchModelVersionMetadata = { [key: string]: unknown };

export interface V1PatchModelVersion {
  checkpoint?: V1Checkpoint;
  /** An updated comment for the model version. */
  comment?: string;
  /** An updated label list for the model version. */
  labels?: string[];
  /** An updated metadata object for the model version. */
  metadata?: V1PatchModelVersionMetadata;
  /** An updated name for the model version. */
  name?: string;
  /** Updated text notes for the model version. */
  notes?: string;
}

/**
 * Response to PatchModelRequest.
 */
export interface V1PatchModelResponse {
  model: V1Model;
}

/**
 * An updated metadata object for the model.
 */
export type V1PatchModelMetadata = { [key: string]: unknown };

/**
 * PatchModel is a partial update to a model with only name required.
 */
export interface V1PatchModel {
  /** An updated description for the model. */
  description?: string;
  /** An updated label list for the model. */
  labels?: string[];
  /** An updated metadata object for the model. */
  metadata?: V1PatchModelMetadata;
  /**
   * An updated name for the model.
   * @minLength 1
   */
  name?: string;
  /** Updated notes associated with this model. */
  notes?: string;
  /** The id of the workspace associated with this model. */
  workspaceId?: number;
  /** The name of the workspace associated with this model. */
  workspaceName?: string;
}

/**
 * Response to PatchMasterConfigRequest.
 */
export interface V1PatchMasterConfigResponse { [key: string]: unknown }

/**
 * Patch master config.
 */
export interface V1PatchMasterConfigRequest {
  config?: V1Config;
  fieldMask?: ProtobufFieldMask;
}

/**
 * Response to PatchExperimentRequest.
 */
export interface V1PatchExperimentResponse {
  experiment?: V1Experiment;
}

/**
 * PatchExperiment is a partial update to an experiment with only id required.
 */
export interface V1PatchExperiment {
  checkpointStorage?: PatchExperimentPatchCheckpointStorage;
  /** The description of the experiment. */
  description?: string;
  /** The id of the experiment. */
  id: number;
  /** Labels attached to the experiment. */
  labels?: string[];
  /** The experiment name. */
  name?: string;
  /** The experiment notes. */
  notes?: string;
  resources?: PatchExperimentPatchResources;
}

/**
 * Intentionally don't send the updated response for performance reasons.
 */
export interface V1PatchCheckpointsResponse { [key: string]: unknown }

/**
 * Request to change checkpoint database information.
 */
export interface V1PatchCheckpoint {
  resources?: PatchCheckpointOptionalResources;
  /** The uuid of the checkpoint. */
  uuid: string;
}

/**
 * Request to patch database info about a checkpoint.
 */
export interface V1PatchCheckpointsRequest {
  /** List of checkpoints to patch. */
  checkpoints: V1PatchCheckpoint[];
}

/**
 * Response to PatchAccessTokenRequest.
 */
export interface V1PatchAccessTokenResponse {
  tokenInfo?: V1TokenInfo;
}

/**
 * Patch user's access token info.
 */
export interface V1PatchAccessTokenRequest {
  /** The requested updated token description. */
  description?: string;
  /** The requested updated token revoke status. */
  setRevoked?: boolean;
  /** The id of the token. */
  tokenId: number;
}

/**
 * Pagination provides information about the offset, limit, and total number of
records returned in the results.
 */
export interface V1Pagination {
  /** The index+1 of the last record in the dataset. */
  endIndex?: number;
  /** The amount of records limited in the results. */
  limit?: number;
  /** The number of records skipped before returning results. */
  offset?: number;
  /** The index of the first record in the dataset. */
  startIndex?: number;
  /** The total number of values that match the filter. */
  total?: number;
}

/**
 * Overwrite and replace the workspaces bound to an RP response.
 */
export interface V1OverwriteRPWorkspaceBindingsResponse { [key: string]: unknown }

/**
 * Overwrite and replace the workspaces bound to an RP request.
 */
export interface V1OverwriteRPWorkspaceBindingsRequest {
  /** The resource pool name. */
  resourcePoolName: string;
  /** The new workspace IDs to bind to the resource_pool. */
  workspaceIds?: number[];
  /** The new workspace names to bind to the resource_pool. */
  workspaceNames?: string[];
}

/**
 * Order records in either ascending or descending order.

 - ORDER_BY_UNSPECIFIED: Returns records in no specific order.
 - ORDER_BY_ASC: Returns records in ascending order.
 - ORDER_BY_DESC: Returns records in descending order.
 */
export type V1OrderBy = typeof V1OrderBy[keyof typeof V1OrderBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1OrderBy = {
  ORDER_BY_UNSPECIFIED: 'ORDER_BY_UNSPECIFIED',
  ORDER_BY_ASC: 'ORDER_BY_ASC',
  ORDER_BY_DESC: 'ORDER_BY_DESC',
} as const;

export type V1NotifyContainerRunningResponseDataItem = { [key: string]: unknown };

export interface V1NotifyContainerRunningResponse {
  /** The data for all the processes. */
  data: V1NotifyContainerRunningResponseDataItem[];
}

/**
 * The data from this process.
 */
export type V1NotifyContainerRunningRequestData = { [key: string]: unknown };

/**
 * Arguments to a notify container running.
 */
export interface V1NotifyContainerRunningRequest {
  /** The ID of the allocation. */
  allocationId: string;
  /** The data from this process. */
  data: V1NotifyContainerRunningRequestData;
  nodeName?: string;
  /** The number of process to wait for. */
  numPeers?: number;
  /** The container's rank. */
  rank?: number;
  /** The UUID of the participant in a notify container running message. */
  requestUuid?: string;
}

/**
 * Notebook is a Jupyter notebook in a containerized environment.
 */
export interface V1Notebook {
  container?: V1Container;
  /** The description of the notebook. */
  description: string;
  /** The display name of the user that created the notebook. */
  displayName?: string;
  /** The exit status. */
  exitStatus?: string;
  /** The id of the notebook. */
  id: string;
  /** The associated job id. */
  jobId: string;
  /** The name of the resource pool the Notebook was created in. */
  resourcePool: string;
  /** The service address. */
  serviceAddress?: string;
  /** The time the notebook was started. */
  startTime: string;
  state: Taskv1State;
  /** The id of the user that created the notebook. */
  userId?: number;
  /** The username of the user that created the notebook. */
  username: string;
  /** Workspace ID. */
  workspaceId: number;
}

/**
 * Note is a user comment connected to a project.
 */
export interface V1Note {
  /** The text contents of the note. */
  contents: string;
  /** The name or title of the note. */
  name: string;
}

/**
 * Response to MoveSearchesRequest.
 */
export interface V1MoveSearchesResponse {
  /** Details on success or error for each search. */
  results: V1SearchActionResult[];
}

/**
 * Request to move the search to a different project.
 */
export interface V1MoveSearchesRequest {
  /** The id of the new parent project. */
  destinationProjectId: number;
  filter?: string;
  /** The ids of the searches being moved. Leave empty if using filter. */
  searchIds?: number[];
  /** The id of the current parent project. */
  sourceProjectId: number;
}

/**
 * Response to MoveRunsRequest.
 */
export interface V1MoveRunsResponse {
  /** Details on success or error for each run. */
  results: V1RunActionResult[];
}

/**
 * Request to move the run to a different project.
 */
export interface V1MoveRunsRequest {
  /** The id of the new parent project. */
  destinationProjectId: number;
  filter?: string;
  /** The ids of the runs being moved. Leave empty if using filter. */
  runIds?: number[];
  /** If true, skip multi-trial experiments for move. */
  skipMultitrial?: boolean;
  /** The id of the current parent project. */
  sourceProjectId: number;
}

/**
 * Response to MoveProjectRequest.
 */
export interface V1MoveProjectResponse { [key: string]: unknown }

/**
 * Request to move a project into a workspace.
 */
export interface V1MoveProjectRequest {
  /** The id of the new parent workspace. */
  destinationWorkspaceId: number;
  /** The id of the project being moved. */
  projectId: number;
}

export interface V1MoveModelResponse { [key: string]: unknown }

/**
 * Request to move a model to a workspace.
 */
export interface V1MoveModelRequest {
  /** The workspace id that the model will be stored. */
  destinationWorkspaceId: number;
  /** The target model name. */
  modelName: string;
}

/**
 * Response to MoveExperimentsRequest.
 */
export interface V1MoveExperimentsResponse {
  /** Details on success or error for each experiment. */
  results: V1ExperimentActionResult[];
}

/**
 * Request to move an experiment into a project.
 */
export interface V1MoveExperimentsRequest {
  /** The id of the new parent project. */
  destinationProjectId: number;
  /** The ids of the experiments being moved. */
  experimentIds: number[];
  filters?: V1BulkExperimentFilters;
  /** Project id that the experiments belong to. */
  projectId: number;
}

/**
 * Response to MoveExperimentRequest.
 */
export interface V1MoveExperimentResponse { [key: string]: unknown }

/**
 * Request to move an experiment into a project.
 */
export interface V1MoveExperimentRequest {
  /** The id of the new parent project. */
  destinationProjectId: number;
  /** The id of the experiment being moved. */
  experimentId: number;
}

/**
 * Metadata associated with this model version.
 */
export type V1ModelVersionMetadata = { [key: string]: unknown };

/**
 * A version of a model containing a checkpoint. Users can label checkpoints as
a version of a model and use the model name and version to locate a
checkpoint.
 */
export interface V1ModelVersion {
  checkpoint: V1Checkpoint;
  /** Comment associated with this model version. */
  comment?: string;
  /** The time the model version was created. */
  creationTime: string;
  /** Unique id for each model version. */
  id: number;
  /** Labels associated with this model version. */
  labels?: string[];
  /** The time this model version was last updated. */
  lastUpdatedTime: string;
  /** Metadata associated with this model version. */
  metadata?: V1ModelVersionMetadata;
  model: V1Model;
  /** Name for this model version. */
  name?: string;
  /** Notes associated with this model version. */
  notes?: string;
  /** Id of the user who created this model version. */
  userId?: number;
  /** Username of the user who created this model version. */
  username?: string;
  /** The version number. */
  version: number;
}

/**
 * The user-defined metadata of the model.
 */
export type V1ModelMetadata = { [key: string]: unknown };

/**
 * Model is a named collection of model versions.
 */
export interface V1Model {
  /** Whether this model is archived or not. */
  archived: boolean;
  /** The time the model was created. */
  creationTime: string;
  /** The description of the model. */
  description?: string;
  /** The id of this model. */
  id: number;
  /** Labels associated with this model. */
  labels?: string[];
  /** The time the model was last updated. */
  lastUpdatedTime: string;
  /** The user-defined metadata of the model. */
  metadata: V1ModelMetadata;
  /**
   * The name of the model.
   * @minLength 1
   */
  name: string;
  /** Notes associated with this model. */
  notes?: string;
  /** The number of versions associated with this model. */
  numVersions: number;
  /** Id of the user who created this model. */
  userId: number;
  /** Username of the user who created this model. */
  username: string;
  /** The id of the workspace associated with this model. */
  workspaceId: number;
}

/**
 * MetricsWorkload is a workload generating metrics.
 */
export interface V1MetricsWorkload {
  /** The time the workload finished or was stopped. */
  endTime?: string;
  metrics: V1Metrics;
  /** Number of inputs processed. */
  numInputs: number;
  /** Total number of batches as of this workload's completion. */
  totalBatches: number;
}

/**
 * Struct of the reported metrics.
 */
export type V1MetricsReportMetrics = { [key: string]: unknown };

/**
 * Metrics report.
 */
export interface V1MetricsReport {
  /** If metric is archived. */
  archived: boolean;
  /** End time of when metric was reported. */
  endTime: string;
  group: string;
  /** ID of metric in table. */
  id: number;
  /** Struct of the reported metrics. */
  metrics: V1MetricsReportMetrics;
  /** batches completed in the report. */
  totalBatches: number;
  /** ID of the trial. */
  trialId: number;
  /** Run ID of trial when metric was reported. */
  trialRunId: number;
}

/**
 * MetricsRange represents the range of a metrics. Range is a in the format of
[min, max].
 */
export interface V1MetricsRange {
  /** The max of metrics values. */
  max: number;
  /** The name of metrics formatted as <type>.<name>. */
  metricsName: string;
  /** The min of metrics values. */
  min: number;
}

export type V1MetricsBatchMetricsItem = { [key: string]: unknown };

export type V1MetricsAvgMetrics = { [key: string]: unknown };

export interface V1Metrics {
  avgMetrics: V1MetricsAvgMetrics;
  batchMetrics?: V1MetricsBatchMetricsItem[];
}

/**
 * To distinguish the different categories of metrics.

 - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).
 - METRIC_TYPE_TRAINING: For metrics emitted during training.
 - METRIC_TYPE_VALIDATION: For metrics emitted during validation.
 - METRIC_TYPE_PROFILING: For metrics emitted during profiling.
 */
export type V1MetricType = typeof V1MetricType[keyof typeof V1MetricType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1MetricType = {
  METRIC_TYPE_UNSPECIFIED: 'METRIC_TYPE_UNSPECIFIED',
  METRIC_TYPE_TRAINING: 'METRIC_TYPE_TRAINING',
  METRIC_TYPE_VALIDATION: 'METRIC_TYPE_VALIDATION',
  METRIC_TYPE_PROFILING: 'METRIC_TYPE_PROFILING',
} as const;

/**
 * MetricIdentifier packages metric name and group.
 */
export interface V1MetricIdentifier {
  /** The group of the metric. */
  group: string;
  /** The name of the metric. */
  name: string;
}

/**
 * Response to MetricBatchesRequest.
 */
export interface V1MetricBatchesResponse {
  /** Milestones (in batches processed) at which the specified metric is
recorded. */
  batches?: number[];
}

/**
 * Response to MasterLogsRequest.
 */
export interface V1MasterLogsResponse {
  logEntry: V1LogEntry;
}

/**
 * Response to MarkAllocationResourcesDaemonRequest.
 */
export interface V1MarkAllocationResourcesDaemonResponse { [key: string]: unknown }

/**
 * Mark some reservation as a daemon.
 */
export interface V1MarkAllocationResourcesDaemonRequest {
  /** The id of the allocation. */
  allocationId: string;
  /** The id of the clump of resources to mark as daemon. */
  resourcesId?: string;
}

/**
 * Response to LogoutRequest.
 */
export interface V1LogoutResponse { [key: string]: unknown }

/**
 * Response to LoginRequest.
 */
export interface V1LoginResponse {
  /** The token to be used when sending results. */
  token: string;
  user: V1User;
}

/**
 * Login the user.
 */
export interface V1LoginRequest {
  /** Indicate whether the provided password is pre-salted & hashed or not. */
  isHashed?: boolean;
  /** The password of the user. */
  password: string;
  /** The username of the user. */
  username: string;
}

/**
 * LogLevel specifies the level for a log.

 - LOG_LEVEL_UNSPECIFIED: Unspecified log level.
 - LOG_LEVEL_TRACE: A log level of TRACE.
 - LOG_LEVEL_DEBUG: A log level of DEBUG.
 - LOG_LEVEL_INFO: A log level of INFO.
 - LOG_LEVEL_WARNING: A log level of WARNING.
 - LOG_LEVEL_ERROR: A log level of ERROR.
 - LOG_LEVEL_CRITICAL: A log level of CRITICAL.
 */
export type V1LogLevel = typeof V1LogLevel[keyof typeof V1LogLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1LogLevel = {
  LOG_LEVEL_UNSPECIFIED: 'LOG_LEVEL_UNSPECIFIED',
  LOG_LEVEL_TRACE: 'LOG_LEVEL_TRACE',
  LOG_LEVEL_DEBUG: 'LOG_LEVEL_DEBUG',
  LOG_LEVEL_INFO: 'LOG_LEVEL_INFO',
  LOG_LEVEL_WARNING: 'LOG_LEVEL_WARNING',
  LOG_LEVEL_ERROR: 'LOG_LEVEL_ERROR',
  LOG_LEVEL_CRITICAL: 'LOG_LEVEL_CRITICAL',
} as const;

/**
 * LogEntry is a log event.
 */
export interface V1LogEntry {
  /** The id. */
  id: number;
  level: V1LogLevel;
  /** The message. */
  message: string;
  /** The timestamp. */
  timestamp: string;
}

export interface V1LogConfig {
  /** The color setting for log in Master Config. */
  color?: boolean;
  level?: V1LogLevel;
}

/**
 * - LOCATION_TYPE_UNSPECIFIED: Location unknown
 - LOCATION_TYPE_EXPERIMENT: Column is located on the experiment
 - LOCATION_TYPE_HYPERPARAMETERS: Column is located in the hyperparameter config of the experiment
 - LOCATION_TYPE_VALIDATIONS: Column is located on the experiment's validation metrics
 - LOCATION_TYPE_TRAINING: Column is located on the experiment's training steps
 - LOCATION_TYPE_CUSTOM_METRIC: Column is located on the experiment's custom metric
 - LOCATION_TYPE_RUN: Column is located on the run
 - LOCATION_TYPE_RUN_HYPERPARAMETERS: Column is located in the hyperparameter of the run
 - LOCATION_TYPE_RUN_METADATA: Column is located on the run's arbitrary metadata
 */
export type V1LocationType = typeof V1LocationType[keyof typeof V1LocationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1LocationType = {
  LOCATION_TYPE_UNSPECIFIED: 'LOCATION_TYPE_UNSPECIFIED',
  LOCATION_TYPE_EXPERIMENT: 'LOCATION_TYPE_EXPERIMENT',
  LOCATION_TYPE_HYPERPARAMETERS: 'LOCATION_TYPE_HYPERPARAMETERS',
  LOCATION_TYPE_VALIDATIONS: 'LOCATION_TYPE_VALIDATIONS',
  LOCATION_TYPE_TRAINING: 'LOCATION_TYPE_TRAINING',
  LOCATION_TYPE_CUSTOM_METRIC: 'LOCATION_TYPE_CUSTOM_METRIC',
  LOCATION_TYPE_RUN: 'LOCATION_TYPE_RUN',
  LOCATION_TYPE_RUN_HYPERPARAMETERS: 'LOCATION_TYPE_RUN_HYPERPARAMETERS',
  LOCATION_TYPE_RUN_METADATA: 'LOCATION_TYPE_RUN_METADATA',
} as const;

/**
 * Response to ListWorkspacesBoundToRPRequest.
 */
export interface V1ListWorkspacesBoundToRPResponse {
  pagination?: V1Pagination;
  /** List of workspace IDs. */
  workspaceIds?: number[];
}

/**
 * List of workspace-namespace bindings for a given workspace.
 */
export type V1ListWorkspaceNamespaceBindingsResponseNamespaceBindings = {[key: string]: V1WorkspaceNamespaceBinding};

/**
 * Response for listing namespaces bound to a workspace.
 */
export interface V1ListWorkspaceNamespaceBindingsResponse {
  /** List of workspace-namespace bindings for a given workspace. */
  namespaceBindings: V1ListWorkspaceNamespaceBindingsResponseNamespaceBindings;
}

/**
 * ListRolesResponse is the body of the response for the call
to search for a role.
 */
export interface V1ListRolesResponse {
  pagination: V1Pagination;
  /** a set of roles and all assignments belonging to it. */
  roles: V1Role[];
}

/**
 * ListRolesRequest is the body of the request for the call
to search for a role.
 */
export interface V1ListRolesRequest {
  /** the limit for pagination. */
  limit: number;
  /** the offset for pagination. */
  offset?: number;
}

/**
 * Response to ListWorkspaceRPsRequest.
 */
export interface V1ListRPsBoundToWorkspaceResponse {
  pagination?: V1Pagination;
  /** List of resource pools bound to the workspace. */
  resourcePools?: string[];
}

/**
 * LimitedJob is a Job with omitted fields.
 */
export interface V1LimitedJob {
  /** Number of allocated slots. */
  allocatedSlots: number;
  /** Whether the job is preemptible. */
  isPreemptible: boolean;
  /** Job type. */
  jobId: string;
  /** The job priority in priority scheduler. */
  priority?: number;
  /** Job's progress from 0 to 1. */
  progress?: number;
  /** Number of requested slots. */
  requestedSlots: number;
  /** Associated resource pool. */
  resourcePool: string;
  summary?: V1JobSummary;
  type: Jobv1Type;
  /** The job weight in fairshare scheduler. */
  weight?: number;
  /** Job's workspace id. */
  workspaceId: number;
}

/**
 * Enum values for warnings when launching commands.

 - LAUNCH_WARNING_UNSPECIFIED: Default value
 - LAUNCH_WARNING_CURRENT_SLOTS_EXCEEDED: For a default webhook
 */
export type V1LaunchWarning = typeof V1LaunchWarning[keyof typeof V1LaunchWarning];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1LaunchWarning = {
  LAUNCH_WARNING_UNSPECIFIED: 'LAUNCH_WARNING_UNSPECIFIED',
  LAUNCH_WARNING_CURRENT_SLOTS_EXCEEDED: 'LAUNCH_WARNING_CURRENT_SLOTS_EXCEEDED',
} as const;

export type V1LaunchTensorboardSearchesResponseConfig = { [key: string]: unknown };

/**
 * Response to LaunchTensorboardSearchesRequest.
 */
export interface V1LaunchTensorboardSearchesResponse {
  config: V1LaunchTensorboardSearchesResponseConfig;
  tensorboard: V1Tensorboard;
  /** List of any related warnings. */
  warnings?: V1LaunchWarning[];
}

/**
 * Tensorboard config (JSON).
 */
export type V1LaunchTensorboardSearchesRequestConfig = { [key: string]: unknown };

/**
 * Request to launch a tensorboard using searches matching a filter.
 */
export interface V1LaunchTensorboardSearchesRequest {
  /** Tensorboard config (JSON). */
  config?: V1LaunchTensorboardSearchesRequestConfig;
  /** The files to run with the command. */
  files?: V1File[];
  /** Targets all searches matching filter expression. Leave empty if using IDs. */
  filter?: string;
  /** Target search IDs. Leave empty if using filter. */
  searchIds?: number[];
  /** Tensorboard template name. */
  templateName?: string;
  /** Workspace in which to launch tensorboard. Defaults to 'Uncategorized'. */
  workspaceId?: number;
}

export type V1LaunchTensorboardResponseConfig = { [key: string]: unknown };

/**
 * Response to LaunchTensorboardRequest.
 */
export interface V1LaunchTensorboardResponse {
  config: V1LaunchTensorboardResponseConfig;
  tensorboard: V1Tensorboard;
  /** List of any related warnings. */
  warnings?: V1LaunchWarning[];
}

/**
 * Tensorboard config (JSON).
 */
export type V1LaunchTensorboardRequestConfig = { [key: string]: unknown };

/**
 * Request to launch a tensorboard.
 */
export interface V1LaunchTensorboardRequest {
  /** Tensorboard config (JSON). */
  config?: V1LaunchTensorboardRequestConfig;
  /** List of source experiment ids. */
  experimentIds?: number[];
  /** The files to run with the command. */
  files?: V1File[];
  filters?: V1BulkExperimentFilters;
  /** Tensorboard template name. */
  templateName?: string;
  /** List of source trial ids. */
  trialIds?: number[];
  /** Workspace in which to launch tensorboard. Defaults to 'Uncategorized'. */
  workspaceId?: number;
}

export type V1LaunchShellResponseConfig = { [key: string]: unknown };

/**
 * Response to LaunchShellRequest.
 */
export interface V1LaunchShellResponse {
  config: V1LaunchShellResponseConfig;
  shell: V1Shell;
  /** List of any related warnings. */
  warnings?: V1LaunchWarning[];
}

/**
 * Shell config (JSON).
 */
export type V1LaunchShellRequestConfig = { [key: string]: unknown };

/**
 * Request to launch a shell.
 */
export interface V1LaunchShellRequest {
  /** Shell config (JSON). */
  config?: V1LaunchShellRequestConfig;
  /** Deprecated: Do not use. */
  data?: string;
  /** The files to run with the command. */
  files?: V1File[];
  /** Template name. */
  templateName?: string;
  /** Workspace ID. Defaults to 'Uncategorized' workspace if not specified. */
  workspaceId?: number;
}

export type V1LaunchNotebookResponseConfig = { [key: string]: unknown };

/**
 * Response to LaunchNotebookRequest.
 */
export interface V1LaunchNotebookResponse {
  config: V1LaunchNotebookResponseConfig;
  notebook: V1Notebook;
  /** List of any related warnings. */
  warnings?: V1LaunchWarning[];
}

/**
 * Notebook config (JSON).
 */
export type V1LaunchNotebookRequestConfig = { [key: string]: unknown };

/**
 * Request to launch a notebook.
 */
export interface V1LaunchNotebookRequest {
  /** Notebook config (JSON). */
  config?: V1LaunchNotebookRequestConfig;
  /** The files to run with the command. */
  files?: V1File[];
  /** Preview a launching request without actually creating a Notebook. */
  preview?: boolean;
  /** Template name. */
  templateName?: string;
  /** Workspace ID. Defaults to 'Uncategorized' workspace if not specified. */
  workspaceId?: number;
}

export type V1LaunchCommandResponseConfig = { [key: string]: unknown };

/**
 * Response to LaunchCommandRequest.
 */
export interface V1LaunchCommandResponse {
  command: V1Command;
  config: V1LaunchCommandResponseConfig;
  /** If the requested slots exceeded the current max available. */
  warnings?: V1LaunchWarning[];
}

/**
 * Command config (JSON).
 */
export type V1LaunchCommandRequestConfig = { [key: string]: unknown };

/**
 * Request to launch a command.
 */
export interface V1LaunchCommandRequest {
  /** Command config (JSON). */
  config?: V1LaunchCommandRequestConfig;
  /** Additional data. */
  data?: string;
  /** The files to run with the command. */
  files?: V1File[];
  /** Template name. */
  templateName?: string;
  /** Workspace ID. Defaults to the 'Uncategorized' workspace if not specified. */
  workspaceId?: number;
}

/**
 * Response to KillTrialRequest.
 */
export interface V1KillTrialResponse { [key: string]: unknown }

/**
 * Response to KillTensorboardRequest.
 */
export interface V1KillTensorboardResponse {
  tensorboard?: V1Tensorboard;
}

/**
 * Response to KillShellRequest.
 */
export interface V1KillShellResponse {
  shell?: V1Shell;
}

/**
 * Response to KillSearchesRequest.
 */
export interface V1KillSearchesResponse {
  /** Details on success or error for each search. */
  results: V1SearchActionResult[];
}

/**
 * Kill searches.
 */
export interface V1KillSearchesRequest {
  filter?: string;
  /** Project id of the searches being killed. */
  projectId: number;
  /** The ids of the searches being killed. Leave empty if using filter. */
  searchIds?: number[];
}

/**
 * Response to KillRunsResponse.
 */
export interface V1KillRunsResponse {
  /** Details on success or error for each run. */
  results: V1RunActionResult[];
}

/**
 * Kill runs.
 */
export interface V1KillRunsRequest {
  filter?: string;
  /** Project id of the runs being killed. */
  projectId?: number;
  /** The ids of the runs being killed. Leave empty if using filter. */
  runIds?: number[];
}

/**
 * Response to KillNotebookRequest.
 */
export interface V1KillNotebookResponse {
  notebook?: V1Notebook;
}

export interface V1KillGenericTaskResponse { [key: string]: unknown }

export interface V1KillGenericTaskRequest {
  killFromRoot?: boolean;
  /** The id of the task. */
  taskId: string;
}

/**
 * Response to KillExperimentsRequest.
 */
export interface V1KillExperimentsResponse {
  /** Details on success or error for each experiment. */
  results: V1ExperimentActionResult[];
}

/**
 * Kill multiple experiments.
 */
export interface V1KillExperimentsRequest {
  /** Selecting experiments by id. */
  experimentIds: number[];
  filters?: V1BulkExperimentFilters;
  /** Project id that the experiments belong to. */
  projectId: number;
}

/**
 * Response to KillExperimentRequest.
 */
export interface V1KillExperimentResponse { [key: string]: unknown }

/**
 * Response to KillCommandRequest.
 */
export interface V1KillCommandResponse {
  command?: V1Command;
}

export interface V1K8PriorityClass {
  /** Priority class name. */
  priorityClass?: string;
  /** Priority class value. */
  priorityValue?: number;
}

/**
 * Job summary.
 */
export interface V1JobSummary {
  /** The number of jobs ahead of this one in the queue. */
  jobsAhead: number;
  state: Jobv1State;
}

/**
 * Job represents a user submitted work that is not in a terminal
state.
 */
export interface V1Job {
  /** Number of allocated slots. */
  allocatedSlots: number;
  /** Entity ID. */
  entityId: string;
  /** Whether the job is preemptible. */
  isPreemptible: boolean;
  /** Job type. */
  jobId: string;
  /** Job name. */
  name: string;
  /** The job priority in priority scheduler. */
  priority?: number;
  /** Job's progress from 0 to 1. */
  progress?: number;
  /** Number of requested slots. */
  requestedSlots: number;
  /** Associated resource pool. */
  resourcePool: string;
  /** The time when the job was submitted by the user. */
  submissionTime: string;
  summary?: V1JobSummary;
  type: Jobv1Type;
  /** The id of the user who submitted the job. */
  userId?: number;
  /** The username of the user who submitted the job. */
  username: string;
  /** The job weight in fairshare scheduler. */
  weight?: number;
  /** Job's workspace id. */
  workspaceId: number;
}

/**
 * Int32 filters.
 */
export interface V1Int32FieldFilter {
  /** Greater than. */
  gt?: number;
  /** Greater than or equal. */
  gte?: number;
  /** In a set. `in` is a reserved word in python. */
  incl?: number[];
  /** Less than. */
  lt?: number;
  /** Less than or equal. */
  lte?: number;
  /** Not in a set. */
  notIn?: number[];
}

/**
 * Response to IdleNotebookRequest.
 */
export interface V1IdleNotebookResponse { [key: string]: unknown }

/**
 * Kill the requested notebook if idle.
 */
export interface V1IdleNotebookRequest {
  idle?: boolean;
  /** The id of the notebook. */
  notebookId?: string;
}

/**
 * GroupSearchResult is the representation of groups as they're returned
by the search endpoint.
 */
export interface V1GroupSearchResult {
  group: V1Group;
  numMembers: number;
}

/**
 * GroupRoleAssignment contains information about the groups
belonging to a role.
 */
export interface V1GroupRoleAssignment {
  groupId: number;
  roleAssignment: V1RoleAssignment;
}

/**
 * GroupDetails contains detailed information about a specific Group
including which users belong to the group.
 */
export interface V1GroupDetails {
  groupId?: number;
  name?: string;
  users?: V1User[];
}

export interface V1Group {
  groupId?: number;
  name?: string;
}

/**
 * Response to GetUnboundWorkspacesRequest.
 */
export interface V1GetWorkspacesWithDefaultNamespaceBindingsResponse {
  /** The list of returned workspace ids. */
  workspaceIds?: number[];
}

/**
 * Response to GetWorkspacesRequest.
 */
export interface V1GetWorkspacesResponse {
  pagination: V1Pagination;
  /** The list of returned workspaces. */
  workspaces: V1Workspace[];
}

/**
 * Sort workspaces by the given field.

 - SORT_BY_UNSPECIFIED: Returns workspaces in an unsorted list.
 - SORT_BY_ID: Returns workspaces sorted by id.
 - SORT_BY_NAME: Returns workspaces sorted by name.
 */
export type V1GetWorkspacesRequestSortBy = typeof V1GetWorkspacesRequestSortBy[keyof typeof V1GetWorkspacesRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetWorkspacesRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_NAME: 'SORT_BY_NAME',
} as const;

/**
 * Response to GetWorkspaceRequest.
 */
export interface V1GetWorkspaceResponse {
  workspace: V1Workspace;
}

/**
 * Response to GetWorkspaceProjectsRequest.
 */
export interface V1GetWorkspaceProjectsResponse {
  pagination: V1Pagination;
  /** The projects associated with the workspace. */
  projects: V1Project[];
}

/**
 * Sort associated projects by the given field.

 - SORT_BY_UNSPECIFIED: Returns projects in an unsorted list.
 - SORT_BY_CREATION_TIME: Returns projects sorted by time that they were created.
 - SORT_BY_LAST_EXPERIMENT_START_TIME: Returns projects sorted by most recent start of an experiment.
 - SORT_BY_NAME: Returns projects sorted by name.
 - SORT_BY_DESCRIPTION: Returns projects sorted by description.
 - SORT_BY_ID: Returns projects sorted by ID.
 */
export type V1GetWorkspaceProjectsRequestSortBy = typeof V1GetWorkspaceProjectsRequestSortBy[keyof typeof V1GetWorkspaceProjectsRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetWorkspaceProjectsRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_CREATION_TIME: 'SORT_BY_CREATION_TIME',
  SORT_BY_LAST_EXPERIMENT_START_TIME: 'SORT_BY_LAST_EXPERIMENT_START_TIME',
  SORT_BY_NAME: 'SORT_BY_NAME',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_ID: 'SORT_BY_ID',
} as const;

/**
 * The current config policies saved for the workspace. Contains both
invariant configs and constraints in yaml or json format.
 */
export type V1GetWorkspaceConfigPoliciesResponseConfigPolicies = { [key: string]: unknown };

/**
 * Response to GetWorkspaceConfigPoliciesRequest.
 */
export interface V1GetWorkspaceConfigPoliciesResponse {
  /** The current config policies saved for the workspace. Contains both
invariant configs and constraints in yaml or json format. */
  configPolicies?: V1GetWorkspaceConfigPoliciesResponseConfigPolicies;
}

/**
 * Response to GetWebhooksRequest.
 */
export interface V1GetWebhooksResponse {
  /** The list of returned webhooks. */
  webhooks: V1Webhook[];
}

/**
 * Response to GetTrainingMetricsRequest.
 */
export interface V1GetValidationMetricsResponse {
  /** Metric response. */
  metrics: V1MetricsReport[];
}

/**
 * Response to GetUsersRequest.
 */
export interface V1GetUsersResponse {
  pagination?: V1Pagination;
  /** The list of requested users. */
  users?: V1User[];
}

/**
 * Sort users by the given field.

 - SORT_BY_UNSPECIFIED: Returns users in an unsorted list.
 - SORT_BY_DISPLAY_NAME: Returns users sorted by display name.
 - SORT_BY_USER_NAME: Returns users sorted by user name.
 - SORT_BY_ADMIN: Returns users sorted by if they are admin.
 - SORT_BY_ACTIVE: Returns users sorted by if they are active.
 - SORT_BY_MODIFIED_TIME: Returns users sorted by modified time.
 - SORT_BY_NAME: Returns users sorted by username unless display name exist.
 - SORT_BY_LAST_AUTH_TIME: Returns users sorted by last authenticated time.
 - SORT_BY_REMOTE: Returns users sorted by local or remote auth.
 */
export type V1GetUsersRequestSortBy = typeof V1GetUsersRequestSortBy[keyof typeof V1GetUsersRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetUsersRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_DISPLAY_NAME: 'SORT_BY_DISPLAY_NAME',
  SORT_BY_USER_NAME: 'SORT_BY_USER_NAME',
  SORT_BY_ADMIN: 'SORT_BY_ADMIN',
  SORT_BY_ACTIVE: 'SORT_BY_ACTIVE',
  SORT_BY_MODIFIED_TIME: 'SORT_BY_MODIFIED_TIME',
  SORT_BY_NAME: 'SORT_BY_NAME',
  SORT_BY_LAST_AUTH_TIME: 'SORT_BY_LAST_AUTH_TIME',
  SORT_BY_REMOTE: 'SORT_BY_REMOTE',
} as const;

/**
 * Response to GetUserSettingRequest.
 */
export interface V1GetUserSettingResponse {
  /** List of user settings. */
  settings: V1UserWebSetting[];
}

/**
 * Response to GetUserRequest.
 */
export interface V1GetUserResponse {
  user: V1User;
}

/**
 * Response to GetUserByUsernameRequest.
 */
export interface V1GetUserByUsernameResponse {
  user: V1User;
}

/**
 * Response to GetTrialWorkloadsRequest.
 */
export interface V1GetTrialWorkloadsResponse {
  pagination: V1Pagination;
  /** The list of returned workloads. */
  workloads: V1WorkloadContainer[];
}

/**
 * Response to GetTrialRequest.
 */
export interface V1GetTrialResponse {
  trial: Trialv1Trial;
}

/**
 * Response to GetTrialRemainingLogRetentionDaysRequest.
 */
export interface V1GetTrialRemainingLogRetentionDaysResponse {
  /** The remaining log retention days for the trial id. */
  remainingDays?: number;
}

export interface V1GetTrialProfilerMetricsResponse {
  batch: V1TrialProfilerMetricsBatch;
}

/**
 * Response to TrialProfilerAvailableSeriesRequest.
 */
export interface V1GetTrialProfilerAvailableSeriesResponse {
  /** The labels for the series. */
  labels: V1TrialProfilerMetricLabels[];
}

export interface V1GetTrialMetricsByModelVersionResponse {
  metrics: V1MetricsReport[];
}

export interface V1GetTrialMetricsByCheckpointResponse {
  metrics: V1MetricsReport[];
}

/**
 * Response to GetTrialCheckpointsRequest.
 */
export interface V1GetTrialCheckpointsResponse {
  /** The list of returned checkpoints. */
  checkpoints: V1Checkpoint[];
  pagination: V1Pagination;
}

/**
 * Response to GetTrialByExternalIDRequest.
 */
export interface V1GetTrialByExternalIDResponse {
  trial: Trialv1Trial;
}

/**
 * Response to GetTrainingMetricsRequest.
 */
export interface V1GetTrainingMetricsResponse {
  /** Metric response. */
  metrics: V1MetricsReport[];
}

/**
 * Response to GetTensorboardsRequest.
 */
export interface V1GetTensorboardsResponse {
  pagination?: V1Pagination;
  /** The list of returned tensorboards. */
  tensorboards: V1Tensorboard[];
}

/**
 * Sorts tensorboards by the given field.

 - SORT_BY_UNSPECIFIED: Returns tensorboards in an unsorted list.
 - SORT_BY_ID: Returns tensorboards sorted by id.
 - SORT_BY_DESCRIPTION: Returns tensorboards sorted by description.
 - SORT_BY_START_TIME: Return tensorboards sorted by start time.
 - SORT_BY_WORKSPACE_ID: Return tensorboards sorted by workspace_id.
 */
export type V1GetTensorboardsRequestSortBy = typeof V1GetTensorboardsRequestSortBy[keyof typeof V1GetTensorboardsRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetTensorboardsRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_START_TIME: 'SORT_BY_START_TIME',
  SORT_BY_WORKSPACE_ID: 'SORT_BY_WORKSPACE_ID',
} as const;

export type V1GetTensorboardResponseConfig = { [key: string]: unknown };

/**
 * Response to GetTensorboardRequest.
 */
export interface V1GetTensorboardResponse {
  config: V1GetTensorboardResponseConfig;
  tensorboard: V1Tensorboard;
}

/**
 * Response to GetTemplatesRequest.
 */
export interface V1GetTemplatesResponse {
  pagination: V1Pagination;
  /** the list of requested templates. */
  templates: V1Template[];
}

/**
 * Sorts templates by the given field.

 - SORT_BY_UNSPECIFIED: Returns templates in an unsorted list.
 - SORT_BY_NAME: Returns templates sorted by name.
 */
export type V1GetTemplatesRequestSortBy = typeof V1GetTemplatesRequestSortBy[keyof typeof V1GetTemplatesRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetTemplatesRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_NAME: 'SORT_BY_NAME',
} as const;

/**
 * Response to GetTemplateRequest.
 */
export interface V1GetTemplateResponse {
  template: V1Template;
}

/**
 * Response to GetTelemetryRequest.
 */
export interface V1GetTelemetryResponse {
  /** Whether telemetry is enabled or not. */
  enabled: boolean;
  /** The key used for analytics in the UI. */
  segmentKey?: string;
}

/**
 * Information about a task for external display.
 */
export type V1GetTasksResponseAllocationIdToSummary = {[key: string]: V1AllocationSummary};

/**
 * Response to GetTasksRequest.
 */
export interface V1GetTasksResponse {
  /** Information about a task for external display. */
  allocationIdToSummary?: V1GetTasksResponseAllocationIdToSummary;
}

/**
 * Response to GetTaskRequest.
 */
export interface V1GetTaskResponse {
  task: V1Task;
}

/**
 * Response to GetTaskContextDirectoryRequest.
 */
export interface V1GetTaskContextDirectoryResponse {
  /** The base64-encoded, gzipped, tarball. */
  b64Tgz: string;
}

export interface V1GetTaskAcceleratorDataResponse {
  /** The accelerator data for each allocation associated with the task. */
  acceleratorData: V1AcceleratorData[];
}

/**
 * Response to GetSlotsRequest.
 */
export interface V1GetSlotsResponse {
  /** The requested slots. */
  slots?: V1Slot[];
}

/**
 * Response to GetSlotRequest.
 */
export interface V1GetSlotResponse {
  slot?: V1Slot;
}

/**
 * Response to GetShellsRequest.
 */
export interface V1GetShellsResponse {
  pagination?: V1Pagination;
  /** The list of returned shells. */
  shells: V1Shell[];
}

/**
 * Sorts shells by the given field.

 - SORT_BY_UNSPECIFIED: Returns shells in an unsorted list.
 - SORT_BY_ID: Returns shells sorted by id.
 - SORT_BY_DESCRIPTION: Returns shells sorted by description.
 - SORT_BY_START_TIME: Return shells sorted by start time.
 - SORT_BY_WORKSPACE_ID: Return shells sorted by workspace_id.
 */
export type V1GetShellsRequestSortBy = typeof V1GetShellsRequestSortBy[keyof typeof V1GetShellsRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetShellsRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_START_TIME: 'SORT_BY_START_TIME',
  SORT_BY_WORKSPACE_ID: 'SORT_BY_WORKSPACE_ID',
} as const;

/**
 * The shell config.
 */
export type V1GetShellResponseConfig = { [key: string]: unknown };

/**
 * Response to GetShellRequest.
 */
export interface V1GetShellResponse {
  /** The shell config. */
  config: V1GetShellResponseConfig;
  shell: V1Shell;
}

/**
 * The arbitrary metadata of the run.
 */
export type V1GetRunMetadataResponseMetadata = { [key: string]: unknown };

/**
 * Response to get the metadata of a run.
 */
export interface V1GetRunMetadataResponse {
  /** The arbitrary metadata of the run. */
  metadata?: V1GetRunMetadataResponseMetadata;
}

export interface V1GetRolesByIDResponse {
  roles?: V1RoleWithAssignments[];
}

export interface V1GetRolesByIDRequest {
  roleIds?: number[];
}

export interface V1GetRolesAssignedToUserResponse {
  /** The roles assigned to the requested user with assignment information. */
  roles: V1RoleWithAssignments[];
}

export interface V1GetRolesAssignedToGroupResponse {
  /** What scope each role is assigned to. */
  assignments: V1RoleAssignmentSummary[];
  /** The roles assigned to the requested groups. */
  roles: V1Role[];
}

/**
 * Response to GetResourcePoolsRequest.
 */
export interface V1GetResourcePoolsResponse {
  pagination?: V1Pagination;
  /** The list of returned resource pools. */
  resourcePools?: V1ResourcePool[];
}

/**
 * Response to GetProjectsByUserActivityRequest.
 */
export interface V1GetProjectsByUserActivityResponse {
  projects?: V1Project[];
}

/**
 * Response to GetProjectRequest.
 */
export interface V1GetProjectResponse {
  project: V1Project;
}

export interface V1GetProjectNumericMetricsRangeResponse {
  /** List of ranges. */
  ranges?: V1MetricsRange[];
}

export interface V1GetProjectColumnsResponse {
  /** List of columns. */
  columns: V1ProjectColumn[];
}

/**
 * Response to GetProjectByKeyRequest.
 */
export interface V1GetProjectByKeyResponse {
  project: V1Project;
}

/**
 * Response to GetPermissionsSummaryRequest.
 */
export interface V1GetPermissionsSummaryResponse {
  /** Lists of assignments for the cluster and other scopes. */
  assignments: V1RoleAssignmentSummary[];
  /** A group of roles in cluster and other scopes. */
  roles: V1Role[];
}

/**
 * Response to GetNotebooksRequest.
 */
export interface V1GetNotebooksResponse {
  /** The list of returned notebooks. */
  notebooks: V1Notebook[];
  pagination?: V1Pagination;
}

/**
 * Sorts notebooks by the given field.

 - SORT_BY_UNSPECIFIED: Returns notebooks in an unsorted list.
 - SORT_BY_ID: Returns notebooks sorted by id.
 - SORT_BY_DESCRIPTION: Returns notebooks sorted by description.
 - SORT_BY_START_TIME: Return notebooks sorted by start time.
 - SORT_BY_WORKSPACE_ID: Return notebooks sorted by workspace_id
 */
export type V1GetNotebooksRequestSortBy = typeof V1GetNotebooksRequestSortBy[keyof typeof V1GetNotebooksRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetNotebooksRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_START_TIME: 'SORT_BY_START_TIME',
  SORT_BY_WORKSPACE_ID: 'SORT_BY_WORKSPACE_ID',
} as const;

/**
 * The notebook config.
 */
export type V1GetNotebookResponseConfig = { [key: string]: unknown };

/**
 * Response to GetNotebookRequest.
 */
export interface V1GetNotebookResponse {
  /** The notebook config. */
  config: V1GetNotebookResponseConfig;
  notebook: V1Notebook;
}

/**
 * Response to GetModelsRequest.
 */
export interface V1GetModelsResponse {
  /** The list of returned models. */
  models: V1Model[];
  pagination: V1Pagination;
}

/**
 * Sort models by the given field.

 - SORT_BY_UNSPECIFIED: Returns models in an unsorted list.
 - SORT_BY_NAME: Returns models sorted by name.
 - SORT_BY_DESCRIPTION: Returns models sorted by description.
 - SORT_BY_CREATION_TIME: Returns models sorted by creation time.
 - SORT_BY_LAST_UPDATED_TIME: Returns models sorted by last updated time.
 - SORT_BY_NUM_VERSIONS: Returns models sorted by number of version.
 - SORT_BY_WORKSPACE: Returns models sorted by workspace name.
 */
export type V1GetModelsRequestSortBy = typeof V1GetModelsRequestSortBy[keyof typeof V1GetModelsRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetModelsRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_NAME: 'SORT_BY_NAME',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_CREATION_TIME: 'SORT_BY_CREATION_TIME',
  SORT_BY_LAST_UPDATED_TIME: 'SORT_BY_LAST_UPDATED_TIME',
  SORT_BY_NUM_VERSIONS: 'SORT_BY_NUM_VERSIONS',
  SORT_BY_WORKSPACE: 'SORT_BY_WORKSPACE',
} as const;

/**
 * Response for GetModelVersionRequest.
 */
export interface V1GetModelVersionsResponse {
  model: V1Model;
  /** The list of returned model versions. */
  modelVersions: V1ModelVersion[];
  pagination: V1Pagination;
}

/**
 * Sort models by the given field.

 - SORT_BY_UNSPECIFIED: Returns model versions in an unsorted list.
 - SORT_BY_VERSION: Returns model versions sorted by version number.
 - SORT_BY_CREATION_TIME: Returns model versions sorted by creation_time.
 */
export type V1GetModelVersionsRequestSortBy = typeof V1GetModelVersionsRequestSortBy[keyof typeof V1GetModelVersionsRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetModelVersionsRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_VERSION: 'SORT_BY_VERSION',
  SORT_BY_CREATION_TIME: 'SORT_BY_CREATION_TIME',
} as const;

/**
 * Response for GetModelVersionRequest.
 */
export interface V1GetModelVersionResponse {
  modelVersion: V1ModelVersion;
}

/**
 * Response to GetModelRequest.
 */
export interface V1GetModelResponse {
  model: V1Model;
}

/**
 * Response to GetModelLabelsRequest.
 */
export interface V1GetModelLabelsResponse {
  /** List of labels used across all models. */
  labels: string[];
}

/**
 * Response to GetModelDefTreeRequest.
 */
export interface V1GetModelDefTreeResponse {
  /** File tree of an experiment. */
  files?: V1FileNode[];
}

/**
 * Response to GetModelDefRequest.
 */
export interface V1GetModelDefResponse {
  /** The base64-encoded, gzipped, tarball. */
  b64Tgz: string;
}

/**
 * Response to GetModelDefFileRequest.
 */
export interface V1GetModelDefFileResponse {
  /** Content of file. */
  file?: string;
}

/**
 * Request to get a file of model definition.
 */
export interface V1GetModelDefFileRequest {
  /** The id of the experiment. */
  experimentId?: number;
  /** The path of file. */
  path?: string;
}

/**
 * Response to GetMetricsRequest.
 */
export interface V1GetMetricsResponse {
  /** Metric response. */
  metrics: V1MetricsReport[];
}

/**
 * Response to GetMetadataValuesRequest.
 */
export interface V1GetMetadataValuesResponse {
  values?: string[];
}

/**
 * Response to GetMeRequest.
 */
export interface V1GetMeResponse {
  user: V1User;
}

/**
 * Response to GetMasterRequest.
 */
export interface V1GetMasterResponse {
  /** Branding style to use on front-end. */
  branding?: string;
  /** The global cluster id of the master. */
  clusterId: string;
  clusterMessage?: V1ClusterMessage;
  /** The cluster name. */
  clusterName: string;
  /** Redirect for starting internal sessions.. */
  externalLoginUri?: string;
  /** Redirect for ending external sessions. */
  externalLogoutUri?: string;
  /** List of features that is on. */
  featureSwitches?: string[];
  /** Whether the cluster has a user-submitted custom logo. */
  hasCustomLogo: boolean;
  /** The current instance id of the master. */
  masterId: string;
  product?: GetMasterResponseProduct;
  /** Feature flag for RBAC and user groups. */
  rbacEnabled?: boolean;
  /** SSO providers. */
  ssoProviders?: V1SSOProvider[];
  /** Feature flag for strict job queue control. */
  strictJobQueueControl: boolean;
  /** Telemetry status. */
  telemetryEnabled?: boolean;
  /** Feature flag for user management. */
  userManagementEnabled?: boolean;
  /** The current version of the master. */
  version: string;
}

/**
 * The config file loaded by the master.
 */
export type V1GetMasterConfigResponseConfig = { [key: string]: unknown };

/**
 * Response to GetMasterRequest.
 */
export interface V1GetMasterConfigResponse {
  /** The config file loaded by the master. */
  config: V1GetMasterConfigResponseConfig;
}

/**
 * List of workspace-namespace bindings for a given workspace.
 */
export type V1GetKubernetesResourceQuotasResponseResourceQuotas = {[key: string]: number};

/**
 * Response for listing namespaces bound to a workspace.
 */
export interface V1GetKubernetesResourceQuotasResponse {
  /** List of workspace-namespace bindings for a given workspace. */
  resourceQuotas: V1GetKubernetesResourceQuotasResponseResourceQuotas;
}

/**
 * Response to GetKubernetesResourceManagersRequest.
 */
export interface V1GetKubernetesResourceManagersResponse {
  resourceManagers: string[];
}

/**
 * Response to GetJobsV2Request.
 */
export interface V1GetJobsV2Response {
  /** List of the requested jobs. */
  jobs: V1RBACJob[];
  pagination: V1Pagination;
}

/**
 * Response to GetJobsRequest.
 */
export interface V1GetJobsResponse {
  /** List of the request jobs. */
  jobs: V1Job[];
  pagination: V1Pagination;
}

/**
 * Response to GetJobQueueStatsRequest.
 */
export interface V1GetJobQueueStatsResponse {
  /** List of queue stats per resource pool. */
  results: V1RPQueueStat[];
}

/**
 * GetGroupsResponse is the body of the response for the call
to search for groups.
 */
export interface V1GetGroupsResponse {
  groups?: V1GroupSearchResult[];
  pagination?: V1Pagination;
}

/**
 * GetGroupsRequest is the body of the request for the call
to search for groups.
 */
export interface V1GetGroupsRequest {
  /** Limit the number of groups. Required and must be must be <= 500. */
  limit: number;
  /** The group name to use when searching. */
  name?: string;
  /** Skip the number of groups before returning results. Negative values
denote number of groups to skip from the end before returning results. */
  offset?: number;
  /** The id of the user to use to find groups to which the user belongs. */
  userId?: number;
}

/**
 * Response object for GetGroupsAndUsersAssignedToWorkspace.
 */
export interface V1GetGroupsAndUsersAssignedToWorkspaceResponse {
  /** Roles assigned to workspace with associations between
groups and users_assigned_directly with roles. */
  assignments: V1RoleWithAssignments[];
  /** Groups with a role assigned to the given workspace scope.
Contains user membership of each group. */
  groups: V1GroupDetails[];
  /** Only contains users assigned directly to roles on the workspace scope. */
  usersAssignedDirectly: V1User[];
}

/**
 * GetGroupResponse is the body of the response for the call
to get a group by id.
 */
export interface V1GetGroupResponse {
  group: V1GroupDetails;
}

/**
 * The global current config policies saved. Contains both invariant configs
and constraints in yaml or json format.
 */
export type V1GetGlobalConfigPoliciesResponseConfigPolicies = { [key: string]: unknown };

/**
 * Response to GetGlobalConfigPoliciesRequest.
 */
export interface V1GetGlobalConfigPoliciesResponse {
  /** The global current config policies saved. Contains both invariant configs
and constraints in yaml or json format. */
  configPolicies?: V1GetGlobalConfigPoliciesResponseConfigPolicies;
}

export interface V1GetGenericTaskConfigResponse {
  config: string;
}

/**
 * Response to GetExperimentsRequest.
 */
export interface V1GetExperimentsResponse {
  /** The list of returned experiments. */
  experiments: V1Experiment[];
  pagination: V1Pagination;
}

/**
 * Sorts experiments by the given field.

 - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.
 - SORT_BY_ID: Returns experiments sorted by id.
 - SORT_BY_DESCRIPTION: Returns experiments sorted by description.
 - SORT_BY_START_TIME: Return experiments sorted by start time.
 - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end_time are
returned after the ones with end_time.
 - SORT_BY_STATE: Return experiments sorted by state.
 - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.
 - SORT_BY_PROGRESS: Return experiments sorted by progress.
 - SORT_BY_USER: Return experiments sorted by user.
 - SORT_BY_NAME: Returns experiments sorted by name.
 - SORT_BY_FORKED_FROM: Returns experiments sorted by originating model.
 - SORT_BY_RESOURCE_POOL: Returns experiments sorted by resource pool.
 - SORT_BY_PROJECT_ID: Returns experiments sorted by project.
 - SORT_BY_CHECKPOINT_SIZE: Returns experiments sorted by checkpoint size.
 - SORT_BY_CHECKPOINT_COUNT: Returns experiments sorted by checkpoint count.
 - SORT_BY_SEARCHER_METRIC_VAL: Returns experiments sorted by searcher metric value..
 */
export type V1GetExperimentsRequestSortBy = typeof V1GetExperimentsRequestSortBy[keyof typeof V1GetExperimentsRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetExperimentsRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_START_TIME: 'SORT_BY_START_TIME',
  SORT_BY_END_TIME: 'SORT_BY_END_TIME',
  SORT_BY_STATE: 'SORT_BY_STATE',
  SORT_BY_NUM_TRIALS: 'SORT_BY_NUM_TRIALS',
  SORT_BY_PROGRESS: 'SORT_BY_PROGRESS',
  SORT_BY_USER: 'SORT_BY_USER',
  SORT_BY_NAME: 'SORT_BY_NAME',
  SORT_BY_FORKED_FROM: 'SORT_BY_FORKED_FROM',
  SORT_BY_RESOURCE_POOL: 'SORT_BY_RESOURCE_POOL',
  SORT_BY_PROJECT_ID: 'SORT_BY_PROJECT_ID',
  SORT_BY_CHECKPOINT_SIZE: 'SORT_BY_CHECKPOINT_SIZE',
  SORT_BY_CHECKPOINT_COUNT: 'SORT_BY_CHECKPOINT_COUNT',
  SORT_BY_SEARCHER_METRIC_VAL: 'SORT_BY_SEARCHER_METRIC_VAL',
} as const;

/**
 * Response to GetExperimentValidationHistoryRequest.
 */
export interface V1GetExperimentValidationHistoryResponse {
  /** validation_history is a collection of zero or more validation metrics for
an experiment, describing the best metrics as they were reported through
the lifetime of an experiment. The historical list of best validations. */
  validationHistory?: V1ValidationHistoryEntry[];
}

/**
 * Response to GetExperimentTrialsRequest.
 */
export interface V1GetExperimentTrialsResponse {
  pagination: V1Pagination;
  /** The list of returned trials. */
  trials: Trialv1Trial[];
}

/**
 * Sorts trials by the given field.

 - SORT_BY_UNSPECIFIED: Returns trials in an unsorted list.
 - SORT_BY_ID: Returns trials sorted by id.
 - SORT_BY_START_TIME: Return trials sorted by start time.
 - SORT_BY_END_TIME: Return trials sorted by end time. Trials without end times are
returned after trials that are.
 - SORT_BY_STATE: Return trials sorted by state.
 - SORT_BY_BEST_VALIDATION_METRIC: Return the trials sorted by the best metric so far, where the metric is
specified by `searcher.metric` in the experiment configuration.
 - SORT_BY_LATEST_VALIDATION_METRIC: Return the trials sorted by the latest metric so far, where the metric is
specified by `searcher.metric` in the experiment configuration.
 - SORT_BY_BATCHES_PROCESSED: Return the trials sorted by the number of batches completed.
 - SORT_BY_DURATION: Return the trials sorted by the total duration.
 - SORT_BY_RESTARTS: Return the trials sorted by the number of restarts.
 - SORT_BY_CHECKPOINT_SIZE: Return the trials sorted by checkpoint size.
 - SORT_BY_LOG_RETENTION_DAYS: Return the trials sorted by number of log retention days.
 */
export type V1GetExperimentTrialsRequestSortBy = typeof V1GetExperimentTrialsRequestSortBy[keyof typeof V1GetExperimentTrialsRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetExperimentTrialsRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_START_TIME: 'SORT_BY_START_TIME',
  SORT_BY_END_TIME: 'SORT_BY_END_TIME',
  SORT_BY_STATE: 'SORT_BY_STATE',
  SORT_BY_BEST_VALIDATION_METRIC: 'SORT_BY_BEST_VALIDATION_METRIC',
  SORT_BY_LATEST_VALIDATION_METRIC: 'SORT_BY_LATEST_VALIDATION_METRIC',
  SORT_BY_BATCHES_PROCESSED: 'SORT_BY_BATCHES_PROCESSED',
  SORT_BY_DURATION: 'SORT_BY_DURATION',
  SORT_BY_RESTARTS: 'SORT_BY_RESTARTS',
  SORT_BY_CHECKPOINT_SIZE: 'SORT_BY_CHECKPOINT_SIZE',
  SORT_BY_LOG_RETENTION_DAYS: 'SORT_BY_LOG_RETENTION_DAYS',
} as const;

/**
 * The experiment's config.
 */
export type V1GetExperimentResponseConfig = { [key: string]: unknown };

/**
 * Response to GetExperimentRequest.
 */
export interface V1GetExperimentResponse {
  /** The experiment's config. */
  config?: V1GetExperimentResponseConfig;
  experiment: V1Experiment;
  jobSummary?: V1JobSummary;
}

/**
 * Response to GetExperimentsLabelsRequest.
 */
export interface V1GetExperimentLabelsResponse {
  /** The list of labels used across all experiments. */
  labels?: string[];
}

/**
 * Response to GetExperimentCheckpointsRequest.
 */
export interface V1GetExperimentCheckpointsResponse {
  /** The list of returned checkpoints. */
  checkpoints: V1Checkpoint[];
  pagination: V1Pagination;
}

/**
 * Response to GetCommandsRequest.
 */
export interface V1GetCommandsResponse {
  /** The list of returned commands. */
  commands: V1Command[];
  pagination?: V1Pagination;
}

/**
 * Sorts commands by the given field.

 - SORT_BY_UNSPECIFIED: Returns commands in an unsorted list.
 - SORT_BY_ID: Returns commands sorted by id.
 - SORT_BY_DESCRIPTION: Returns commands sorted by description.
 - SORT_BY_START_TIME: Return commands sorted by start time.
 - SORT_BY_WORKSPACE_ID: Return commands sorted by workspace_id.
 */
export type V1GetCommandsRequestSortBy = typeof V1GetCommandsRequestSortBy[keyof typeof V1GetCommandsRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetCommandsRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
  SORT_BY_START_TIME: 'SORT_BY_START_TIME',
  SORT_BY_WORKSPACE_ID: 'SORT_BY_WORKSPACE_ID',
} as const;

/**
 * The command config.
 */
export type V1GetCommandResponseConfig = { [key: string]: unknown };

/**
 * Response to GetCommandRequest.
 */
export interface V1GetCommandResponse {
  command: V1Command;
  /** The command config. */
  config: V1GetCommandResponseConfig;
}

/**
 * GetClusterMessageResponse is the response that contains the current cluster
message.
 */
export interface V1GetClusterMessageResponse {
  clusterMessage?: V1ClusterMessage;
}

/**
 * Response to GetCheckpointRequest.
 */
export interface V1GetCheckpointResponse {
  checkpoint: V1Checkpoint;
}

/**
 * Response to GetBestSearcherValidationMetricRequest.
 */
export interface V1GetBestSearcherValidationMetricResponse {
  /** The value of the metric. */
  metric?: number;
}

export interface V1GetAllocationResponse {
  allocation: V1Allocation;
}

/**
 * Response to GetAgentsRequest.
 */
export interface V1GetAgentsResponse {
  /** The list of returned agents. */
  agents: V1Agent[];
  pagination?: V1Pagination;
}

/**
 * Sorts agents by the given field.

 - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.
 - SORT_BY_ID: Returns agents sorted by id.
 - SORT_BY_TIME: Returns agents sorted by time.
 */
export type V1GetAgentsRequestSortBy = typeof V1GetAgentsRequestSortBy[keyof typeof V1GetAgentsRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetAgentsRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_ID: 'SORT_BY_ID',
  SORT_BY_TIME: 'SORT_BY_TIME',
} as const;

/**
 * Response to GetAgentRequest.
 */
export interface V1GetAgentResponse {
  agent: V1Agent;
}

/**
 * Response to GetActiveTasksCountRequest.
 */
export interface V1GetActiveTasksCountResponse {
  /** The count of commands. */
  commands: number;
  /** The count of notebooks. */
  notebooks: number;
  /** The count of shells. */
  shells: number;
  /** The count of TensorBoards. */
  tensorboards: number;
}

/**
 * Response to GetAccessTokensRequest.
 */
export interface V1GetAccessTokensResponse {
  pagination?: V1Pagination;
  /** List of token information. */
  tokenInfo: V1TokenInfo[];
}

/**
 * Sort token info by the given field.

 - SORT_BY_UNSPECIFIED: Returns token info in an unsorted list.
 - SORT_BY_USER_ID: Returns token info sorted by user id.
 - SORT_BY_EXPIRY: Returns token info sorted by expiry.
 - SORT_BY_CREATED_AT: Returns token info sorted by created at.
 - SORT_BY_TOKEN_TYPE: Returns token info sorted by token type.
 - SORT_BY_REVOKED: Returns token info sorted by if it is revoked.
 - SORT_BY_DESCRIPTION: Returns token info sorted by description of token.
 */
export type V1GetAccessTokensRequestSortBy = typeof V1GetAccessTokensRequestSortBy[keyof typeof V1GetAccessTokensRequestSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GetAccessTokensRequestSortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_USER_ID: 'SORT_BY_USER_ID',
  SORT_BY_EXPIRY: 'SORT_BY_EXPIRY',
  SORT_BY_CREATED_AT: 'SORT_BY_CREATED_AT',
  SORT_BY_TOKEN_TYPE: 'SORT_BY_TOKEN_TYPE',
  SORT_BY_REVOKED: 'SORT_BY_REVOKED',
  SORT_BY_DESCRIPTION: 'SORT_BY_DESCRIPTION',
} as const;

/**
 * - GENERIC_TASK_STATE_UNSPECIFIED: The task state unknown
 - GENERIC_TASK_STATE_ACTIVE: The task state unknown
 - GENERIC_TASK_STATE_CANCELED: The task state unknown
 - GENERIC_TASK_STATE_COMPLETED: The task state unknown
 - GENERIC_TASK_STATE_ERROR: The task state unknown
 - GENERIC_TASK_STATE_PAUSED: The task state unknown
 - GENERIC_TASK_STATE_STOPPING_PAUSED: The task state unknown
 - GENERIC_TASK_STATE_STOPPING_CANCELED: The task state unknown
 - GENERIC_TASK_STATE_STOPPING_COMPLETED: The task state unknown
 - GENERIC_TASK_STATE_STOPPING_ERROR: The task state unknown
 */
export type V1GenericTaskState = typeof V1GenericTaskState[keyof typeof V1GenericTaskState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1GenericTaskState = {
  GENERIC_TASK_STATE_UNSPECIFIED: 'GENERIC_TASK_STATE_UNSPECIFIED',
  GENERIC_TASK_STATE_ACTIVE: 'GENERIC_TASK_STATE_ACTIVE',
  GENERIC_TASK_STATE_CANCELED: 'GENERIC_TASK_STATE_CANCELED',
  GENERIC_TASK_STATE_COMPLETED: 'GENERIC_TASK_STATE_COMPLETED',
  GENERIC_TASK_STATE_ERROR: 'GENERIC_TASK_STATE_ERROR',
  GENERIC_TASK_STATE_PAUSED: 'GENERIC_TASK_STATE_PAUSED',
  GENERIC_TASK_STATE_STOPPING_PAUSED: 'GENERIC_TASK_STATE_STOPPING_PAUSED',
  GENERIC_TASK_STATE_STOPPING_CANCELED: 'GENERIC_TASK_STATE_STOPPING_CANCELED',
  GENERIC_TASK_STATE_STOPPING_COMPLETED: 'GENERIC_TASK_STATE_STOPPING_COMPLETED',
  GENERIC_TASK_STATE_STOPPING_ERROR: 'GENERIC_TASK_STATE_STOPPING_ERROR',
} as const;

/**
 * The experiment pachyderm integration config.
 */
export type V1FlatRunExperimentPachydermIntegration = { [key: string]: unknown };

export interface V1FlatRunExperiment {
  /** The description of the experiment. */
  description: string;
  externalExperimentId?: string;
  /** Original id of a forked or continued experiment. */
  forkedFrom?: number;
  /** The id of the experiment linked to the run. */
  id: number;
  isMultitrial: boolean;
  /** The experiment name. */
  name: string;
  /** The experiment pachyderm integration config. */
  pachydermIntegration?: V1FlatRunExperimentPachydermIntegration;
  /** The current progress of a running experiment. */
  progress: number;
  /** The resource pool the experiment was created in. */
  resourcePool: string;
  /** The searcher metric name for the experiment. */
  searcherMetric: string;
  /** The type of searcher for the experiment. */
  searcherType: string;
  /** Unmanaged experiments are detached. */
  unmanaged: boolean;
}

/**
 * summary metrics.
 */
export type V1FlatRunSummaryMetrics = { [key: string]: unknown };

/**
 * The arbitrary metadata of the run.
 */
export type V1FlatRunMetadata = { [key: string]: unknown };

/**
 * Trial hyperparameters.
 */
export type V1FlatRunHyperparameters = { [key: string]: unknown };

/**
 * Flat run respresentation. Used for the rows of the Run Table.
 */
export interface V1FlatRun {
  /** The archived status of this run.
This is only looking at the archived status at the run level and not taking
into account whether the experiment is archived or not. */
  archived: boolean;
  /** The count of checkpoints. */
  checkpointCount: number;
  /** The total size of checkpoints. */
  checkpointSize: string;
  /** Time in seconds which the run ran or has been running. */
  duration?: number;
  /** The time the run ended. */
  endTime?: string;
  experiment?: V1FlatRunExperiment;
  externalRunId?: string;
  /** Trial hyperparameters. */
  hyperparameters?: V1FlatRunHyperparameters;
  /** The id of the run. */
  id: number;
  /** The tags of the associated experiment.
TODO(aaron.amanuel): Create add/remove tags for runs. */
  labels?: string[];
  /** Project level local id of run. */
  localId?: string;
  /** Log policy matched. */
  logPolicyMatched?: string;
  /** The arbitrary metadata of the run. */
  metadata?: V1FlatRunMetadata;
  /** The archived status of the parent project (can be inherited from
workspace). */
  parentArchived: boolean;
  /** The id of the project associated with this run. */
  projectId: number;
  /** The name of the project associated with this run. */
  projectName: string;
  /** Signed searcher metrics value. */
  searcherMetricValue?: number;
  /** The time the run was started. */
  startTime: string;
  state: Trialv1State;
  /** summary metrics. */
  summaryMetrics?: V1FlatRunSummaryMetrics;
  /** The id of the user who created the run. */
  userId?: number;
  /** The id of the workspace associated with this run. */
  workspaceId: number;
  /** The name of the workspace associated with this run. */
  workspaceName: string;
}

/**
 * The fitting policy of the scheduler.

 - FITTING_POLICY_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is
just an artifact of using protobuf.
 - FITTING_POLICY_BEST: Best fit. Tasks are preferentially ‚Äúpacked‚Äù together on the smallest number
of agents
 - FITTING_POLICY_WORST: Worst fit. Tasks are placed on under-utilized agents, spreading out the
tasks.
 - FITTING_POLICY_KUBERNETES: A kubernetes placeholder. In k8s, the task placement is delegated to the
k8s scheduler so the fitting policy is not relevant.
 - FITTING_POLICY_SLURM: A slurm placeholder. When running on slurm, task placement is delegated.
 - FITTING_POLICY_PBS: A PBS placeholder. When running on PBS, task placement is delegated.
 */
export type V1FittingPolicy = typeof V1FittingPolicy[keyof typeof V1FittingPolicy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1FittingPolicy = {
  FITTING_POLICY_UNSPECIFIED: 'FITTING_POLICY_UNSPECIFIED',
  FITTING_POLICY_BEST: 'FITTING_POLICY_BEST',
  FITTING_POLICY_WORST: 'FITTING_POLICY_WORST',
  FITTING_POLICY_KUBERNETES: 'FITTING_POLICY_KUBERNETES',
  FITTING_POLICY_SLURM: 'FITTING_POLICY_SLURM',
  FITTING_POLICY_PBS: 'FITTING_POLICY_PBS',
} as const;

/**
 * File node is one node of file in experiment model definition file tree.
 */
export interface V1FileNode {
  /** Number of bytes in file content. */
  contentLength?: number;
  /** MIME type of file. */
  contentType?: string;
  /** Subdirectory files. */
  files?: V1FileNode[];
  /** Is this a directory. */
  isDir?: boolean;
  /** Modification time of file. */
  modifiedTime?: string;
  /** Name of file. */
  name?: string;
  /** Path of file. */
  path?: string;
}

/**
 * File is a Unix file.
 */
export interface V1File {
  /** base64 encoded contents of the file. */
  content: string;
  /** Group ID. */
  gid: number;
  /** File mode. */
  mode: number;
  /** Modified time (Unix timestamp). */
  mtime: string;
  /** Path to the file. */
  path: string;
  /** File type. */
  type: number;
  /** User ID. */
  uid: number;
}

/**
 * The failure type of a resource.

 - FAILURE_TYPE_UNSPECIFIED: UNSPECIFIED denotes an error that is not defined below.
 - FAILURE_TYPE_RESOURCES_FAILED: ResourcesFailed denotes that the container ran but failed with a non-zero
exit code.
 - FAILURE_TYPE_RESOURCES_ABORTED: ResourcesAborted denotes the container was canceled before it was started.
 - FAILURE_TYPE_RESOURCES_MISSING: ResourcesMissing denotes the resources were missing when the master asked
about it.
 - FAILURE_TYPE_TASK_ABORTED: TaskAborted denotes that the task was canceled before it was started.
 - FAILURE_TYPE_TASK_ERROR: TaskError denotes that the task failed without an associated exit code.
 - FAILURE_TYPE_AGENT_FAILED: AgentFailed denotes that the agent failed while the container was running.
 - FAILURE_TYPE_AGENT_ERROR: AgentError denotes that the agent failed to launch the container.
 - FAILURE_TYPE_RESTORE_ERROR: RestoreError denotes a failure to restore a running allocation on master
blip.
 - FAILURE_TYPE_UNKNOWN_ERROR: UnknownError denotes an internal error that did not map to a know failure
type.
 */
export type V1FailureType = typeof V1FailureType[keyof typeof V1FailureType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1FailureType = {
  FAILURE_TYPE_UNSPECIFIED: 'FAILURE_TYPE_UNSPECIFIED',
  FAILURE_TYPE_RESOURCES_FAILED: 'FAILURE_TYPE_RESOURCES_FAILED',
  FAILURE_TYPE_RESOURCES_ABORTED: 'FAILURE_TYPE_RESOURCES_ABORTED',
  FAILURE_TYPE_RESOURCES_MISSING: 'FAILURE_TYPE_RESOURCES_MISSING',
  FAILURE_TYPE_TASK_ABORTED: 'FAILURE_TYPE_TASK_ABORTED',
  FAILURE_TYPE_TASK_ERROR: 'FAILURE_TYPE_TASK_ERROR',
  FAILURE_TYPE_AGENT_FAILED: 'FAILURE_TYPE_AGENT_FAILED',
  FAILURE_TYPE_AGENT_ERROR: 'FAILURE_TYPE_AGENT_ERROR',
  FAILURE_TYPE_RESTORE_ERROR: 'FAILURE_TYPE_RESTORE_ERROR',
  FAILURE_TYPE_UNKNOWN_ERROR: 'FAILURE_TYPE_UNKNOWN_ERROR',
} as const;

/**
 * Message for results of individual experiments in a multi-experiment action.
 */
export interface V1ExperimentActionResult {
  /** Optional error message. */
  error: string;
  /** Experiment ID. */
  id: number;
}

/**
 * The experiment pachyderm integration config.
 */
export type V1ExperimentPachydermIntegration = { [key: string]: unknown };

export type V1ExperimentHyperparameters = { [key: string]: unknown };

/**
 * The configuration of the experiment.
Is deprecated for performance reasons on the listing experiment route.
Use GetExperimentResponse.config instead.
 */
export type V1ExperimentConfig = { [key: string]: unknown };

/**
 * Experiment is a collection of one or more trials that are exploring a
user-defined hyperparameter space.
 */
export interface V1Experiment {
  /** Boolean denoting whether the experiment was archived. */
  archived: boolean;
  /** Id of experiment's best trial, calculated by the best searcher metrics
value of trial's best validation. */
  bestTrialId?: number;
  /** The metrics and hyperparameters associated with the best trial by searcher
metric. */
  bestTrialSearcherMetric?: number;
  /** The count of checkpoints. */
  checkpointCount?: number;
  /** The total size of checkpoints. */
  checkpointSize?: string;
  /** The configuration of the experiment.
Is deprecated for performance reasons on the listing experiment route.
Use GetExperimentResponse.config instead. */
  config: V1ExperimentConfig;
  /** The description of the experiment. */
  description?: string;
  /** The display name of the user that created the experiment. */
  displayName?: string;
  /** Time in seconds which experiment ran or has been running. */
  duration?: number;
  /** The time the experiment ended if the experiment is stopped. */
  endTime?: string;
  externalExperimentId?: string;
  externalTrialId?: string;
  /** Original id of a forked or continued experiment. */
  forkedFrom?: number;
  hyperparameters?: V1ExperimentHyperparameters;
  /** The id of the experiment. */
  id: number;
  /** Associated job's id. */
  jobId: string;
  /** Labels attached to the experiment. */
  labels?: string[];
  /** Size of model definition file, for unmanaged experiments this should be 0. */
  modelDefinitionSize?: number;
  /** The experiment name. */
  name: string;
  /** The experiment notes. */
  notes?: string;
  /** The number of trials linked to the experiment. */
  numTrials: number;
  /** The original configuration that the user submitted. */
  originalConfig: string;
  /** The experiment pachyderm integration config. */
  pachydermIntegration?: V1ExperimentPachydermIntegration;
  /** The archived status of the parent project (can be inherited from
workspace). */
  parentArchived?: boolean;
  /** The current progress of a running experiment. */
  progress?: number;
  /** The id of the project associated with this experiment. */
  projectId: number;
  /** The name of the project associated with this experiment. */
  projectName?: string;
  /** The id of the user who created the parent project. */
  projectOwnerId: number;
  resourcePool?: string;
  searcherMetric?: string;
  searcherType: string;
  /** The time the experiment was started. */
  startTime: string;
  state: Experimentv1State;
  /** The ids of trials linked to the experiment. */
  trialIds?: number[];
  /** Unmanaged experiments are detached. */
  unmanaged?: boolean;
  /** The id of the user that created the experiment. */
  userId?: number;
  /** The username of the user that created the experiment. */
  username: string;
  /** The id of the workspace associated with this experiment. */
  workspaceId?: number;
  /** The name of the workspace associated with this experiment. */
  workspaceName?: string;
}

/**
 * Response to ExpMetricNamesRequest.
 */
export interface V1ExpMetricNamesResponse {
  /** List of metric group-name pairs. */
  metricNames?: V1MetricIdentifier[];
  /** The names of the searcher metrics. */
  searcherMetrics?: string[];
  /** List of training metric names. */
  trainingMetrics?: string[];
  /** List of validation metric names. */
  validationMetrics?: string[];
}

/**
 * - ENTITY_TYPE_UNSPECIFIED: Default entity type.
 - ENTITY_TYPE_PROJECT: Represents a project.
 */
export type V1EntityType = typeof V1EntityType[keyof typeof V1EntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1EntityType = {
  ENTITY_TYPE_UNSPECIFIED: 'ENTITY_TYPE_UNSPECIFIED',
  ENTITY_TYPE_PROJECT: 'ENTITY_TYPE_PROJECT',
} as const;

/**
 * Response to EnableSlotRequest.
 */
export interface V1EnableSlotResponse {
  slot?: V1Slot;
}

/**
 * Response to EnableAgentRequest.
 */
export interface V1EnableAgentResponse {
  agent?: V1Agent;
}

/**
 * DownsampledMetrics captures a metric's name and downsampled data points.
 */
export interface V1DownsampledMetrics {
  /** A possibly down-sampled series of metrics' readings through the progress of
the trial. */
  data: V1DataPoint[];
  /** Metric group (training, validation, etc). */
  group: string;
  type: V1MetricType;
}

/**
 * Double filters.
 */
export interface V1DoubleFieldFilter {
  /** Greater than. */
  gt?: number;
  /** Greater than or equal. */
  gte?: number;
  /** Less than. */
  lt?: number;
  /** Less than or equal. */
  lte?: number;
}

/**
 * Response to DisableSlotRequest.
 */
export interface V1DisableSlotResponse {
  slot?: V1Slot;
}

/**
 * Disable the slot.
 */
export interface V1DisableSlotRequest {
  /** The id of the agent. */
  agentId?: string;
  /** If true, wait for running task to finish. */
  drain?: boolean;
  /** The id of the slot. */
  slotId?: string;
}

/**
 * Response to DisableAgentRequest.
 */
export interface V1DisableAgentResponse {
  agent?: V1Agent;
}

/**
 * Disable the agent.
 */
export interface V1DisableAgentRequest {
  /** The id of the agent. */
  agentId?: string;
  /** If true, wait for running tasks to finish. */
  drain?: boolean;
}

/**
 * The number of slots in each state if there's an associated container.
 */
export type V1DeviceStatsStates = {[key: string]: number};

/**
 * DeviceStats contains statistics about a single device group.
 */
export interface V1DeviceStats {
  /** the number of disabled slots. */
  disabled: number;
  /** the number of draining slots. */
  draining: number;
  /** The number of slots in each state if there's an associated container. */
  states?: V1DeviceStatsStates;
  /** the total number of slots. */
  total: number;
}

/**
 * Device represents a single computational device on an agent.
 */
export interface V1Device {
  /** The brand name of the device. */
  brand?: string;
  /** The index of the device. */
  id?: number;
  type?: Devicev1Type;
  /** The unique UUID of the device. */
  uuid?: string;
}

/**
 * Response to DeleteWorkspaceRequest.
 */
export interface V1DeleteWorkspaceResponse {
  /** Status of deletion. */
  completed: boolean;
}

/**
 * Response to DeleteWorkspaceNamespaceBindingsRequest.
 */
export interface V1DeleteWorkspaceNamespaceBindingsResponse { [key: string]: unknown }

/**
 * Response to DeleteWorkspaceConfigPoliciesRequest.
 */
export interface V1DeleteWorkspaceConfigPoliciesResponse { [key: string]: unknown }

/**
 * Response to DeleteWebhookRequest.
 */
export interface V1DeleteWebhookResponse { [key: string]: unknown }

/**
 * Response to DeleteTensorboardRequest.
 */
export interface V1DeleteTensorboardFilesResponse { [key: string]: unknown }

/**
 * Response to DeleteTemplateRequest.
 */
export interface V1DeleteTemplateResponse { [key: string]: unknown }

/**
 * Response to DeleteSearchesRequest.
 */
export interface V1DeleteSearchesResponse {
  /** Details on success or error for each search. */
  results: V1SearchActionResult[];
}

/**
 * Delete searches.
 */
export interface V1DeleteSearchesRequest {
  filter?: string;
  /** Project id of the searches being deleted. */
  projectId: number;
  /** The ids of the searches being deleted. Leave empty if using filter. */
  searchIds?: number[];
}

/**
 * Response to DeleteRunsResponse.
 */
export interface V1DeleteRunsResponse {
  /** Details on success or error for each run. */
  results: V1RunActionResult[];
}

/**
 * Delete runs.
 */
export interface V1DeleteRunsRequest {
  filter?: string;
  /** Project id of the runs being deleted. */
  projectId: number;
  /** The ids of the runs being deleted. Leave empty if using filter. */
  runIds?: number[];
}

/**
 * Response to DeleteProjectRequest.
 */
export interface V1DeleteProjectResponse {
  /** Status of deletion. */
  completed: boolean;
}

export interface V1DeleteModelVersionResponse { [key: string]: unknown }

export interface V1DeleteModelResponse { [key: string]: unknown }

/**
 * DeleteGroupResponse is the body of the response for the call
to delete a group.
 */
export interface V1DeleteGroupResponse { [key: string]: unknown }

/**
 * Response to DeleteGlobalConfigPoliciesRequest.
 */
export interface V1DeleteGlobalConfigPoliciesResponse { [key: string]: unknown }

/**
 * Response to DeleteExperimentsRequest.
 */
export interface V1DeleteExperimentsResponse {
  /** Details on success or error for each experiment. */
  results: V1ExperimentActionResult[];
}

/**
 * Delete multiple experiments.
 */
export interface V1DeleteExperimentsRequest {
  /** Selecting experiments by id. */
  experimentIds: number[];
  filters?: V1BulkExperimentFilters;
  /** Project id that the experiments belong to. */
  projectId: number;
}

/**
 * Response to DeleteExperimentRequest.
 */
export interface V1DeleteExperimentResponse { [key: string]: unknown }

/**
 * Response to DeleteExperimentLabelRequest.
 */
export interface V1DeleteExperimentLabelResponse {
  /** The complete list of labels associated with the experiment. */
  labels: string[];
}

/**
 * Response to DeleteClusterMessageRequest.
 */
export interface V1DeleteClusterMessageResponse { [key: string]: unknown }

export interface V1DeleteCheckpointsResponse { [key: string]: unknown }

export interface V1DeleteCheckpointsRequest {
  /** The list of checkpoint_uuids for the requested checkpoint. */
  checkpointUuids: string[];
}

/**
 * Values of the requested metrics at this point in the trial.
 */
export type V1DataPointValues = { [key: string]: unknown };

/**
 * One datapoint in a series of metrics from a trial in batch.
 */
export interface V1DataPoint {
  /** Total batches processed by the time this measurement is taken. */
  batches: number;
  /** The epoch this measurement is taken. */
  epoch?: number;
  /** The time the measurement is taken. */
  time: string;
  /** Values of the requested metrics at this point in the trial. */
  values?: V1DataPointValues;
}

/**
 * Event data for custom trigger.
 */
export interface V1CustomWebhookEventData {
  /** The description for the event data. */
  description?: string;
  level?: V1LogLevel;
  /** The title for the event data. */
  title?: string;
}

/**
 * Response to CurrentUserRequest.
 */
export interface V1CurrentUserResponse {
  user: V1User;
}

/**
 * Response to CreateTrialRequest.
 */
export interface V1CreateTrialResponse {
  trial: Trialv1Trial;
}

/**
 * Trial hyperparameters.
 */
export type V1CreateTrialRequestHparams = { [key: string]: unknown };

/**
 * Create a trial.
 */
export interface V1CreateTrialRequest {
  /** The id of the parent experiment. */
  experimentId?: number;
  /** Trial hyperparameters. */
  hparams?: V1CreateTrialRequestHparams;
  /** Currently only unmanaged trials are supported, must be true. */
  unmanaged?: boolean;
}

/**
 * CreateGroupResponse is the body of the response for the call
to update a group and its members.
 */
export interface V1CreateGroupResponse {
  group: V1GroupDetails;
}

/**
 * CreateGroupRequest is the body of the request for the call
to create a group.
 */
export interface V1CreateGroupRequest {
  addUsers?: number[];
  name: string;
}

/**
 * Response to CreateExperimentRequest.
 */
export interface V1CreateGenericTaskResponse {
  /** The created generic taskID. */
  taskId: string;
  /** List of any related warnings. */
  warnings?: V1LaunchWarning[];
}

/**
 * Request to create a new generic task.
 */
export interface V1CreateGenericTaskRequest {
  /** Generic task config (YAML). */
  config: string;
  /** Generic task context. */
  contextDirectory: V1File[];
  forkedFrom?: string;
  inheritContext?: boolean;
  /** Flag for whether task can be paused or not. */
  noPause?: boolean;
  parentId?: string;
  /** Project id to contain the experiment. */
  projectId?: number;
}

/**
 * The created experiment config.
 */
export type V1CreateExperimentResponseConfig = { [key: string]: unknown };

/**
 * Response to CreateExperimentRequest.
 */
export interface V1CreateExperimentResponse {
  /** The created experiment config. */
  config: V1CreateExperimentResponseConfig;
  experiment: V1Experiment;
  /** List of any related warnings. */
  warnings?: V1LaunchWarning[];
}

/**
 * Request to create a new experiment.
 */
export interface V1CreateExperimentRequest {
  /** Request to auto-activate the experiment. */
  activate?: boolean;
  /** Experiment config (YAML). */
  config?: string;
  /** Experiment context. */
  modelDefinition?: V1File[];
  /** Parent experiment id. */
  parentId?: number;
  /** Project id to contain the experiment. */
  projectId?: number;
  /** Template to use for the experiment. */
  template?: string;
  /** Unmanaged experiments are detached. */
  unmanaged?: boolean;
  /** Only validate instead of creating the experiment. A dry run. */
  validateOnly?: boolean;
}

/**
 * Request to continue an experiment.
 */
export interface V1ContinueExperimentResponse {
  experiment: V1Experiment;
  /** List of any related warnings. */
  warnings?: V1LaunchWarning[];
}

/**
 * Request to continue an experiment.
 */
export interface V1ContinueExperimentRequest {
  /** Experiment ID to continue. */
  id: number;
  /** Experiment config (YAML) to merge with the experiment's config. */
  overrideConfig?: string;
}

/**
 * Container is a Docker container that is either scheduled to run or is
currently running on a set of slots.
 */
export interface V1Container {
  /** A list of devices that is being used by this container. */
  devices?: V1Device[];
  /** The unique id of this instance of a container. */
  id: string;
  /** The id of the task that is currently managing this container. */
  parent?: string;
  permissionDenied?: boolean;
  state: Containerv1State;
}

/**
 * The config to be patched into Master Config.
 */
export interface V1Config {
  log?: V1LogConfig;
}

/**
 * Container for a requested trial and its metrics.
 */
export interface V1ComparableTrial {
  /** The downsampled datapoints. */
  metrics: V1DownsampledMetrics[];
  trial: Trialv1Trial;
}

/**
 * Response to CompareTrialsRequest.
 */
export interface V1CompareTrialsResponse {
  /** A list of objects containing trial and metrics information. */
  trials: V1ComparableTrial[];
}

/**
 * Command is a single container running the configured command.
 */
export interface V1Command {
  container?: V1Container;
  /** The description of the command. */
  description: string;
  /** The display name of the user that created the command. */
  displayName?: string;
  exitStatus?: string;
  /** The id of the command. */
  id: string;
  /** The associated job id. */
  jobId: string;
  resourcePool: string;
  /** The time the command was started. */
  startTime: string;
  state: Taskv1State;
  /** The id of the user that created the command. */
  userId?: number;
  /** The username of the user that created the command. */
  username: string;
  /** The workspace id. */
  workspaceId: number;
}

/**
 * - COLUMN_TYPE_UNSPECIFIED: data type is unknown/mixed
 - COLUMN_TYPE_TEXT: data type is textual
 - COLUMN_TYPE_NUMBER: data type is numeric
 - COLUMN_TYPE_DATE: data type is a date
 - COLUMN_TYPE_ARRAY: data type is an array
 */
export type V1ColumnType = typeof V1ColumnType[keyof typeof V1ColumnType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1ColumnType = {
  COLUMN_TYPE_UNSPECIFIED: 'COLUMN_TYPE_UNSPECIFIED',
  COLUMN_TYPE_TEXT: 'COLUMN_TYPE_TEXT',
  COLUMN_TYPE_NUMBER: 'COLUMN_TYPE_NUMBER',
  COLUMN_TYPE_DATE: 'COLUMN_TYPE_DATE',
  COLUMN_TYPE_ARRAY: 'COLUMN_TYPE_ARRAY',
} as const;

/**
 * Active notice from the server admin.
 */
export interface V1ClusterMessage {
  /** Time message was created. */
  createdTime?: string;
  /** Time to stop showing message. */
  endTime?: string;
  /** Text content of message. */
  message: string;
  /** Time to begin showing message. */
  startTime: string;
}

/**
 * Response to CleanupLogsRequest.
 */
export interface V1CleanupLogsResponse {
  /** How many row of logs were removed. */
  removedCount: string;
}

/**
 * Response to CheckpointRemoveFilesRequest.
 */
export interface V1CheckpointsRemoveFilesResponse { [key: string]: unknown }

/**
 * Request to delete files matching globs in checkpoints.
 */
export interface V1CheckpointsRemoveFilesRequest {
  /** The list of checkpoint_globs for the requested checkpoints.
If a value is set to the empty string the checkpoint will only
have its metadata refreshed. */
  checkpointGlobs: string[];
  /** The list of checkpoint_uuids for the requested checkpoints. */
  checkpointUuids: string[];
}

/**
 * Dictionary of file paths to file sizes in bytes of all files in the
checkpoint.
 */
export type V1CheckpointWorkloadResources = {[key: string]: string};

/**
 * User defined metadata associated with the checkpoint.
 */
export type V1CheckpointWorkloadMetadata = { [key: string]: unknown };

/**
 * CheckpointWorkload is an artifact created by a trial during training.
 */
export interface V1CheckpointWorkload {
  /** The time the workload finished or was stopped. */
  endTime?: string;
  /** User defined metadata associated with the checkpoint. */
  metadata?: V1CheckpointWorkloadMetadata;
  /** Dictionary of file paths to file sizes in bytes of all files in the
checkpoint. */
  resources?: V1CheckpointWorkloadResources;
  state: Checkpointv1State;
  /** Total number of batches as of this workload's completion. */
  totalBatches: number;
  /** UUID of the checkpoint. */
  uuid?: string;
}

/**
 * Hyperparameter values for the trial that created this checkpoint.
 */
export type V1CheckpointTrainingMetadataHparams = { [key: string]: unknown };

/**
 * The configuration of the experiment that created this checkpoint.
 */
export type V1CheckpointTrainingMetadataExperimentConfig = { [key: string]: unknown };

/**
 * CheckpointTrainingMetadata is specifically metadata about training.
 */
export interface V1CheckpointTrainingMetadata {
  /** The configuration of the experiment that created this checkpoint. */
  experimentConfig?: V1CheckpointTrainingMetadataExperimentConfig;
  /** The ID of the experiment that created this checkpoint. */
  experimentId?: number;
  /** Hyperparameter values for the trial that created this checkpoint. */
  hparams?: V1CheckpointTrainingMetadataHparams;
  /** Searcher metric (as specified by the expconf) at the same steps_completed
of the checkpoint. */
  searcherMetric?: number;
  trainingMetrics?: V1Metrics;
  /** The ID of the trial that created this checkpoint. */
  trialId?: number;
  validationMetrics?: V1Metrics;
}

/**
 * Dictionary of file paths to file sizes in bytes of all files in the
checkpoint.
 */
export type V1CheckpointResources = {[key: string]: string};

/**
 * User defined metadata associated with the checkpoint.
 */
export type V1CheckpointMetadata = { [key: string]: unknown };

/**
 * Checkpoint a collection of files saved by a task.
 */
export interface V1Checkpoint {
  /** ID of the allocation which generated this checkpoint. */
  allocationId?: string;
  /** User defined metadata associated with the checkpoint. */
  metadata: V1CheckpointMetadata;
  /** Timestamp when the checkpoint was reported. */
  reportTime?: string;
  /** Dictionary of file paths to file sizes in bytes of all files in the
checkpoint. */
  resources: V1CheckpointResources;
  state: Checkpointv1State;
  /** Optional ID that describes where this checkpoint is stored.
It will be null on every checkpoint pre 0.27.1. It can also be null when a
user does not specify the storageID calling the report API themselves or
when users don't provide a storage config to core_context. */
  storageId?: number;
  /** ID of the task which generated this checkpoint. */
  taskId?: string;
  training: V1CheckpointTrainingMetadata;
  /** UUID of the checkpoint. */
  uuid: string;
}

/**
 * Response to CancelSearchesRequest.
 */
export interface V1CancelSearchesResponse {
  /** Details on success or error for each search. */
  results: V1SearchActionResult[];
}

/**
 * Cancel searches.
 */
export interface V1CancelSearchesRequest {
  filter?: string;
  /** Project id of the searches being canceled. */
  projectId: number;
  /** The ids of the searches being canceled. Leave empty if using filter. */
  searchIds?: number[];
}

/**
 * Response to CancelExperimentsRequest.
 */
export interface V1CancelExperimentsResponse {
  /** Details on success or error for each experiment. */
  results: V1ExperimentActionResult[];
}

/**
 * Cancel multiple experiments.
 */
export interface V1CancelExperimentsRequest {
  /** Selecting experiments by id. */
  experimentIds: number[];
  filters?: V1BulkExperimentFilters;
  /** Project id that the experiments belong to. */
  projectId: number;
}

/**
 * Response to CancelExperimentRequest.
 */
export interface V1CancelExperimentResponse { [key: string]: unknown }

/**
 * Filters to apply actions to multiple experiments.
 */
export interface V1BulkExperimentFilters {
  /** Limit experiments to those that are archived. */
  archived?: boolean;
  /** Limit experiments to those that match the description. */
  description?: string;
  /** Experiment ids to exclude when filters are used. */
  excludedExperimentIds?: number[];
  /** Limit experiments to those that match the provided labels. */
  labels?: string[];
  /** Limit experiments to those that match the name. */
  name?: string;
  /** Limit experiments to those within a specified project, or 0 for all
projects. */
  projectId?: number;
  /** Limit experiments to those that match the provided state. */
  states?: Experimentv1State[];
  /** Limit experiments to those that are owned by users with the specified
userIds. */
  userIds?: number[];
}

/**
 * Response to BulkAutoCreateWorkspaceNamespaceBindingsRequest.
 */
export interface V1BulkAutoCreateWorkspaceNamespaceBindingsResponse { [key: string]: unknown }

/**
 * Request for binding the given workpaces to new auto-created namespaces.
 */
export interface V1BulkAutoCreateWorkspaceNamespaceBindingsRequest {
  /** The list of workspace ids. */
  workspaceIds?: number[];
}

/**
 * Bind a resource pool to workspaces response.
 */
export interface V1BindRPToWorkspaceResponse { [key: string]: unknown }

export interface V1BindRPToWorkspaceRequest {
  /** The resource pool name. */
  resourcePoolName: string;
  /** The workspace IDs to be bound to the resource pool. */
  workspaceIds?: number[];
  /** The workspace names to be bound to the resource pool. */
  workspaceNames?: string[];
}

export interface V1AwsCustomTag {
  key: string;
  value: string;
}

/**
 * AssignRolesResponse is the body of the request for the call
to grant a user or group a role.
 */
export interface V1AssignRolesResponse { [key: string]: unknown }

/**
 * AssignRolesRequest is the body of the request for the call to
grant a user or group a role. It requires group_id, role_id,
and either scope_workspace_id or scope_project_id.
 */
export interface V1AssignRolesRequest {
  /** the set of groups being assigned to a role. */
  groupRoleAssignments?: V1GroupRoleAssignment[];
  /** the set of users being assigned to a role. */
  userRoleAssignments?: V1UserRoleAssignment[];
}

/**
 * Response to AssignMultipleGroupsRequest.
 */
export interface V1AssignMultipleGroupsResponse { [key: string]: unknown }

/**
 * Add and remove multiple users from multiple groups.
 */
export interface V1AssignMultipleGroupsRequest {
  /** The ids of groups to associate with users. */
  addGroups: number[];
  /** The ids of groups to disassociate from users. */
  removeGroups: number[];
  /** The user ids of users to edit group associations. */
  userIds: number[];
}

/**
 * Response to ArchiveWorkspaceRequest.
 */
export interface V1ArchiveWorkspaceResponse { [key: string]: unknown }

/**
 * Response to ArchiveSearchesRequest.
 */
export interface V1ArchiveSearchesResponse {
  /** Details on success or error for each search. */
  results: V1SearchActionResult[];
}

export interface V1ArchiveSearchesRequest {
  filter?: string;
  /** The id of the current parent project. */
  projectId: number;
  /** The ids of the searches being archived. Leave empty if using filter. */
  searchIds?: number[];
}

/**
 * Response to ArchiveRunsRequest.
 */
export interface V1ArchiveRunsResponse {
  /** Details on success or error for each run. */
  results: V1RunActionResult[];
}

export interface V1ArchiveRunsRequest {
  filter?: string;
  /** The id of the current parent project. */
  projectId: number;
  /** The ids of the runs being archived. Leave empty if using filter. */
  runIds?: number[];
}

/**
 * Response to ArchiveProjectRequest.
 */
export interface V1ArchiveProjectResponse { [key: string]: unknown }

export interface V1ArchiveModelResponse { [key: string]: unknown }

/**
 * Response to ArchiveExperimentsRequest.
 */
export interface V1ArchiveExperimentsResponse {
  /** Details on success or error for each experiment. */
  results: V1ExperimentActionResult[];
}

/**
 * Archive multiple experiments.
 */
export interface V1ArchiveExperimentsRequest {
  /** Selecting experiments by id. */
  experimentIds: number[];
  filters?: V1BulkExperimentFilters;
  /** Project id that the experiments belong to. */
  projectId: number;
}

/**
 * Response to ArchiveExperimentRequest.
 */
export interface V1ArchiveExperimentResponse { [key: string]: unknown }

/**
 * Response to AllocationWaitingRequest.
 */
export interface V1AllocationWaitingResponse { [key: string]: unknown }

/**
 * Mark the given task as waiting.
 */
export interface V1AllocationWaitingRequest {
  /** The id of the allocation. */
  allocationId?: string;
}

/**
 * AllocationSummary contains information about a task for external display.
 */
export interface V1AllocationSummary {
  /** AllocationID is the ID of an allocation of a task. It is usually of the
form TaskID.allocation_number, maybe with some other metadata if different
types of allocations run. */
  allocationId?: string;
  /** The name of the task. */
  name?: string;
  /** THe priority of the task. */
  priority?: number;
  /** ProxyPortConfig configures a proxy the allocation should start. */
  proxyPorts?: V1ProxyPortConfig[];
  /** The registered time of the task. */
  registeredTime?: string;
  /** The name of the resource pool. */
  resourcePool?: string;
  /** ResourcesSummary provides a summary of the resources comprising what we
know at the time the allocation is granted. */
  resources?: V1ResourcesSummary[];
  /** The type of the scheduler. Either 'FAIR_SHARE', 'PRIORITY', or
'ROUND_ROBIN'. */
  schedulerType?: string;
  /** The number of slots that are needed. */
  slotsNeeded?: number;
  /** TaskID is the unique ID of a task among all tasks. */
  taskId?: string;
}

export interface V1AllocationRendezvousInfoResponse {
  rendezvousInfo: V1RendezvousInfo;
}

/**
 * Response to AllocationReadyRequest.
 */
export interface V1AllocationReadyResponse { [key: string]: unknown }

/**
 * Mark the given task as ready.
 */
export interface V1AllocationReadyRequest {
  /** The id of the allocation. */
  allocationId?: string;
}

/**
 * Response to AllocationPreemptionSignalRequest.
 */
export interface V1AllocationPreemptionSignalResponse {
  /** True if signaling preempt, otherwise just a synchronization marker. */
  preempt?: boolean;
}

export interface V1AllocationPendingPreemptionSignalResponse { [key: string]: unknown }

export interface V1AllocationPendingPreemptionSignalRequest {
  /** The id of the allocation. */
  allocationId: string;
}

export type V1AllocationAllGatherResponseDataItem = { [key: string]: unknown };

export interface V1AllocationAllGatherResponse {
  /** The data for all the processes. */
  data: V1AllocationAllGatherResponseDataItem[];
}

/**
 * The data from this process.
 */
export type V1AllocationAllGatherRequestData = { [key: string]: unknown };

/**
 * Arguments to an all gather.
 */
export interface V1AllocationAllGatherRequest {
  /** The ID of the allocation. */
  allocationId: string;
  /** The data from this process. */
  data: V1AllocationAllGatherRequestData;
  /** The number of process to wait for. */
  numPeers?: number;
  /** The UUID of the participant in an all gather. */
  requestUuid?: string;
}

/**
 * Allocation tracks a specific instance of a Task.
 */
export interface V1Allocation {
  /** Unique ID of the allocation. */
  allocationId: string;
  /** End timestamp if completed. */
  endTime?: string;
  /** The exit reason for the allocation. */
  exitReason?: string;
  /** Whether the allocation is ready to access. */
  isReady?: boolean;
  /** The number of slots associated with the allocation. */
  slots: number;
  /** Start timestamp. */
  startTime?: string;
  state: Taskv1State;
  /** The status code the allocation exits with. */
  statusCode?: number;
  /** Unique ID of task associated with the allocation. */
  taskId: string;
}

/**
 * Aggregate statistics for a queue.
 */
export interface V1AggregateQueueStats {
  /** The date of this entry. */
  periodStart: string;
  /** The total number of seconds queued. */
  seconds: number;
}

/**
 * AgentUserGroup represents a username and primary group for a user on an
agent host machine.
 */
export interface V1AgentUserGroup {
  /** The group id on the agent. */
  agentGid?: number;
  /** Group name. */
  agentGroup?: string;
  /** The user id on the agent. */
  agentUid?: number;
  /** User name. */
  agentUser?: string;
}

/**
 * A map of slot id to each slot of this agent.
 */
export type V1AgentSlots = {[key: string]: V1Slot};

/**
 * A map of container id to all containers assigned to this agent.
 */
export type V1AgentContainers = {[key: string]: V1Container};

/**
 * Agent is a pool of resources where containers are run.
 */
export interface V1Agent {
  /** The addresses of the agent. */
  addresses?: string[];
  /** A map of container id to all containers assigned to this agent. */
  containers?: V1AgentContainers;
  /** Flag notifying if this agent is in the draining mode: current containers
will be allowed to finish but no new ones will be scheduled. */
  draining?: boolean;
  /** Flag notifying if containers can be scheduled on this agent. */
  enabled?: boolean;
  /** The unique id of the agent. */
  id: string;
  /** The time when the agent registered with the master. */
  registeredTime?: string;
  /** The name of the resource pools the agent is in. Only slurm can contain
multiples. */
  resourcePools?: string[];
  /** A map of slot id to each slot of this agent. */
  slots?: V1AgentSlots;
  slotStats: V1SlotStats;
  /** The Determined version that this agent was built from. */
  version?: string;
}

/**
 * Address represents an exposed port on a container.
 */
export interface V1Address {
  /** ContainerIP is the IP address from inside the container. */
  containerIp?: string;
  /** ContainerPort is the port from inside the container. */
  containerPort?: number;
  /** HostIP is the IP address from outside the container. This can be
different than the ContainerIP because of network forwarding on the host
machine. */
  hostIp?: string;
  /** HostPort is the IP port from outside the container. This can be different
than the ContainerPort because of network forwarding on the host machine. */
  hostPort?: number;
}

/**
 * Response to AddProjectNoteRequest.
 */
export interface V1AddProjectNoteResponse {
  /** The complete list of notes on a project. */
  notes: V1Note[];
}

/**
 * - ACTIVITY_TYPE_UNSPECIFIED: Default activity type.
 - ACTIVITY_TYPE_GET: Represents a get request.
 */
export type V1ActivityType = typeof V1ActivityType[keyof typeof V1ActivityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1ActivityType = {
  ACTIVITY_TYPE_UNSPECIFIED: 'ACTIVITY_TYPE_UNSPECIFIED',
  ACTIVITY_TYPE_GET: 'ACTIVITY_TYPE_GET',
} as const;

/**
 * Response to ActivateExperimentsRequest.
 */
export interface V1ActivateExperimentsResponse {
  /** Details on success or error for each experiment. */
  results: V1ExperimentActionResult[];
}

/**
 * Activate multiple experiments.
 */
export interface V1ActivateExperimentsRequest {
  /** Select experiments by id. */
  experimentIds: number[];
  filters?: V1BulkExperimentFilters;
  /** Project id that the experiments belong to. */
  projectId: number;
}

/**
 * Response to ActivateExperimentRequest.
 */
export interface V1ActivateExperimentResponse { [key: string]: unknown }

/**
 * Response to AckAllocationPreemptionSignalRequest.
 */
export interface V1AckAllocationPreemptionSignalResponse { [key: string]: unknown }

/**
 * Acknowledge the receipt of some stop signal.
 */
export interface V1AckAllocationPreemptionSignalRequest {
  /** The allocation that is acknowledging the request. */
  allocationId: string;
}

export interface V1AcceleratorData {
  /** The type of accelerator. */
  acceleratorType?: string;
  /** An array of UUIDs of the accelerators associated with the allocation. */
  acceleratorUuids?: string[];
  /** The id of the allocation. */
  allocationId?: string;
  /** The id of the container. */
  containerId?: string;
  /** The name of the node the allocation is on. */
  nodeName?: string;
  /** The name of the resource pool. */
  resourcePool?: string;
  /** The id of the agent associated with the allocation. */
  taskId?: string;
}

export type Trialv1TrialSummaryMetrics = { [key: string]: unknown };

/**
 * metadata associated with the trial (based off the metadata stored in the
run).
 */
export type Trialv1TrialMetadata = { [key: string]: unknown };

/**
 * Trial hyperparameters.
 */
export type Trialv1TrialHparams = { [key: string]: unknown };

/**
 * Trial is a set of workloads and are exploring a determined set of
hyperparameters.
 */
export interface Trialv1Trial {
  bestCheckpoint?: V1CheckpointWorkload;
  bestValidation?: V1MetricsWorkload;
  /** The count of checkpoints. */
  checkpointCount?: number;
  /** The time the trial ended if the trial is stopped. */
  endTime?: string;
  /** The id of the parent experiment. */
  experimentId: number;
  /** Trial hyperparameters. */
  hparams: Trialv1TrialHparams;
  /** The id of the trial. */
  id: number;
  latestValidation?: V1MetricsWorkload;
  /** Log Policy Matched. */
  logPolicyMatched?: string;
  /** Number of days to retain logs for. */
  logRetentionDays?: number;
  /** metadata associated with the trial (based off the metadata stored in the
run). */
  metadata?: Trialv1TrialMetadata;
  /** Number times the trial restarted. */
  restarts: number;
  /** The last reported state of the trial runner (harness code). */
  runnerState?: string;
  /** Signed searcher metrics value. */
  searcherMetricValue?: number;
  /** The time the trial was started. */
  startTime: string;
  state: Trialv1State;
  summaryMetrics?: Trialv1TrialSummaryMetrics;
  /** Id of the first task associated with this trial.
This field is deprecated since trials can have multiple tasks. */
  taskId?: string;
  /** Task IDs of tasks associated with this trial.
Length of task_ids will always be greater or equal to one when TaskID is
sent. For example CompareTrial we will send a reduced Trial object, without
TaskID or TaskIDs fileld in. The first element of task_ids will be the same
as task_id. task_ids is sorted ascending by task_run_id. */
  taskIds?: string[];
  /** The current processed batches. */
  totalBatchesProcessed: number;
  /** The sum of sizes of all resources in all checkpoints for the trial. */
  totalCheckpointSize?: string;
  /** The wall clock time is all active time of the cluster for the trial,
inclusive of everything (restarts, initiailization, etc), in seconds. */
  wallClockTime?: number;
  /** UUID of checkpoint that this trial started from. */
  warmStartCheckpointUuid?: string;
}

export interface RuntimeError {
  code?: number;
  details?: ProtobufAny[];
  error?: string;
  message?: string;
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the
`Value` type union.

 The JSON representation for `NullValue` is JSON `null`.

 - NULL_VALUE: Null value.
 */
export type ProtobufNullValue = typeof ProtobufNullValue[keyof typeof ProtobufNullValue];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProtobufNullValue = {
  NULL_VALUE: 'NULL_VALUE',
} as const;

/**
 * https://protobuf.dev/reference/java/api-docs/com/google/protobuf/FieldMask
 */
export interface ProtobufFieldMask {
  /** The set of field mask paths. */
  paths?: string[];
}

/**
 * https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Any
 */
export interface ProtobufAny {
  /** https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Any */
  typeUrl?: string;
  /** Must be a valid serialized protocol buffer of the above specified type. */
  value?: string;
}

export interface RuntimeStreamError {
  details?: ProtobufAny[];
  grpcCode?: number;
  httpCode?: number;
  httpStatus?: string;
  message?: string;
}

/**
 * Sorts options for checkpoints by the given field.

 - SORT_BY_UNSPECIFIED: Returns checkpoints in an unsorted list.
 - SORT_BY_UUID: Returns checkpoints sorted by UUID.
 - SORT_BY_TRIAL_ID: Returns checkpoints sorted by trial id.
 - SORT_BY_BATCH_NUMBER: Returns checkpoints sorted by batch number.
 - SORT_BY_END_TIME: Returns checkpoints sorted by end time.
 - SORT_BY_STATE: Returns checkpoints sorted by state.
 - SORT_BY_SEARCHER_METRIC: Returns checkpoints sorted by the experiment's `searcher.metric`
configuration setting.
 */
export type Checkpointv1SortBy = typeof Checkpointv1SortBy[keyof typeof Checkpointv1SortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Checkpointv1SortBy = {
  SORT_BY_UNSPECIFIED: 'SORT_BY_UNSPECIFIED',
  SORT_BY_UUID: 'SORT_BY_UUID',
  SORT_BY_TRIAL_ID: 'SORT_BY_TRIAL_ID',
  SORT_BY_BATCH_NUMBER: 'SORT_BY_BATCH_NUMBER',
  SORT_BY_END_TIME: 'SORT_BY_END_TIME',
  SORT_BY_STATE: 'SORT_BY_STATE',
  SORT_BY_SEARCHER_METRIC: 'SORT_BY_SEARCHER_METRIC',
} as const;

/**
 * To distinguish the 2 different categories of metrics.

 - PROFILER_METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).
 - PROFILER_METRIC_TYPE_SYSTEM: For systems metrics, like GPU utilization or memory.
 - PROFILER_METRIC_TYPE_TIMING: For timing metrics, like how long a backwards pass or getting a batch
from the dataloader took.
 - PROFILER_METRIC_TYPE_MISC: For other miscellaneous metrics.
 */
export type TrialProfilerMetricLabelsProfilerMetricType = typeof TrialProfilerMetricLabelsProfilerMetricType[keyof typeof TrialProfilerMetricLabelsProfilerMetricType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TrialProfilerMetricLabelsProfilerMetricType = {
  PROFILER_METRIC_TYPE_UNSPECIFIED: 'PROFILER_METRIC_TYPE_UNSPECIFIED',
  PROFILER_METRIC_TYPE_SYSTEM: 'PROFILER_METRIC_TYPE_SYSTEM',
  PROFILER_METRIC_TYPE_TIMING: 'PROFILER_METRIC_TYPE_TIMING',
  PROFILER_METRIC_TYPE_MISC: 'PROFILER_METRIC_TYPE_MISC',
} as const;

/**
 * A wrapper message of a list of devices.
 */
export interface ResourcesSummaryDevices {
  /** The devices on an agent. */
  devices?: V1Device[];
}

/**
 * Nested object for resources field patch.
 */
export interface PatchExperimentPatchResources {
  /** Experiment config resources.max_slots. */
  maxSlots?: number;
  /** Experiment config resources.priority. */
  priority?: number;
  /** Experiment config resources.weight. */
  weight?: number;
}

/**
 * Nested object for checkpoint_storage field patch.
 */
export interface PatchExperimentPatchCheckpointStorage {
  /** Experiment config checkpoint_storage.save_experiment_best. */
  saveExperimentBest?: number;
  /** Experiment config checkpoint_storage.save_trial_best. */
  saveTrialBest?: number;
  /** Experiment config checkpoint_storage.save_trial_latest. */
  saveTrialLatest?: number;
}

/**
 * Resources.
 */
export type PatchCheckpointOptionalResourcesResources = {[key: string]: string};

/**
 * Gets around not being able to do "Optional map<string, int64>".
Not ideal but this API is marked internal for now.
 */
export interface PatchCheckpointOptionalResources {
  /** Resources. */
  resources?: PatchCheckpointOptionalResourcesResources;
}

/**
 * Filter workloads with training, validation, and checkpoint information.

 - FILTER_OPTION_UNSPECIFIED: Any workload.
 - FILTER_OPTION_CHECKPOINT: Only workloads with an associated checkpoint.
 - FILTER_OPTION_VALIDATION: Only validation workloads.
 - FILTER_OPTION_CHECKPOINT_OR_VALIDATION: Only validation workloads or ones with an associated checkpoint.
 */
export type GetTrialWorkloadsRequestFilterOption = typeof GetTrialWorkloadsRequestFilterOption[keyof typeof GetTrialWorkloadsRequestFilterOption];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTrialWorkloadsRequestFilterOption = {
  FILTER_OPTION_UNSPECIFIED: 'FILTER_OPTION_UNSPECIFIED',
  FILTER_OPTION_CHECKPOINT: 'FILTER_OPTION_CHECKPOINT',
  FILTER_OPTION_VALIDATION: 'FILTER_OPTION_VALIDATION',
  FILTER_OPTION_CHECKPOINT_OR_VALIDATION: 'FILTER_OPTION_CHECKPOINT_OR_VALIDATION',
} as const;

/**
 * - PRODUCT_UNSPECIFIED: Not a Cloud Community offering
 - PRODUCT_COMMUNITY: Determined Cloud, Community Edition
 */
export type GetMasterResponseProduct = typeof GetMasterResponseProduct[keyof typeof GetMasterResponseProduct];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMasterResponseProduct = {
  PRODUCT_UNSPECIFIED: 'PRODUCT_UNSPECIFIED',
  PRODUCT_COMMUNITY: 'PRODUCT_COMMUNITY',
} as const;





  /**
 * @summary Get a set of agents from the cluster.
 */
export const getAgents = <TData = AxiosResponse<V1GetAgentsResponse>>(
    params?: GetAgentsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/agents`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get the requested agent.
 */
export const getAgent = <TData = AxiosResponse<V1GetAgentResponse>>(
    agentId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/agents/${agentId}`,options
    );
  }

/**
 * @summary Disable the agent.
 */
export const disableAgent = <TData = AxiosResponse<V1DisableAgentResponse>>(
    agentId: string,
    v1DisableAgentRequest: V1DisableAgentRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/agents/${agentId}/disable`,
      v1DisableAgentRequest,options
    );
  }

/**
 * @summary Enable the agent.
 */
export const enableAgent = <TData = AxiosResponse<V1EnableAgentResponse>>(
    agentId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/agents/${agentId}/enable`,undefined,options
    );
  }

/**
 * @summary Get all the slots for an agent.
 */
export const getSlots = <TData = AxiosResponse<V1GetSlotsResponse>>(
    agentId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/agents/${agentId}/slots`,options
    );
  }

/**
 * @summary Get the requested slot for an agent.
 */
export const getSlot = <TData = AxiosResponse<V1GetSlotResponse>>(
    agentId: string,
    slotId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/agents/${agentId}/slots/${slotId}`,options
    );
  }

/**
 * @summary Disable the slot.
 */
export const disableSlot = <TData = AxiosResponse<V1DisableSlotResponse>>(
    agentId: string,
    slotId: string,
    v1DisableSlotRequest: V1DisableSlotRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/agents/${agentId}/slots/${slotId}/disable`,
      v1DisableSlotRequest,options
    );
  }

/**
 * @summary Enable the slot.
 */
export const enableSlot = <TData = AxiosResponse<V1EnableSlotResponse>>(
    agentId: string,
    slotId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/agents/${agentId}/slots/${slotId}/enable`,undefined,options
    );
  }

/**
 * @summary Get details about an Allocation.
 */
export const getAllocation = <TData = AxiosResponse<V1GetAllocationResponse>>(
    allocationId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/allocations/${allocationId}`,options
    );
  }

/**
 * @summary PostAllocationAcceleratorData sets the accelerator for a given allocation.
 */
export const postAllocationAcceleratorData = <TData = AxiosResponse<V1PostAllocationAcceleratorDataResponse>>(
    allocationId: string,
    v1PostAllocationAcceleratorDataRequest: V1PostAllocationAcceleratorDataRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/allocations/${allocationId}/acceleratorData`,
      v1PostAllocationAcceleratorDataRequest,options
    );
  }

/**
 * @summary AllocationAllGather performs an all gather through the master. An
allocation can only perform once all gather at a time.
 */
export const allocationAllGather = <TData = AxiosResponse<V1AllocationAllGatherResponse>>(
    allocationId: string,
    v1AllocationAllGatherRequest: V1AllocationAllGatherRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/allocations/${allocationId}/all_gather`,
      v1AllocationAllGatherRequest,options
    );
  }

/**
 * @summary NotifyContainterRunning is used to notify the master that the container
is running.  On HPC, the launcher will report a state of "Running" as
soon as Slurm starts the job, but the container may be in the process
of getting pulled down from the Internet, so the experiment is not
really considered to be in a "Running" state until all the containers
that are part of the experiment are running and not being pulled.
 */
export const notifyContainerRunning = <TData = AxiosResponse<V1NotifyContainerRunningResponse>>(
    allocationId: string,
    v1NotifyContainerRunningRequest: V1NotifyContainerRunningRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/allocations/${allocationId}/notify_container_running`,
      v1NotifyContainerRunningRequest,options
    );
  }

/**
 * @summary PostAllocationProxyAddress sets the proxy address to use when proxying to
services provided by an allocation. Upon receipt, the master will also
register any proxies specified by the task.
 */
export const postAllocationProxyAddress = <TData = AxiosResponse<V1PostAllocationProxyAddressResponse>>(
    allocationId: string,
    v1PostAllocationProxyAddressRequest: V1PostAllocationProxyAddressRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/allocations/${allocationId}/proxy_address`,
      v1PostAllocationProxyAddressRequest,options
    );
  }

/**
 * @summary Set allocation to ready state.
 */
export const allocationReady = <TData = AxiosResponse<V1AllocationReadyResponse>>(
    allocationId: string,
    v1AllocationReadyRequest: V1AllocationReadyRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/allocations/${allocationId}/ready`,
      v1AllocationReadyRequest,options
    );
  }

/**
 * @summary Mark the given reservation (container, pod, etc) within an allocation as
a daemon reservation. In the exit of a successful exit, Determined will
wait for all resources to exit - unless they are marked as daemon
resources, in which case Determined will clean them up regardless of
exit status after all non-daemon resources have exited.
 */
export const markAllocationResourcesDaemon = <TData = AxiosResponse<V1MarkAllocationResourcesDaemonResponse>>(
    allocationId: string,
    resourcesId: string,
    v1MarkAllocationResourcesDaemonRequest: V1MarkAllocationResourcesDaemonRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/allocations/${allocationId}/resources/${resourcesId}/daemon`,
      v1MarkAllocationResourcesDaemonRequest,options
    );
  }

/**
 * @summary Gather an allocation's rendezvous info. Blocks until all trial containers
connect to gather their rendezvous information and responds to them all at
once.
 */
export const allocationRendezvousInfo = <TData = AxiosResponse<V1AllocationRendezvousInfoResponse>>(
    allocationId: string,
    resourcesId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/allocations/${allocationId}/resources/${resourcesId}/rendezvous`,options
    );
  }

/**
 * @summary Acknowledge the receipt of a signal to stop the given allocation early.
This is used indicate and exit 0 isn't final; specifically, it is used
for HP search directed early stops and preemption signals (not necessarily
just scheduler preemption).
 */
export const ackAllocationPreemptionSignal = <TData = AxiosResponse<V1AckAllocationPreemptionSignalResponse>>(
    allocationId: string,
    v1AckAllocationPreemptionSignalRequest: V1AckAllocationPreemptionSignalRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/allocations/${allocationId}/signals/ack_preemption`,
      v1AckAllocationPreemptionSignalRequest,options
    );
  }

/**
 * @summary Report the receipt of a signal to stop the given allocation early.
This is used to communicate back from a SLURM job that it has been
notified of a pending preememption. Upon a call to this API
the RM should then trigger a checkpoint and immediate exit.
 */
export const allocationPendingPreemptionSignal = <TData = AxiosResponse<V1AllocationPendingPreemptionSignalResponse>>(
    allocationId: string,
    v1AllocationPendingPreemptionSignalRequest: V1AllocationPendingPreemptionSignalRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/allocations/${allocationId}/signals/pending_preemption`,
      v1AllocationPendingPreemptionSignalRequest,options
    );
  }

/**
 * @summary Long poll preemption signals for the given allocation. If the allocation
has been preempted when called, it will return so immediately. Otherwise,
the connection will be kept open until the timeout is reached or
the allocation is preempted.
 */
export const allocationPreemptionSignal = <TData = AxiosResponse<V1AllocationPreemptionSignalResponse>>(
    allocationId: string,
    params?: AllocationPreemptionSignalParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/allocations/${allocationId}/signals/preemption`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Set allocation to waiting state.
 */
export const allocationWaiting = <TData = AxiosResponse<V1AllocationWaitingResponse>>(
    allocationId: string,
    v1AllocationWaitingRequest: V1AllocationWaitingRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/allocations/${allocationId}/waiting`,
      v1AllocationWaitingRequest,options
    );
  }

/**
 * @summary Login the user.
 */
export const login = <TData = AxiosResponse<V1LoginResponse>>(
    v1LoginRequest: V1LoginRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/auth/login`,
      v1LoginRequest,options
    );
  }

/**
 * @summary Logout the user.
 */
export const logout = <TData = AxiosResponse<V1LogoutResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/auth/logout`,undefined,options
    );
  }

/**
 * @summary Get the current user.
 */
export const currentUser = <TData = AxiosResponse<V1CurrentUserResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/auth/user`,options
    );
  }

/**
 * @summary Delete Checkpoints.
 */
export const deleteCheckpoints = <TData = AxiosResponse<V1DeleteCheckpointsResponse>>(
    v1DeleteCheckpointsRequest: V1DeleteCheckpointsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/checkpoints`,{data:
      v1DeleteCheckpointsRequest, ...options}
    );
  }

/**
 * @summary Record a checkpoint.
 */
export const reportCheckpoint = <TData = AxiosResponse<V1ReportCheckpointResponse>>(
    v1Checkpoint: V1Checkpoint, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/checkpoints`,
      v1Checkpoint,options
    );
  }

/**
 * @summary Update checkpoints. Won't modify checkpoint files.
 */
export const patchCheckpoints = <TData = AxiosResponse<V1PatchCheckpointsResponse>>(
    v1PatchCheckpointsRequest: V1PatchCheckpointsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/checkpoints`,
      v1PatchCheckpointsRequest,options
    );
  }

/**
 * @summary Remove files from checkpoints.
 */
export const checkpointsRemoveFiles = <TData = AxiosResponse<V1CheckpointsRemoveFilesResponse>>(
    v1CheckpointsRemoveFilesRequest: V1CheckpointsRemoveFilesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/checkpoints/rm`,
      v1CheckpointsRemoveFilesRequest,options
    );
  }

/**
 * @summary Update checkpoint metadata.
 */
export const postCheckpointMetadata = <TData = AxiosResponse<V1PostCheckpointMetadataResponse>>(
    v1PostCheckpointMetadataRequest: V1PostCheckpointMetadataRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/checkpoints/checkpoint.uuid}/metadata`,
      v1PostCheckpointMetadataRequest,options
    );
  }

/**
 * @summary Get the requested checkpoint.
 */
export const getCheckpoint = <TData = AxiosResponse<V1GetCheckpointResponse>>(
    checkpointUuid: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/checkpoints/${checkpointUuid}`,options
    );
  }

/**
 * @summary Gets the metrics for all trials associated with this checkpoint
 */
export const getTrialMetricsByCheckpoint = <TData = AxiosResponse<V1GetTrialMetricsByCheckpointResponse>>(
    checkpointUuid: string,
    params?: GetTrialMetricsByCheckpointParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/checkpoints/${checkpointUuid}/metrics`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Cleanup task logs according to the retention policy.
 */
export const cleanupLogs = <TData = AxiosResponse<V1CleanupLogsResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/cleanup_logs`,undefined,options
    );
  }

/**
 * @summary Get a list of commands.
 */
export const getCommands = <TData = AxiosResponse<V1GetCommandsResponse>>(
    params?: GetCommandsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/commands`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Launch a command.
 */
export const launchCommand = <TData = AxiosResponse<V1LaunchCommandResponse>>(
    v1LaunchCommandRequest: V1LaunchCommandRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/commands`,
      v1LaunchCommandRequest,options
    );
  }

/**
 * @summary Get the requested command.
 */
export const getCommand = <TData = AxiosResponse<V1GetCommandResponse>>(
    commandId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/commands/${commandId}`,options
    );
  }

/**
 * @summary Kill the requested command.
 */
export const killCommand = <TData = AxiosResponse<V1KillCommandResponse>>(
    commandId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/commands/${commandId}/kill`,undefined,options
    );
  }

/**
 * @summary Set the priority of the requested command.
 */
export const setCommandPriority = <TData = AxiosResponse<V1SetCommandPriorityResponse>>(
    commandId: string,
    v1SetCommandPriorityRequest: V1SetCommandPriorityRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/commands/${commandId}/set_priority`,
      v1SetCommandPriorityRequest,options
    );
  }

/**
 * @summary Get global task config policies.
 */
export const getGlobalConfigPolicies = <TData = AxiosResponse<V1GetGlobalConfigPoliciesResponse>>(
    workloadType: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/config-policies/global/${workloadType}`,options
    );
  }

/**
 * @summary Delete global task config policies.
 */
export const deleteGlobalConfigPolicies = <TData = AxiosResponse<V1DeleteGlobalConfigPoliciesResponse>>(
    workloadType: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/config-policies/global/${workloadType}`,options
    );
  }

/**
 * @summary Add or update global task config policies.
 */
export const putGlobalConfigPolicies = <TData = AxiosResponse<V1PutGlobalConfigPoliciesResponse>>(
    workloadType: string,
    v1PutGlobalConfigPoliciesRequest: V1PutGlobalConfigPoliciesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/config-policies/global/${workloadType}`,
      v1PutGlobalConfigPoliciesRequest,options
    );
  }

/**
 * @summary Get workspace task config policies.
 */
export const getWorkspaceConfigPolicies = <TData = AxiosResponse<V1GetWorkspaceConfigPoliciesResponse>>(
    workspaceId: number,
    workloadType: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/config-policies/workspaces/${workspaceId}/${workloadType}`,options
    );
  }

/**
 * @summary Delete workspace task config policies.
 */
export const deleteWorkspaceConfigPolicies = <TData = AxiosResponse<V1DeleteWorkspaceConfigPoliciesResponse>>(
    workspaceId: number,
    workloadType: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/config-policies/workspaces/${workspaceId}/${workloadType}`,options
    );
  }

/**
 * @summary Add or update workspace task config policies.
 */
export const putWorkspaceConfigPolicies = <TData = AxiosResponse<V1PutWorkspaceConfigPoliciesResponse>>(
    workspaceId: number,
    workloadType: string,
    v1PutWorkspaceConfigPoliciesRequest: V1PutWorkspaceConfigPoliciesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/config-policies/workspaces/${workspaceId}/${workloadType}`,
      v1PutWorkspaceConfigPoliciesRequest,options
    );
  }

/**
 * @summary Get a list of unique experiment labels (sorted by popularity).
 */
export const getExperimentLabels = <TData = AxiosResponse<V1GetExperimentLabelsResponse>>(
    params?: GetExperimentLabelsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/experiment/labels`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get a list of experiments.
 */
export const getExperiments = <TData = AxiosResponse<V1GetExperimentsResponse>>(
    params?: GetExperimentsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/experiments`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Create an experiment.
 */
export const createExperiment = <TData = AxiosResponse<V1CreateExperimentResponse>>(
    v1CreateExperimentRequest: V1CreateExperimentRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/experiments`,
      v1CreateExperimentRequest,options
    );
  }

/**
 * @summary Get experiments with grouping and search syntax
 */
export const searchExperiments = <TData = AxiosResponse<V1SearchExperimentsResponse>>(
    v1SearchExperimentsRequest: V1SearchExperimentsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/experiments-search`,
      v1SearchExperimentsRequest,options
    );
  }

/**
 * @summary Put an experiment by external id.
 */
export const putExperiment = <TData = AxiosResponse<V1PutExperimentResponse>>(
    externalExperimentId: string,
    v1CreateExperimentRequest: V1CreateExperimentRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/experiments/by-external-id/${externalExperimentId}`,
      v1CreateExperimentRequest,options
    );
  }

/**
 * @summary Continues an experiment either to make the existing experiment train longer
or to retry it.
 */
export const continueExperiment = <TData = AxiosResponse<V1ContinueExperimentResponse>>(
    v1ContinueExperimentRequest: V1ContinueExperimentRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/experiments/continue`,
      v1ContinueExperimentRequest,options
    );
  }

/**
 * @summary Get the set of metric names recorded for a list of experiments.
 */
export const expMetricNames = <TData = AxiosResponse<ExpMetricNames200>>(
    params: ExpMetricNamesParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/experiments/metrics-stream/metric-names`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Patch an experiment's fields.
 */
export const patchExperiment = <TData = AxiosResponse<V1PatchExperimentResponse>>(
    v1PatchExperiment: V1PatchExperiment, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/experiments/experiment.id}`,
      v1PatchExperiment,options
    );
  }

/**
 * @summary Get the requested experiment.
 */
export const getExperiment = <TData = AxiosResponse<V1GetExperimentResponse>>(
    experimentId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/experiments/${experimentId}`,options
    );
  }

/**
 * @summary Delete the requested experiment.
 */
export const deleteExperiment = <TData = AxiosResponse<V1DeleteExperimentResponse>>(
    experimentId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/experiments/${experimentId}`,options
    );
  }

/**
 * @summary Get one file content of model definition of an experiment.
 */
export const getModelDefFile = <TData = AxiosResponse<V1GetModelDefFileResponse>>(
    experimentId: number,
    v1GetModelDefFileRequest: V1GetModelDefFileRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/experiments/${experimentId}/file`,
      v1GetModelDefFileRequest,options
    );
  }

/**
 * @summary Get the model definition file tree of an experiment.
 */
export const getModelDefTree = <TData = AxiosResponse<V1GetModelDefTreeResponse>>(
    experimentId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/experiments/${experimentId}/file_tree`,options
    );
  }

/**
 * @summary Delete a label from the experiment.
 */
export const deleteExperimentLabel = <TData = AxiosResponse<V1DeleteExperimentLabelResponse>>(
    experimentId: number,
    label: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/experiments/${experimentId}/labels/${label}`,options
    );
  }

/**
 * @summary Put a new label on the experiment.
 */
export const putExperimentLabel = <TData = AxiosResponse<V1PutExperimentLabelResponse>>(
    experimentId: number,
    label: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/experiments/${experimentId}/labels/${label}`,undefined,options
    );
  }

/**
 * @summary Get the milestones (in batches processed) at which a metric is recorded by
an experiment.
 */
export const metricBatches = <TData = AxiosResponse<MetricBatches200>>(
    experimentId: number,
    params: MetricBatchesParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/experiments/${experimentId}/metrics-stream/batches`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get a sample of the metrics over time for a sample of the trials.
 */
export const trialsSample = <TData = AxiosResponse<TrialsSample200>>(
    experimentId: number,
    params: TrialsSampleParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/experiments/${experimentId}/metrics-stream/trials-sample`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get a snapshot of a metric across all trials at a certain point of
progress.
 */
export const trialsSnapshot = <TData = AxiosResponse<TrialsSnapshot200>>(
    experimentId: number,
    params: TrialsSnapshotParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/experiments/${experimentId}/metrics-stream/trials-snapshot`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get the model definition of an experiment.
 */
export const getModelDef = <TData = AxiosResponse<V1GetModelDefResponse>>(
    experimentId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/experiments/${experimentId}/model_def`,options
    );
  }

/**
 * @summary Move an experiment into a project.
 */
export const moveExperiment = <TData = AxiosResponse<V1MoveExperimentResponse>>(
    experimentId: number,
    v1MoveExperimentRequest: V1MoveExperimentRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/experiments/${experimentId}/move`,
      v1MoveExperimentRequest,options
    );
  }

/**
 * @summary Retain logs for an experiment.
 */
export const putExperimentRetainLogs = <TData = AxiosResponse<V1PutExperimentRetainLogsResponse>>(
    experimentId: number,
    v1PutExperimentRetainLogsRequest: V1PutExperimentRetainLogsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/experiments/${experimentId}/retain_logs`,
      v1PutExperimentRetainLogsRequest,options
    );
  }

/**
 * @summary Get the best searcher validation for an experiment by the given metric.
 */
export const getBestSearcherValidationMetric = <TData = AxiosResponse<V1GetBestSearcherValidationMetricResponse>>(
    experimentId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/experiments/${experimentId}/searcher/best_searcher_validation_metric`,options
    );
  }

/**
 * @summary Delete tensorboard files.
 */
export const deleteTensorboardFiles = <TData = AxiosResponse<V1DeleteTensorboardFilesResponse>>(
    experimentId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/experiments/${experimentId}/tensorboard-files`,options
    );
  }

/**
 * @summary Get the list of trials for an experiment.
 */
export const getExperimentTrials = <TData = AxiosResponse<V1GetExperimentTrialsResponse>>(
    experimentId: number,
    params?: GetExperimentTrialsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/experiments/${experimentId}/trials`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get the validation history for an experiment.
 */
export const getExperimentValidationHistory = <TData = AxiosResponse<V1GetExperimentValidationHistoryResponse>>(
    experimentId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/experiments/${experimentId}/validation-history`,options
    );
  }

/**
 * @summary Activate an experiment.
 */
export const activateExperiment = <TData = AxiosResponse<V1ActivateExperimentResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/experiments/${id}/activate`,undefined,options
    );
  }

/**
 * @summary Archive an experiment.
 */
export const archiveExperiment = <TData = AxiosResponse<V1ArchiveExperimentResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/experiments/${id}/archive`,undefined,options
    );
  }

/**
 * @summary Cancel an experiment.
 */
export const cancelExperiment = <TData = AxiosResponse<V1CancelExperimentResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/experiments/${id}/cancel`,undefined,options
    );
  }

/**
 * @summary Get a list of checkpoints for an experiment.
 */
export const getExperimentCheckpoints = <TData = AxiosResponse<V1GetExperimentCheckpointsResponse>>(
    id: number,
    params?: GetExperimentCheckpointsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/experiments/${id}/checkpoints`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Kill an experiment.
 */
export const killExperiment = <TData = AxiosResponse<V1KillExperimentResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/experiments/${id}/kill`,undefined,options
    );
  }

/**
 * @summary Pause an experiment.
 */
export const pauseExperiment = <TData = AxiosResponse<V1PauseExperimentResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/experiments/${id}/pause`,undefined,options
    );
  }

/**
 * @summary Unarchive an experiment.
 */
export const unarchiveExperiment = <TData = AxiosResponse<V1UnarchiveExperimentResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/experiments/${id}/unarchive`,undefined,options
    );
  }

/**
 * @summary Create an experiment.
 */
export const createGenericTask = <TData = AxiosResponse<V1CreateGenericTaskResponse>>(
    v1CreateGenericTaskRequest: V1CreateGenericTaskRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/generic-tasks`,
      v1CreateGenericTaskRequest,options
    );
  }

/**
 * @summary Create a group with optional members on creation.
 */
export const createGroup = <TData = AxiosResponse<V1CreateGroupResponse>>(
    v1CreateGroupRequest: V1CreateGroupRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/groups`,
      v1CreateGroupRequest,options
    );
  }

/**
 * @summary Search for groups with optional filters.
 */
export const getGroups = <TData = AxiosResponse<V1GetGroupsResponse>>(
    v1GetGroupsRequest: V1GetGroupsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/groups/search`,
      v1GetGroupsRequest,options
    );
  }

/**
 * @summary Get a group by id.
 */
export const getGroup = <TData = AxiosResponse<V1GetGroupResponse>>(
    groupId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/groups/${groupId}`,options
    );
  }

/**
 * @summary Remove a group.
 */
export const deleteGroup = <TData = AxiosResponse<V1DeleteGroupResponse>>(
    groupId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/groups/${groupId}`,options
    );
  }

/**
 * @summary Update group info.
 */
export const updateGroup = <TData = AxiosResponse<V1UpdateGroupResponse>>(
    groupId: number,
    v1UpdateGroupRequest: V1UpdateGroupRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/groups/${groupId}`,
      v1UpdateGroupRequest,options
    );
  }

/**
 * @summary Get a list of jobs in queue.
 */
export const getJobs = <TData = AxiosResponse<V1GetJobsResponse>>(
    params?: GetJobsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/job-queues`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Control the job queues.
 */
export const updateJobQueue = <TData = AxiosResponse<V1UpdateJobQueueResponse>>(
    v1UpdateJobQueueRequest: V1UpdateJobQueueRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/job-queues`,
      v1UpdateJobQueueRequest,options
    );
  }

/**
 * @summary Get a list of jobs in queue.
 */
export const getJobsV2 = <TData = AxiosResponse<V1GetJobsV2Response>>(
    params?: GetJobsV2Params, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/job-queues-v2`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get job queue stats for a resource pool.
 */
export const getJobQueueStats = <TData = AxiosResponse<V1GetJobQueueStatsResponse>>(
    params?: GetJobQueueStatsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/job-queues/stats`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get a list of all Kubernetes cluster names.
 */
export const getKubernetesResourceManagers = <TData = AxiosResponse<V1GetKubernetesResourceManagersResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/k8s-resource-managers`,options
    );
  }

/**
 * @summary Get master information.
 */
export const getMaster = <TData = AxiosResponse<V1GetMasterResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/master`,options
    );
  }

/**
 * @summary Get the currently configured cluster-wide message.
 */
export const getClusterMessage = <TData = AxiosResponse<V1GetClusterMessageResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/master/cluster_message`,options
    );
  }

/**
 * @summary Clear the cluster-wide message shown to all users.
 */
export const deleteClusterMessage = <TData = AxiosResponse<V1DeleteClusterMessageResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/master/cluster_message`,options
    );
  }

/**
 * @summary Set the cluster-wide message shown to users. Only one can be set at at
time, so any existing message will be disabled.
 */
export const setClusterMessage = <TData = AxiosResponse<V1SetClusterMessageResponse>>(
    v1SetClusterMessageRequest: V1SetClusterMessageRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/master/cluster_message`,
      v1SetClusterMessageRequest,options
    );
  }

/**
 * @summary Get master config.
 */
export const getMasterConfig = <TData = AxiosResponse<V1GetMasterConfigResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/master/config`,options
    );
  }

/**
 * @summary Patch master config.
 */
export const patchMasterConfig = <TData = AxiosResponse<V1PatchMasterConfigResponse>>(
    v1PatchMasterConfigRequest: V1PatchMasterConfigRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/master/config`,
      v1PatchMasterConfigRequest,options
    );
  }

/**
 * @summary Stream master logs.
 */
export const masterLogs = <TData = AxiosResponse<MasterLogs200>>(
    params?: MasterLogsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/master/logs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get telemetry information.
 */
export const getTelemetry = <TData = AxiosResponse<V1GetTelemetryResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/master/telemetry`,options
    );
  }

/**
 * @summary Get the current user.
 */
export const getMe = <TData = AxiosResponse<V1GetMeResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/me`,options
    );
  }

/**
 * @summary Get a list of unique model labels (sorted by popularity).
 */
export const getModelLabels = <TData = AxiosResponse<V1GetModelLabelsResponse>>(
    params?: GetModelLabelsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/model/labels`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get a list of models.
 */
export const getModels = <TData = AxiosResponse<V1GetModelsResponse>>(
    params?: GetModelsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/models`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Create a model in the registry.
 */
export const postModel = <TData = AxiosResponse<V1PostModelResponse>>(
    v1PostModelRequest: V1PostModelRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/models`,
      v1PostModelRequest,options
    );
  }

/**
 * @summary Get the requested model.
 */
export const getModel = <TData = AxiosResponse<V1GetModelResponse>>(
    modelName: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/models/${modelName}`,options
    );
  }

/**
 * @summary Delete a model
 */
export const deleteModel = <TData = AxiosResponse<V1DeleteModelResponse>>(
    modelName: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/models/${modelName}`,options
    );
  }

/**
 * @summary Patch a model's fields.
 */
export const patchModel = <TData = AxiosResponse<V1PatchModelResponse>>(
    modelName: string,
    v1PatchModel: V1PatchModel, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/models/${modelName}`,
      v1PatchModel,options
    );
  }

/**
 * @summary Archive a model
 */
export const archiveModel = <TData = AxiosResponse<V1ArchiveModelResponse>>(
    modelName: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/models/${modelName}/archive`,undefined,options
    );
  }

/**
 * @summary Move a model into a workspace
 */
export const moveModel = <TData = AxiosResponse<V1MoveModelResponse>>(
    modelName: string,
    v1MoveModelRequest: V1MoveModelRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/models/${modelName}/move`,
      v1MoveModelRequest,options
    );
  }

/**
 * @summary Unarchive a model
 */
export const unarchiveModel = <TData = AxiosResponse<V1UnarchiveModelResponse>>(
    modelName: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/models/${modelName}/unarchive`,undefined,options
    );
  }

/**
 * @summary Get a list of versions for the requested model.
 */
export const getModelVersions = <TData = AxiosResponse<V1GetModelVersionsResponse>>(
    modelName: string,
    params?: GetModelVersionsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/models/${modelName}/versions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Create a model version.
 */
export const postModelVersion = <TData = AxiosResponse<V1PostModelVersionResponse>>(
    modelName: string,
    v1PostModelVersionRequest: V1PostModelVersionRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/models/${modelName}/versions`,
      v1PostModelVersionRequest,options
    );
  }

/**
 * @summary Get the requested model version.
 */
export const getModelVersion = <TData = AxiosResponse<V1GetModelVersionResponse>>(
    modelName: string,
    modelVersionNum: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/models/${modelName}/versions/${modelVersionNum}`,options
    );
  }

/**
 * @summary Delete a model version
 */
export const deleteModelVersion = <TData = AxiosResponse<V1DeleteModelVersionResponse>>(
    modelName: string,
    modelVersionNum: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/models/${modelName}/versions/${modelVersionNum}`,options
    );
  }

/**
 * @summary Patch a model version's fields.
 */
export const patchModelVersion = <TData = AxiosResponse<V1PatchModelVersionResponse>>(
    modelName: string,
    modelVersionNum: number,
    v1PatchModelVersion: V1PatchModelVersion, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/models/${modelName}/versions/${modelVersionNum}`,
      v1PatchModelVersion,options
    );
  }

/**
 * @summary Gets the metrics for all trials associated with this model version
 */
export const getTrialMetricsByModelVersion = <TData = AxiosResponse<V1GetTrialMetricsByModelVersionResponse>>(
    modelName: string,
    modelVersionNum: number,
    params?: GetTrialMetricsByModelVersionParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/models/${modelName}/versions/${modelVersionNum}/metrics`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Binds the given workpaces to new auto-created namespaces.
 */
export const bulkAutoCreateWorkspaceNamespaceBindings = <TData = AxiosResponse<V1BulkAutoCreateWorkspaceNamespaceBindingsResponse>>(
    v1BulkAutoCreateWorkspaceNamespaceBindingsRequest: V1BulkAutoCreateWorkspaceNamespaceBindingsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/namespace-bindings/bulk-auto-create`,
      v1BulkAutoCreateWorkspaceNamespaceBindingsRequest,options
    );
  }

/**
 * @summary Gets the ids of all workspaces that are bound to the default namespace for
atleast one cluster.
 */
export const getWorkspacesWithDefaultNamespaceBindings = <TData = AxiosResponse<V1GetWorkspacesWithDefaultNamespaceBindingsResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/namespace-bindings/workspace-ids-with-default-bindings`,options
    );
  }

/**
 * @summary Get a list of notebooks.
 */
export const getNotebooks = <TData = AxiosResponse<V1GetNotebooksResponse>>(
    params?: GetNotebooksParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/notebooks`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Launch a notebook.
 */
export const launchNotebook = <TData = AxiosResponse<V1LaunchNotebookResponse>>(
    v1LaunchNotebookRequest: V1LaunchNotebookRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/notebooks`,
      v1LaunchNotebookRequest,options
    );
  }

/**
 * @summary Get the requested notebook.
 */
export const getNotebook = <TData = AxiosResponse<V1GetNotebookResponse>>(
    notebookId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/notebooks/${notebookId}`,options
    );
  }

/**
 * @summary Kill the requested notebook.
 */
export const killNotebook = <TData = AxiosResponse<V1KillNotebookResponse>>(
    notebookId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/notebooks/${notebookId}/kill`,undefined,options
    );
  }

/**
 * @summary Send notebook idle data to master
 */
export const idleNotebook = <TData = AxiosResponse<V1IdleNotebookResponse>>(
    notebookId: string,
    v1IdleNotebookRequest: V1IdleNotebookRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/notebooks/${notebookId}/report_idle`,
      v1IdleNotebookRequest,options
    );
  }

/**
 * @summary Set the priority of the requested notebook.
 */
export const setNotebookPriority = <TData = AxiosResponse<V1SetNotebookPriorityResponse>>(
    notebookId: string,
    v1SetNotebookPriorityRequest: V1SetNotebookPriorityRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/notebooks/${notebookId}/set_priority`,
      v1SetNotebookPriorityRequest,options
    );
  }

/**
 * @summary List all permissions for the logged in user in all scopes.
 */
export const getPermissionsSummary = <TData = AxiosResponse<V1GetPermissionsSummaryResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/permissions/summary`,options
    );
  }

/**
 * @summary Preview hyperparameter search.
 */
export const previewHPSearch = <TData = AxiosResponse<V1PreviewHPSearchResponse>>(
    v1PreviewHPSearchRequest: V1PreviewHPSearchRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/preview-hp-search`,
      v1PreviewHPSearchRequest,options
    );
  }

/**
 * @summary Get the request project by key.
 */
export const getProjectByKey = <TData = AxiosResponse<V1GetProjectByKeyResponse>>(
    key: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/projects/key/${key}`,options
    );
  }

/**
 * @summary Get the requested project.
 */
export const getProject = <TData = AxiosResponse<V1GetProjectResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/projects/${id}`,options
    );
  }

/**
 * @summary Delete a project.
 */
export const deleteProject = <TData = AxiosResponse<V1DeleteProjectResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/projects/${id}`,options
    );
  }

/**
 * @summary Update a project.
 */
export const patchProject = <TData = AxiosResponse<V1PatchProjectResponse>>(
    id: number,
    v1PatchProject: V1PatchProject, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/projects/${id}`,
      v1PatchProject,options
    );
  }

/**
 * @summary Archive a project.
 */
export const archiveProject = <TData = AxiosResponse<V1ArchiveProjectResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/projects/${id}/archive`,undefined,options
    );
  }

/**
 * @summary Get a list of columns for experiment list table.
 */
export const getProjectColumns = <TData = AxiosResponse<V1GetProjectColumnsResponse>>(
    id: number,
    params?: GetProjectColumnsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/projects/${id}/columns`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get metrics range for a project.
 */
export const getProjectNumericMetricsRange = <TData = AxiosResponse<V1GetProjectNumericMetricsRangeResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/projects/${id}/experiments/metric-ranges`,options
    );
  }

/**
 * @summary Unarchive a project.
 */
export const unarchiveProject = <TData = AxiosResponse<V1UnarchiveProjectResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/projects/${id}/unarchive`,undefined,options
    );
  }

/**
 * @summary Activate multiple experiments.
 */
export const activateExperiments = <TData = AxiosResponse<V1ActivateExperimentsResponse>>(
    projectId: number,
    v1ActivateExperimentsRequest: V1ActivateExperimentsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/projects/${projectId}/experiments/activate`,
      v1ActivateExperimentsRequest,options
    );
  }

/**
 * @summary Archive multiple experiments.
 */
export const archiveExperiments = <TData = AxiosResponse<V1ArchiveExperimentsResponse>>(
    projectId: number,
    v1ArchiveExperimentsRequest: V1ArchiveExperimentsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/projects/${projectId}/experiments/archive`,
      v1ArchiveExperimentsRequest,options
    );
  }

/**
 * @summary Cancel multiple experiments.
 */
export const cancelExperiments = <TData = AxiosResponse<V1CancelExperimentsResponse>>(
    projectId: number,
    v1CancelExperimentsRequest: V1CancelExperimentsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/projects/${projectId}/experiments/cancel`,
      v1CancelExperimentsRequest,options
    );
  }

/**
 * @summary Delete multiple experiments.
 */
export const deleteExperiments = <TData = AxiosResponse<V1DeleteExperimentsResponse>>(
    projectId: number,
    v1DeleteExperimentsRequest: V1DeleteExperimentsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/projects/${projectId}/experiments/delete`,{data:
      v1DeleteExperimentsRequest, ...options}
    );
  }

/**
 * @summary Kill multiple experiments.
 */
export const killExperiments = <TData = AxiosResponse<V1KillExperimentsResponse>>(
    projectId: number,
    v1KillExperimentsRequest: V1KillExperimentsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/projects/${projectId}/experiments/kill`,
      v1KillExperimentsRequest,options
    );
  }

/**
 * @summary Move multiple experiments into a project.
 */
export const moveExperiments = <TData = AxiosResponse<V1MoveExperimentsResponse>>(
    projectId: number,
    v1MoveExperimentsRequest: V1MoveExperimentsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/projects/${projectId}/experiments/move`,
      v1MoveExperimentsRequest,options
    );
  }

/**
 * @summary Pause multiple experiments.
 */
export const pauseExperiments = <TData = AxiosResponse<V1PauseExperimentsResponse>>(
    projectId: number,
    v1PauseExperimentsRequest: V1PauseExperimentsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/projects/${projectId}/experiments/pause`,
      v1PauseExperimentsRequest,options
    );
  }

/**
 * @summary Retain logs for an experiment.
 */
export const putExperimentsRetainLogs = <TData = AxiosResponse<V1PutExperimentsRetainLogsResponse>>(
    projectId: number,
    v1PutExperimentsRetainLogsRequest: V1PutExperimentsRetainLogsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/projects/${projectId}/experiments/retain_logs`,
      v1PutExperimentsRetainLogsRequest,options
    );
  }

/**
 * @summary Unarchive multiple experiments.
 */
export const unarchiveExperiments = <TData = AxiosResponse<V1UnarchiveExperimentsResponse>>(
    projectId: number,
    v1UnarchiveExperimentsRequest: V1UnarchiveExperimentsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/projects/${projectId}/experiments/unarchive`,
      v1UnarchiveExperimentsRequest,options
    );
  }

/**
 * @summary Retrieve run metadata values for a given string typed key within
a given project.
 */
export const getMetadataValues = <TData = AxiosResponse<V1GetMetadataValuesResponse>>(
    projectId: number,
    key: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/projects/${projectId}/metadata/${key}`,options
    );
  }

/**
 * @summary Move a project into a workspace.
 */
export const moveProject = <TData = AxiosResponse<V1MoveProjectResponse>>(
    projectId: number,
    v1MoveProjectRequest: V1MoveProjectRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/projects/${projectId}/move`,
      v1MoveProjectRequest,options
    );
  }

/**
 * @summary Add a note to a project.
 */
export const addProjectNote = <TData = AxiosResponse<V1AddProjectNoteResponse>>(
    projectId: number,
    v1Note: V1Note, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/projects/${projectId}/notes`,
      v1Note,options
    );
  }

/**
 * @summary Set project notes.
 */
export const putProjectNotes = <TData = AxiosResponse<V1PutProjectNotesResponse>>(
    projectId: number,
    v1PutProjectNotesRequest: V1PutProjectNotesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/projects/${projectId}/notes`,
      v1PutProjectNotesRequest,options
    );
  }

/**
 * @summary Get a list of all resource pools from the cluster.
 */
export const getResourcePools = <TData = AxiosResponse<V1GetResourcePoolsResponse>>(
    params?: GetResourcePoolsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/resource-pools`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary List all workspaces bound to a specific resource pool
 */
export const listWorkspacesBoundToRP = <TData = AxiosResponse<V1ListWorkspacesBoundToRPResponse>>(
    resourcePoolName: string,
    params?: ListWorkspacesBoundToRPParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/resource-pools/${resourcePoolName}/workspace-bindings`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Unbind resource pool to workspace
 */
export const unbindRPFromWorkspace = <TData = AxiosResponse<V1UnbindRPFromWorkspaceResponse>>(
    resourcePoolName: string,
    v1UnbindRPFromWorkspaceRequest: V1UnbindRPFromWorkspaceRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/resource-pools/${resourcePoolName}/workspace-bindings`,{data:
      v1UnbindRPFromWorkspaceRequest, ...options}
    );
  }

/**
 * @summary Bind resource pool to workspace
 */
export const bindRPToWorkspace = <TData = AxiosResponse<V1BindRPToWorkspaceResponse>>(
    resourcePoolName: string,
    v1BindRPToWorkspaceRequest: V1BindRPToWorkspaceRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/resource-pools/${resourcePoolName}/workspace-bindings`,
      v1BindRPToWorkspaceRequest,options
    );
  }

/**
 * @summary Overwrite resource pool - workspace bindings
 */
export const overwriteRPWorkspaceBindings = <TData = AxiosResponse<V1OverwriteRPWorkspaceBindingsResponse>>(
    resourcePoolName: string,
    v1OverwriteRPWorkspaceBindingsRequest: V1OverwriteRPWorkspaceBindingsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/resource-pools/${resourcePoolName}/workspace-bindings`,
      v1OverwriteRPWorkspaceBindingsRequest,options
    );
  }

/**
 * @summary Get an aggregated view of resource allocation during the given time period.
 */
export const resourceAllocationAggregated = <TData = AxiosResponse<V1ResourceAllocationAggregatedResponse>>(
    params: ResourceAllocationAggregatedParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/resources/allocation/aggregated`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get a detailed view of resource allocation during the given time period.
 */
export const resourceAllocationRaw = <TData = AxiosResponse<V1ResourceAllocationRawResponse>>(
    params: ResourceAllocationRawParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/resources/allocation/raw`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary AssignRoles adds a set of role assignments to the system.
 */
export const assignRoles = <TData = AxiosResponse<V1AssignRolesResponse>>(
    v1AssignRolesRequest: V1AssignRolesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/roles/add-assignments`,
      v1AssignRolesRequest,options
    );
  }

/**
 * @summary RemoveAssignments removes a set of role assignments from the system.
 */
export const removeAssignments = <TData = AxiosResponse<V1RemoveAssignmentsResponse>>(
    v1RemoveAssignmentsRequest: V1RemoveAssignmentsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/roles/remove-assignments`,
      v1RemoveAssignmentsRequest,options
    );
  }

/**
 * @summary ListRoles returns roles and groups/users granted that role.
 */
export const listRoles = <TData = AxiosResponse<V1ListRolesResponse>>(
    v1ListRolesRequest: V1ListRolesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/roles/search`,
      v1ListRolesRequest,options
    );
  }

/**
 * @summary Search for roles assignable to a given scope.
 */
export const searchRolesAssignableToScope = <TData = AxiosResponse<V1SearchRolesAssignableToScopeResponse>>(
    v1SearchRolesAssignableToScopeRequest: V1SearchRolesAssignableToScopeRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/roles/search/by-assignability`,
      v1SearchRolesAssignableToScopeRequest,options
    );
  }

/**
 * @summary Get the roles which are assigned to a group.
 */
export const getRolesAssignedToGroup = <TData = AxiosResponse<V1GetRolesAssignedToGroupResponse>>(
    groupId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/roles/search/by-group/${groupId}`,options
    );
  }

/**
 * @summary Get a set of roles with the corresponding IDs.
 */
export const getRolesByID = <TData = AxiosResponse<V1GetRolesByIDResponse>>(
    v1GetRolesByIDRequest: V1GetRolesByIDRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/roles/search/by-ids`,
      v1GetRolesByIDRequest,options
    );
  }

/**
 * @summary Get the roles which are assigned to a user.
 */
export const getRolesAssignedToUser = <TData = AxiosResponse<V1GetRolesAssignedToUserResponse>>(
    userId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/roles/search/by-user/${userId}`,options
    );
  }

/**
 * @summary Get groups and users assigned to a given workspace with what roles are
assigned.
 */
export const getGroupsAndUsersAssignedToWorkspace = <TData = AxiosResponse<V1GetGroupsAndUsersAssignedToWorkspaceResponse>>(
    workspaceId: number,
    params?: GetGroupsAndUsersAssignedToWorkspaceParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/roles/workspace/${workspaceId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get a list of runs.
 */
export const searchRuns = <TData = AxiosResponse<V1SearchRunsResponse>>(
    v1SearchRunsRequest: V1SearchRunsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/runs`,
      v1SearchRunsRequest,options
    );
  }

/**
 * @summary Archive runs.
 */
export const archiveRuns = <TData = AxiosResponse<V1ArchiveRunsResponse>>(
    v1ArchiveRunsRequest: V1ArchiveRunsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/runs/archive`,
      v1ArchiveRunsRequest,options
    );
  }

/**
 * @summary Delete runs.
 */
export const deleteRuns = <TData = AxiosResponse<V1DeleteRunsResponse>>(
    v1DeleteRunsRequest: V1DeleteRunsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/runs/delete`,
      v1DeleteRunsRequest,options
    );
  }

/**
 * @summary Kill runs.
 */
export const killRuns = <TData = AxiosResponse<V1KillRunsResponse>>(
    v1KillRunsRequest: V1KillRunsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/runs/kill`,
      v1KillRunsRequest,options
    );
  }

/**
 * @summary Move runs.
 */
export const moveRuns = <TData = AxiosResponse<V1MoveRunsResponse>>(
    v1MoveRunsRequest: V1MoveRunsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/runs/move`,
      v1MoveRunsRequest,options
    );
  }

/**
 * @summary Pause experiment associated with provided runs.
 */
export const pauseRuns = <TData = AxiosResponse<V1PauseRunsResponse>>(
    v1PauseRunsRequest: V1PauseRunsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/runs/pause`,
      v1PauseRunsRequest,options
    );
  }

/**
 * @summary Unpause experiment associated with provided runs.
 */
export const resumeRuns = <TData = AxiosResponse<V1ResumeRunsResponse>>(
    v1ResumeRunsRequest: V1ResumeRunsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/runs/resume`,
      v1ResumeRunsRequest,options
    );
  }

/**
 * @summary Start syncing and prepare to be able to report to a run.
This should be called once per task that will report to the run.
 */
export const runPrepareForReporting = <TData = AxiosResponse<V1RunPrepareForReportingResponse>>(
    v1RunPrepareForReportingRequest: V1RunPrepareForReportingRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/runs/start`,
      v1RunPrepareForReportingRequest,options
    );
  }

/**
 * @summary Unarchive runs.
 */
export const unarchiveRuns = <TData = AxiosResponse<V1UnarchiveRunsResponse>>(
    v1UnarchiveRunsRequest: V1UnarchiveRunsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/runs/unarchive`,
      v1UnarchiveRunsRequest,options
    );
  }

/**
 * @summary Get run metadata.
 */
export const getRunMetadata = <TData = AxiosResponse<V1GetRunMetadataResponse>>(
    runId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/runs/${runId}/metadata`,options
    );
  }

/**
 * @summary Update run metadata.
 */
export const postRunMetadata = <TData = AxiosResponse<V1PostRunMetadataResponse>>(
    runId: number,
    v1PostRunMetadataRequest: V1PostRunMetadataRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/runs/${runId}/metadata`,
      v1PostRunMetadataRequest,options
    );
  }

/**
 * @summary Archive searches.
 */
export const archiveSearches = <TData = AxiosResponse<V1ArchiveSearchesResponse>>(
    v1ArchiveSearchesRequest: V1ArchiveSearchesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/searches/archive`,
      v1ArchiveSearchesRequest,options
    );
  }

/**
 * @summary Cancel searches.
 */
export const cancelSearches = <TData = AxiosResponse<V1CancelSearchesResponse>>(
    v1CancelSearchesRequest: V1CancelSearchesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/searches/cancel`,
      v1CancelSearchesRequest,options
    );
  }

/**
 * @summary Delete searches.
 */
export const deleteSearches = <TData = AxiosResponse<V1DeleteSearchesResponse>>(
    v1DeleteSearchesRequest: V1DeleteSearchesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/searches/delete`,
      v1DeleteSearchesRequest,options
    );
  }

/**
 * @summary Kill searches.
 */
export const killSearches = <TData = AxiosResponse<V1KillSearchesResponse>>(
    v1KillSearchesRequest: V1KillSearchesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/searches/kill`,
      v1KillSearchesRequest,options
    );
  }

/**
 * @summary Move searches.
 */
export const moveSearches = <TData = AxiosResponse<V1MoveSearchesResponse>>(
    v1MoveSearchesRequest: V1MoveSearchesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/searches/move`,
      v1MoveSearchesRequest,options
    );
  }

/**
 * @summary Pause experiment associated with provided searches.
 */
export const pauseSearches = <TData = AxiosResponse<V1PauseSearchesResponse>>(
    v1PauseSearchesRequest: V1PauseSearchesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/searches/pause`,
      v1PauseSearchesRequest,options
    );
  }

/**
 * @summary Unpause experiment associated with provided searches.
 */
export const resumeSearches = <TData = AxiosResponse<V1ResumeSearchesResponse>>(
    v1ResumeSearchesRequest: V1ResumeSearchesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/searches/resume`,
      v1ResumeSearchesRequest,options
    );
  }

/**
 * @summary Launch a tensorboard for one or more searches using bulk search filters.
 */
export const launchTensorboardSearches = <TData = AxiosResponse<V1LaunchTensorboardSearchesResponse>>(
    v1LaunchTensorboardSearchesRequest: V1LaunchTensorboardSearchesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/searches/tensorboards`,
      v1LaunchTensorboardSearchesRequest,options
    );
  }

/**
 * @summary Unarchive searches.
 */
export const unarchiveSearches = <TData = AxiosResponse<V1UnarchiveSearchesResponse>>(
    v1UnarchiveSearchesRequest: V1UnarchiveSearchesRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/searches/unarchive`,
      v1UnarchiveSearchesRequest,options
    );
  }

/**
 * @summary Get a list of shells.
 */
export const getShells = <TData = AxiosResponse<V1GetShellsResponse>>(
    params?: GetShellsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/shells`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Launch a shell.
 */
export const launchShell = <TData = AxiosResponse<V1LaunchShellResponse>>(
    v1LaunchShellRequest: V1LaunchShellRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/shells`,
      v1LaunchShellRequest,options
    );
  }

/**
 * @summary Get the requested shell.
 */
export const getShell = <TData = AxiosResponse<V1GetShellResponse>>(
    shellId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/shells/${shellId}`,options
    );
  }

/**
 * @summary Kill the requested shell.
 */
export const killShell = <TData = AxiosResponse<V1KillShellResponse>>(
    shellId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/shells/${shellId}/kill`,undefined,options
    );
  }

/**
 * @summary Set the priority of the requested shell.
 */
export const setShellPriority = <TData = AxiosResponse<V1SetShellPriorityResponse>>(
    shellId: string,
    v1SetShellPriorityRequest: V1SetShellPriorityRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/shells/${shellId}/set_priority`,
      v1SetShellPriorityRequest,options
    );
  }

/**
 * @summary Persist the given task logs.
 */
export const postTaskLogs = <TData = AxiosResponse<V1PostTaskLogsResponse>>(
    v1PostTaskLogsRequest: V1PostTaskLogsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/task/logs`,
      v1PostTaskLogsRequest,options
    );
  }

/**
 * @summary Get all tasks.
 */
export const getTasks = <TData = AxiosResponse<V1GetTasksResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/tasks`,options
    );
  }

/**
 * @summary Get a count of active tasks.
 */
export const getActiveTasksCount = <TData = AxiosResponse<V1GetActiveTasksCountResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/tasks/count`,options
    );
  }

/**
 * @summary Check the status of a requested task.
 */
export const getTask = <TData = AxiosResponse<V1GetTaskResponse>>(
    taskId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/tasks/${taskId}`,options
    );
  }

/**
 * @summary GetTaskAcceleratorData gets the accelerator data for each allocation
associated with a task.
 */
export const getTaskAcceleratorData = <TData = AxiosResponse<V1GetTaskAcceleratorDataResponse>>(
    taskId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/tasks/${taskId}/acceleratorData`,options
    );
  }

/**
 * @summary Get task config
 */
export const getGenericTaskConfig = <TData = AxiosResponse<V1GetGenericTaskConfigResponse>>(
    taskId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/tasks/${taskId}/config`,options
    );
  }

/**
 * @summary Get the model definition of a task.
 */
export const getTaskContextDirectory = <TData = AxiosResponse<V1GetTaskContextDirectoryResponse>>(
    taskId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/tasks/${taskId}/context_directory`,options
    );
  }

/**
 * @summary Kill generic task
 */
export const killGenericTask = <TData = AxiosResponse<V1KillGenericTaskResponse>>(
    taskId: string,
    v1KillGenericTaskRequest: V1KillGenericTaskRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/tasks/${taskId}/kill`,
      v1KillGenericTaskRequest,options
    );
  }

/**
 * @summary Stream task logs.
 */
export const taskLogs = <TData = AxiosResponse<TaskLogs200>>(
    taskId: string,
    params?: TaskLogsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/tasks/${taskId}/logs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Stream task log fields.
 */
export const taskLogsFields = <TData = AxiosResponse<TaskLogsFields200>>(
    taskId: string,
    params?: TaskLogsFieldsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/tasks/${taskId}/logs/fields`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Pause generic task
 */
export const pauseGenericTask = <TData = AxiosResponse<V1PauseGenericTaskResponse>>(
    taskId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/tasks/${taskId}/pause`,undefined,options
    );
  }

/**
 * @summary Unpause generic task
 */
export const unpauseGenericTask = <TData = AxiosResponse<V1UnpauseGenericTaskResponse>>(
    taskId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/tasks/${taskId}/unpause`,undefined,options
    );
  }

/**
 * @summary Patch template name.
 */
export const patchTemplateName = <TData = AxiosResponse<V1PatchTemplateNameResponse>>(
    v1PatchTemplateNameRequest: V1PatchTemplateNameRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/template/rename`,
      v1PatchTemplateNameRequest,options
    );
  }

/**
 * @summary Get a list of templates.
 */
export const getTemplates = <TData = AxiosResponse<V1GetTemplatesResponse>>(
    params?: GetTemplatesParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/templates`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Post a new template.
 */
export const postTemplate = <TData = AxiosResponse<V1PostTemplateResponse>>(
    v1TemplateBody: V1TemplateBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/templates/template.name}`,
      v1TemplateBody,options
    );
  }

/**
 * @summary Update or create (upsert) the requested template.
 */
export const putTemplate = <TData = AxiosResponse<V1PutTemplateResponse>>(
    v1TemplateBody: V1TemplateBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/templates/template.name}`,
      v1TemplateBody,options
    );
  }

/**
 * @summary Get the requested template.
 */
export const getTemplate = <TData = AxiosResponse<V1GetTemplateResponse>>(
    templateName: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/templates/${templateName}`,options
    );
  }

/**
 * @summary Delete a template.
 */
export const deleteTemplate = <TData = AxiosResponse<V1DeleteTemplateResponse>>(
    templateName: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/templates/${templateName}`,options
    );
  }

/**
 * @summary Patch template config.
 */
export const patchTemplateConfig = <TData = AxiosResponse<V1PatchTemplateConfigResponse>>(
    templateName: string,
    patchTemplateConfigBody: PatchTemplateConfigBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/templates/${templateName}`,
      patchTemplateConfigBody,options
    );
  }

/**
 * @summary Get a list of tensorboards.
 */
export const getTensorboards = <TData = AxiosResponse<V1GetTensorboardsResponse>>(
    params?: GetTensorboardsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/tensorboards`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Launch a tensorboard.
 */
export const launchTensorboard = <TData = AxiosResponse<V1LaunchTensorboardResponse>>(
    v1LaunchTensorboardRequest: V1LaunchTensorboardRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/tensorboards`,
      v1LaunchTensorboardRequest,options
    );
  }

/**
 * @summary Get the requested tensorboard.
 */
export const getTensorboard = <TData = AxiosResponse<V1GetTensorboardResponse>>(
    tensorboardId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/tensorboards/${tensorboardId}`,options
    );
  }

/**
 * @summary Kill the requested tensorboard.
 */
export const killTensorboard = <TData = AxiosResponse<V1KillTensorboardResponse>>(
    tensorboardId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/tensorboards/${tensorboardId}/kill`,undefined,options
    );
  }

/**
 * @summary Set the priority of the requested TensorBoard.
 */
export const setTensorboardPriority = <TData = AxiosResponse<V1SetTensorboardPriorityResponse>>(
    tensorboardId: string,
    v1SetTensorboardPriorityRequest: V1SetTensorboardPriorityRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/tensorboards/${tensorboardId}/set_priority`,
      v1SetTensorboardPriorityRequest,options
    );
  }

/**
 * @summary Get a list of all access token records.
 */
export const getAccessTokens = <TData = AxiosResponse<V1GetAccessTokensResponse>>(
    params?: GetAccessTokensParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/tokens`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Create and get a user's access token
 */
export const postAccessToken = <TData = AxiosResponse<V1PostAccessTokenResponse>>(
    v1PostAccessTokenRequest: V1PostAccessTokenRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/tokens`,
      v1PostAccessTokenRequest,options
    );
  }

/**
 * @summary Patch an access token's mutable fields.
 */
export const patchAccessToken = <TData = AxiosResponse<V1PatchAccessTokenResponse>>(
    tokenId: number,
    v1PatchAccessTokenRequest: V1PatchAccessTokenRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/tokens/${tokenId}`,
      v1PatchAccessTokenRequest,options
    );
  }

/**
 * @summary Reports a TrialSourceInfo entry for tracking inference or fine-tuning runs
 */
export const reportTrialSourceInfo = <TData = AxiosResponse<V1ReportTrialSourceInfoResponse>>(
    v1ReportTrialSourceInfoRequest: V1ReportTrialSourceInfoRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/trial-source-info`,
      v1ReportTrialSourceInfoRequest,options
    );
  }

/**
 * @summary Create unmanaged trial.
 */
export const createTrial = <TData = AxiosResponse<V1CreateTrialResponse>>(
    v1CreateTrialRequest: V1CreateTrialRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/trials`,
      v1CreateTrialRequest,options
    );
  }

/**
 * @summary Put a trial.
 */
export const putTrial = <TData = AxiosResponse<V1PutTrialResponse>>(
    v1PutTrialRequest: V1PutTrialRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/trials`,
      v1PutTrialRequest,options
    );
  }

/**
 * @summary Get a single trial by external id.
 */
export const getTrialByExternalID = <TData = AxiosResponse<V1GetTrialByExternalIDResponse>>(
    externalExperimentId: string,
    externalTrialId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/trials/by-external-id/${externalExperimentId}/${externalTrialId}`,options
    );
  }

/**
 * @summary Stream one or more trial's training metrics.
 */
export const getTrainingMetrics = <TData = AxiosResponse<GetTrainingMetrics200>>(
    params?: GetTrainingMetricsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/trials/metrics/training_metrics`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Stream one or more trial's metrics.
 */
export const getMetrics = <TData = AxiosResponse<GetMetrics200>>(
    params: GetMetricsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/trials/metrics/trial_metrics`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Stream one or more trial's validation metrics.
 */
export const getValidationMetrics = <TData = AxiosResponse<GetValidationMetrics200>>(
    params?: GetValidationMetricsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/trials/metrics/validation_metrics`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Persist the given TrialProfilerMetricsBatch. The trial ID is in the labels.
 */
export const postTrialProfilerMetricsBatch = <TData = AxiosResponse<V1PostTrialProfilerMetricsBatchResponse>>(
    v1PostTrialProfilerMetricsBatchRequest: V1PostTrialProfilerMetricsBatchRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/trials/profiler/metrics`,
      v1PostTrialProfilerMetricsBatchRequest,options
    );
  }

/**
 * @summary Return a downsampled time series of metrics from multiple trials to compare
them side-by-side.
 */
export const compareTrials = <TData = AxiosResponse<V1CompareTrialsResponse>>(
    params?: CompareTrialsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/trials/time-series`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get a list of checkpoints for a trial.
 */
export const getTrialCheckpoints = <TData = AxiosResponse<V1GetTrialCheckpointsResponse>>(
    id: number,
    params?: GetTrialCheckpointsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/trials/${id}/checkpoints`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Kill a trial.
 */
export const killTrial = <TData = AxiosResponse<V1KillTrialResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/trials/${id}/kill`,undefined,options
    );
  }

/**
 * @summary Get the list of trials for an experiment.
 */
export const getTrialRemainingLogRetentionDays = <TData = AxiosResponse<V1GetTrialRemainingLogRetentionDaysResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/trials/${id}/remaining_log_retention_days`,options
    );
  }

/**
 * @summary Stream trial profiler metrics.
 */
export const getTrialProfilerMetrics = <TData = AxiosResponse<GetTrialProfilerMetrics200>>(
    params?: GetTrialProfilerMetricsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/trials/labels.trialId}/profiler/metrics`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Record metrics for specified trial.
 */
export const reportTrialMetrics = <TData = AxiosResponse<V1ReportTrialMetricsResponse>>(
    v1ReportTrialMetricsRequest: V1ReportTrialMetricsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/trials/metrics.trialId}/metrics`,
      v1ReportTrialMetricsRequest,options
    );
  }

/**
 * @summary Record training metrics for specified training.
 */
export const reportTrialTrainingMetrics = <TData = AxiosResponse<V1ReportTrialTrainingMetricsResponse>>(
    v1TrialMetricsBody: V1TrialMetricsBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/trials/trainingMetrics.trialId}/training_metrics`,
      v1TrialMetricsBody,options
    );
  }

/**
 * @summary Get a single trial.
 */
export const getTrial = <TData = AxiosResponse<V1GetTrialResponse>>(
    trialId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/trials/${trialId}`,options
    );
  }

/**
 * @summary Patch (an unmanaged) trial.
 */
export const patchTrial = <TData = AxiosResponse<V1PatchTrialResponse>>(
    trialId: number,
    v1PatchTrialRequest: V1PatchTrialRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/trials/${trialId}`,
      v1PatchTrialRequest,options
    );
  }

/**
 * @summary Reports to the searcher that the trial has completed the current
requested amount of training with the given searcher validation
metric.
 */
export const reportTrialSearcherEarlyExit = <TData = AxiosResponse<V1ReportTrialSearcherEarlyExitResponse>>(
    trialId: number,
    v1TrialEarlyExit: V1TrialEarlyExit, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/trials/${trialId}/early_exit`,
      v1TrialEarlyExit,options
    );
  }

/**
 * @summary Stream trial logs.
 */
export const trialLogs = <TData = AxiosResponse<TrialLogs200>>(
    trialId: number,
    params?: TrialLogsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/trials/${trialId}/logs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Stream trial log fields.
 */
export const trialLogsFields = <TData = AxiosResponse<TrialLogsFields200>>(
    trialId: number,
    params?: TrialLogsFieldsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/trials/${trialId}/logs/fields`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Stream the available series in a trial's profiler metrics.
 */
export const getTrialProfilerAvailableSeries = <TData = AxiosResponse<GetTrialProfilerAvailableSeries200>>(
    trialId: number,
    params?: GetTrialProfilerAvailableSeriesParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/trials/${trialId}/profiler/available_series`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary For bookkeeping, updates the progress towards to current requested searcher
training length.
 */
export const reportTrialProgress = <TData = AxiosResponse<V1ReportTrialProgressResponse>>(
    trialId: number,
    v1ReportTrialProgressRequest: V1ReportTrialProgressRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/trials/${trialId}/progress`,
      v1ReportTrialProgressRequest,options
    );
  }

/**
 * @summary Retain logs for a Trial.
 */
export const putTrialRetainLogs = <TData = AxiosResponse<V1PutTrialRetainLogsResponse>>(
    trialId: number,
    v1PutTrialRetainLogsRequest: V1PutTrialRetainLogsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/api/v1/trials/${trialId}/retain_logs`,
      v1PutTrialRetainLogsRequest,options
    );
  }

/**
 * @summary For bookkeeping, update trial runner metadata (currently just state).
 */
export const postTrialRunnerMetadata = <TData = AxiosResponse<V1PostTrialRunnerMetadataResponse>>(
    trialId: number,
    v1TrialRunnerMetadata: V1TrialRunnerMetadata, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/trials/${trialId}/runner/metadata`,
      v1TrialRunnerMetadata,options
    );
  }

/**
 * @summary Start (an unmanaged) trial.
 */
export const startTrial = <TData = AxiosResponse<V1StartTrialResponse>>(
    trialId: number,
    v1StartTrialRequest: V1StartTrialRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/trials/${trialId}/start`,
      v1StartTrialRequest,options
    );
  }

/**
 * @summary Get the list of workloads for a trial.
 */
export const getTrialWorkloads = <TData = AxiosResponse<V1GetTrialWorkloadsResponse>>(
    trialId: number,
    params?: GetTrialWorkloadsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/trials/${trialId}/workloads`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Record validation metrics.
 */
export const reportTrialValidationMetrics = <TData = AxiosResponse<V1ReportTrialValidationMetricsResponse>>(
    v1TrialMetricsBody: V1TrialMetricsBody, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/trials/validationMetrics.trialId}/validation_metrics`,
      v1TrialMetricsBody,options
    );
  }

/**
 * @summary Get projects by user activity
 */
export const getProjectsByUserActivity = <TData = AxiosResponse<V1GetProjectsByUserActivityResponse>>(
    params?: GetProjectsByUserActivityParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/user/projects/activity`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get a list of users.
 */
export const getUsers = <TData = AxiosResponse<V1GetUsersResponse>>(
    params?: GetUsersParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/users`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Create a new user.
 */
export const postUser = <TData = AxiosResponse<V1PostUserResponse>>(
    v1PostUserRequest: V1PostUserRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/users`,
      v1PostUserRequest,options
    );
  }

/**
 * @summary Patch multiple users' activation status.
 */
export const patchUsers = <TData = AxiosResponse<V1PatchUsersResponse>>(
    v1PatchUsersRequest: V1PatchUsersRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/users`,
      v1PatchUsersRequest,options
    );
  }

/**
 * @summary Patch a user's activity
 */
export const postUserActivity = <TData = AxiosResponse<V1PostUserActivityResponse>>(
    v1PostUserActivityRequest: V1PostUserActivityRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/users/activity`,
      v1PostUserActivityRequest,options
    );
  }

/**
 * @summary Assign multiple users to multiple groups.
 */
export const assignMultipleGroups = <TData = AxiosResponse<V1AssignMultipleGroupsResponse>>(
    v1AssignMultipleGroupsRequest: V1AssignMultipleGroupsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/users/assignments`,
      v1AssignMultipleGroupsRequest,options
    );
  }

/**
 * @summary Get a user's settings for website
 */
export const getUserSetting = <TData = AxiosResponse<V1GetUserSettingResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/users/setting`,options
    );
  }

/**
 * @summary Post a user's settings for website
 */
export const postUserSetting = <TData = AxiosResponse<V1PostUserSettingResponse>>(
    v1PostUserSettingRequest: V1PostUserSettingRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/users/setting`,
      v1PostUserSettingRequest,options
    );
  }

/**
 * @summary Reset a user's settings for website
 */
export const resetUserSetting = <TData = AxiosResponse<V1ResetUserSettingResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/users/setting/reset`,undefined,options
    );
  }

/**
 * @summary Get the requested user.
 */
export const getUser = <TData = AxiosResponse<V1GetUserResponse>>(
    userId: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/users/${userId}`,options
    );
  }

/**
 * @summary Patch a user's fields.
 */
export const patchUser = <TData = AxiosResponse<V1PatchUserResponse>>(
    userId: number,
    v1PatchUser: V1PatchUser, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/users/${userId}`,
      v1PatchUser,options
    );
  }

/**
 * @summary Set the requested user's password.
 */
export const setUserPassword = <TData = AxiosResponse<V1SetUserPasswordResponse>>(
    userId: number,
    setUserPasswordBody: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/users/${userId}/password`,
      setUserPasswordBody,options
    );
  }

/**
 * @summary Get the requested user with username.
 */
export const getUserByUsername = <TData = AxiosResponse<V1GetUserByUsernameResponse>>(
    username: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/users/${username}/by-username`,options
    );
  }

/**
 * @summary Get a list of webhooks.
 */
export const getWebhooks = <TData = AxiosResponse<V1GetWebhooksResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/webhooks`,options
    );
  }

/**
 * @summary Create a webhook.
TODO(???): Simplify req/response structs?
 */
export const postWebhook = <TData = AxiosResponse<V1PostWebhookResponse>>(
    v1Webhook: V1Webhook, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/webhooks`,
      v1Webhook,options
    );
  }

/**
 * @summary Trigger custom trigger of webhooks.
 */
export const postWebhookEventData = <TData = AxiosResponse<V1PostWebhookEventDataResponse>>(
    v1PostWebhookEventDataRequest: V1PostWebhookEventDataRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/webhooks/custom`,
      v1PostWebhookEventDataRequest,options
    );
  }

/**
 * @summary Delete a webhook.
 */
export const deleteWebhook = <TData = AxiosResponse<V1DeleteWebhookResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/webhooks/${id}`,options
    );
  }

/**
 * @summary Update a webhook.
 */
export const patchWebhook = <TData = AxiosResponse<V1PatchWebhookResponse>>(
    id: number,
    v1PatchWebhook: V1PatchWebhook, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/webhooks/${id}`,
      v1PatchWebhook,options
    );
  }

/**
 * @summary Test a webhook.
 */
export const testWebhook = <TData = AxiosResponse<V1TestWebhookResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/webhooks/${id}/test`,undefined,options
    );
  }

/**
 * @summary Get a list of workspaces.
 */
export const getWorkspaces = <TData = AxiosResponse<V1GetWorkspacesResponse>>(
    params?: GetWorkspacesParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/workspaces`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Create a workspace.
 */
export const postWorkspace = <TData = AxiosResponse<V1PostWorkspaceResponse>>(
    v1PostWorkspaceRequest: V1PostWorkspaceRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/workspaces`,
      v1PostWorkspaceRequest,options
    );
  }

/**
 * @summary Get the requested workspace.
 */
export const getWorkspace = <TData = AxiosResponse<V1GetWorkspaceResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/workspaces/${id}`,options
    );
  }

/**
 * @summary Delete a workspace.
 */
export const deleteWorkspace = <TData = AxiosResponse<V1DeleteWorkspaceResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/workspaces/${id}`,options
    );
  }

/**
 * @summary Update a workspace.
 */
export const patchWorkspace = <TData = AxiosResponse<V1PatchWorkspaceResponse>>(
    id: number,
    v1PatchWorkspace: V1PatchWorkspace, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/api/v1/workspaces/${id}`,
      v1PatchWorkspace,options
    );
  }

/**
 * @summary Archive a workspace.
 */
export const archiveWorkspace = <TData = AxiosResponse<V1ArchiveWorkspaceResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/workspaces/${id}/archive`,undefined,options
    );
  }

/**
 * @summary Get Kubernetes Resource Quotas for a workspace by the cluster name.
 */
export const getKubernetesResourceQuotas = <TData = AxiosResponse<V1GetKubernetesResourceQuotasResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/workspaces/${id}/get-k8s-resource-quotas`,options
    );
  }

/**
 * @summary List namespaces bound to a workspace.
 */
export const listWorkspaceNamespaceBindings = <TData = AxiosResponse<V1ListWorkspaceNamespaceBindingsResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/workspaces/${id}/list-namespace-bindings`,options
    );
  }

/**
 * @summary Pin a workspace.
 */
export const pinWorkspace = <TData = AxiosResponse<V1PinWorkspaceResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/workspaces/${id}/pin`,undefined,options
    );
  }

/**
 * @summary Get projects associated with a workspace.
 */
export const getWorkspaceProjects = <TData = AxiosResponse<V1GetWorkspaceProjectsResponse>>(
    id: number,
    params?: GetWorkspaceProjectsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/workspaces/${id}/projects`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Set a resource quota for a workspace (within a specific cluster).
 */
export const setResourceQuotas = <TData = AxiosResponse<V1SetResourceQuotasResponse>>(
    id: number,
    v1SetResourceQuotasRequest: V1SetResourceQuotasRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/workspaces/${id}/set-resource-quota`,
      v1SetResourceQuotasRequest,options
    );
  }

/**
 * @summary Unarchive a workspace.
 */
export const unarchiveWorkspace = <TData = AxiosResponse<V1UnarchiveWorkspaceResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/workspaces/${id}/unarchive`,undefined,options
    );
  }

/**
 * @summary Unpin a workspace.
 */
export const unpinWorkspace = <TData = AxiosResponse<V1UnpinWorkspaceResponse>>(
    id: number, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/workspaces/${id}/unpin`,undefined,options
    );
  }

/**
 * @summary List all resource pools, bound and unbound, available to a specific
workspace
 */
export const listRPsBoundToWorkspace = <TData = AxiosResponse<V1ListRPsBoundToWorkspaceResponse>>(
    workspaceId: number,
    params?: ListRPsBoundToWorkspaceParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/api/v1/workspaces/${workspaceId}/available-resource-pools`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Deletes workpace namespace bindings.
 */
export const deleteWorkspaceNamespaceBindings = <TData = AxiosResponse<V1DeleteWorkspaceNamespaceBindingsResponse>>(
    workspaceId: number,
    params?: DeleteWorkspaceNamespaceBindingsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/api/v1/workspaces/${workspaceId}/namespace-bindings`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Bind a namespace to a workspace.
 */
export const setWorkspaceNamespaceBindings = <TData = AxiosResponse<V1SetWorkspaceNamespaceBindingsResponse>>(
    workspaceId: number,
    v1SetWorkspaceNamespaceBindingsRequest: V1SetWorkspaceNamespaceBindingsRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/workspaces/${workspaceId}/namespace-bindings`,
      v1SetWorkspaceNamespaceBindingsRequest,options
    );
  }

/**
 * @summary Create a project.
 */
export const postProject = <TData = AxiosResponse<V1PostProjectResponse>>(
    workspaceId: number,
    v1PostProjectRequest: V1PostProjectRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/api/v1/workspaces/${workspaceId}/projects`,
      v1PostProjectRequest,options
    );
  }

/**
 * @summary Get a checkpoint's contents in a tar, tgz, or zip file.
 */
export const getCheckpoint = <TData = AxiosResponse<unknown>>(
    checkpointUuid: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/checkpoints/${checkpointUuid}`,options
    );
  }

/**
 * @summary Get individual file from modal definitions for download.
 */
export const getExperimentModelFile = <TData = AxiosResponse<unknown>>(
    experimentId: number,
    params: GetExperimentModelFileParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/experiments/${experimentId}/file/download`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get health of Determined and the dependencies.
 */
export const health = <TData = AxiosResponse<HealthCheck>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/health`,options
    );
  }

/**
 * @summary Get an aggregated view of resource allocation during the given time period (CSV).
 */
export const getAggregatedResourceAllocationCsv = <TData = AxiosResponse<unknown>>(
    params: GetAggregatedResourceAllocationCsvParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/resources/allocation/aggregated`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get a detailed view of resource allocation at a allocation-level during the given time period (CSV).
 */
export const getResourceAllocationCsv = <TData = AxiosResponse<unknown>>(
    params: GetResourceAllocationCsvParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/resources/allocation/allocations-csv`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @deprecated
 * @summary Get a detailed view of resource allocation during the given time period (CSV).
 */
export const getRawResourceAllocationCsv = <TData = AxiosResponse<unknown>>(
    params: GetRawResourceAllocationCsvParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/resources/allocation/raw`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

export type GetAgentsResult = AxiosResponse<V1GetAgentsResponse>
export type GetAgentResult = AxiosResponse<V1GetAgentResponse>
export type DisableAgentResult = AxiosResponse<V1DisableAgentResponse>
export type EnableAgentResult = AxiosResponse<V1EnableAgentResponse>
export type GetSlotsResult = AxiosResponse<V1GetSlotsResponse>
export type GetSlotResult = AxiosResponse<V1GetSlotResponse>
export type DisableSlotResult = AxiosResponse<V1DisableSlotResponse>
export type EnableSlotResult = AxiosResponse<V1EnableSlotResponse>
export type GetAllocationResult = AxiosResponse<V1GetAllocationResponse>
export type PostAllocationAcceleratorDataResult = AxiosResponse<V1PostAllocationAcceleratorDataResponse>
export type AllocationAllGatherResult = AxiosResponse<V1AllocationAllGatherResponse>
export type NotifyContainerRunningResult = AxiosResponse<V1NotifyContainerRunningResponse>
export type PostAllocationProxyAddressResult = AxiosResponse<V1PostAllocationProxyAddressResponse>
export type AllocationReadyResult = AxiosResponse<V1AllocationReadyResponse>
export type MarkAllocationResourcesDaemonResult = AxiosResponse<V1MarkAllocationResourcesDaemonResponse>
export type AllocationRendezvousInfoResult = AxiosResponse<V1AllocationRendezvousInfoResponse>
export type AckAllocationPreemptionSignalResult = AxiosResponse<V1AckAllocationPreemptionSignalResponse>
export type AllocationPendingPreemptionSignalResult = AxiosResponse<V1AllocationPendingPreemptionSignalResponse>
export type AllocationPreemptionSignalResult = AxiosResponse<V1AllocationPreemptionSignalResponse>
export type AllocationWaitingResult = AxiosResponse<V1AllocationWaitingResponse>
export type LoginResult = AxiosResponse<V1LoginResponse>
export type LogoutResult = AxiosResponse<V1LogoutResponse>
export type CurrentUserResult = AxiosResponse<V1CurrentUserResponse>
export type DeleteCheckpointsResult = AxiosResponse<V1DeleteCheckpointsResponse>
export type ReportCheckpointResult = AxiosResponse<V1ReportCheckpointResponse>
export type PatchCheckpointsResult = AxiosResponse<V1PatchCheckpointsResponse>
export type CheckpointsRemoveFilesResult = AxiosResponse<V1CheckpointsRemoveFilesResponse>
export type PostCheckpointMetadataResult = AxiosResponse<V1PostCheckpointMetadataResponse>
export type GetCheckpointResult = AxiosResponse<unknown>
export type GetTrialMetricsByCheckpointResult = AxiosResponse<V1GetTrialMetricsByCheckpointResponse>
export type CleanupLogsResult = AxiosResponse<V1CleanupLogsResponse>
export type GetCommandsResult = AxiosResponse<V1GetCommandsResponse>
export type LaunchCommandResult = AxiosResponse<V1LaunchCommandResponse>
export type GetCommandResult = AxiosResponse<V1GetCommandResponse>
export type KillCommandResult = AxiosResponse<V1KillCommandResponse>
export type SetCommandPriorityResult = AxiosResponse<V1SetCommandPriorityResponse>
export type GetGlobalConfigPoliciesResult = AxiosResponse<V1GetGlobalConfigPoliciesResponse>
export type DeleteGlobalConfigPoliciesResult = AxiosResponse<V1DeleteGlobalConfigPoliciesResponse>
export type PutGlobalConfigPoliciesResult = AxiosResponse<V1PutGlobalConfigPoliciesResponse>
export type GetWorkspaceConfigPoliciesResult = AxiosResponse<V1GetWorkspaceConfigPoliciesResponse>
export type DeleteWorkspaceConfigPoliciesResult = AxiosResponse<V1DeleteWorkspaceConfigPoliciesResponse>
export type PutWorkspaceConfigPoliciesResult = AxiosResponse<V1PutWorkspaceConfigPoliciesResponse>
export type GetExperimentLabelsResult = AxiosResponse<V1GetExperimentLabelsResponse>
export type GetExperimentsResult = AxiosResponse<V1GetExperimentsResponse>
export type CreateExperimentResult = AxiosResponse<V1CreateExperimentResponse>
export type SearchExperimentsResult = AxiosResponse<V1SearchExperimentsResponse>
export type PutExperimentResult = AxiosResponse<V1PutExperimentResponse>
export type ContinueExperimentResult = AxiosResponse<V1ContinueExperimentResponse>
export type ExpMetricNamesResult = AxiosResponse<ExpMetricNames200>
export type PatchExperimentResult = AxiosResponse<V1PatchExperimentResponse>
export type GetExperimentResult = AxiosResponse<V1GetExperimentResponse>
export type DeleteExperimentResult = AxiosResponse<V1DeleteExperimentResponse>
export type GetModelDefFileResult = AxiosResponse<V1GetModelDefFileResponse>
export type GetModelDefTreeResult = AxiosResponse<V1GetModelDefTreeResponse>
export type DeleteExperimentLabelResult = AxiosResponse<V1DeleteExperimentLabelResponse>
export type PutExperimentLabelResult = AxiosResponse<V1PutExperimentLabelResponse>
export type MetricBatchesResult = AxiosResponse<MetricBatches200>
export type TrialsSampleResult = AxiosResponse<TrialsSample200>
export type TrialsSnapshotResult = AxiosResponse<TrialsSnapshot200>
export type GetModelDefResult = AxiosResponse<V1GetModelDefResponse>
export type MoveExperimentResult = AxiosResponse<V1MoveExperimentResponse>
export type PutExperimentRetainLogsResult = AxiosResponse<V1PutExperimentRetainLogsResponse>
export type GetBestSearcherValidationMetricResult = AxiosResponse<V1GetBestSearcherValidationMetricResponse>
export type DeleteTensorboardFilesResult = AxiosResponse<V1DeleteTensorboardFilesResponse>
export type GetExperimentTrialsResult = AxiosResponse<V1GetExperimentTrialsResponse>
export type GetExperimentValidationHistoryResult = AxiosResponse<V1GetExperimentValidationHistoryResponse>
export type ActivateExperimentResult = AxiosResponse<V1ActivateExperimentResponse>
export type ArchiveExperimentResult = AxiosResponse<V1ArchiveExperimentResponse>
export type CancelExperimentResult = AxiosResponse<V1CancelExperimentResponse>
export type GetExperimentCheckpointsResult = AxiosResponse<V1GetExperimentCheckpointsResponse>
export type KillExperimentResult = AxiosResponse<V1KillExperimentResponse>
export type PauseExperimentResult = AxiosResponse<V1PauseExperimentResponse>
export type UnarchiveExperimentResult = AxiosResponse<V1UnarchiveExperimentResponse>
export type CreateGenericTaskResult = AxiosResponse<V1CreateGenericTaskResponse>
export type CreateGroupResult = AxiosResponse<V1CreateGroupResponse>
export type GetGroupsResult = AxiosResponse<V1GetGroupsResponse>
export type GetGroupResult = AxiosResponse<V1GetGroupResponse>
export type DeleteGroupResult = AxiosResponse<V1DeleteGroupResponse>
export type UpdateGroupResult = AxiosResponse<V1UpdateGroupResponse>
export type GetJobsResult = AxiosResponse<V1GetJobsResponse>
export type UpdateJobQueueResult = AxiosResponse<V1UpdateJobQueueResponse>
export type GetJobsV2Result = AxiosResponse<V1GetJobsV2Response>
export type GetJobQueueStatsResult = AxiosResponse<V1GetJobQueueStatsResponse>
export type GetKubernetesResourceManagersResult = AxiosResponse<V1GetKubernetesResourceManagersResponse>
export type GetMasterResult = AxiosResponse<V1GetMasterResponse>
export type GetClusterMessageResult = AxiosResponse<V1GetClusterMessageResponse>
export type DeleteClusterMessageResult = AxiosResponse<V1DeleteClusterMessageResponse>
export type SetClusterMessageResult = AxiosResponse<V1SetClusterMessageResponse>
export type GetMasterConfigResult = AxiosResponse<V1GetMasterConfigResponse>
export type PatchMasterConfigResult = AxiosResponse<V1PatchMasterConfigResponse>
export type MasterLogsResult = AxiosResponse<MasterLogs200>
export type GetTelemetryResult = AxiosResponse<V1GetTelemetryResponse>
export type GetMeResult = AxiosResponse<V1GetMeResponse>
export type GetModelLabelsResult = AxiosResponse<V1GetModelLabelsResponse>
export type GetModelsResult = AxiosResponse<V1GetModelsResponse>
export type PostModelResult = AxiosResponse<V1PostModelResponse>
export type GetModelResult = AxiosResponse<V1GetModelResponse>
export type DeleteModelResult = AxiosResponse<V1DeleteModelResponse>
export type PatchModelResult = AxiosResponse<V1PatchModelResponse>
export type ArchiveModelResult = AxiosResponse<V1ArchiveModelResponse>
export type MoveModelResult = AxiosResponse<V1MoveModelResponse>
export type UnarchiveModelResult = AxiosResponse<V1UnarchiveModelResponse>
export type GetModelVersionsResult = AxiosResponse<V1GetModelVersionsResponse>
export type PostModelVersionResult = AxiosResponse<V1PostModelVersionResponse>
export type GetModelVersionResult = AxiosResponse<V1GetModelVersionResponse>
export type DeleteModelVersionResult = AxiosResponse<V1DeleteModelVersionResponse>
export type PatchModelVersionResult = AxiosResponse<V1PatchModelVersionResponse>
export type GetTrialMetricsByModelVersionResult = AxiosResponse<V1GetTrialMetricsByModelVersionResponse>
export type BulkAutoCreateWorkspaceNamespaceBindingsResult = AxiosResponse<V1BulkAutoCreateWorkspaceNamespaceBindingsResponse>
export type GetWorkspacesWithDefaultNamespaceBindingsResult = AxiosResponse<V1GetWorkspacesWithDefaultNamespaceBindingsResponse>
export type GetNotebooksResult = AxiosResponse<V1GetNotebooksResponse>
export type LaunchNotebookResult = AxiosResponse<V1LaunchNotebookResponse>
export type GetNotebookResult = AxiosResponse<V1GetNotebookResponse>
export type KillNotebookResult = AxiosResponse<V1KillNotebookResponse>
export type IdleNotebookResult = AxiosResponse<V1IdleNotebookResponse>
export type SetNotebookPriorityResult = AxiosResponse<V1SetNotebookPriorityResponse>
export type GetPermissionsSummaryResult = AxiosResponse<V1GetPermissionsSummaryResponse>
export type PreviewHPSearchResult = AxiosResponse<V1PreviewHPSearchResponse>
export type GetProjectByKeyResult = AxiosResponse<V1GetProjectByKeyResponse>
export type GetProjectResult = AxiosResponse<V1GetProjectResponse>
export type DeleteProjectResult = AxiosResponse<V1DeleteProjectResponse>
export type PatchProjectResult = AxiosResponse<V1PatchProjectResponse>
export type ArchiveProjectResult = AxiosResponse<V1ArchiveProjectResponse>
export type GetProjectColumnsResult = AxiosResponse<V1GetProjectColumnsResponse>
export type GetProjectNumericMetricsRangeResult = AxiosResponse<V1GetProjectNumericMetricsRangeResponse>
export type UnarchiveProjectResult = AxiosResponse<V1UnarchiveProjectResponse>
export type ActivateExperimentsResult = AxiosResponse<V1ActivateExperimentsResponse>
export type ArchiveExperimentsResult = AxiosResponse<V1ArchiveExperimentsResponse>
export type CancelExperimentsResult = AxiosResponse<V1CancelExperimentsResponse>
export type DeleteExperimentsResult = AxiosResponse<V1DeleteExperimentsResponse>
export type KillExperimentsResult = AxiosResponse<V1KillExperimentsResponse>
export type MoveExperimentsResult = AxiosResponse<V1MoveExperimentsResponse>
export type PauseExperimentsResult = AxiosResponse<V1PauseExperimentsResponse>
export type PutExperimentsRetainLogsResult = AxiosResponse<V1PutExperimentsRetainLogsResponse>
export type UnarchiveExperimentsResult = AxiosResponse<V1UnarchiveExperimentsResponse>
export type GetMetadataValuesResult = AxiosResponse<V1GetMetadataValuesResponse>
export type MoveProjectResult = AxiosResponse<V1MoveProjectResponse>
export type AddProjectNoteResult = AxiosResponse<V1AddProjectNoteResponse>
export type PutProjectNotesResult = AxiosResponse<V1PutProjectNotesResponse>
export type GetResourcePoolsResult = AxiosResponse<V1GetResourcePoolsResponse>
export type ListWorkspacesBoundToRPResult = AxiosResponse<V1ListWorkspacesBoundToRPResponse>
export type UnbindRPFromWorkspaceResult = AxiosResponse<V1UnbindRPFromWorkspaceResponse>
export type BindRPToWorkspaceResult = AxiosResponse<V1BindRPToWorkspaceResponse>
export type OverwriteRPWorkspaceBindingsResult = AxiosResponse<V1OverwriteRPWorkspaceBindingsResponse>
export type ResourceAllocationAggregatedResult = AxiosResponse<V1ResourceAllocationAggregatedResponse>
export type ResourceAllocationRawResult = AxiosResponse<V1ResourceAllocationRawResponse>
export type AssignRolesResult = AxiosResponse<V1AssignRolesResponse>
export type RemoveAssignmentsResult = AxiosResponse<V1RemoveAssignmentsResponse>
export type ListRolesResult = AxiosResponse<V1ListRolesResponse>
export type SearchRolesAssignableToScopeResult = AxiosResponse<V1SearchRolesAssignableToScopeResponse>
export type GetRolesAssignedToGroupResult = AxiosResponse<V1GetRolesAssignedToGroupResponse>
export type GetRolesByIDResult = AxiosResponse<V1GetRolesByIDResponse>
export type GetRolesAssignedToUserResult = AxiosResponse<V1GetRolesAssignedToUserResponse>
export type GetGroupsAndUsersAssignedToWorkspaceResult = AxiosResponse<V1GetGroupsAndUsersAssignedToWorkspaceResponse>
export type SearchRunsResult = AxiosResponse<V1SearchRunsResponse>
export type ArchiveRunsResult = AxiosResponse<V1ArchiveRunsResponse>
export type DeleteRunsResult = AxiosResponse<V1DeleteRunsResponse>
export type KillRunsResult = AxiosResponse<V1KillRunsResponse>
export type MoveRunsResult = AxiosResponse<V1MoveRunsResponse>
export type PauseRunsResult = AxiosResponse<V1PauseRunsResponse>
export type ResumeRunsResult = AxiosResponse<V1ResumeRunsResponse>
export type RunPrepareForReportingResult = AxiosResponse<V1RunPrepareForReportingResponse>
export type UnarchiveRunsResult = AxiosResponse<V1UnarchiveRunsResponse>
export type GetRunMetadataResult = AxiosResponse<V1GetRunMetadataResponse>
export type PostRunMetadataResult = AxiosResponse<V1PostRunMetadataResponse>
export type ArchiveSearchesResult = AxiosResponse<V1ArchiveSearchesResponse>
export type CancelSearchesResult = AxiosResponse<V1CancelSearchesResponse>
export type DeleteSearchesResult = AxiosResponse<V1DeleteSearchesResponse>
export type KillSearchesResult = AxiosResponse<V1KillSearchesResponse>
export type MoveSearchesResult = AxiosResponse<V1MoveSearchesResponse>
export type PauseSearchesResult = AxiosResponse<V1PauseSearchesResponse>
export type ResumeSearchesResult = AxiosResponse<V1ResumeSearchesResponse>
export type LaunchTensorboardSearchesResult = AxiosResponse<V1LaunchTensorboardSearchesResponse>
export type UnarchiveSearchesResult = AxiosResponse<V1UnarchiveSearchesResponse>
export type GetShellsResult = AxiosResponse<V1GetShellsResponse>
export type LaunchShellResult = AxiosResponse<V1LaunchShellResponse>
export type GetShellResult = AxiosResponse<V1GetShellResponse>
export type KillShellResult = AxiosResponse<V1KillShellResponse>
export type SetShellPriorityResult = AxiosResponse<V1SetShellPriorityResponse>
export type PostTaskLogsResult = AxiosResponse<V1PostTaskLogsResponse>
export type GetTasksResult = AxiosResponse<V1GetTasksResponse>
export type GetActiveTasksCountResult = AxiosResponse<V1GetActiveTasksCountResponse>
export type GetTaskResult = AxiosResponse<V1GetTaskResponse>
export type GetTaskAcceleratorDataResult = AxiosResponse<V1GetTaskAcceleratorDataResponse>
export type GetGenericTaskConfigResult = AxiosResponse<V1GetGenericTaskConfigResponse>
export type GetTaskContextDirectoryResult = AxiosResponse<V1GetTaskContextDirectoryResponse>
export type KillGenericTaskResult = AxiosResponse<V1KillGenericTaskResponse>
export type TaskLogsResult = AxiosResponse<TaskLogs200>
export type TaskLogsFieldsResult = AxiosResponse<TaskLogsFields200>
export type PauseGenericTaskResult = AxiosResponse<V1PauseGenericTaskResponse>
export type UnpauseGenericTaskResult = AxiosResponse<V1UnpauseGenericTaskResponse>
export type PatchTemplateNameResult = AxiosResponse<V1PatchTemplateNameResponse>
export type GetTemplatesResult = AxiosResponse<V1GetTemplatesResponse>
export type PostTemplateResult = AxiosResponse<V1PostTemplateResponse>
export type PutTemplateResult = AxiosResponse<V1PutTemplateResponse>
export type GetTemplateResult = AxiosResponse<V1GetTemplateResponse>
export type DeleteTemplateResult = AxiosResponse<V1DeleteTemplateResponse>
export type PatchTemplateConfigResult = AxiosResponse<V1PatchTemplateConfigResponse>
export type GetTensorboardsResult = AxiosResponse<V1GetTensorboardsResponse>
export type LaunchTensorboardResult = AxiosResponse<V1LaunchTensorboardResponse>
export type GetTensorboardResult = AxiosResponse<V1GetTensorboardResponse>
export type KillTensorboardResult = AxiosResponse<V1KillTensorboardResponse>
export type SetTensorboardPriorityResult = AxiosResponse<V1SetTensorboardPriorityResponse>
export type GetAccessTokensResult = AxiosResponse<V1GetAccessTokensResponse>
export type PostAccessTokenResult = AxiosResponse<V1PostAccessTokenResponse>
export type PatchAccessTokenResult = AxiosResponse<V1PatchAccessTokenResponse>
export type ReportTrialSourceInfoResult = AxiosResponse<V1ReportTrialSourceInfoResponse>
export type CreateTrialResult = AxiosResponse<V1CreateTrialResponse>
export type PutTrialResult = AxiosResponse<V1PutTrialResponse>
export type GetTrialByExternalIDResult = AxiosResponse<V1GetTrialByExternalIDResponse>
export type GetTrainingMetricsResult = AxiosResponse<GetTrainingMetrics200>
export type GetMetricsResult = AxiosResponse<GetMetrics200>
export type GetValidationMetricsResult = AxiosResponse<GetValidationMetrics200>
export type PostTrialProfilerMetricsBatchResult = AxiosResponse<V1PostTrialProfilerMetricsBatchResponse>
export type CompareTrialsResult = AxiosResponse<V1CompareTrialsResponse>
export type GetTrialCheckpointsResult = AxiosResponse<V1GetTrialCheckpointsResponse>
export type KillTrialResult = AxiosResponse<V1KillTrialResponse>
export type GetTrialRemainingLogRetentionDaysResult = AxiosResponse<V1GetTrialRemainingLogRetentionDaysResponse>
export type GetTrialProfilerMetricsResult = AxiosResponse<GetTrialProfilerMetrics200>
export type ReportTrialMetricsResult = AxiosResponse<V1ReportTrialMetricsResponse>
export type ReportTrialTrainingMetricsResult = AxiosResponse<V1ReportTrialTrainingMetricsResponse>
export type GetTrialResult = AxiosResponse<V1GetTrialResponse>
export type PatchTrialResult = AxiosResponse<V1PatchTrialResponse>
export type ReportTrialSearcherEarlyExitResult = AxiosResponse<V1ReportTrialSearcherEarlyExitResponse>
export type TrialLogsResult = AxiosResponse<TrialLogs200>
export type TrialLogsFieldsResult = AxiosResponse<TrialLogsFields200>
export type GetTrialProfilerAvailableSeriesResult = AxiosResponse<GetTrialProfilerAvailableSeries200>
export type ReportTrialProgressResult = AxiosResponse<V1ReportTrialProgressResponse>
export type PutTrialRetainLogsResult = AxiosResponse<V1PutTrialRetainLogsResponse>
export type PostTrialRunnerMetadataResult = AxiosResponse<V1PostTrialRunnerMetadataResponse>
export type StartTrialResult = AxiosResponse<V1StartTrialResponse>
export type GetTrialWorkloadsResult = AxiosResponse<V1GetTrialWorkloadsResponse>
export type ReportTrialValidationMetricsResult = AxiosResponse<V1ReportTrialValidationMetricsResponse>
export type GetProjectsByUserActivityResult = AxiosResponse<V1GetProjectsByUserActivityResponse>
export type GetUsersResult = AxiosResponse<V1GetUsersResponse>
export type PostUserResult = AxiosResponse<V1PostUserResponse>
export type PatchUsersResult = AxiosResponse<V1PatchUsersResponse>
export type PostUserActivityResult = AxiosResponse<V1PostUserActivityResponse>
export type AssignMultipleGroupsResult = AxiosResponse<V1AssignMultipleGroupsResponse>
export type GetUserSettingResult = AxiosResponse<V1GetUserSettingResponse>
export type PostUserSettingResult = AxiosResponse<V1PostUserSettingResponse>
export type ResetUserSettingResult = AxiosResponse<V1ResetUserSettingResponse>
export type GetUserResult = AxiosResponse<V1GetUserResponse>
export type PatchUserResult = AxiosResponse<V1PatchUserResponse>
export type SetUserPasswordResult = AxiosResponse<V1SetUserPasswordResponse>
export type GetUserByUsernameResult = AxiosResponse<V1GetUserByUsernameResponse>
export type GetWebhooksResult = AxiosResponse<V1GetWebhooksResponse>
export type PostWebhookResult = AxiosResponse<V1PostWebhookResponse>
export type PostWebhookEventDataResult = AxiosResponse<V1PostWebhookEventDataResponse>
export type DeleteWebhookResult = AxiosResponse<V1DeleteWebhookResponse>
export type PatchWebhookResult = AxiosResponse<V1PatchWebhookResponse>
export type TestWebhookResult = AxiosResponse<V1TestWebhookResponse>
export type GetWorkspacesResult = AxiosResponse<V1GetWorkspacesResponse>
export type PostWorkspaceResult = AxiosResponse<V1PostWorkspaceResponse>
export type GetWorkspaceResult = AxiosResponse<V1GetWorkspaceResponse>
export type DeleteWorkspaceResult = AxiosResponse<V1DeleteWorkspaceResponse>
export type PatchWorkspaceResult = AxiosResponse<V1PatchWorkspaceResponse>
export type ArchiveWorkspaceResult = AxiosResponse<V1ArchiveWorkspaceResponse>
export type GetKubernetesResourceQuotasResult = AxiosResponse<V1GetKubernetesResourceQuotasResponse>
export type ListWorkspaceNamespaceBindingsResult = AxiosResponse<V1ListWorkspaceNamespaceBindingsResponse>
export type PinWorkspaceResult = AxiosResponse<V1PinWorkspaceResponse>
export type GetWorkspaceProjectsResult = AxiosResponse<V1GetWorkspaceProjectsResponse>
export type SetResourceQuotasResult = AxiosResponse<V1SetResourceQuotasResponse>
export type UnarchiveWorkspaceResult = AxiosResponse<V1UnarchiveWorkspaceResponse>
export type UnpinWorkspaceResult = AxiosResponse<V1UnpinWorkspaceResponse>
export type ListRPsBoundToWorkspaceResult = AxiosResponse<V1ListRPsBoundToWorkspaceResponse>
export type DeleteWorkspaceNamespaceBindingsResult = AxiosResponse<V1DeleteWorkspaceNamespaceBindingsResponse>
export type SetWorkspaceNamespaceBindingsResult = AxiosResponse<V1SetWorkspaceNamespaceBindingsResponse>
export type PostProjectResult = AxiosResponse<V1PostProjectResponse>
export type GetCheckpointResult = AxiosResponse<unknown>
export type GetExperimentModelFileResult = AxiosResponse<unknown>
export type HealthResult = AxiosResponse<HealthCheck>
export type GetAggregatedResourceAllocationCsvResult = AxiosResponse<unknown>
export type GetResourceAllocationCsvResult = AxiosResponse<unknown>
export type GetRawResourceAllocationCsvResult = AxiosResponse<unknown>
