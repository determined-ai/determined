/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Determined API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * The current state of the experiment.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.
 * @export
 * @enum {string}
 */
export enum Experimentv1State {
    UNSPECIFIED = <any> 'STATE_UNSPECIFIED',
    ACTIVE = <any> 'STATE_ACTIVE',
    PAUSED = <any> 'STATE_PAUSED',
    STOPPINGCOMPLETED = <any> 'STATE_STOPPING_COMPLETED',
    STOPPINGCANCELED = <any> 'STATE_STOPPING_CANCELED',
    STOPPINGERROR = <any> 'STATE_STOPPING_ERROR',
    COMPLETED = <any> 'STATE_COMPLETED',
    CANCELED = <any> 'STATE_CANCELED',
    ERROR = <any> 'STATE_ERROR',
    DELETED = <any> 'STATE_DELETED'
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ProtobufAny
     */
    typeUrl?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ProtobufAny
     */
    value?: string;
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */
export enum ProtobufNullValue {
    NULLVALUE = <any> 'NULL_VALUE'
}

/**
 * 
 * @export
 * @interface RuntimeError
 */
export interface RuntimeError {
    /**
     * 
     * @type {string}
     * @memberof RuntimeError
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof RuntimeError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof RuntimeError
     */
    message?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RuntimeError
     */
    details?: Array<ProtobufAny>;
}

/**
 * Agent is a pool of resources where containers are run.
 * @export
 * @interface V1Agent
 */
export interface V1Agent {
    /**
     * The unique id of the agent.
     * @type {string}
     * @memberof V1Agent
     */
    id?: string;
    /**
     * The time when the agent registered with the master.
     * @type {Date}
     * @memberof V1Agent
     */
    registeredTime?: Date;
    /**
     * A map of slot id to each slot of this agent.
     * @type {{ [key: string]: V1Slot; }}
     * @memberof V1Agent
     */
    slots?: { [key: string]: V1Slot; };
    /**
     * A map of container id to all containers assigned to this agent.
     * @type {{ [key: string]: V1Container; }}
     * @memberof V1Agent
     */
    containers?: { [key: string]: V1Container; };
    /**
     * An optional label applied to the agent for scheduling restrictions.
     * @type {string}
     * @memberof V1Agent
     */
    label?: string;
}

/**
 * AgentUserGroup represents a username and primary group for a user on an agent host machine.
 * @export
 * @interface V1AgentUserGroup
 */
export interface V1AgentUserGroup {
    /**
     * The user id on the agent.
     * @type {number}
     * @memberof V1AgentUserGroup
     */
    agentUid?: number;
    /**
     * The group id on the agent.
     * @type {number}
     * @memberof V1AgentUserGroup
     */
    agentGid?: number;
}

/**
 * Container is a Docker container that is either scheduled to run or is currently running on a set of slots.
 * @export
 * @interface V1Container
 */
export interface V1Container {
    /**
     * The id of the task that is currently managing this container.
     * @type {string}
     * @memberof V1Container
     */
    parent?: string;
    /**
     * The unique id of this instance of a container.
     * @type {string}
     * @memberof V1Container
     */
    id?: string;
    /**
     * The current state that the container is currently in.
     * @type {V1ContainerState}
     * @memberof V1Container
     */
    state?: V1ContainerState;
    /**
     * A list of devices that is being used by this container.
     * @type {Array<V1Device>}
     * @memberof V1Container
     */
    devices?: Array<V1Device>;
}

/**
 * The current state of the container.   - STATE_UNSPECIFIED: The container state is unknown.  - STATE_ASSIGNED: The container has been assigned to an agent but has not started yet.  - STATE_PULLING: The container's base image is being pulled from the Docker registry.  - STATE_STARTING: The image has been built and the container is being started, but the service in the container is not ready yet.  - STATE_RUNNING: The service in the container is able to accept requests.  - STATE_TERMINATED: The container has completely exited or the container has been aborted prior to getting assigned.
 * @export
 * @enum {string}
 */
export enum V1ContainerState {
    UNSPECIFIED = <any> 'STATE_UNSPECIFIED',
    ASSIGNED = <any> 'STATE_ASSIGNED',
    PULLING = <any> 'STATE_PULLING',
    STARTING = <any> 'STATE_STARTING',
    RUNNING = <any> 'STATE_RUNNING',
    TERMINATED = <any> 'STATE_TERMINATED'
}

/**
 * Response to CurrentUserRequest.
 * @export
 * @interface V1CurrentUserResponse
 */
export interface V1CurrentUserResponse {
    /**
     * The currently logged in user.
     * @type {V1User}
     * @memberof V1CurrentUserResponse
     */
    user?: V1User;
}

/**
 * Response to DeleteTemplateRequest.
 * @export
 * @interface V1DeleteTemplateResponse
 */
export interface V1DeleteTemplateResponse {
}

/**
 * Device represents a single computational device on an agent.
 * @export
 * @interface V1Device
 */
export interface V1Device {
    /**
     * The index of the device.
     * @type {number}
     * @memberof V1Device
     */
    id?: number;
    /**
     * The brand name of the device.
     * @type {string}
     * @memberof V1Device
     */
    brand?: string;
    /**
     * The unique UUID of the device.
     * @type {string}
     * @memberof V1Device
     */
    uuid?: string;
    /**
     * The type of the Device.
     * @type {V1DeviceType}
     * @memberof V1Device
     */
    type?: V1DeviceType;
}

/**
 * The type of the Device.   - TYPE_UNSPECIFIED: An unspecified device type.  - TYPE_CPU: A CPU device.  - TYPE_GPU: A GPU device.
 * @export
 * @enum {string}
 */
export enum V1DeviceType {
    UNSPECIFIED = <any> 'TYPE_UNSPECIFIED',
    CPU = <any> 'TYPE_CPU',
    GPU = <any> 'TYPE_GPU'
}

/**
 * Response to DisableAgentRequest.
 * @export
 * @interface V1DisableAgentResponse
 */
export interface V1DisableAgentResponse {
    /**
     * The disabled agent.
     * @type {V1Agent}
     * @memberof V1DisableAgentResponse
     */
    agent?: V1Agent;
}

/**
 * Response to DisableSlotRequest.
 * @export
 * @interface V1DisableSlotResponse
 */
export interface V1DisableSlotResponse {
    /**
     * The disabled slot.
     * @type {V1Slot}
     * @memberof V1DisableSlotResponse
     */
    slot?: V1Slot;
}

/**
 * Response to EnableAgentRequest.
 * @export
 * @interface V1EnableAgentResponse
 */
export interface V1EnableAgentResponse {
    /**
     * The enabled agent.
     * @type {V1Agent}
     * @memberof V1EnableAgentResponse
     */
    agent?: V1Agent;
}

/**
 * Response to EnableSlotRequest.
 * @export
 * @interface V1EnableSlotResponse
 */
export interface V1EnableSlotResponse {
    /**
     * The enabled slot.
     * @type {V1Slot}
     * @memberof V1EnableSlotResponse
     */
    slot?: V1Slot;
}

/**
 * Experiment is a collection of one or more trials that are exploring a user-defined hyperparameter space.
 * @export
 * @interface V1Experiment
 */
export interface V1Experiment {
    /**
     * The id of the experiment.
     * @type {number}
     * @memberof V1Experiment
     */
    id?: number;
    /**
     * The description of the experiment.
     * @type {string}
     * @memberof V1Experiment
     */
    description?: string;
    /**
     * Labels attached to the experiment.
     * @type {Array<string>}
     * @memberof V1Experiment
     */
    labels?: Array<string>;
    /**
     * The time the experiment was started.
     * @type {Date}
     * @memberof V1Experiment
     */
    startTime?: Date;
    /**
     * The time the experiment ended if the experiment is stopped.
     * @type {Date}
     * @memberof V1Experiment
     */
    endTime?: Date;
    /**
     * The current state of the experiment.
     * @type {Experimentv1State}
     * @memberof V1Experiment
     */
    state?: Experimentv1State;
    /**
     * Boolean denoting whether the experiment was archived.
     * @type {boolean}
     * @memberof V1Experiment
     */
    archived?: boolean;
    /**
     * The number of trials linked to the experiment.
     * @type {number}
     * @memberof V1Experiment
     */
    numTrials?: number;
    /**
     * The current progress of the experiment.
     * @type {number}
     * @memberof V1Experiment
     */
    progress?: number;
    /**
     * The username of the user that created the experiment.
     * @type {string}
     * @memberof V1Experiment
     */
    username?: string;
}

/**
 * Response to GetAgentRequest.
 * @export
 * @interface V1GetAgentResponse
 */
export interface V1GetAgentResponse {
    /**
     * The requested agent.
     * @type {V1Agent}
     * @memberof V1GetAgentResponse
     */
    agent?: V1Agent;
}

/**
 * - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
 * @export
 * @enum {string}
 */
export enum V1GetAgentsRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    ID = <any> 'SORT_BY_ID',
    TIME = <any> 'SORT_BY_TIME'
}

/**
 * Response to GetAgentsRequest.
 * @export
 * @interface V1GetAgentsResponse
 */
export interface V1GetAgentsResponse {
    /**
     * The list of returned agents.
     * @type {Array<V1Agent>}
     * @memberof V1GetAgentsResponse
     */
    agents?: Array<V1Agent>;
}

/**
 * Sorts experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end times are returned after experiments that are.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.
 * @export
 * @enum {string}
 */
export enum V1GetExperimentsRequestSortBy {
    UNSPECIFIED = <any> 'SORT_BY_UNSPECIFIED',
    ID = <any> 'SORT_BY_ID',
    DESCRIPTION = <any> 'SORT_BY_DESCRIPTION',
    STARTTIME = <any> 'SORT_BY_START_TIME',
    ENDTIME = <any> 'SORT_BY_END_TIME',
    STATE = <any> 'SORT_BY_STATE',
    NUMTRIALS = <any> 'SORT_BY_NUM_TRIALS',
    PROGRESS = <any> 'SORT_BY_PROGRESS',
    USER = <any> 'SORT_BY_USER'
}

/**
 * Response to GetExperimentsRequest.
 * @export
 * @interface V1GetExperimentsResponse
 */
export interface V1GetExperimentsResponse {
    /**
     * The list of returned experiments.
     * @type {Array<V1Experiment>}
     * @memberof V1GetExperimentsResponse
     */
    experiments?: Array<V1Experiment>;
    /**
     * Pagination information of the full dataset.
     * @type {V1Pagination}
     * @memberof V1GetExperimentsResponse
     */
    pagination?: V1Pagination;
}

/**
 * Response to GetMasterRequest.
 * @export
 * @interface V1GetMasterResponse
 */
export interface V1GetMasterResponse {
    /**
     * The current version of the master.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    version?: string;
    /**
     * The current instance id of the master.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    masterId?: string;
    /**
     * The global cluster id of the master.
     * @type {string}
     * @memberof V1GetMasterResponse
     */
    clusterId?: string;
    /**
     * The config file loaded by the master.
     * @type {any}
     * @memberof V1GetMasterResponse
     */
    config?: any;
}

/**
 * Response to GetModelRequest.
 * @export
 * @interface V1GetModelResponse
 */
export interface V1GetModelResponse {
    /**
     * The model requested.
     * @type {V1Model}
     * @memberof V1GetModelResponse
     */
    model?: V1Model;
}

/**
 * Response to GetSlotRequest.
 * @export
 * @interface V1GetSlotResponse
 */
export interface V1GetSlotResponse {
    /**
     * The requested slot.
     * @type {V1Slot}
     * @memberof V1GetSlotResponse
     */
    slot?: V1Slot;
}

/**
 * Response to GetSlotsRequest.
 * @export
 * @interface V1GetSlotsResponse
 */
export interface V1GetSlotsResponse {
    /**
     * The requested slots.
     * @type {Array<V1Slot>}
     * @memberof V1GetSlotsResponse
     */
    slots?: Array<V1Slot>;
}

/**
 * Response to GetTemplateRequest.
 * @export
 * @interface V1GetTemplateResponse
 */
export interface V1GetTemplateResponse {
    /**
     * The requested template.
     * @type {V1Template}
     * @memberof V1GetTemplateResponse
     */
    template?: V1Template;
}

/**
 * Response to GetTemplatesRequest.
 * @export
 * @interface V1GetTemplatesResponse
 */
export interface V1GetTemplatesResponse {
    /**
     * the list of requested templates.
     * @type {Array<V1Template>}
     * @memberof V1GetTemplatesResponse
     */
    templates?: Array<V1Template>;
}

/**
 * Response to GetUserRequest.
 * @export
 * @interface V1GetUserResponse
 */
export interface V1GetUserResponse {
    /**
     * The requested user.
     * @type {V1User}
     * @memberof V1GetUserResponse
     */
    user?: V1User;
}

/**
 * Response to GetTemplatesRequest.
 * @export
 * @interface V1GetUsersResponse
 */
export interface V1GetUsersResponse {
    /**
     * The list of requested users.
     * @type {Array<V1User>}
     * @memberof V1GetUsersResponse
     */
    users?: Array<V1User>;
}

/**
 * Login the user.
 * @export
 * @interface V1LoginRequest
 */
export interface V1LoginRequest {
    /**
     * The username of the user.
     * @type {string}
     * @memberof V1LoginRequest
     */
    username?: string;
    /**
     * The password of the user.
     * @type {string}
     * @memberof V1LoginRequest
     */
    password?: string;
}

/**
 * Response to LoginRequest.
 * @export
 * @interface V1LoginResponse
 */
export interface V1LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof V1LoginResponse
     */
    token?: string;
    /**
     * The logged in user.
     * @type {V1User}
     * @memberof V1LoginResponse
     */
    user?: V1User;
}

/**
 * Response to LogoutRequest.
 * @export
 * @interface V1LogoutResponse
 */
export interface V1LogoutResponse {
}

/**
 * Model is a named collection of model versions.
 * @export
 * @interface V1Model
 */
export interface V1Model {
    /**
     * The name of the model.
     * @type {string}
     * @memberof V1Model
     */
    name?: string;
    /**
     * The description of the model.
     * @type {string}
     * @memberof V1Model
     */
    description?: string;
    /**
     * The user-defined metadata of the model.
     * @type {any}
     * @memberof V1Model
     */
    metadata?: any;
    /**
     * The time the model was created.
     * @type {Date}
     * @memberof V1Model
     */
    creationTime?: Date;
    /**
     * The time the model was last updated.
     * @type {Date}
     * @memberof V1Model
     */
    lastUpdatedTime?: Date;
}

/**
 * Order records in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
 * @export
 * @enum {string}
 */
export enum V1OrderBy {
    UNSPECIFIED = <any> 'ORDER_BY_UNSPECIFIED',
    ASC = <any> 'ORDER_BY_ASC',
    DESC = <any> 'ORDER_BY_DESC'
}

/**
 * Pagination provides information about the offset, limit, and total number of records returned in the results.
 * @export
 * @interface V1Pagination
 */
export interface V1Pagination {
    /**
     * The number of records skipped before returning results.
     * @type {number}
     * @memberof V1Pagination
     */
    offset?: number;
    /**
     * The amount of records limited in the results.
     * @type {number}
     * @memberof V1Pagination
     */
    limit?: number;
    /**
     * The index of the first record in the dataset.
     * @type {number}
     * @memberof V1Pagination
     */
    startIndex?: number;
    /**
     * The index+1 of the last record in the dataset.
     * @type {number}
     * @memberof V1Pagination
     */
    endIndex?: number;
    /**
     * The total number of values that match the filter.
     * @type {number}
     * @memberof V1Pagination
     */
    total?: number;
}

/**
 * Response to PostModelRequest.
 * @export
 * @interface V1PostModelResponse
 */
export interface V1PostModelResponse {
    /**
     * The model created.
     * @type {V1Model}
     * @memberof V1PostModelResponse
     */
    model?: V1Model;
}

/**
 * Create a new user.
 * @export
 * @interface V1PostUserRequest
 */
export interface V1PostUserRequest {
    /**
     * The user to create.
     * @type {V1User}
     * @memberof V1PostUserRequest
     */
    user?: V1User;
    /**
     * The password of the user.
     * @type {string}
     * @memberof V1PostUserRequest
     */
    password?: string;
}

/**
 * Response to PostUserRequest.
 * @export
 * @interface V1PostUserResponse
 */
export interface V1PostUserResponse {
    /**
     * The created user.
     * @type {V1User}
     * @memberof V1PostUserResponse
     */
    user?: V1User;
}

/**
 * Response to PutTemplateRequest.
 * @export
 * @interface V1PutTemplateResponse
 */
export interface V1PutTemplateResponse {
    /**
     * The updated or created template.
     * @type {V1Template}
     * @memberof V1PutTemplateResponse
     */
    template?: V1Template;
}

/**
 * Response to SetUserPasswordRequest.
 * @export
 * @interface V1SetUserPasswordResponse
 */
export interface V1SetUserPasswordResponse {
    /**
     * The updated user.
     * @type {V1User}
     * @memberof V1SetUserPasswordResponse
     */
    user?: V1User;
}

/**
 * Slot wraps a single device on the agent.
 * @export
 * @interface V1Slot
 */
export interface V1Slot {
    /**
     * The unqiue id of the slot for a given agent.
     * @type {string}
     * @memberof V1Slot
     */
    id?: string;
    /**
     * The individual resource this slot wraps.
     * @type {V1Device}
     * @memberof V1Slot
     */
    device?: V1Device;
    /**
     * Flag notifying if containers can be scheduled on this slot.
     * @type {boolean}
     * @memberof V1Slot
     */
    enabled?: boolean;
    /**
     * Container that is currently running on this agent. It is unset if there is no container currently running on this slot.
     * @type {V1Container}
     * @memberof V1Slot
     */
    container?: V1Container;
}

/**
 * Templates move settings that are shared by many experiments into a single YAML file.
 * @export
 * @interface V1Template
 */
export interface V1Template {
    /**
     * The name of the template.
     * @type {string}
     * @memberof V1Template
     */
    name?: string;
    /**
     * The template value.
     * @type {any}
     * @memberof V1Template
     */
    config?: any;
}

/**
 * User is an account in the determined cluster.
 * @export
 * @interface V1User
 */
export interface V1User {
    /**
     * The user login name of the user.
     * @type {string}
     * @memberof V1User
     */
    username?: string;
    /**
     * Bool denoting whether the account is an admin account.
     * @type {boolean}
     * @memberof V1User
     */
    admin?: boolean;
    /**
     * Bool denoting whether the account is active.
     * @type {boolean}
     * @memberof V1User
     */
    active?: boolean;
    /**
     * The user and group on the agent host machine.
     * @type {V1AgentUserGroup}
     * @memberof V1User
     */
    agentUserGroup?: V1AgentUserGroup;
}


/**
 * DeterminedApi - fetch parameter creator
 * @export
 */
export const DeterminedApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCurrentUser(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/auth/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the template with the given id.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDeleteTemplate(templateName: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling determinedDeleteTemplate.');
            }
            const localVarPath = `/api/v1/templates/{template_name}`
                .replace(`{${"template_name"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable the agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDisableAgent(agentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedDisableAgent.');
            }
            const localVarPath = `/api/v1/agents/{agent_id}/disable`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDisableSlot(agentId: string, slotId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedDisableSlot.');
            }
            // verify required parameter 'slotId' is not null or undefined
            if (slotId === null || slotId === undefined) {
                throw new RequiredError('slotId','Required parameter slotId was null or undefined when calling determinedDisableSlot.');
            }
            const localVarPath = `/api/v1/agents/{agent_id}/slots/{slot_id}/disable`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"slot_id"}}`, encodeURIComponent(String(slotId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable the agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedEnableAgent(agentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedEnableAgent.');
            }
            const localVarPath = `/api/v1/agents/{agent_id}/enable`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedEnableSlot(agentId: string, slotId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedEnableSlot.');
            }
            // verify required parameter 'slotId' is not null or undefined
            if (slotId === null || slotId === undefined) {
                throw new RequiredError('slotId','Required parameter slotId was null or undefined when calling determinedEnableSlot.');
            }
            const localVarPath = `/api/v1/agents/{agent_id}/slots/{slot_id}/enable`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"slot_id"}}`, encodeURIComponent(String(slotId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetAgent(agentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedGetAgent.');
            }
            const localVarPath = `/api/v1/agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a set of agents from the cluster
         * @param {string} [label] Filter agents by their label. If no label is specified or is empty, all agents are returned.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME'} [sortBy] Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetAgents(label?: string, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/agents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of experiments.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER'} [sortBy] Sort experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end times are returned after experiments that are.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order experiments in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of experiments before returning results. Negative values denote number of experiments to skip from the end before returning results.
         * @param {number} [limit] Limit the number of experiments. A value of 0 denotes no limit.
         * @param {string} [description] Limit experiments to those that match the description.
         * @param {boolean} [archived] Limit experiments to those that are archived.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED'>} [states] Limit experiments to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.
         * @param {Array<string>} [users] Limit experiments to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperiments(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, description?: string, archived?: boolean, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED'>, users?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/experiments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (states) {
                localVarQueryParameter['states'] = states;
            }

            if (users) {
                localVarQueryParameter['users'] = users;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get master information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetMaster(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/master`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested model.
         * @param {string} modelName The name of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModel(modelName: string, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling determinedGetModel.');
            }
            const localVarPath = `/api/v1/models/{model_name}`
                .replace(`{${"model_name"}}`, encodeURIComponent(String(modelName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested slot for the agent with the given id.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetSlot(agentId: string, slotId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedGetSlot.');
            }
            // verify required parameter 'slotId' is not null or undefined
            if (slotId === null || slotId === undefined) {
                throw new RequiredError('slotId','Required parameter slotId was null or undefined when calling determinedGetSlot.');
            }
            const localVarPath = `/api/v1/agents/{agent_id}/slots/{slot_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"slot_id"}}`, encodeURIComponent(String(slotId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the set of slots for the agent with the given id.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetSlots(agentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling determinedGetSlots.');
            }
            const localVarPath = `/api/v1/agents/{agent_id}/slots`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTemplate(templateName: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling determinedGetTemplate.');
            }
            const localVarPath = `/api/v1/templates/{template_name}`
                .replace(`{${"template_name"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of templates.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order templates in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTemplates(orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the requested user.
         * @param {string} username The username of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetUser(username: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling determinedGetUser.');
            }
            const localVarPath = `/api/v1/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetUsers(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login the user.
         * @param {V1LoginRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLogin(body: V1LoginRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedLogin.');
            }
            const localVarPath = `/api/v1/auth/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1LoginRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLogout(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/auth/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a model in the registry.
         * @param {string} modelName The name of the model.
         * @param {V1Model} body The model to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostModel(modelName: string, body: V1Model, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling determinedPostModel.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedPostModel.');
            }
            const localVarPath = `/api/v1/models/{model.name}`
                .replace(`{${"model.name"}}`, encodeURIComponent(String(modelName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Model" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user.
         * @param {V1PostUserRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostUser(body: V1PostUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedPostUser.');
            }
            const localVarPath = `/api/v1/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1PostUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the requested template. If one does not exist, a new template is created
         * @param {string} templateName The name of the template.
         * @param {V1Template} body The template to put.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPutTemplate(templateName: string, body: V1Template, options: any = {}): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling determinedPutTemplate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedPutTemplate.');
            }
            const localVarPath = `/api/v1/templates/{template.name}`
                .replace(`{${"template.name"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Template" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the requested user's passwords.
         * @param {string} username The username of the user.
         * @param {string} body The password of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetUserPassword(username: string, body: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling determinedSetUserPassword.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling determinedSetUserPassword.');
            }
            const localVarPath = `/api/v1/users/{username}/password`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeterminedApi - functional programming interface
 * @export
 */
export const DeterminedApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCurrentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CurrentUserResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedCurrentUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the template with the given id.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDeleteTemplate(templateName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeleteTemplateResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedDeleteTemplate(templateName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Disable the agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDisableAgent(agentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DisableAgentResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedDisableAgent(agentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Disable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDisableSlot(agentId: string, slotId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DisableSlotResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedDisableSlot(agentId, slotId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Enable the agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedEnableAgent(agentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1EnableAgentResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedEnableAgent(agentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Enable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedEnableSlot(agentId: string, slotId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1EnableSlotResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedEnableSlot(agentId, slotId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetAgent(agentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetAgentResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedGetAgent(agentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a set of agents from the cluster
         * @param {string} [label] Filter agents by their label. If no label is specified or is empty, all agents are returned.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME'} [sortBy] Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetAgents(label?: string, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetAgentsResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedGetAgents(label, sortBy, orderBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of experiments.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER'} [sortBy] Sort experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end times are returned after experiments that are.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order experiments in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of experiments before returning results. Negative values denote number of experiments to skip from the end before returning results.
         * @param {number} [limit] Limit the number of experiments. A value of 0 denotes no limit.
         * @param {string} [description] Limit experiments to those that match the description.
         * @param {boolean} [archived] Limit experiments to those that are archived.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED'>} [states] Limit experiments to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.
         * @param {Array<string>} [users] Limit experiments to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperiments(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, description?: string, archived?: boolean, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED'>, users?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetExperimentsResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedGetExperiments(sortBy, orderBy, offset, limit, description, archived, states, users, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get master information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetMaster(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetMasterResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedGetMaster(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested model.
         * @param {string} modelName The name of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModel(modelName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetModelResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedGetModel(modelName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested slot for the agent with the given id.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetSlot(agentId: string, slotId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetSlotResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedGetSlot(agentId, slotId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the set of slots for the agent with the given id.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetSlots(agentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetSlotsResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedGetSlots(agentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTemplate(templateName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTemplateResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedGetTemplate(templateName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of templates.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order templates in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTemplates(orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetTemplatesResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedGetTemplates(orderBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the requested user.
         * @param {string} username The username of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetUser(username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetUserResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedGetUser(username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetUsersResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedGetUsers(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Login the user.
         * @param {V1LoginRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLogin(body: V1LoginRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LoginResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedLogin(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Logout the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LogoutResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedLogout(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a model in the registry.
         * @param {string} modelName The name of the model.
         * @param {V1Model} body The model to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostModel(modelName: string, body: V1Model, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostModelResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedPostModel(modelName, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new user.
         * @param {V1PostUserRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostUser(body: V1PostUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PostUserResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedPostUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the requested template. If one does not exist, a new template is created
         * @param {string} templateName The name of the template.
         * @param {V1Template} body The template to put.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPutTemplate(templateName: string, body: V1Template, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PutTemplateResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedPutTemplate(templateName, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the requested user's passwords.
         * @param {string} username The username of the user.
         * @param {string} body The password of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetUserPassword(username: string, body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SetUserPasswordResponse> {
            const localVarFetchArgs = DeterminedApiFetchParamCreator(configuration).determinedSetUserPassword(username, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeterminedApi - factory interface
 * @export
 */
export const DeterminedApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedCurrentUser(options?: any) {
            return DeterminedApiFp(configuration).determinedCurrentUser(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the template with the given id.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDeleteTemplate(templateName: string, options?: any) {
            return DeterminedApiFp(configuration).determinedDeleteTemplate(templateName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Disable the agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDisableAgent(agentId: string, options?: any) {
            return DeterminedApiFp(configuration).determinedDisableAgent(agentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Disable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedDisableSlot(agentId: string, slotId: string, options?: any) {
            return DeterminedApiFp(configuration).determinedDisableSlot(agentId, slotId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Enable the agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedEnableAgent(agentId: string, options?: any) {
            return DeterminedApiFp(configuration).determinedEnableAgent(agentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Enable the slot.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedEnableSlot(agentId: string, slotId: string, options?: any) {
            return DeterminedApiFp(configuration).determinedEnableSlot(agentId, slotId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested agent.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetAgent(agentId: string, options?: any) {
            return DeterminedApiFp(configuration).determinedGetAgent(agentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a set of agents from the cluster
         * @param {string} [label] Filter agents by their label. If no label is specified or is empty, all agents are returned.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME'} [sortBy] Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetAgents(label?: string, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options?: any) {
            return DeterminedApiFp(configuration).determinedGetAgents(label, sortBy, orderBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of experiments.
         * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER'} [sortBy] Sort experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end times are returned after experiments that are.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order experiments in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {number} [offset] Skip the number of experiments before returning results. Negative values denote number of experiments to skip from the end before returning results.
         * @param {number} [limit] Limit the number of experiments. A value of 0 denotes no limit.
         * @param {string} [description] Limit experiments to those that match the description.
         * @param {boolean} [archived] Limit experiments to those that are archived.
         * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED'>} [states] Limit experiments to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.
         * @param {Array<string>} [users] Limit experiments to those that are owned by the specified users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetExperiments(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, description?: string, archived?: boolean, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED'>, users?: Array<string>, options?: any) {
            return DeterminedApiFp(configuration).determinedGetExperiments(sortBy, orderBy, offset, limit, description, archived, states, users, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get master information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetMaster(options?: any) {
            return DeterminedApiFp(configuration).determinedGetMaster(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested model.
         * @param {string} modelName The name of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetModel(modelName: string, options?: any) {
            return DeterminedApiFp(configuration).determinedGetModel(modelName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested slot for the agent with the given id.
         * @param {string} agentId The id of the agent.
         * @param {string} slotId The id of the slot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetSlot(agentId: string, slotId: string, options?: any) {
            return DeterminedApiFp(configuration).determinedGetSlot(agentId, slotId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the set of slots for the agent with the given id.
         * @param {string} agentId The id of the agent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetSlots(agentId: string, options?: any) {
            return DeterminedApiFp(configuration).determinedGetSlots(agentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested template.
         * @param {string} templateName The id of the template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTemplate(templateName: string, options?: any) {
            return DeterminedApiFp(configuration).determinedGetTemplate(templateName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of templates.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order templates in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetTemplates(orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options?: any) {
            return DeterminedApiFp(configuration).determinedGetTemplates(orderBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the requested user.
         * @param {string} username The username of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetUser(username: string, options?: any) {
            return DeterminedApiFp(configuration).determinedGetUser(username, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedGetUsers(options?: any) {
            return DeterminedApiFp(configuration).determinedGetUsers(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login the user.
         * @param {V1LoginRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLogin(body: V1LoginRequest, options?: any) {
            return DeterminedApiFp(configuration).determinedLogin(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logout the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedLogout(options?: any) {
            return DeterminedApiFp(configuration).determinedLogout(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a model in the registry.
         * @param {string} modelName The name of the model.
         * @param {V1Model} body The model to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostModel(modelName: string, body: V1Model, options?: any) {
            return DeterminedApiFp(configuration).determinedPostModel(modelName, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new user.
         * @param {V1PostUserRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPostUser(body: V1PostUserRequest, options?: any) {
            return DeterminedApiFp(configuration).determinedPostUser(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the requested template. If one does not exist, a new template is created
         * @param {string} templateName The name of the template.
         * @param {V1Template} body The template to put.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedPutTemplate(templateName: string, body: V1Template, options?: any) {
            return DeterminedApiFp(configuration).determinedPutTemplate(templateName, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the requested user's passwords.
         * @param {string} username The username of the user.
         * @param {string} body The password of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        determinedSetUserPassword(username: string, body: string, options?: any) {
            return DeterminedApiFp(configuration).determinedSetUserPassword(username, body, options)(fetch, basePath);
        },
    };
};

/**
 * DeterminedApi - object-oriented interface
 * @export
 * @class DeterminedApi
 * @extends {BaseAPI}
 */
export class DeterminedApi extends BaseAPI {
    /**
     * 
     * @summary Get the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedCurrentUser(options?: any) {
        return DeterminedApiFp(this.configuration).determinedCurrentUser(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the template with the given id.
     * @param {string} templateName The id of the template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedDeleteTemplate(templateName: string, options?: any) {
        return DeterminedApiFp(this.configuration).determinedDeleteTemplate(templateName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Disable the agent.
     * @param {string} agentId The id of the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedDisableAgent(agentId: string, options?: any) {
        return DeterminedApiFp(this.configuration).determinedDisableAgent(agentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Disable the slot.
     * @param {string} agentId The id of the agent.
     * @param {string} slotId The id of the slot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedDisableSlot(agentId: string, slotId: string, options?: any) {
        return DeterminedApiFp(this.configuration).determinedDisableSlot(agentId, slotId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Enable the agent.
     * @param {string} agentId The id of the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedEnableAgent(agentId: string, options?: any) {
        return DeterminedApiFp(this.configuration).determinedEnableAgent(agentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Enable the slot.
     * @param {string} agentId The id of the agent.
     * @param {string} slotId The id of the slot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedEnableSlot(agentId: string, slotId: string, options?: any) {
        return DeterminedApiFp(this.configuration).determinedEnableSlot(agentId, slotId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the requested agent.
     * @param {string} agentId The id of the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedGetAgent(agentId: string, options?: any) {
        return DeterminedApiFp(this.configuration).determinedGetAgent(agentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a set of agents from the cluster
     * @param {string} [label] Filter agents by their label. If no label is specified or is empty, all agents are returned.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME'} [sortBy] Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedGetAgents(label?: string, sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_TIME', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options?: any) {
        return DeterminedApiFp(this.configuration).determinedGetAgents(label, sortBy, orderBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of experiments.
     * @param {'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER'} [sortBy] Sort experiments by the given field.   - SORT_BY_UNSPECIFIED: Returns experiments in an unsorted list.  - SORT_BY_ID: Returns experiments sorted by id.  - SORT_BY_DESCRIPTION: Returns experiments sorted by description.  - SORT_BY_START_TIME: Return experiments sorted by start time.  - SORT_BY_END_TIME: Return experiments sorted by end time. Experiments without end times are returned after experiments that are.  - SORT_BY_STATE: Return experiments sorted by state.  - SORT_BY_NUM_TRIALS: Return experiments sorted by number of trials.  - SORT_BY_PROGRESS: Return experiments sorted by progress.  - SORT_BY_USER: Return experiments sorted by user.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order experiments in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {number} [offset] Skip the number of experiments before returning results. Negative values denote number of experiments to skip from the end before returning results.
     * @param {number} [limit] Limit the number of experiments. A value of 0 denotes no limit.
     * @param {string} [description] Limit experiments to those that match the description.
     * @param {boolean} [archived] Limit experiments to those that are archived.
     * @param {Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED'>} [states] Limit experiments to those that match the provided state.   - STATE_UNSPECIFIED: The state of the experiment is unknown.  - STATE_ACTIVE: The experiment is in an active state.  - STATE_PAUSED: The experiment is in a paused state  - STATE_STOPPING_COMPLETED: The experiment is completed and is shutting down.  - STATE_STOPPING_CANCELED: The experiment is canceled and is shutting down.  - STATE_STOPPING_ERROR: The experiment is errored and is shutting down.  - STATE_COMPLETED: The experiment is completed and is shut down.  - STATE_CANCELED: The experiment is canceled and is shut down.  - STATE_ERROR: The experiment is errored and is shut down.  - STATE_DELETED: The experiment has been deleted.
     * @param {Array<string>} [users] Limit experiments to those that are owned by the specified users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedGetExperiments(sortBy?: 'SORT_BY_UNSPECIFIED' | 'SORT_BY_ID' | 'SORT_BY_DESCRIPTION' | 'SORT_BY_START_TIME' | 'SORT_BY_END_TIME' | 'SORT_BY_STATE' | 'SORT_BY_NUM_TRIALS' | 'SORT_BY_PROGRESS' | 'SORT_BY_USER', orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', offset?: number, limit?: number, description?: string, archived?: boolean, states?: Array<'STATE_UNSPECIFIED' | 'STATE_ACTIVE' | 'STATE_PAUSED' | 'STATE_STOPPING_COMPLETED' | 'STATE_STOPPING_CANCELED' | 'STATE_STOPPING_ERROR' | 'STATE_COMPLETED' | 'STATE_CANCELED' | 'STATE_ERROR' | 'STATE_DELETED'>, users?: Array<string>, options?: any) {
        return DeterminedApiFp(this.configuration).determinedGetExperiments(sortBy, orderBy, offset, limit, description, archived, states, users, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get master information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedGetMaster(options?: any) {
        return DeterminedApiFp(this.configuration).determinedGetMaster(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the requested model.
     * @param {string} modelName The name of the template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedGetModel(modelName: string, options?: any) {
        return DeterminedApiFp(this.configuration).determinedGetModel(modelName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the requested slot for the agent with the given id.
     * @param {string} agentId The id of the agent.
     * @param {string} slotId The id of the slot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedGetSlot(agentId: string, slotId: string, options?: any) {
        return DeterminedApiFp(this.configuration).determinedGetSlot(agentId, slotId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the set of slots for the agent with the given id.
     * @param {string} agentId The id of the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedGetSlots(agentId: string, options?: any) {
        return DeterminedApiFp(this.configuration).determinedGetSlots(agentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the requested template.
     * @param {string} templateName The id of the template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedGetTemplate(templateName: string, options?: any) {
        return DeterminedApiFp(this.configuration).determinedGetTemplate(templateName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of templates.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy] Order templates in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedGetTemplates(orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', options?: any) {
        return DeterminedApiFp(this.configuration).determinedGetTemplates(orderBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the requested user.
     * @param {string} username The username of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedGetUser(username: string, options?: any) {
        return DeterminedApiFp(this.configuration).determinedGetUser(username, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedGetUsers(options?: any) {
        return DeterminedApiFp(this.configuration).determinedGetUsers(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Login the user.
     * @param {V1LoginRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedLogin(body: V1LoginRequest, options?: any) {
        return DeterminedApiFp(this.configuration).determinedLogin(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Logout the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedLogout(options?: any) {
        return DeterminedApiFp(this.configuration).determinedLogout(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a model in the registry.
     * @param {string} modelName The name of the model.
     * @param {V1Model} body The model to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedPostModel(modelName: string, body: V1Model, options?: any) {
        return DeterminedApiFp(this.configuration).determinedPostModel(modelName, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new user.
     * @param {V1PostUserRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedPostUser(body: V1PostUserRequest, options?: any) {
        return DeterminedApiFp(this.configuration).determinedPostUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the requested template. If one does not exist, a new template is created
     * @param {string} templateName The name of the template.
     * @param {V1Template} body The template to put.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedPutTemplate(templateName: string, body: V1Template, options?: any) {
        return DeterminedApiFp(this.configuration).determinedPutTemplate(templateName, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set the requested user's passwords.
     * @param {string} username The username of the user.
     * @param {string} body The password of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeterminedApi
     */
    public determinedSetUserPassword(username: string, body: string, options?: any) {
        return DeterminedApiFp(this.configuration).determinedSetUserPassword(username, body, options)(this.fetch, this.basePath);
    }

}

