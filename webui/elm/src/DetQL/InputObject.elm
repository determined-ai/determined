-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module DetQL.InputObject exposing (..)

import CustomScalarCodecs
import DetQL.Enum.Order_by
import DetQL.Interface
import DetQL.Object
import DetQL.Scalar
import DetQL.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAgent_user_groups_aggregate_order_by : (Agent_user_groups_aggregate_order_byOptionalFields -> Agent_user_groups_aggregate_order_byOptionalFields) -> Agent_user_groups_aggregate_order_by
buildAgent_user_groups_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Agent_user_groups_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Agent_user_groups_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Agent_user_groups_max_order_by
    , min : OptionalArgument Agent_user_groups_min_order_by
    , stddev : OptionalArgument Agent_user_groups_stddev_order_by
    , stddev_pop : OptionalArgument Agent_user_groups_stddev_pop_order_by
    , stddev_samp : OptionalArgument Agent_user_groups_stddev_samp_order_by
    , sum : OptionalArgument Agent_user_groups_sum_order_by
    , var_pop : OptionalArgument Agent_user_groups_var_pop_order_by
    , var_samp : OptionalArgument Agent_user_groups_var_samp_order_by
    , variance : OptionalArgument Agent_user_groups_variance_order_by
    }


{-| Type for the Agent\_user\_groups\_aggregate\_order\_by input object.
-}
type alias Agent_user_groups_aggregate_order_by =
    { avg : OptionalArgument Agent_user_groups_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Agent_user_groups_max_order_by
    , min : OptionalArgument Agent_user_groups_min_order_by
    , stddev : OptionalArgument Agent_user_groups_stddev_order_by
    , stddev_pop : OptionalArgument Agent_user_groups_stddev_pop_order_by
    , stddev_samp : OptionalArgument Agent_user_groups_stddev_samp_order_by
    , sum : OptionalArgument Agent_user_groups_sum_order_by
    , var_pop : OptionalArgument Agent_user_groups_var_pop_order_by
    , var_samp : OptionalArgument Agent_user_groups_var_samp_order_by
    , variance : OptionalArgument Agent_user_groups_variance_order_by
    }


{-| Encode a Agent\_user\_groups\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeAgent_user_groups_aggregate_order_by : Agent_user_groups_aggregate_order_by -> Value
encodeAgent_user_groups_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeAgent_user_groups_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeAgent_user_groups_max_order_by |> Encode.optional input.max ), ( "min", encodeAgent_user_groups_min_order_by |> Encode.optional input.min ), ( "stddev", encodeAgent_user_groups_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeAgent_user_groups_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeAgent_user_groups_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeAgent_user_groups_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeAgent_user_groups_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeAgent_user_groups_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeAgent_user_groups_variance_order_by |> Encode.optional input.variance ) ]


buildAgent_user_groups_avg_order_by : (Agent_user_groups_avg_order_byOptionalFields -> Agent_user_groups_avg_order_byOptionalFields) -> Agent_user_groups_avg_order_by
buildAgent_user_groups_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { gid = Absent, id = Absent, uid = Absent, user_id = Absent }
    in
    { gid = optionals.gid, id = optionals.id, uid = optionals.uid, user_id = optionals.user_id }


type alias Agent_user_groups_avg_order_byOptionalFields =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Agent\_user\_groups\_avg\_order\_by input object.
-}
type alias Agent_user_groups_avg_order_by =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Agent\_user\_groups\_avg\_order\_by into a value that can be used as an argument.
-}
encodeAgent_user_groups_avg_order_by : Agent_user_groups_avg_order_by -> Value
encodeAgent_user_groups_avg_order_by input =
    Encode.maybeObject
        [ ( "gid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.gid ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "uid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.uid ), ( "user_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildAgent_user_groups_bool_exp : (Agent_user_groups_bool_expOptionalFields -> Agent_user_groups_bool_expOptionalFields) -> Agent_user_groups_bool_exp
buildAgent_user_groups_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, gid = Absent, group_ = Absent, id = Absent, uid = Absent, user = Absent, user_ = Absent, user_id = Absent }
    in
    Agent_user_groups_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, gid = optionals.gid, group_ = optionals.group_, id = optionals.id, uid = optionals.uid, user = optionals.user, user_ = optionals.user_, user_id = optionals.user_id }


type alias Agent_user_groups_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Agent_user_groups_bool_exp))
    , not_ : OptionalArgument Agent_user_groups_bool_exp
    , or_ : OptionalArgument (List (Maybe Agent_user_groups_bool_exp))
    , gid : OptionalArgument Int_comparison_exp
    , group_ : OptionalArgument String_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , uid : OptionalArgument Int_comparison_exp
    , user : OptionalArgument Users_bool_exp
    , user_ : OptionalArgument String_comparison_exp
    , user_id : OptionalArgument Int_comparison_exp
    }


{-| Type alias for the `Agent_user_groups_bool_exp` attributes. Note that this type
needs to use the `Agent_user_groups_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Agent_user_groups_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Agent_user_groups_bool_exp))
    , not_ : OptionalArgument Agent_user_groups_bool_exp
    , or_ : OptionalArgument (List (Maybe Agent_user_groups_bool_exp))
    , gid : OptionalArgument Int_comparison_exp
    , group_ : OptionalArgument String_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , uid : OptionalArgument Int_comparison_exp
    , user : OptionalArgument Users_bool_exp
    , user_ : OptionalArgument String_comparison_exp
    , user_id : OptionalArgument Int_comparison_exp
    }


{-| Type for the Agent\_user\_groups\_bool\_exp input object.
-}
type Agent_user_groups_bool_exp
    = Agent_user_groups_bool_exp Agent_user_groups_bool_expRaw


{-| Encode a Agent\_user\_groups\_bool\_exp into a value that can be used as an argument.
-}
encodeAgent_user_groups_bool_exp : Agent_user_groups_bool_exp -> Value
encodeAgent_user_groups_bool_exp (Agent_user_groups_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeAgent_user_groups_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeAgent_user_groups_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeAgent_user_groups_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "gid", encodeInt_comparison_exp |> Encode.optional input.gid ), ( "group_", encodeString_comparison_exp |> Encode.optional input.group_ ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "uid", encodeInt_comparison_exp |> Encode.optional input.uid ), ( "user", encodeUsers_bool_exp |> Encode.optional input.user ), ( "user_", encodeString_comparison_exp |> Encode.optional input.user_ ), ( "user_id", encodeInt_comparison_exp |> Encode.optional input.user_id ) ]


buildAgent_user_groups_max_order_by : (Agent_user_groups_max_order_byOptionalFields -> Agent_user_groups_max_order_byOptionalFields) -> Agent_user_groups_max_order_by
buildAgent_user_groups_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { gid = Absent, group_ = Absent, id = Absent, uid = Absent, user_ = Absent, user_id = Absent }
    in
    { gid = optionals.gid, group_ = optionals.group_, id = optionals.id, uid = optionals.uid, user_ = optionals.user_, user_id = optionals.user_id }


type alias Agent_user_groups_max_order_byOptionalFields =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , group_ : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_ : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Agent\_user\_groups\_max\_order\_by input object.
-}
type alias Agent_user_groups_max_order_by =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , group_ : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_ : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Agent\_user\_groups\_max\_order\_by into a value that can be used as an argument.
-}
encodeAgent_user_groups_max_order_by : Agent_user_groups_max_order_by -> Value
encodeAgent_user_groups_max_order_by input =
    Encode.maybeObject
        [ ( "gid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.gid ), ( "group_", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.group_ ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "uid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.uid ), ( "user_", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_ ), ( "user_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildAgent_user_groups_min_order_by : (Agent_user_groups_min_order_byOptionalFields -> Agent_user_groups_min_order_byOptionalFields) -> Agent_user_groups_min_order_by
buildAgent_user_groups_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { gid = Absent, group_ = Absent, id = Absent, uid = Absent, user_ = Absent, user_id = Absent }
    in
    { gid = optionals.gid, group_ = optionals.group_, id = optionals.id, uid = optionals.uid, user_ = optionals.user_, user_id = optionals.user_id }


type alias Agent_user_groups_min_order_byOptionalFields =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , group_ : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_ : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Agent\_user\_groups\_min\_order\_by input object.
-}
type alias Agent_user_groups_min_order_by =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , group_ : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_ : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Agent\_user\_groups\_min\_order\_by into a value that can be used as an argument.
-}
encodeAgent_user_groups_min_order_by : Agent_user_groups_min_order_by -> Value
encodeAgent_user_groups_min_order_by input =
    Encode.maybeObject
        [ ( "gid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.gid ), ( "group_", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.group_ ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "uid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.uid ), ( "user_", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_ ), ( "user_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildAgent_user_groups_order_by : (Agent_user_groups_order_byOptionalFields -> Agent_user_groups_order_byOptionalFields) -> Agent_user_groups_order_by
buildAgent_user_groups_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { gid = Absent, group_ = Absent, id = Absent, uid = Absent, user = Absent, user_ = Absent, user_id = Absent }
    in
    Agent_user_groups_order_by { gid = optionals.gid, group_ = optionals.group_, id = optionals.id, uid = optionals.uid, user = optionals.user, user_ = optionals.user_, user_id = optionals.user_id }


type alias Agent_user_groups_order_byOptionalFields =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , group_ : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    , user_ : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Agent_user_groups_order_by` attributes. Note that this type
needs to use the `Agent_user_groups_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Agent_user_groups_order_byRaw =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , group_ : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    , user_ : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Agent\_user\_groups\_order\_by input object.
-}
type Agent_user_groups_order_by
    = Agent_user_groups_order_by Agent_user_groups_order_byRaw


{-| Encode a Agent\_user\_groups\_order\_by into a value that can be used as an argument.
-}
encodeAgent_user_groups_order_by : Agent_user_groups_order_by -> Value
encodeAgent_user_groups_order_by (Agent_user_groups_order_by input) =
    Encode.maybeObject
        [ ( "gid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.gid ), ( "group_", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.group_ ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "uid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.uid ), ( "user", encodeUsers_order_by |> Encode.optional input.user ), ( "user_", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_ ), ( "user_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildAgent_user_groups_stddev_order_by : (Agent_user_groups_stddev_order_byOptionalFields -> Agent_user_groups_stddev_order_byOptionalFields) -> Agent_user_groups_stddev_order_by
buildAgent_user_groups_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { gid = Absent, id = Absent, uid = Absent, user_id = Absent }
    in
    { gid = optionals.gid, id = optionals.id, uid = optionals.uid, user_id = optionals.user_id }


type alias Agent_user_groups_stddev_order_byOptionalFields =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Agent\_user\_groups\_stddev\_order\_by input object.
-}
type alias Agent_user_groups_stddev_order_by =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Agent\_user\_groups\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeAgent_user_groups_stddev_order_by : Agent_user_groups_stddev_order_by -> Value
encodeAgent_user_groups_stddev_order_by input =
    Encode.maybeObject
        [ ( "gid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.gid ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "uid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.uid ), ( "user_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildAgent_user_groups_stddev_pop_order_by : (Agent_user_groups_stddev_pop_order_byOptionalFields -> Agent_user_groups_stddev_pop_order_byOptionalFields) -> Agent_user_groups_stddev_pop_order_by
buildAgent_user_groups_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { gid = Absent, id = Absent, uid = Absent, user_id = Absent }
    in
    { gid = optionals.gid, id = optionals.id, uid = optionals.uid, user_id = optionals.user_id }


type alias Agent_user_groups_stddev_pop_order_byOptionalFields =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Agent\_user\_groups\_stddev\_pop\_order\_by input object.
-}
type alias Agent_user_groups_stddev_pop_order_by =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Agent\_user\_groups\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeAgent_user_groups_stddev_pop_order_by : Agent_user_groups_stddev_pop_order_by -> Value
encodeAgent_user_groups_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "gid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.gid ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "uid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.uid ), ( "user_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildAgent_user_groups_stddev_samp_order_by : (Agent_user_groups_stddev_samp_order_byOptionalFields -> Agent_user_groups_stddev_samp_order_byOptionalFields) -> Agent_user_groups_stddev_samp_order_by
buildAgent_user_groups_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { gid = Absent, id = Absent, uid = Absent, user_id = Absent }
    in
    { gid = optionals.gid, id = optionals.id, uid = optionals.uid, user_id = optionals.user_id }


type alias Agent_user_groups_stddev_samp_order_byOptionalFields =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Agent\_user\_groups\_stddev\_samp\_order\_by input object.
-}
type alias Agent_user_groups_stddev_samp_order_by =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Agent\_user\_groups\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeAgent_user_groups_stddev_samp_order_by : Agent_user_groups_stddev_samp_order_by -> Value
encodeAgent_user_groups_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "gid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.gid ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "uid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.uid ), ( "user_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildAgent_user_groups_sum_order_by : (Agent_user_groups_sum_order_byOptionalFields -> Agent_user_groups_sum_order_byOptionalFields) -> Agent_user_groups_sum_order_by
buildAgent_user_groups_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { gid = Absent, id = Absent, uid = Absent, user_id = Absent }
    in
    { gid = optionals.gid, id = optionals.id, uid = optionals.uid, user_id = optionals.user_id }


type alias Agent_user_groups_sum_order_byOptionalFields =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Agent\_user\_groups\_sum\_order\_by input object.
-}
type alias Agent_user_groups_sum_order_by =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Agent\_user\_groups\_sum\_order\_by into a value that can be used as an argument.
-}
encodeAgent_user_groups_sum_order_by : Agent_user_groups_sum_order_by -> Value
encodeAgent_user_groups_sum_order_by input =
    Encode.maybeObject
        [ ( "gid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.gid ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "uid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.uid ), ( "user_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildAgent_user_groups_var_pop_order_by : (Agent_user_groups_var_pop_order_byOptionalFields -> Agent_user_groups_var_pop_order_byOptionalFields) -> Agent_user_groups_var_pop_order_by
buildAgent_user_groups_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { gid = Absent, id = Absent, uid = Absent, user_id = Absent }
    in
    { gid = optionals.gid, id = optionals.id, uid = optionals.uid, user_id = optionals.user_id }


type alias Agent_user_groups_var_pop_order_byOptionalFields =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Agent\_user\_groups\_var\_pop\_order\_by input object.
-}
type alias Agent_user_groups_var_pop_order_by =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Agent\_user\_groups\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeAgent_user_groups_var_pop_order_by : Agent_user_groups_var_pop_order_by -> Value
encodeAgent_user_groups_var_pop_order_by input =
    Encode.maybeObject
        [ ( "gid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.gid ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "uid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.uid ), ( "user_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildAgent_user_groups_var_samp_order_by : (Agent_user_groups_var_samp_order_byOptionalFields -> Agent_user_groups_var_samp_order_byOptionalFields) -> Agent_user_groups_var_samp_order_by
buildAgent_user_groups_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { gid = Absent, id = Absent, uid = Absent, user_id = Absent }
    in
    { gid = optionals.gid, id = optionals.id, uid = optionals.uid, user_id = optionals.user_id }


type alias Agent_user_groups_var_samp_order_byOptionalFields =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Agent\_user\_groups\_var\_samp\_order\_by input object.
-}
type alias Agent_user_groups_var_samp_order_by =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Agent\_user\_groups\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeAgent_user_groups_var_samp_order_by : Agent_user_groups_var_samp_order_by -> Value
encodeAgent_user_groups_var_samp_order_by input =
    Encode.maybeObject
        [ ( "gid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.gid ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "uid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.uid ), ( "user_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildAgent_user_groups_variance_order_by : (Agent_user_groups_variance_order_byOptionalFields -> Agent_user_groups_variance_order_byOptionalFields) -> Agent_user_groups_variance_order_by
buildAgent_user_groups_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { gid = Absent, id = Absent, uid = Absent, user_id = Absent }
    in
    { gid = optionals.gid, id = optionals.id, uid = optionals.uid, user_id = optionals.user_id }


type alias Agent_user_groups_variance_order_byOptionalFields =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Agent\_user\_groups\_variance\_order\_by input object.
-}
type alias Agent_user_groups_variance_order_by =
    { gid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , uid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , user_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Agent\_user\_groups\_variance\_order\_by into a value that can be used as an argument.
-}
encodeAgent_user_groups_variance_order_by : Agent_user_groups_variance_order_by -> Value
encodeAgent_user_groups_variance_order_by input =
    Encode.maybeObject
        [ ( "gid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.gid ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "uid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.uid ), ( "user_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildBest_checkpoint_by_metric_args : (Best_checkpoint_by_metric_argsOptionalFields -> Best_checkpoint_by_metric_argsOptionalFields) -> Best_checkpoint_by_metric_args
buildBest_checkpoint_by_metric_args fillOptionals =
    let
        optionals =
            fillOptionals
                { metric = Absent, smaller_is_better = Absent, tid = Absent }
    in
    { metric = optionals.metric, smaller_is_better = optionals.smaller_is_better, tid = optionals.tid }


type alias Best_checkpoint_by_metric_argsOptionalFields =
    { metric : OptionalArgument String
    , smaller_is_better : OptionalArgument Bool
    , tid : OptionalArgument Int
    }


{-| Type for the Best\_checkpoint\_by\_metric\_args input object.
-}
type alias Best_checkpoint_by_metric_args =
    { metric : OptionalArgument String
    , smaller_is_better : OptionalArgument Bool
    , tid : OptionalArgument Int
    }


{-| Encode a Best\_checkpoint\_by\_metric\_args into a value that can be used as an argument.
-}
encodeBest_checkpoint_by_metric_args : Best_checkpoint_by_metric_args -> Value
encodeBest_checkpoint_by_metric_args input =
    Encode.maybeObject
        [ ( "metric", Encode.string |> Encode.optional input.metric ), ( "smaller_is_better", Encode.bool |> Encode.optional input.smaller_is_better ), ( "tid", Encode.int |> Encode.optional input.tid ) ]


buildBoolean_comparison_exp : (Boolean_comparison_expOptionalFields -> Boolean_comparison_expOptionalFields) -> Boolean_comparison_exp
buildBoolean_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Boolean_comparison_expOptionalFields =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Type for the Boolean\_comparison\_exp input object.
-}
type alias Boolean_comparison_exp =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Encode a Boolean\_comparison\_exp into a value that can be used as an argument.
-}
encodeBoolean_comparison_exp : Boolean_comparison_exp -> Value
encodeBoolean_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.bool |> Encode.optional input.eq_ ), ( "_gt", Encode.bool |> Encode.optional input.gt_ ), ( "_gte", Encode.bool |> Encode.optional input.gte_ ), ( "_in", (Encode.bool |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.bool |> Encode.optional input.lt_ ), ( "_lte", Encode.bool |> Encode.optional input.lte_ ), ( "_neq", Encode.bool |> Encode.optional input.neq_ ), ( "_nin", (Encode.bool |> Encode.list) |> Encode.optional input.nin_ ) ]


buildBytea_comparison_exp : (Bytea_comparison_expOptionalFields -> Bytea_comparison_expOptionalFields) -> Bytea_comparison_exp
buildBytea_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Bytea_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalarCodecs.Bytea
    , gt_ : OptionalArgument CustomScalarCodecs.Bytea
    , gte_ : OptionalArgument CustomScalarCodecs.Bytea
    , in_ : OptionalArgument (List CustomScalarCodecs.Bytea)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Bytea
    , lte_ : OptionalArgument CustomScalarCodecs.Bytea
    , neq_ : OptionalArgument CustomScalarCodecs.Bytea
    , nin_ : OptionalArgument (List CustomScalarCodecs.Bytea)
    }


{-| Type for the Bytea\_comparison\_exp input object.
-}
type alias Bytea_comparison_exp =
    { eq_ : OptionalArgument CustomScalarCodecs.Bytea
    , gt_ : OptionalArgument CustomScalarCodecs.Bytea
    , gte_ : OptionalArgument CustomScalarCodecs.Bytea
    , in_ : OptionalArgument (List CustomScalarCodecs.Bytea)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Bytea
    , lte_ : OptionalArgument CustomScalarCodecs.Bytea
    , neq_ : OptionalArgument CustomScalarCodecs.Bytea
    , nin_ : OptionalArgument (List CustomScalarCodecs.Bytea)
    }


{-| Encode a Bytea\_comparison\_exp into a value that can be used as an argument.
-}
encodeBytea_comparison_exp : Bytea_comparison_exp -> Value
encodeBytea_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecBytea) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecBytea) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecBytea) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecBytea) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecBytea) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecBytea) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecBytea) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecBytea) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildCheckpoint_state_comparison_exp : (Checkpoint_state_comparison_expOptionalFields -> Checkpoint_state_comparison_expOptionalFields) -> Checkpoint_state_comparison_exp
buildCheckpoint_state_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Checkpoint_state_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalarCodecs.Checkpoint_state
    , gt_ : OptionalArgument CustomScalarCodecs.Checkpoint_state
    , gte_ : OptionalArgument CustomScalarCodecs.Checkpoint_state
    , in_ : OptionalArgument (List CustomScalarCodecs.Checkpoint_state)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Checkpoint_state
    , lte_ : OptionalArgument CustomScalarCodecs.Checkpoint_state
    , neq_ : OptionalArgument CustomScalarCodecs.Checkpoint_state
    , nin_ : OptionalArgument (List CustomScalarCodecs.Checkpoint_state)
    }


{-| Type for the Checkpoint\_state\_comparison\_exp input object.
-}
type alias Checkpoint_state_comparison_exp =
    { eq_ : OptionalArgument CustomScalarCodecs.Checkpoint_state
    , gt_ : OptionalArgument CustomScalarCodecs.Checkpoint_state
    , gte_ : OptionalArgument CustomScalarCodecs.Checkpoint_state
    , in_ : OptionalArgument (List CustomScalarCodecs.Checkpoint_state)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Checkpoint_state
    , lte_ : OptionalArgument CustomScalarCodecs.Checkpoint_state
    , neq_ : OptionalArgument CustomScalarCodecs.Checkpoint_state
    , nin_ : OptionalArgument (List CustomScalarCodecs.Checkpoint_state)
    }


{-| Encode a Checkpoint\_state\_comparison\_exp into a value that can be used as an argument.
-}
encodeCheckpoint_state_comparison_exp : Checkpoint_state_comparison_exp -> Value
encodeCheckpoint_state_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecCheckpoint_state) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecCheckpoint_state) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecCheckpoint_state) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecCheckpoint_state) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecCheckpoint_state) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecCheckpoint_state) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecCheckpoint_state) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecCheckpoint_state) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildCheckpoints_aggregate_order_by : (Checkpoints_aggregate_order_byOptionalFields -> Checkpoints_aggregate_order_byOptionalFields) -> Checkpoints_aggregate_order_by
buildCheckpoints_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Checkpoints_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Checkpoints_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Checkpoints_max_order_by
    , min : OptionalArgument Checkpoints_min_order_by
    , stddev : OptionalArgument Checkpoints_stddev_order_by
    , stddev_pop : OptionalArgument Checkpoints_stddev_pop_order_by
    , stddev_samp : OptionalArgument Checkpoints_stddev_samp_order_by
    , sum : OptionalArgument Checkpoints_sum_order_by
    , var_pop : OptionalArgument Checkpoints_var_pop_order_by
    , var_samp : OptionalArgument Checkpoints_var_samp_order_by
    , variance : OptionalArgument Checkpoints_variance_order_by
    }


{-| Type for the Checkpoints\_aggregate\_order\_by input object.
-}
type alias Checkpoints_aggregate_order_by =
    { avg : OptionalArgument Checkpoints_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Checkpoints_max_order_by
    , min : OptionalArgument Checkpoints_min_order_by
    , stddev : OptionalArgument Checkpoints_stddev_order_by
    , stddev_pop : OptionalArgument Checkpoints_stddev_pop_order_by
    , stddev_samp : OptionalArgument Checkpoints_stddev_samp_order_by
    , sum : OptionalArgument Checkpoints_sum_order_by
    , var_pop : OptionalArgument Checkpoints_var_pop_order_by
    , var_samp : OptionalArgument Checkpoints_var_samp_order_by
    , variance : OptionalArgument Checkpoints_variance_order_by
    }


{-| Encode a Checkpoints\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeCheckpoints_aggregate_order_by : Checkpoints_aggregate_order_by -> Value
encodeCheckpoints_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeCheckpoints_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeCheckpoints_max_order_by |> Encode.optional input.max ), ( "min", encodeCheckpoints_min_order_by |> Encode.optional input.min ), ( "stddev", encodeCheckpoints_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeCheckpoints_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeCheckpoints_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeCheckpoints_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeCheckpoints_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeCheckpoints_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeCheckpoints_variance_order_by |> Encode.optional input.variance ) ]


buildCheckpoints_avg_order_by : (Checkpoints_avg_order_byOptionalFields -> Checkpoints_avg_order_byOptionalFields) -> Checkpoints_avg_order_by
buildCheckpoints_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Checkpoints_avg_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Checkpoints\_avg\_order\_by input object.
-}
type alias Checkpoints_avg_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Checkpoints\_avg\_order\_by into a value that can be used as an argument.
-}
encodeCheckpoints_avg_order_by : Checkpoints_avg_order_by -> Value
encodeCheckpoints_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildCheckpoints_bool_exp : (Checkpoints_bool_expOptionalFields -> Checkpoints_bool_expOptionalFields) -> Checkpoints_bool_exp
buildCheckpoints_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, end_time = Absent, id = Absent, labels = Absent, resources = Absent, start_time = Absent, state = Absent, step = Absent, step_id = Absent, trial_id = Absent, trials = Absent, uuid = Absent, validation = Absent }
    in
    Checkpoints_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, end_time = optionals.end_time, id = optionals.id, labels = optionals.labels, resources = optionals.resources, start_time = optionals.start_time, state = optionals.state, step = optionals.step, step_id = optionals.step_id, trial_id = optionals.trial_id, trials = optionals.trials, uuid = optionals.uuid, validation = optionals.validation }


type alias Checkpoints_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Checkpoints_bool_exp))
    , not_ : OptionalArgument Checkpoints_bool_exp
    , or_ : OptionalArgument (List (Maybe Checkpoints_bool_exp))
    , end_time : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , labels : OptionalArgument Jsonb_comparison_exp
    , resources : OptionalArgument Jsonb_comparison_exp
    , start_time : OptionalArgument Timestamptz_comparison_exp
    , state : OptionalArgument Checkpoint_state_comparison_exp
    , step : OptionalArgument Steps_bool_exp
    , step_id : OptionalArgument Int_comparison_exp
    , trial_id : OptionalArgument Int_comparison_exp
    , trials : OptionalArgument Trials_bool_exp
    , uuid : OptionalArgument Uuid_comparison_exp
    , validation : OptionalArgument Validations_bool_exp
    }


{-| Type alias for the `Checkpoints_bool_exp` attributes. Note that this type
needs to use the `Checkpoints_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Checkpoints_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Checkpoints_bool_exp))
    , not_ : OptionalArgument Checkpoints_bool_exp
    , or_ : OptionalArgument (List (Maybe Checkpoints_bool_exp))
    , end_time : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , labels : OptionalArgument Jsonb_comparison_exp
    , resources : OptionalArgument Jsonb_comparison_exp
    , start_time : OptionalArgument Timestamptz_comparison_exp
    , state : OptionalArgument Checkpoint_state_comparison_exp
    , step : OptionalArgument Steps_bool_exp
    , step_id : OptionalArgument Int_comparison_exp
    , trial_id : OptionalArgument Int_comparison_exp
    , trials : OptionalArgument Trials_bool_exp
    , uuid : OptionalArgument Uuid_comparison_exp
    , validation : OptionalArgument Validations_bool_exp
    }


{-| Type for the Checkpoints\_bool\_exp input object.
-}
type Checkpoints_bool_exp
    = Checkpoints_bool_exp Checkpoints_bool_expRaw


{-| Encode a Checkpoints\_bool\_exp into a value that can be used as an argument.
-}
encodeCheckpoints_bool_exp : Checkpoints_bool_exp -> Value
encodeCheckpoints_bool_exp (Checkpoints_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeCheckpoints_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeCheckpoints_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeCheckpoints_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "end_time", encodeTimestamptz_comparison_exp |> Encode.optional input.end_time ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "labels", encodeJsonb_comparison_exp |> Encode.optional input.labels ), ( "resources", encodeJsonb_comparison_exp |> Encode.optional input.resources ), ( "start_time", encodeTimestamptz_comparison_exp |> Encode.optional input.start_time ), ( "state", encodeCheckpoint_state_comparison_exp |> Encode.optional input.state ), ( "step", encodeSteps_bool_exp |> Encode.optional input.step ), ( "step_id", encodeInt_comparison_exp |> Encode.optional input.step_id ), ( "trial_id", encodeInt_comparison_exp |> Encode.optional input.trial_id ), ( "trials", encodeTrials_bool_exp |> Encode.optional input.trials ), ( "uuid", encodeUuid_comparison_exp |> Encode.optional input.uuid ), ( "validation", encodeValidations_bool_exp |> Encode.optional input.validation ) ]


buildCheckpoints_max_order_by : (Checkpoints_max_order_byOptionalFields -> Checkpoints_max_order_byOptionalFields) -> Checkpoints_max_order_by
buildCheckpoints_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { end_time = Absent, id = Absent, start_time = Absent, step_id = Absent, trial_id = Absent }
    in
    { end_time = optionals.end_time, id = optionals.id, start_time = optionals.start_time, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Checkpoints_max_order_byOptionalFields =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Checkpoints\_max\_order\_by input object.
-}
type alias Checkpoints_max_order_by =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Checkpoints\_max\_order\_by into a value that can be used as an argument.
-}
encodeCheckpoints_max_order_by : Checkpoints_max_order_by -> Value
encodeCheckpoints_max_order_by input =
    Encode.maybeObject
        [ ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildCheckpoints_min_order_by : (Checkpoints_min_order_byOptionalFields -> Checkpoints_min_order_byOptionalFields) -> Checkpoints_min_order_by
buildCheckpoints_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { end_time = Absent, id = Absent, start_time = Absent, step_id = Absent, trial_id = Absent }
    in
    { end_time = optionals.end_time, id = optionals.id, start_time = optionals.start_time, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Checkpoints_min_order_byOptionalFields =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Checkpoints\_min\_order\_by input object.
-}
type alias Checkpoints_min_order_by =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Checkpoints\_min\_order\_by into a value that can be used as an argument.
-}
encodeCheckpoints_min_order_by : Checkpoints_min_order_by -> Value
encodeCheckpoints_min_order_by input =
    Encode.maybeObject
        [ ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildCheckpoints_order_by : (Checkpoints_order_byOptionalFields -> Checkpoints_order_byOptionalFields) -> Checkpoints_order_by
buildCheckpoints_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { end_time = Absent, id = Absent, labels = Absent, resources = Absent, start_time = Absent, state = Absent, step = Absent, step_id = Absent, trial_id = Absent, trials_aggregate = Absent, uuid = Absent, validation = Absent }
    in
    Checkpoints_order_by { end_time = optionals.end_time, id = optionals.id, labels = optionals.labels, resources = optionals.resources, start_time = optionals.start_time, state = optionals.state, step = optionals.step, step_id = optionals.step_id, trial_id = optionals.trial_id, trials_aggregate = optionals.trials_aggregate, uuid = optionals.uuid, validation = optionals.validation }


type alias Checkpoints_order_byOptionalFields =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , labels : OptionalArgument DetQL.Enum.Order_by.Order_by
    , resources : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , state : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step : OptionalArgument Steps_order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trials_aggregate : OptionalArgument Trials_aggregate_order_by
    , uuid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , validation : OptionalArgument Validations_order_by
    }


{-| Type alias for the `Checkpoints_order_by` attributes. Note that this type
needs to use the `Checkpoints_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Checkpoints_order_byRaw =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , labels : OptionalArgument DetQL.Enum.Order_by.Order_by
    , resources : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , state : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step : OptionalArgument Steps_order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trials_aggregate : OptionalArgument Trials_aggregate_order_by
    , uuid : OptionalArgument DetQL.Enum.Order_by.Order_by
    , validation : OptionalArgument Validations_order_by
    }


{-| Type for the Checkpoints\_order\_by input object.
-}
type Checkpoints_order_by
    = Checkpoints_order_by Checkpoints_order_byRaw


{-| Encode a Checkpoints\_order\_by into a value that can be used as an argument.
-}
encodeCheckpoints_order_by : Checkpoints_order_by -> Value
encodeCheckpoints_order_by (Checkpoints_order_by input) =
    Encode.maybeObject
        [ ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "labels", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.labels ), ( "resources", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.resources ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ), ( "state", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.state ), ( "step", encodeSteps_order_by |> Encode.optional input.step ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ), ( "trials_aggregate", encodeTrials_aggregate_order_by |> Encode.optional input.trials_aggregate ), ( "uuid", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.uuid ), ( "validation", encodeValidations_order_by |> Encode.optional input.validation ) ]


buildCheckpoints_stddev_order_by : (Checkpoints_stddev_order_byOptionalFields -> Checkpoints_stddev_order_byOptionalFields) -> Checkpoints_stddev_order_by
buildCheckpoints_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Checkpoints_stddev_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Checkpoints\_stddev\_order\_by input object.
-}
type alias Checkpoints_stddev_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Checkpoints\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeCheckpoints_stddev_order_by : Checkpoints_stddev_order_by -> Value
encodeCheckpoints_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildCheckpoints_stddev_pop_order_by : (Checkpoints_stddev_pop_order_byOptionalFields -> Checkpoints_stddev_pop_order_byOptionalFields) -> Checkpoints_stddev_pop_order_by
buildCheckpoints_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Checkpoints_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Checkpoints\_stddev\_pop\_order\_by input object.
-}
type alias Checkpoints_stddev_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Checkpoints\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeCheckpoints_stddev_pop_order_by : Checkpoints_stddev_pop_order_by -> Value
encodeCheckpoints_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildCheckpoints_stddev_samp_order_by : (Checkpoints_stddev_samp_order_byOptionalFields -> Checkpoints_stddev_samp_order_byOptionalFields) -> Checkpoints_stddev_samp_order_by
buildCheckpoints_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Checkpoints_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Checkpoints\_stddev\_samp\_order\_by input object.
-}
type alias Checkpoints_stddev_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Checkpoints\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeCheckpoints_stddev_samp_order_by : Checkpoints_stddev_samp_order_by -> Value
encodeCheckpoints_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildCheckpoints_sum_order_by : (Checkpoints_sum_order_byOptionalFields -> Checkpoints_sum_order_byOptionalFields) -> Checkpoints_sum_order_by
buildCheckpoints_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Checkpoints_sum_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Checkpoints\_sum\_order\_by input object.
-}
type alias Checkpoints_sum_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Checkpoints\_sum\_order\_by into a value that can be used as an argument.
-}
encodeCheckpoints_sum_order_by : Checkpoints_sum_order_by -> Value
encodeCheckpoints_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildCheckpoints_var_pop_order_by : (Checkpoints_var_pop_order_byOptionalFields -> Checkpoints_var_pop_order_byOptionalFields) -> Checkpoints_var_pop_order_by
buildCheckpoints_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Checkpoints_var_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Checkpoints\_var\_pop\_order\_by input object.
-}
type alias Checkpoints_var_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Checkpoints\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeCheckpoints_var_pop_order_by : Checkpoints_var_pop_order_by -> Value
encodeCheckpoints_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildCheckpoints_var_samp_order_by : (Checkpoints_var_samp_order_byOptionalFields -> Checkpoints_var_samp_order_byOptionalFields) -> Checkpoints_var_samp_order_by
buildCheckpoints_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Checkpoints_var_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Checkpoints\_var\_samp\_order\_by input object.
-}
type alias Checkpoints_var_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Checkpoints\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeCheckpoints_var_samp_order_by : Checkpoints_var_samp_order_by -> Value
encodeCheckpoints_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildCheckpoints_variance_order_by : (Checkpoints_variance_order_byOptionalFields -> Checkpoints_variance_order_byOptionalFields) -> Checkpoints_variance_order_by
buildCheckpoints_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Checkpoints_variance_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Checkpoints\_variance\_order\_by input object.
-}
type alias Checkpoints_variance_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Checkpoints\_variance\_order\_by into a value that can be used as an argument.
-}
encodeCheckpoints_variance_order_by : Checkpoints_variance_order_by -> Value
encodeCheckpoints_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildCluster_id_aggregate_order_by : (Cluster_id_aggregate_order_byOptionalFields -> Cluster_id_aggregate_order_byOptionalFields) -> Cluster_id_aggregate_order_by
buildCluster_id_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals.count, max = optionals.max, min = optionals.min }


type alias Cluster_id_aggregate_order_byOptionalFields =
    { count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Cluster_id_max_order_by
    , min : OptionalArgument Cluster_id_min_order_by
    }


{-| Type for the Cluster\_id\_aggregate\_order\_by input object.
-}
type alias Cluster_id_aggregate_order_by =
    { count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Cluster_id_max_order_by
    , min : OptionalArgument Cluster_id_min_order_by
    }


{-| Encode a Cluster\_id\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeCluster_id_aggregate_order_by : Cluster_id_aggregate_order_by -> Value
encodeCluster_id_aggregate_order_by input =
    Encode.maybeObject
        [ ( "count", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeCluster_id_max_order_by |> Encode.optional input.max ), ( "min", encodeCluster_id_min_order_by |> Encode.optional input.min ) ]


buildCluster_id_bool_exp : (Cluster_id_bool_expOptionalFields -> Cluster_id_bool_expOptionalFields) -> Cluster_id_bool_exp
buildCluster_id_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, cluster_id = Absent }
    in
    Cluster_id_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, cluster_id = optionals.cluster_id }


type alias Cluster_id_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Cluster_id_bool_exp))
    , not_ : OptionalArgument Cluster_id_bool_exp
    , or_ : OptionalArgument (List (Maybe Cluster_id_bool_exp))
    , cluster_id : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Cluster_id_bool_exp` attributes. Note that this type
needs to use the `Cluster_id_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Cluster_id_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Cluster_id_bool_exp))
    , not_ : OptionalArgument Cluster_id_bool_exp
    , or_ : OptionalArgument (List (Maybe Cluster_id_bool_exp))
    , cluster_id : OptionalArgument String_comparison_exp
    }


{-| Type for the Cluster\_id\_bool\_exp input object.
-}
type Cluster_id_bool_exp
    = Cluster_id_bool_exp Cluster_id_bool_expRaw


{-| Encode a Cluster\_id\_bool\_exp into a value that can be used as an argument.
-}
encodeCluster_id_bool_exp : Cluster_id_bool_exp -> Value
encodeCluster_id_bool_exp (Cluster_id_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeCluster_id_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeCluster_id_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeCluster_id_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "cluster_id", encodeString_comparison_exp |> Encode.optional input.cluster_id ) ]


buildCluster_id_max_order_by : (Cluster_id_max_order_byOptionalFields -> Cluster_id_max_order_byOptionalFields) -> Cluster_id_max_order_by
buildCluster_id_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { cluster_id = Absent }
    in
    { cluster_id = optionals.cluster_id }


type alias Cluster_id_max_order_byOptionalFields =
    { cluster_id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Cluster\_id\_max\_order\_by input object.
-}
type alias Cluster_id_max_order_by =
    { cluster_id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Cluster\_id\_max\_order\_by into a value that can be used as an argument.
-}
encodeCluster_id_max_order_by : Cluster_id_max_order_by -> Value
encodeCluster_id_max_order_by input =
    Encode.maybeObject
        [ ( "cluster_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.cluster_id ) ]


buildCluster_id_min_order_by : (Cluster_id_min_order_byOptionalFields -> Cluster_id_min_order_byOptionalFields) -> Cluster_id_min_order_by
buildCluster_id_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { cluster_id = Absent }
    in
    { cluster_id = optionals.cluster_id }


type alias Cluster_id_min_order_byOptionalFields =
    { cluster_id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Cluster\_id\_min\_order\_by input object.
-}
type alias Cluster_id_min_order_by =
    { cluster_id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Cluster\_id\_min\_order\_by into a value that can be used as an argument.
-}
encodeCluster_id_min_order_by : Cluster_id_min_order_by -> Value
encodeCluster_id_min_order_by input =
    Encode.maybeObject
        [ ( "cluster_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.cluster_id ) ]


buildCluster_id_order_by : (Cluster_id_order_byOptionalFields -> Cluster_id_order_byOptionalFields) -> Cluster_id_order_by
buildCluster_id_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { cluster_id = Absent }
    in
    { cluster_id = optionals.cluster_id }


type alias Cluster_id_order_byOptionalFields =
    { cluster_id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Cluster\_id\_order\_by input object.
-}
type alias Cluster_id_order_by =
    { cluster_id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Cluster\_id\_order\_by into a value that can be used as an argument.
-}
encodeCluster_id_order_by : Cluster_id_order_by -> Value
encodeCluster_id_order_by input =
    Encode.maybeObject
        [ ( "cluster_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.cluster_id ) ]


buildConfig_files_aggregate_order_by : (Config_files_aggregate_order_byOptionalFields -> Config_files_aggregate_order_byOptionalFields) -> Config_files_aggregate_order_by
buildConfig_files_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Config_files_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Config_files_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Config_files_max_order_by
    , min : OptionalArgument Config_files_min_order_by
    , stddev : OptionalArgument Config_files_stddev_order_by
    , stddev_pop : OptionalArgument Config_files_stddev_pop_order_by
    , stddev_samp : OptionalArgument Config_files_stddev_samp_order_by
    , sum : OptionalArgument Config_files_sum_order_by
    , var_pop : OptionalArgument Config_files_var_pop_order_by
    , var_samp : OptionalArgument Config_files_var_samp_order_by
    , variance : OptionalArgument Config_files_variance_order_by
    }


{-| Type for the Config\_files\_aggregate\_order\_by input object.
-}
type alias Config_files_aggregate_order_by =
    { avg : OptionalArgument Config_files_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Config_files_max_order_by
    , min : OptionalArgument Config_files_min_order_by
    , stddev : OptionalArgument Config_files_stddev_order_by
    , stddev_pop : OptionalArgument Config_files_stddev_pop_order_by
    , stddev_samp : OptionalArgument Config_files_stddev_samp_order_by
    , sum : OptionalArgument Config_files_sum_order_by
    , var_pop : OptionalArgument Config_files_var_pop_order_by
    , var_samp : OptionalArgument Config_files_var_samp_order_by
    , variance : OptionalArgument Config_files_variance_order_by
    }


{-| Encode a Config\_files\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeConfig_files_aggregate_order_by : Config_files_aggregate_order_by -> Value
encodeConfig_files_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeConfig_files_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeConfig_files_max_order_by |> Encode.optional input.max ), ( "min", encodeConfig_files_min_order_by |> Encode.optional input.min ), ( "stddev", encodeConfig_files_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeConfig_files_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeConfig_files_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeConfig_files_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeConfig_files_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeConfig_files_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeConfig_files_variance_order_by |> Encode.optional input.variance ) ]


buildConfig_files_avg_order_by : (Config_files_avg_order_byOptionalFields -> Config_files_avg_order_byOptionalFields) -> Config_files_avg_order_by
buildConfig_files_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Config_files_avg_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Config\_files\_avg\_order\_by input object.
-}
type alias Config_files_avg_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Config\_files\_avg\_order\_by into a value that can be used as an argument.
-}
encodeConfig_files_avg_order_by : Config_files_avg_order_by -> Value
encodeConfig_files_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildConfig_files_bool_exp : (Config_files_bool_expOptionalFields -> Config_files_bool_expOptionalFields) -> Config_files_bool_exp
buildConfig_files_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, content = Absent, id = Absent }
    in
    Config_files_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, content = optionals.content, id = optionals.id }


type alias Config_files_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Config_files_bool_exp))
    , not_ : OptionalArgument Config_files_bool_exp
    , or_ : OptionalArgument (List (Maybe Config_files_bool_exp))
    , content : OptionalArgument Bytea_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    }


{-| Type alias for the `Config_files_bool_exp` attributes. Note that this type
needs to use the `Config_files_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Config_files_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Config_files_bool_exp))
    , not_ : OptionalArgument Config_files_bool_exp
    , or_ : OptionalArgument (List (Maybe Config_files_bool_exp))
    , content : OptionalArgument Bytea_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    }


{-| Type for the Config\_files\_bool\_exp input object.
-}
type Config_files_bool_exp
    = Config_files_bool_exp Config_files_bool_expRaw


{-| Encode a Config\_files\_bool\_exp into a value that can be used as an argument.
-}
encodeConfig_files_bool_exp : Config_files_bool_exp -> Value
encodeConfig_files_bool_exp (Config_files_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeConfig_files_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeConfig_files_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeConfig_files_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "content", encodeBytea_comparison_exp |> Encode.optional input.content ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ) ]


buildConfig_files_max_order_by : (Config_files_max_order_byOptionalFields -> Config_files_max_order_byOptionalFields) -> Config_files_max_order_by
buildConfig_files_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Config_files_max_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Config\_files\_max\_order\_by input object.
-}
type alias Config_files_max_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Config\_files\_max\_order\_by into a value that can be used as an argument.
-}
encodeConfig_files_max_order_by : Config_files_max_order_by -> Value
encodeConfig_files_max_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildConfig_files_min_order_by : (Config_files_min_order_byOptionalFields -> Config_files_min_order_byOptionalFields) -> Config_files_min_order_by
buildConfig_files_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Config_files_min_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Config\_files\_min\_order\_by input object.
-}
type alias Config_files_min_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Config\_files\_min\_order\_by into a value that can be used as an argument.
-}
encodeConfig_files_min_order_by : Config_files_min_order_by -> Value
encodeConfig_files_min_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildConfig_files_order_by : (Config_files_order_byOptionalFields -> Config_files_order_byOptionalFields) -> Config_files_order_by
buildConfig_files_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { content = Absent, id = Absent }
    in
    { content = optionals.content, id = optionals.id }


type alias Config_files_order_byOptionalFields =
    { content : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Config\_files\_order\_by input object.
-}
type alias Config_files_order_by =
    { content : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Config\_files\_order\_by into a value that can be used as an argument.
-}
encodeConfig_files_order_by : Config_files_order_by -> Value
encodeConfig_files_order_by input =
    Encode.maybeObject
        [ ( "content", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.content ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildConfig_files_stddev_order_by : (Config_files_stddev_order_byOptionalFields -> Config_files_stddev_order_byOptionalFields) -> Config_files_stddev_order_by
buildConfig_files_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Config_files_stddev_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Config\_files\_stddev\_order\_by input object.
-}
type alias Config_files_stddev_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Config\_files\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeConfig_files_stddev_order_by : Config_files_stddev_order_by -> Value
encodeConfig_files_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildConfig_files_stddev_pop_order_by : (Config_files_stddev_pop_order_byOptionalFields -> Config_files_stddev_pop_order_byOptionalFields) -> Config_files_stddev_pop_order_by
buildConfig_files_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Config_files_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Config\_files\_stddev\_pop\_order\_by input object.
-}
type alias Config_files_stddev_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Config\_files\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeConfig_files_stddev_pop_order_by : Config_files_stddev_pop_order_by -> Value
encodeConfig_files_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildConfig_files_stddev_samp_order_by : (Config_files_stddev_samp_order_byOptionalFields -> Config_files_stddev_samp_order_byOptionalFields) -> Config_files_stddev_samp_order_by
buildConfig_files_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Config_files_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Config\_files\_stddev\_samp\_order\_by input object.
-}
type alias Config_files_stddev_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Config\_files\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeConfig_files_stddev_samp_order_by : Config_files_stddev_samp_order_by -> Value
encodeConfig_files_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildConfig_files_sum_order_by : (Config_files_sum_order_byOptionalFields -> Config_files_sum_order_byOptionalFields) -> Config_files_sum_order_by
buildConfig_files_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Config_files_sum_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Config\_files\_sum\_order\_by input object.
-}
type alias Config_files_sum_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Config\_files\_sum\_order\_by into a value that can be used as an argument.
-}
encodeConfig_files_sum_order_by : Config_files_sum_order_by -> Value
encodeConfig_files_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildConfig_files_var_pop_order_by : (Config_files_var_pop_order_byOptionalFields -> Config_files_var_pop_order_byOptionalFields) -> Config_files_var_pop_order_by
buildConfig_files_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Config_files_var_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Config\_files\_var\_pop\_order\_by input object.
-}
type alias Config_files_var_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Config\_files\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeConfig_files_var_pop_order_by : Config_files_var_pop_order_by -> Value
encodeConfig_files_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildConfig_files_var_samp_order_by : (Config_files_var_samp_order_byOptionalFields -> Config_files_var_samp_order_byOptionalFields) -> Config_files_var_samp_order_by
buildConfig_files_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Config_files_var_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Config\_files\_var\_samp\_order\_by input object.
-}
type alias Config_files_var_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Config\_files\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeConfig_files_var_samp_order_by : Config_files_var_samp_order_by -> Value
encodeConfig_files_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildConfig_files_variance_order_by : (Config_files_variance_order_byOptionalFields -> Config_files_variance_order_byOptionalFields) -> Config_files_variance_order_by
buildConfig_files_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Config_files_variance_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Config\_files\_variance\_order\_by input object.
-}
type alias Config_files_variance_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Config\_files\_variance\_order\_by into a value that can be used as an argument.
-}
encodeConfig_files_variance_order_by : Config_files_variance_order_by -> Value
encodeConfig_files_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildExperiment_state_comparison_exp : (Experiment_state_comparison_expOptionalFields -> Experiment_state_comparison_expOptionalFields) -> Experiment_state_comparison_exp
buildExperiment_state_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Experiment_state_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalarCodecs.Experiment_state
    , gt_ : OptionalArgument CustomScalarCodecs.Experiment_state
    , gte_ : OptionalArgument CustomScalarCodecs.Experiment_state
    , in_ : OptionalArgument (List CustomScalarCodecs.Experiment_state)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Experiment_state
    , lte_ : OptionalArgument CustomScalarCodecs.Experiment_state
    , neq_ : OptionalArgument CustomScalarCodecs.Experiment_state
    , nin_ : OptionalArgument (List CustomScalarCodecs.Experiment_state)
    }


{-| Type for the Experiment\_state\_comparison\_exp input object.
-}
type alias Experiment_state_comparison_exp =
    { eq_ : OptionalArgument CustomScalarCodecs.Experiment_state
    , gt_ : OptionalArgument CustomScalarCodecs.Experiment_state
    , gte_ : OptionalArgument CustomScalarCodecs.Experiment_state
    , in_ : OptionalArgument (List CustomScalarCodecs.Experiment_state)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Experiment_state
    , lte_ : OptionalArgument CustomScalarCodecs.Experiment_state
    , neq_ : OptionalArgument CustomScalarCodecs.Experiment_state
    , nin_ : OptionalArgument (List CustomScalarCodecs.Experiment_state)
    }


{-| Encode a Experiment\_state\_comparison\_exp into a value that can be used as an argument.
-}
encodeExperiment_state_comparison_exp : Experiment_state_comparison_exp -> Value
encodeExperiment_state_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecExperiment_state) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecExperiment_state) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecExperiment_state) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecExperiment_state) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecExperiment_state) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecExperiment_state) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecExperiment_state) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecExperiment_state) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildExperiments_aggregate_order_by : (Experiments_aggregate_order_byOptionalFields -> Experiments_aggregate_order_byOptionalFields) -> Experiments_aggregate_order_by
buildExperiments_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Experiments_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Experiments_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Experiments_max_order_by
    , min : OptionalArgument Experiments_min_order_by
    , stddev : OptionalArgument Experiments_stddev_order_by
    , stddev_pop : OptionalArgument Experiments_stddev_pop_order_by
    , stddev_samp : OptionalArgument Experiments_stddev_samp_order_by
    , sum : OptionalArgument Experiments_sum_order_by
    , var_pop : OptionalArgument Experiments_var_pop_order_by
    , var_samp : OptionalArgument Experiments_var_samp_order_by
    , variance : OptionalArgument Experiments_variance_order_by
    }


{-| Type for the Experiments\_aggregate\_order\_by input object.
-}
type alias Experiments_aggregate_order_by =
    { avg : OptionalArgument Experiments_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Experiments_max_order_by
    , min : OptionalArgument Experiments_min_order_by
    , stddev : OptionalArgument Experiments_stddev_order_by
    , stddev_pop : OptionalArgument Experiments_stddev_pop_order_by
    , stddev_samp : OptionalArgument Experiments_stddev_samp_order_by
    , sum : OptionalArgument Experiments_sum_order_by
    , var_pop : OptionalArgument Experiments_var_pop_order_by
    , var_samp : OptionalArgument Experiments_var_samp_order_by
    , variance : OptionalArgument Experiments_variance_order_by
    }


{-| Encode a Experiments\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeExperiments_aggregate_order_by : Experiments_aggregate_order_by -> Value
encodeExperiments_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeExperiments_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeExperiments_max_order_by |> Encode.optional input.max ), ( "min", encodeExperiments_min_order_by |> Encode.optional input.min ), ( "stddev", encodeExperiments_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeExperiments_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeExperiments_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeExperiments_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeExperiments_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeExperiments_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeExperiments_variance_order_by |> Encode.optional input.variance ) ]


buildExperiments_avg_order_by : (Experiments_avg_order_byOptionalFields -> Experiments_avg_order_byOptionalFields) -> Experiments_avg_order_by
buildExperiments_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, owner_id = Absent, parent_id = Absent, progress = Absent }
    in
    { id = optionals.id, owner_id = optionals.owner_id, parent_id = optionals.parent_id, progress = optionals.progress }


type alias Experiments_avg_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Experiments\_avg\_order\_by input object.
-}
type alias Experiments_avg_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Experiments\_avg\_order\_by into a value that can be used as an argument.
-}
encodeExperiments_avg_order_by : Experiments_avg_order_by -> Value
encodeExperiments_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "owner_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.owner_id ), ( "parent_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.parent_id ), ( "progress", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.progress ) ]


buildExperiments_best_checkpoints_by_metric_args : (Experiments_best_checkpoints_by_metric_argsOptionalFields -> Experiments_best_checkpoints_by_metric_argsOptionalFields) -> Experiments_best_checkpoints_by_metric_args
buildExperiments_best_checkpoints_by_metric_args fillOptionals =
    let
        optionals =
            fillOptionals
                { lim = Absent, metric = Absent, smaller_is_better = Absent }
    in
    { lim = optionals.lim, metric = optionals.metric, smaller_is_better = optionals.smaller_is_better }


type alias Experiments_best_checkpoints_by_metric_argsOptionalFields =
    { lim : OptionalArgument Int
    , metric : OptionalArgument String
    , smaller_is_better : OptionalArgument Bool
    }


{-| Type for the Experiments\_best\_checkpoints\_by\_metric\_args input object.
-}
type alias Experiments_best_checkpoints_by_metric_args =
    { lim : OptionalArgument Int
    , metric : OptionalArgument String
    , smaller_is_better : OptionalArgument Bool
    }


{-| Encode a Experiments\_best\_checkpoints\_by\_metric\_args into a value that can be used as an argument.
-}
encodeExperiments_best_checkpoints_by_metric_args : Experiments_best_checkpoints_by_metric_args -> Value
encodeExperiments_best_checkpoints_by_metric_args input =
    Encode.maybeObject
        [ ( "lim", Encode.int |> Encode.optional input.lim ), ( "metric", Encode.string |> Encode.optional input.metric ), ( "smaller_is_better", Encode.bool |> Encode.optional input.smaller_is_better ) ]


buildExperiments_bool_exp : (Experiments_bool_expOptionalFields -> Experiments_bool_expOptionalFields) -> Experiments_bool_exp
buildExperiments_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, archived = Absent, config = Absent, end_time = Absent, git_commit = Absent, git_commit_date = Absent, git_committer = Absent, git_remote = Absent, id = Absent, model_definition = Absent, model_packages = Absent, owner = Absent, owner_id = Absent, parent_id = Absent, progress = Absent, searcher_events = Absent, start_time = Absent, state = Absent, trials = Absent }
    in
    Experiments_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, archived = optionals.archived, config = optionals.config, end_time = optionals.end_time, git_commit = optionals.git_commit, git_commit_date = optionals.git_commit_date, git_committer = optionals.git_committer, git_remote = optionals.git_remote, id = optionals.id, model_definition = optionals.model_definition, model_packages = optionals.model_packages, owner = optionals.owner, owner_id = optionals.owner_id, parent_id = optionals.parent_id, progress = optionals.progress, searcher_events = optionals.searcher_events, start_time = optionals.start_time, state = optionals.state, trials = optionals.trials }


type alias Experiments_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Experiments_bool_exp))
    , not_ : OptionalArgument Experiments_bool_exp
    , or_ : OptionalArgument (List (Maybe Experiments_bool_exp))
    , archived : OptionalArgument Boolean_comparison_exp
    , config : OptionalArgument Jsonb_comparison_exp
    , end_time : OptionalArgument Timestamptz_comparison_exp
    , git_commit : OptionalArgument String_comparison_exp
    , git_commit_date : OptionalArgument Timestamp_comparison_exp
    , git_committer : OptionalArgument String_comparison_exp
    , git_remote : OptionalArgument String_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , model_definition : OptionalArgument Bytea_comparison_exp
    , model_packages : OptionalArgument Bytea_comparison_exp
    , owner : OptionalArgument Users_bool_exp
    , owner_id : OptionalArgument Int_comparison_exp
    , parent_id : OptionalArgument Int_comparison_exp
    , progress : OptionalArgument Float8_comparison_exp
    , searcher_events : OptionalArgument Searcher_events_bool_exp
    , start_time : OptionalArgument Timestamptz_comparison_exp
    , state : OptionalArgument Experiment_state_comparison_exp
    , trials : OptionalArgument Trials_bool_exp
    }


{-| Type alias for the `Experiments_bool_exp` attributes. Note that this type
needs to use the `Experiments_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Experiments_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Experiments_bool_exp))
    , not_ : OptionalArgument Experiments_bool_exp
    , or_ : OptionalArgument (List (Maybe Experiments_bool_exp))
    , archived : OptionalArgument Boolean_comparison_exp
    , config : OptionalArgument Jsonb_comparison_exp
    , end_time : OptionalArgument Timestamptz_comparison_exp
    , git_commit : OptionalArgument String_comparison_exp
    , git_commit_date : OptionalArgument Timestamp_comparison_exp
    , git_committer : OptionalArgument String_comparison_exp
    , git_remote : OptionalArgument String_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , model_definition : OptionalArgument Bytea_comparison_exp
    , model_packages : OptionalArgument Bytea_comparison_exp
    , owner : OptionalArgument Users_bool_exp
    , owner_id : OptionalArgument Int_comparison_exp
    , parent_id : OptionalArgument Int_comparison_exp
    , progress : OptionalArgument Float8_comparison_exp
    , searcher_events : OptionalArgument Searcher_events_bool_exp
    , start_time : OptionalArgument Timestamptz_comparison_exp
    , state : OptionalArgument Experiment_state_comparison_exp
    , trials : OptionalArgument Trials_bool_exp
    }


{-| Type for the Experiments\_bool\_exp input object.
-}
type Experiments_bool_exp
    = Experiments_bool_exp Experiments_bool_expRaw


{-| Encode a Experiments\_bool\_exp into a value that can be used as an argument.
-}
encodeExperiments_bool_exp : Experiments_bool_exp -> Value
encodeExperiments_bool_exp (Experiments_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeExperiments_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeExperiments_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeExperiments_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "archived", encodeBoolean_comparison_exp |> Encode.optional input.archived ), ( "config", encodeJsonb_comparison_exp |> Encode.optional input.config ), ( "end_time", encodeTimestamptz_comparison_exp |> Encode.optional input.end_time ), ( "git_commit", encodeString_comparison_exp |> Encode.optional input.git_commit ), ( "git_commit_date", encodeTimestamp_comparison_exp |> Encode.optional input.git_commit_date ), ( "git_committer", encodeString_comparison_exp |> Encode.optional input.git_committer ), ( "git_remote", encodeString_comparison_exp |> Encode.optional input.git_remote ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "model_definition", encodeBytea_comparison_exp |> Encode.optional input.model_definition ), ( "model_packages", encodeBytea_comparison_exp |> Encode.optional input.model_packages ), ( "owner", encodeUsers_bool_exp |> Encode.optional input.owner ), ( "owner_id", encodeInt_comparison_exp |> Encode.optional input.owner_id ), ( "parent_id", encodeInt_comparison_exp |> Encode.optional input.parent_id ), ( "progress", encodeFloat8_comparison_exp |> Encode.optional input.progress ), ( "searcher_events", encodeSearcher_events_bool_exp |> Encode.optional input.searcher_events ), ( "start_time", encodeTimestamptz_comparison_exp |> Encode.optional input.start_time ), ( "state", encodeExperiment_state_comparison_exp |> Encode.optional input.state ), ( "trials", encodeTrials_bool_exp |> Encode.optional input.trials ) ]


buildExperiments_max_order_by : (Experiments_max_order_byOptionalFields -> Experiments_max_order_byOptionalFields) -> Experiments_max_order_by
buildExperiments_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { end_time = Absent, git_commit = Absent, git_committer = Absent, git_remote = Absent, id = Absent, owner_id = Absent, parent_id = Absent, progress = Absent, start_time = Absent }
    in
    { end_time = optionals.end_time, git_commit = optionals.git_commit, git_committer = optionals.git_committer, git_remote = optionals.git_remote, id = optionals.id, owner_id = optionals.owner_id, parent_id = optionals.parent_id, progress = optionals.progress, start_time = optionals.start_time }


type alias Experiments_max_order_byOptionalFields =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_commit : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_committer : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_remote : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Experiments\_max\_order\_by input object.
-}
type alias Experiments_max_order_by =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_commit : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_committer : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_remote : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Experiments\_max\_order\_by into a value that can be used as an argument.
-}
encodeExperiments_max_order_by : Experiments_max_order_by -> Value
encodeExperiments_max_order_by input =
    Encode.maybeObject
        [ ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "git_commit", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.git_commit ), ( "git_committer", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.git_committer ), ( "git_remote", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.git_remote ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "owner_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.owner_id ), ( "parent_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.parent_id ), ( "progress", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.progress ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ) ]


buildExperiments_min_order_by : (Experiments_min_order_byOptionalFields -> Experiments_min_order_byOptionalFields) -> Experiments_min_order_by
buildExperiments_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { end_time = Absent, git_commit = Absent, git_committer = Absent, git_remote = Absent, id = Absent, owner_id = Absent, parent_id = Absent, progress = Absent, start_time = Absent }
    in
    { end_time = optionals.end_time, git_commit = optionals.git_commit, git_committer = optionals.git_committer, git_remote = optionals.git_remote, id = optionals.id, owner_id = optionals.owner_id, parent_id = optionals.parent_id, progress = optionals.progress, start_time = optionals.start_time }


type alias Experiments_min_order_byOptionalFields =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_commit : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_committer : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_remote : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Experiments\_min\_order\_by input object.
-}
type alias Experiments_min_order_by =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_commit : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_committer : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_remote : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Experiments\_min\_order\_by into a value that can be used as an argument.
-}
encodeExperiments_min_order_by : Experiments_min_order_by -> Value
encodeExperiments_min_order_by input =
    Encode.maybeObject
        [ ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "git_commit", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.git_commit ), ( "git_committer", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.git_committer ), ( "git_remote", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.git_remote ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "owner_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.owner_id ), ( "parent_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.parent_id ), ( "progress", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.progress ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ) ]


buildExperiments_order_by : (Experiments_order_byOptionalFields -> Experiments_order_byOptionalFields) -> Experiments_order_by
buildExperiments_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { archived = Absent, config = Absent, end_time = Absent, git_commit = Absent, git_commit_date = Absent, git_committer = Absent, git_remote = Absent, id = Absent, model_definition = Absent, model_packages = Absent, owner = Absent, owner_id = Absent, parent_id = Absent, progress = Absent, searcher_events_aggregate = Absent, start_time = Absent, state = Absent, trials_aggregate = Absent }
    in
    Experiments_order_by { archived = optionals.archived, config = optionals.config, end_time = optionals.end_time, git_commit = optionals.git_commit, git_commit_date = optionals.git_commit_date, git_committer = optionals.git_committer, git_remote = optionals.git_remote, id = optionals.id, model_definition = optionals.model_definition, model_packages = optionals.model_packages, owner = optionals.owner, owner_id = optionals.owner_id, parent_id = optionals.parent_id, progress = optionals.progress, searcher_events_aggregate = optionals.searcher_events_aggregate, start_time = optionals.start_time, state = optionals.state, trials_aggregate = optionals.trials_aggregate }


type alias Experiments_order_byOptionalFields =
    { archived : OptionalArgument DetQL.Enum.Order_by.Order_by
    , config : OptionalArgument DetQL.Enum.Order_by.Order_by
    , end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_commit : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_commit_date : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_committer : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_remote : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , model_definition : OptionalArgument DetQL.Enum.Order_by.Order_by
    , model_packages : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner : OptionalArgument Users_order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    , searcher_events_aggregate : OptionalArgument Searcher_events_aggregate_order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , state : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trials_aggregate : OptionalArgument Trials_aggregate_order_by
    }


{-| Type alias for the `Experiments_order_by` attributes. Note that this type
needs to use the `Experiments_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Experiments_order_byRaw =
    { archived : OptionalArgument DetQL.Enum.Order_by.Order_by
    , config : OptionalArgument DetQL.Enum.Order_by.Order_by
    , end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_commit : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_commit_date : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_committer : OptionalArgument DetQL.Enum.Order_by.Order_by
    , git_remote : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , model_definition : OptionalArgument DetQL.Enum.Order_by.Order_by
    , model_packages : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner : OptionalArgument Users_order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    , searcher_events_aggregate : OptionalArgument Searcher_events_aggregate_order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , state : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trials_aggregate : OptionalArgument Trials_aggregate_order_by
    }


{-| Type for the Experiments\_order\_by input object.
-}
type Experiments_order_by
    = Experiments_order_by Experiments_order_byRaw


{-| Encode a Experiments\_order\_by into a value that can be used as an argument.
-}
encodeExperiments_order_by : Experiments_order_by -> Value
encodeExperiments_order_by (Experiments_order_by input) =
    Encode.maybeObject
        [ ( "archived", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.archived ), ( "config", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.config ), ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "git_commit", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.git_commit ), ( "git_commit_date", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.git_commit_date ), ( "git_committer", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.git_committer ), ( "git_remote", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.git_remote ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "model_definition", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.model_definition ), ( "model_packages", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.model_packages ), ( "owner", encodeUsers_order_by |> Encode.optional input.owner ), ( "owner_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.owner_id ), ( "parent_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.parent_id ), ( "progress", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.progress ), ( "searcher_events_aggregate", encodeSearcher_events_aggregate_order_by |> Encode.optional input.searcher_events_aggregate ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ), ( "state", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.state ), ( "trials_aggregate", encodeTrials_aggregate_order_by |> Encode.optional input.trials_aggregate ) ]


buildExperiments_stddev_order_by : (Experiments_stddev_order_byOptionalFields -> Experiments_stddev_order_byOptionalFields) -> Experiments_stddev_order_by
buildExperiments_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, owner_id = Absent, parent_id = Absent, progress = Absent }
    in
    { id = optionals.id, owner_id = optionals.owner_id, parent_id = optionals.parent_id, progress = optionals.progress }


type alias Experiments_stddev_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Experiments\_stddev\_order\_by input object.
-}
type alias Experiments_stddev_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Experiments\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeExperiments_stddev_order_by : Experiments_stddev_order_by -> Value
encodeExperiments_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "owner_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.owner_id ), ( "parent_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.parent_id ), ( "progress", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.progress ) ]


buildExperiments_stddev_pop_order_by : (Experiments_stddev_pop_order_byOptionalFields -> Experiments_stddev_pop_order_byOptionalFields) -> Experiments_stddev_pop_order_by
buildExperiments_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, owner_id = Absent, parent_id = Absent, progress = Absent }
    in
    { id = optionals.id, owner_id = optionals.owner_id, parent_id = optionals.parent_id, progress = optionals.progress }


type alias Experiments_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Experiments\_stddev\_pop\_order\_by input object.
-}
type alias Experiments_stddev_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Experiments\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeExperiments_stddev_pop_order_by : Experiments_stddev_pop_order_by -> Value
encodeExperiments_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "owner_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.owner_id ), ( "parent_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.parent_id ), ( "progress", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.progress ) ]


buildExperiments_stddev_samp_order_by : (Experiments_stddev_samp_order_byOptionalFields -> Experiments_stddev_samp_order_byOptionalFields) -> Experiments_stddev_samp_order_by
buildExperiments_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, owner_id = Absent, parent_id = Absent, progress = Absent }
    in
    { id = optionals.id, owner_id = optionals.owner_id, parent_id = optionals.parent_id, progress = optionals.progress }


type alias Experiments_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Experiments\_stddev\_samp\_order\_by input object.
-}
type alias Experiments_stddev_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Experiments\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeExperiments_stddev_samp_order_by : Experiments_stddev_samp_order_by -> Value
encodeExperiments_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "owner_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.owner_id ), ( "parent_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.parent_id ), ( "progress", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.progress ) ]


buildExperiments_sum_order_by : (Experiments_sum_order_byOptionalFields -> Experiments_sum_order_byOptionalFields) -> Experiments_sum_order_by
buildExperiments_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, owner_id = Absent, parent_id = Absent, progress = Absent }
    in
    { id = optionals.id, owner_id = optionals.owner_id, parent_id = optionals.parent_id, progress = optionals.progress }


type alias Experiments_sum_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Experiments\_sum\_order\_by input object.
-}
type alias Experiments_sum_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Experiments\_sum\_order\_by into a value that can be used as an argument.
-}
encodeExperiments_sum_order_by : Experiments_sum_order_by -> Value
encodeExperiments_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "owner_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.owner_id ), ( "parent_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.parent_id ), ( "progress", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.progress ) ]


buildExperiments_var_pop_order_by : (Experiments_var_pop_order_byOptionalFields -> Experiments_var_pop_order_byOptionalFields) -> Experiments_var_pop_order_by
buildExperiments_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, owner_id = Absent, parent_id = Absent, progress = Absent }
    in
    { id = optionals.id, owner_id = optionals.owner_id, parent_id = optionals.parent_id, progress = optionals.progress }


type alias Experiments_var_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Experiments\_var\_pop\_order\_by input object.
-}
type alias Experiments_var_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Experiments\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeExperiments_var_pop_order_by : Experiments_var_pop_order_by -> Value
encodeExperiments_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "owner_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.owner_id ), ( "parent_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.parent_id ), ( "progress", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.progress ) ]


buildExperiments_var_samp_order_by : (Experiments_var_samp_order_byOptionalFields -> Experiments_var_samp_order_byOptionalFields) -> Experiments_var_samp_order_by
buildExperiments_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, owner_id = Absent, parent_id = Absent, progress = Absent }
    in
    { id = optionals.id, owner_id = optionals.owner_id, parent_id = optionals.parent_id, progress = optionals.progress }


type alias Experiments_var_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Experiments\_var\_samp\_order\_by input object.
-}
type alias Experiments_var_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Experiments\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeExperiments_var_samp_order_by : Experiments_var_samp_order_by -> Value
encodeExperiments_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "owner_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.owner_id ), ( "parent_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.parent_id ), ( "progress", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.progress ) ]


buildExperiments_variance_order_by : (Experiments_variance_order_byOptionalFields -> Experiments_variance_order_byOptionalFields) -> Experiments_variance_order_by
buildExperiments_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, owner_id = Absent, parent_id = Absent, progress = Absent }
    in
    { id = optionals.id, owner_id = optionals.owner_id, parent_id = optionals.parent_id, progress = optionals.progress }


type alias Experiments_variance_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Experiments\_variance\_order\_by input object.
-}
type alias Experiments_variance_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , owner_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , parent_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , progress : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Experiments\_variance\_order\_by into a value that can be used as an argument.
-}
encodeExperiments_variance_order_by : Experiments_variance_order_by -> Value
encodeExperiments_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "owner_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.owner_id ), ( "parent_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.parent_id ), ( "progress", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.progress ) ]


buildFloat8_comparison_exp : (Float8_comparison_expOptionalFields -> Float8_comparison_expOptionalFields) -> Float8_comparison_exp
buildFloat8_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Float8_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalarCodecs.Float8
    , gt_ : OptionalArgument CustomScalarCodecs.Float8
    , gte_ : OptionalArgument CustomScalarCodecs.Float8
    , in_ : OptionalArgument (List CustomScalarCodecs.Float8)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Float8
    , lte_ : OptionalArgument CustomScalarCodecs.Float8
    , neq_ : OptionalArgument CustomScalarCodecs.Float8
    , nin_ : OptionalArgument (List CustomScalarCodecs.Float8)
    }


{-| Type for the Float8\_comparison\_exp input object.
-}
type alias Float8_comparison_exp =
    { eq_ : OptionalArgument CustomScalarCodecs.Float8
    , gt_ : OptionalArgument CustomScalarCodecs.Float8
    , gte_ : OptionalArgument CustomScalarCodecs.Float8
    , in_ : OptionalArgument (List CustomScalarCodecs.Float8)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Float8
    , lte_ : OptionalArgument CustomScalarCodecs.Float8
    , neq_ : OptionalArgument CustomScalarCodecs.Float8
    , nin_ : OptionalArgument (List CustomScalarCodecs.Float8)
    }


{-| Encode a Float8\_comparison\_exp into a value that can be used as an argument.
-}
encodeFloat8_comparison_exp : Float8_comparison_exp -> Value
encodeFloat8_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecFloat8) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildInt_comparison_exp : (Int_comparison_expOptionalFields -> Int_comparison_expOptionalFields) -> Int_comparison_exp
buildInt_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Int_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Type for the Int\_comparison\_exp input object.
-}
type alias Int_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Encode a Int\_comparison\_exp into a value that can be used as an argument.
-}
encodeInt_comparison_exp : Int_comparison_exp -> Value
encodeInt_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input.eq_ ), ( "_gt", Encode.int |> Encode.optional input.gt_ ), ( "_gte", Encode.int |> Encode.optional input.gte_ ), ( "_in", (Encode.int |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.int |> Encode.optional input.lt_ ), ( "_lte", Encode.int |> Encode.optional input.lte_ ), ( "_neq", Encode.int |> Encode.optional input.neq_ ), ( "_nin", (Encode.int |> Encode.list) |> Encode.optional input.nin_ ) ]


buildJsonb_comparison_exp : (Jsonb_comparison_expOptionalFields -> Jsonb_comparison_expOptionalFields) -> Jsonb_comparison_exp
buildJsonb_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { contained_in_ = Absent, contains_ = Absent, eq_ = Absent, gt_ = Absent, gte_ = Absent, has_key_ = Absent, has_keys_all_ = Absent, has_keys_any_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { contained_in_ = optionals.contained_in_, contains_ = optionals.contains_, eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, has_key_ = optionals.has_key_, has_keys_all_ = optionals.has_keys_all_, has_keys_any_ = optionals.has_keys_any_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Jsonb_comparison_expOptionalFields =
    { contained_in_ : OptionalArgument CustomScalarCodecs.Jsonb
    , contains_ : OptionalArgument CustomScalarCodecs.Jsonb
    , eq_ : OptionalArgument CustomScalarCodecs.Jsonb
    , gt_ : OptionalArgument CustomScalarCodecs.Jsonb
    , gte_ : OptionalArgument CustomScalarCodecs.Jsonb
    , has_key_ : OptionalArgument String
    , has_keys_all_ : OptionalArgument (List String)
    , has_keys_any_ : OptionalArgument (List String)
    , in_ : OptionalArgument (List CustomScalarCodecs.Jsonb)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Jsonb
    , lte_ : OptionalArgument CustomScalarCodecs.Jsonb
    , neq_ : OptionalArgument CustomScalarCodecs.Jsonb
    , nin_ : OptionalArgument (List CustomScalarCodecs.Jsonb)
    }


{-| Type for the Jsonb\_comparison\_exp input object.
-}
type alias Jsonb_comparison_exp =
    { contained_in_ : OptionalArgument CustomScalarCodecs.Jsonb
    , contains_ : OptionalArgument CustomScalarCodecs.Jsonb
    , eq_ : OptionalArgument CustomScalarCodecs.Jsonb
    , gt_ : OptionalArgument CustomScalarCodecs.Jsonb
    , gte_ : OptionalArgument CustomScalarCodecs.Jsonb
    , has_key_ : OptionalArgument String
    , has_keys_all_ : OptionalArgument (List String)
    , has_keys_any_ : OptionalArgument (List String)
    , in_ : OptionalArgument (List CustomScalarCodecs.Jsonb)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Jsonb
    , lte_ : OptionalArgument CustomScalarCodecs.Jsonb
    , neq_ : OptionalArgument CustomScalarCodecs.Jsonb
    , nin_ : OptionalArgument (List CustomScalarCodecs.Jsonb)
    }


{-| Encode a Jsonb\_comparison\_exp into a value that can be used as an argument.
-}
encodeJsonb_comparison_exp : Jsonb_comparison_exp -> Value
encodeJsonb_comparison_exp input =
    Encode.maybeObject
        [ ( "_contained_in", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.contained_in_ ), ( "_contains", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.contains_ ), ( "_eq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.gte_ ), ( "_has_key", Encode.string |> Encode.optional input.has_key_ ), ( "_has_keys_all", (Encode.string |> Encode.list) |> Encode.optional input.has_keys_all_ ), ( "_has_keys_any", (Encode.string |> Encode.list) |> Encode.optional input.has_keys_any_ ), ( "_in", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecJsonb) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildSearcher_events_aggregate_order_by : (Searcher_events_aggregate_order_byOptionalFields -> Searcher_events_aggregate_order_byOptionalFields) -> Searcher_events_aggregate_order_by
buildSearcher_events_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Searcher_events_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Searcher_events_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Searcher_events_max_order_by
    , min : OptionalArgument Searcher_events_min_order_by
    , stddev : OptionalArgument Searcher_events_stddev_order_by
    , stddev_pop : OptionalArgument Searcher_events_stddev_pop_order_by
    , stddev_samp : OptionalArgument Searcher_events_stddev_samp_order_by
    , sum : OptionalArgument Searcher_events_sum_order_by
    , var_pop : OptionalArgument Searcher_events_var_pop_order_by
    , var_samp : OptionalArgument Searcher_events_var_samp_order_by
    , variance : OptionalArgument Searcher_events_variance_order_by
    }


{-| Type for the Searcher\_events\_aggregate\_order\_by input object.
-}
type alias Searcher_events_aggregate_order_by =
    { avg : OptionalArgument Searcher_events_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Searcher_events_max_order_by
    , min : OptionalArgument Searcher_events_min_order_by
    , stddev : OptionalArgument Searcher_events_stddev_order_by
    , stddev_pop : OptionalArgument Searcher_events_stddev_pop_order_by
    , stddev_samp : OptionalArgument Searcher_events_stddev_samp_order_by
    , sum : OptionalArgument Searcher_events_sum_order_by
    , var_pop : OptionalArgument Searcher_events_var_pop_order_by
    , var_samp : OptionalArgument Searcher_events_var_samp_order_by
    , variance : OptionalArgument Searcher_events_variance_order_by
    }


{-| Encode a Searcher\_events\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeSearcher_events_aggregate_order_by : Searcher_events_aggregate_order_by -> Value
encodeSearcher_events_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeSearcher_events_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeSearcher_events_max_order_by |> Encode.optional input.max ), ( "min", encodeSearcher_events_min_order_by |> Encode.optional input.min ), ( "stddev", encodeSearcher_events_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeSearcher_events_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeSearcher_events_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeSearcher_events_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeSearcher_events_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeSearcher_events_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeSearcher_events_variance_order_by |> Encode.optional input.variance ) ]


buildSearcher_events_avg_order_by : (Searcher_events_avg_order_byOptionalFields -> Searcher_events_avg_order_byOptionalFields) -> Searcher_events_avg_order_by
buildSearcher_events_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id }


type alias Searcher_events_avg_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Searcher\_events\_avg\_order\_by input object.
-}
type alias Searcher_events_avg_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Searcher\_events\_avg\_order\_by into a value that can be used as an argument.
-}
encodeSearcher_events_avg_order_by : Searcher_events_avg_order_by -> Value
encodeSearcher_events_avg_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildSearcher_events_bool_exp : (Searcher_events_bool_expOptionalFields -> Searcher_events_bool_expOptionalFields) -> Searcher_events_bool_exp
buildSearcher_events_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, content = Absent, event_type = Absent, experiment = Absent, experiment_id = Absent, id = Absent }
    in
    Searcher_events_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, content = optionals.content, event_type = optionals.event_type, experiment = optionals.experiment, experiment_id = optionals.experiment_id, id = optionals.id }


type alias Searcher_events_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Searcher_events_bool_exp))
    , not_ : OptionalArgument Searcher_events_bool_exp
    , or_ : OptionalArgument (List (Maybe Searcher_events_bool_exp))
    , content : OptionalArgument Jsonb_comparison_exp
    , event_type : OptionalArgument String_comparison_exp
    , experiment : OptionalArgument Experiments_bool_exp
    , experiment_id : OptionalArgument Int_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    }


{-| Type alias for the `Searcher_events_bool_exp` attributes. Note that this type
needs to use the `Searcher_events_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Searcher_events_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Searcher_events_bool_exp))
    , not_ : OptionalArgument Searcher_events_bool_exp
    , or_ : OptionalArgument (List (Maybe Searcher_events_bool_exp))
    , content : OptionalArgument Jsonb_comparison_exp
    , event_type : OptionalArgument String_comparison_exp
    , experiment : OptionalArgument Experiments_bool_exp
    , experiment_id : OptionalArgument Int_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    }


{-| Type for the Searcher\_events\_bool\_exp input object.
-}
type Searcher_events_bool_exp
    = Searcher_events_bool_exp Searcher_events_bool_expRaw


{-| Encode a Searcher\_events\_bool\_exp into a value that can be used as an argument.
-}
encodeSearcher_events_bool_exp : Searcher_events_bool_exp -> Value
encodeSearcher_events_bool_exp (Searcher_events_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeSearcher_events_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeSearcher_events_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeSearcher_events_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "content", encodeJsonb_comparison_exp |> Encode.optional input.content ), ( "event_type", encodeString_comparison_exp |> Encode.optional input.event_type ), ( "experiment", encodeExperiments_bool_exp |> Encode.optional input.experiment ), ( "experiment_id", encodeInt_comparison_exp |> Encode.optional input.experiment_id ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ) ]


buildSearcher_events_max_order_by : (Searcher_events_max_order_byOptionalFields -> Searcher_events_max_order_byOptionalFields) -> Searcher_events_max_order_by
buildSearcher_events_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { event_type = Absent, experiment_id = Absent, id = Absent }
    in
    { event_type = optionals.event_type, experiment_id = optionals.experiment_id, id = optionals.id }


type alias Searcher_events_max_order_byOptionalFields =
    { event_type : OptionalArgument DetQL.Enum.Order_by.Order_by
    , experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Searcher\_events\_max\_order\_by input object.
-}
type alias Searcher_events_max_order_by =
    { event_type : OptionalArgument DetQL.Enum.Order_by.Order_by
    , experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Searcher\_events\_max\_order\_by into a value that can be used as an argument.
-}
encodeSearcher_events_max_order_by : Searcher_events_max_order_by -> Value
encodeSearcher_events_max_order_by input =
    Encode.maybeObject
        [ ( "event_type", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.event_type ), ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildSearcher_events_min_order_by : (Searcher_events_min_order_byOptionalFields -> Searcher_events_min_order_byOptionalFields) -> Searcher_events_min_order_by
buildSearcher_events_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { event_type = Absent, experiment_id = Absent, id = Absent }
    in
    { event_type = optionals.event_type, experiment_id = optionals.experiment_id, id = optionals.id }


type alias Searcher_events_min_order_byOptionalFields =
    { event_type : OptionalArgument DetQL.Enum.Order_by.Order_by
    , experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Searcher\_events\_min\_order\_by input object.
-}
type alias Searcher_events_min_order_by =
    { event_type : OptionalArgument DetQL.Enum.Order_by.Order_by
    , experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Searcher\_events\_min\_order\_by into a value that can be used as an argument.
-}
encodeSearcher_events_min_order_by : Searcher_events_min_order_by -> Value
encodeSearcher_events_min_order_by input =
    Encode.maybeObject
        [ ( "event_type", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.event_type ), ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildSearcher_events_order_by : (Searcher_events_order_byOptionalFields -> Searcher_events_order_byOptionalFields) -> Searcher_events_order_by
buildSearcher_events_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { content = Absent, event_type = Absent, experiment = Absent, experiment_id = Absent, id = Absent }
    in
    Searcher_events_order_by { content = optionals.content, event_type = optionals.event_type, experiment = optionals.experiment, experiment_id = optionals.experiment_id, id = optionals.id }


type alias Searcher_events_order_byOptionalFields =
    { content : OptionalArgument DetQL.Enum.Order_by.Order_by
    , event_type : OptionalArgument DetQL.Enum.Order_by.Order_by
    , experiment : OptionalArgument Experiments_order_by
    , experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Searcher_events_order_by` attributes. Note that this type
needs to use the `Searcher_events_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Searcher_events_order_byRaw =
    { content : OptionalArgument DetQL.Enum.Order_by.Order_by
    , event_type : OptionalArgument DetQL.Enum.Order_by.Order_by
    , experiment : OptionalArgument Experiments_order_by
    , experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Searcher\_events\_order\_by input object.
-}
type Searcher_events_order_by
    = Searcher_events_order_by Searcher_events_order_byRaw


{-| Encode a Searcher\_events\_order\_by into a value that can be used as an argument.
-}
encodeSearcher_events_order_by : Searcher_events_order_by -> Value
encodeSearcher_events_order_by (Searcher_events_order_by input) =
    Encode.maybeObject
        [ ( "content", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.content ), ( "event_type", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.event_type ), ( "experiment", encodeExperiments_order_by |> Encode.optional input.experiment ), ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildSearcher_events_stddev_order_by : (Searcher_events_stddev_order_byOptionalFields -> Searcher_events_stddev_order_byOptionalFields) -> Searcher_events_stddev_order_by
buildSearcher_events_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id }


type alias Searcher_events_stddev_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Searcher\_events\_stddev\_order\_by input object.
-}
type alias Searcher_events_stddev_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Searcher\_events\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeSearcher_events_stddev_order_by : Searcher_events_stddev_order_by -> Value
encodeSearcher_events_stddev_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildSearcher_events_stddev_pop_order_by : (Searcher_events_stddev_pop_order_byOptionalFields -> Searcher_events_stddev_pop_order_byOptionalFields) -> Searcher_events_stddev_pop_order_by
buildSearcher_events_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id }


type alias Searcher_events_stddev_pop_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Searcher\_events\_stddev\_pop\_order\_by input object.
-}
type alias Searcher_events_stddev_pop_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Searcher\_events\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeSearcher_events_stddev_pop_order_by : Searcher_events_stddev_pop_order_by -> Value
encodeSearcher_events_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildSearcher_events_stddev_samp_order_by : (Searcher_events_stddev_samp_order_byOptionalFields -> Searcher_events_stddev_samp_order_byOptionalFields) -> Searcher_events_stddev_samp_order_by
buildSearcher_events_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id }


type alias Searcher_events_stddev_samp_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Searcher\_events\_stddev\_samp\_order\_by input object.
-}
type alias Searcher_events_stddev_samp_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Searcher\_events\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeSearcher_events_stddev_samp_order_by : Searcher_events_stddev_samp_order_by -> Value
encodeSearcher_events_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildSearcher_events_sum_order_by : (Searcher_events_sum_order_byOptionalFields -> Searcher_events_sum_order_byOptionalFields) -> Searcher_events_sum_order_by
buildSearcher_events_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id }


type alias Searcher_events_sum_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Searcher\_events\_sum\_order\_by input object.
-}
type alias Searcher_events_sum_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Searcher\_events\_sum\_order\_by into a value that can be used as an argument.
-}
encodeSearcher_events_sum_order_by : Searcher_events_sum_order_by -> Value
encodeSearcher_events_sum_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildSearcher_events_var_pop_order_by : (Searcher_events_var_pop_order_byOptionalFields -> Searcher_events_var_pop_order_byOptionalFields) -> Searcher_events_var_pop_order_by
buildSearcher_events_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id }


type alias Searcher_events_var_pop_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Searcher\_events\_var\_pop\_order\_by input object.
-}
type alias Searcher_events_var_pop_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Searcher\_events\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeSearcher_events_var_pop_order_by : Searcher_events_var_pop_order_by -> Value
encodeSearcher_events_var_pop_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildSearcher_events_var_samp_order_by : (Searcher_events_var_samp_order_byOptionalFields -> Searcher_events_var_samp_order_byOptionalFields) -> Searcher_events_var_samp_order_by
buildSearcher_events_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id }


type alias Searcher_events_var_samp_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Searcher\_events\_var\_samp\_order\_by input object.
-}
type alias Searcher_events_var_samp_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Searcher\_events\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeSearcher_events_var_samp_order_by : Searcher_events_var_samp_order_by -> Value
encodeSearcher_events_var_samp_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildSearcher_events_variance_order_by : (Searcher_events_variance_order_byOptionalFields -> Searcher_events_variance_order_byOptionalFields) -> Searcher_events_variance_order_by
buildSearcher_events_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id }


type alias Searcher_events_variance_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Searcher\_events\_variance\_order\_by input object.
-}
type alias Searcher_events_variance_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Searcher\_events\_variance\_order\_by into a value that can be used as an argument.
-}
encodeSearcher_events_variance_order_by : Searcher_events_variance_order_by -> Value
encodeSearcher_events_variance_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildStep_state_comparison_exp : (Step_state_comparison_expOptionalFields -> Step_state_comparison_expOptionalFields) -> Step_state_comparison_exp
buildStep_state_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Step_state_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalarCodecs.Step_state
    , gt_ : OptionalArgument CustomScalarCodecs.Step_state
    , gte_ : OptionalArgument CustomScalarCodecs.Step_state
    , in_ : OptionalArgument (List CustomScalarCodecs.Step_state)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Step_state
    , lte_ : OptionalArgument CustomScalarCodecs.Step_state
    , neq_ : OptionalArgument CustomScalarCodecs.Step_state
    , nin_ : OptionalArgument (List CustomScalarCodecs.Step_state)
    }


{-| Type for the Step\_state\_comparison\_exp input object.
-}
type alias Step_state_comparison_exp =
    { eq_ : OptionalArgument CustomScalarCodecs.Step_state
    , gt_ : OptionalArgument CustomScalarCodecs.Step_state
    , gte_ : OptionalArgument CustomScalarCodecs.Step_state
    , in_ : OptionalArgument (List CustomScalarCodecs.Step_state)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Step_state
    , lte_ : OptionalArgument CustomScalarCodecs.Step_state
    , neq_ : OptionalArgument CustomScalarCodecs.Step_state
    , nin_ : OptionalArgument (List CustomScalarCodecs.Step_state)
    }


{-| Encode a Step\_state\_comparison\_exp into a value that can be used as an argument.
-}
encodeStep_state_comparison_exp : Step_state_comparison_exp -> Value
encodeStep_state_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecStep_state) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecStep_state) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecStep_state) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecStep_state) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecStep_state) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecStep_state) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecStep_state) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecStep_state) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildSteps_aggregate_order_by : (Steps_aggregate_order_byOptionalFields -> Steps_aggregate_order_byOptionalFields) -> Steps_aggregate_order_by
buildSteps_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Steps_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Steps_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Steps_max_order_by
    , min : OptionalArgument Steps_min_order_by
    , stddev : OptionalArgument Steps_stddev_order_by
    , stddev_pop : OptionalArgument Steps_stddev_pop_order_by
    , stddev_samp : OptionalArgument Steps_stddev_samp_order_by
    , sum : OptionalArgument Steps_sum_order_by
    , var_pop : OptionalArgument Steps_var_pop_order_by
    , var_samp : OptionalArgument Steps_var_samp_order_by
    , variance : OptionalArgument Steps_variance_order_by
    }


{-| Type for the Steps\_aggregate\_order\_by input object.
-}
type alias Steps_aggregate_order_by =
    { avg : OptionalArgument Steps_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Steps_max_order_by
    , min : OptionalArgument Steps_min_order_by
    , stddev : OptionalArgument Steps_stddev_order_by
    , stddev_pop : OptionalArgument Steps_stddev_pop_order_by
    , stddev_samp : OptionalArgument Steps_stddev_samp_order_by
    , sum : OptionalArgument Steps_sum_order_by
    , var_pop : OptionalArgument Steps_var_pop_order_by
    , var_samp : OptionalArgument Steps_var_samp_order_by
    , variance : OptionalArgument Steps_variance_order_by
    }


{-| Encode a Steps\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeSteps_aggregate_order_by : Steps_aggregate_order_by -> Value
encodeSteps_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeSteps_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeSteps_max_order_by |> Encode.optional input.max ), ( "min", encodeSteps_min_order_by |> Encode.optional input.min ), ( "stddev", encodeSteps_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeSteps_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeSteps_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeSteps_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeSteps_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeSteps_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeSteps_variance_order_by |> Encode.optional input.variance ) ]


buildSteps_avg_order_by : (Steps_avg_order_byOptionalFields -> Steps_avg_order_byOptionalFields) -> Steps_avg_order_by
buildSteps_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Steps_avg_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Steps\_avg\_order\_by input object.
-}
type alias Steps_avg_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Steps\_avg\_order\_by into a value that can be used as an argument.
-}
encodeSteps_avg_order_by : Steps_avg_order_by -> Value
encodeSteps_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildSteps_bool_exp : (Steps_bool_expOptionalFields -> Steps_bool_expOptionalFields) -> Steps_bool_exp
buildSteps_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, checkpoint = Absent, end_time = Absent, id = Absent, metrics = Absent, start_time = Absent, state = Absent, trial = Absent, trial_id = Absent, validation = Absent }
    in
    Steps_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, checkpoint = optionals.checkpoint, end_time = optionals.end_time, id = optionals.id, metrics = optionals.metrics, start_time = optionals.start_time, state = optionals.state, trial = optionals.trial, trial_id = optionals.trial_id, validation = optionals.validation }


type alias Steps_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Steps_bool_exp))
    , not_ : OptionalArgument Steps_bool_exp
    , or_ : OptionalArgument (List (Maybe Steps_bool_exp))
    , checkpoint : OptionalArgument Checkpoints_bool_exp
    , end_time : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , metrics : OptionalArgument Jsonb_comparison_exp
    , start_time : OptionalArgument Timestamptz_comparison_exp
    , state : OptionalArgument Step_state_comparison_exp
    , trial : OptionalArgument Trials_bool_exp
    , trial_id : OptionalArgument Int_comparison_exp
    , validation : OptionalArgument Validations_bool_exp
    }


{-| Type alias for the `Steps_bool_exp` attributes. Note that this type
needs to use the `Steps_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Steps_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Steps_bool_exp))
    , not_ : OptionalArgument Steps_bool_exp
    , or_ : OptionalArgument (List (Maybe Steps_bool_exp))
    , checkpoint : OptionalArgument Checkpoints_bool_exp
    , end_time : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , metrics : OptionalArgument Jsonb_comparison_exp
    , start_time : OptionalArgument Timestamptz_comparison_exp
    , state : OptionalArgument Step_state_comparison_exp
    , trial : OptionalArgument Trials_bool_exp
    , trial_id : OptionalArgument Int_comparison_exp
    , validation : OptionalArgument Validations_bool_exp
    }


{-| Type for the Steps\_bool\_exp input object.
-}
type Steps_bool_exp
    = Steps_bool_exp Steps_bool_expRaw


{-| Encode a Steps\_bool\_exp into a value that can be used as an argument.
-}
encodeSteps_bool_exp : Steps_bool_exp -> Value
encodeSteps_bool_exp (Steps_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeSteps_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeSteps_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeSteps_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "checkpoint", encodeCheckpoints_bool_exp |> Encode.optional input.checkpoint ), ( "end_time", encodeTimestamptz_comparison_exp |> Encode.optional input.end_time ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "metrics", encodeJsonb_comparison_exp |> Encode.optional input.metrics ), ( "start_time", encodeTimestamptz_comparison_exp |> Encode.optional input.start_time ), ( "state", encodeStep_state_comparison_exp |> Encode.optional input.state ), ( "trial", encodeTrials_bool_exp |> Encode.optional input.trial ), ( "trial_id", encodeInt_comparison_exp |> Encode.optional input.trial_id ), ( "validation", encodeValidations_bool_exp |> Encode.optional input.validation ) ]


buildSteps_max_order_by : (Steps_max_order_byOptionalFields -> Steps_max_order_byOptionalFields) -> Steps_max_order_by
buildSteps_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { end_time = Absent, id = Absent, start_time = Absent, trial_id = Absent }
    in
    { end_time = optionals.end_time, id = optionals.id, start_time = optionals.start_time, trial_id = optionals.trial_id }


type alias Steps_max_order_byOptionalFields =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Steps\_max\_order\_by input object.
-}
type alias Steps_max_order_by =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Steps\_max\_order\_by into a value that can be used as an argument.
-}
encodeSteps_max_order_by : Steps_max_order_by -> Value
encodeSteps_max_order_by input =
    Encode.maybeObject
        [ ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildSteps_min_order_by : (Steps_min_order_byOptionalFields -> Steps_min_order_byOptionalFields) -> Steps_min_order_by
buildSteps_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { end_time = Absent, id = Absent, start_time = Absent, trial_id = Absent }
    in
    { end_time = optionals.end_time, id = optionals.id, start_time = optionals.start_time, trial_id = optionals.trial_id }


type alias Steps_min_order_byOptionalFields =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Steps\_min\_order\_by input object.
-}
type alias Steps_min_order_by =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Steps\_min\_order\_by into a value that can be used as an argument.
-}
encodeSteps_min_order_by : Steps_min_order_by -> Value
encodeSteps_min_order_by input =
    Encode.maybeObject
        [ ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildSteps_order_by : (Steps_order_byOptionalFields -> Steps_order_byOptionalFields) -> Steps_order_by
buildSteps_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { checkpoint = Absent, end_time = Absent, id = Absent, metrics = Absent, start_time = Absent, state = Absent, trial = Absent, trial_id = Absent, validation = Absent }
    in
    Steps_order_by { checkpoint = optionals.checkpoint, end_time = optionals.end_time, id = optionals.id, metrics = optionals.metrics, start_time = optionals.start_time, state = optionals.state, trial = optionals.trial, trial_id = optionals.trial_id, validation = optionals.validation }


type alias Steps_order_byOptionalFields =
    { checkpoint : OptionalArgument Checkpoints_order_by
    , end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , metrics : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , state : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial : OptionalArgument Trials_order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , validation : OptionalArgument Validations_order_by
    }


{-| Type alias for the `Steps_order_by` attributes. Note that this type
needs to use the `Steps_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Steps_order_byRaw =
    { checkpoint : OptionalArgument Checkpoints_order_by
    , end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , metrics : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , state : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial : OptionalArgument Trials_order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , validation : OptionalArgument Validations_order_by
    }


{-| Type for the Steps\_order\_by input object.
-}
type Steps_order_by
    = Steps_order_by Steps_order_byRaw


{-| Encode a Steps\_order\_by into a value that can be used as an argument.
-}
encodeSteps_order_by : Steps_order_by -> Value
encodeSteps_order_by (Steps_order_by input) =
    Encode.maybeObject
        [ ( "checkpoint", encodeCheckpoints_order_by |> Encode.optional input.checkpoint ), ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "metrics", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.metrics ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ), ( "state", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.state ), ( "trial", encodeTrials_order_by |> Encode.optional input.trial ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ), ( "validation", encodeValidations_order_by |> Encode.optional input.validation ) ]


buildSteps_stddev_order_by : (Steps_stddev_order_byOptionalFields -> Steps_stddev_order_byOptionalFields) -> Steps_stddev_order_by
buildSteps_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Steps_stddev_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Steps\_stddev\_order\_by input object.
-}
type alias Steps_stddev_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Steps\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeSteps_stddev_order_by : Steps_stddev_order_by -> Value
encodeSteps_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildSteps_stddev_pop_order_by : (Steps_stddev_pop_order_byOptionalFields -> Steps_stddev_pop_order_byOptionalFields) -> Steps_stddev_pop_order_by
buildSteps_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Steps_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Steps\_stddev\_pop\_order\_by input object.
-}
type alias Steps_stddev_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Steps\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeSteps_stddev_pop_order_by : Steps_stddev_pop_order_by -> Value
encodeSteps_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildSteps_stddev_samp_order_by : (Steps_stddev_samp_order_byOptionalFields -> Steps_stddev_samp_order_byOptionalFields) -> Steps_stddev_samp_order_by
buildSteps_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Steps_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Steps\_stddev\_samp\_order\_by input object.
-}
type alias Steps_stddev_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Steps\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeSteps_stddev_samp_order_by : Steps_stddev_samp_order_by -> Value
encodeSteps_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildSteps_sum_order_by : (Steps_sum_order_byOptionalFields -> Steps_sum_order_byOptionalFields) -> Steps_sum_order_by
buildSteps_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Steps_sum_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Steps\_sum\_order\_by input object.
-}
type alias Steps_sum_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Steps\_sum\_order\_by into a value that can be used as an argument.
-}
encodeSteps_sum_order_by : Steps_sum_order_by -> Value
encodeSteps_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildSteps_var_pop_order_by : (Steps_var_pop_order_byOptionalFields -> Steps_var_pop_order_byOptionalFields) -> Steps_var_pop_order_by
buildSteps_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Steps_var_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Steps\_var\_pop\_order\_by input object.
-}
type alias Steps_var_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Steps\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeSteps_var_pop_order_by : Steps_var_pop_order_by -> Value
encodeSteps_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildSteps_var_samp_order_by : (Steps_var_samp_order_byOptionalFields -> Steps_var_samp_order_byOptionalFields) -> Steps_var_samp_order_by
buildSteps_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Steps_var_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Steps\_var\_samp\_order\_by input object.
-}
type alias Steps_var_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Steps\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeSteps_var_samp_order_by : Steps_var_samp_order_by -> Value
encodeSteps_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildSteps_variance_order_by : (Steps_variance_order_byOptionalFields -> Steps_variance_order_byOptionalFields) -> Steps_variance_order_by
buildSteps_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Steps_variance_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Steps\_variance\_order\_by input object.
-}
type alias Steps_variance_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Steps\_variance\_order\_by into a value that can be used as an argument.
-}
encodeSteps_variance_order_by : Steps_variance_order_by -> Value
encodeSteps_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildString_comparison_exp : (String_comparison_expOptionalFields -> String_comparison_expOptionalFields) -> String_comparison_exp
buildString_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildTemplates_aggregate_order_by : (Templates_aggregate_order_byOptionalFields -> Templates_aggregate_order_byOptionalFields) -> Templates_aggregate_order_by
buildTemplates_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals.count, max = optionals.max, min = optionals.min }


type alias Templates_aggregate_order_byOptionalFields =
    { count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Templates_max_order_by
    , min : OptionalArgument Templates_min_order_by
    }


{-| Type for the Templates\_aggregate\_order\_by input object.
-}
type alias Templates_aggregate_order_by =
    { count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Templates_max_order_by
    , min : OptionalArgument Templates_min_order_by
    }


{-| Encode a Templates\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeTemplates_aggregate_order_by : Templates_aggregate_order_by -> Value
encodeTemplates_aggregate_order_by input =
    Encode.maybeObject
        [ ( "count", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeTemplates_max_order_by |> Encode.optional input.max ), ( "min", encodeTemplates_min_order_by |> Encode.optional input.min ) ]


buildTemplates_bool_exp : (Templates_bool_expOptionalFields -> Templates_bool_expOptionalFields) -> Templates_bool_exp
buildTemplates_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, config = Absent, name = Absent }
    in
    Templates_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, config = optionals.config, name = optionals.name }


type alias Templates_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Templates_bool_exp))
    , not_ : OptionalArgument Templates_bool_exp
    , or_ : OptionalArgument (List (Maybe Templates_bool_exp))
    , config : OptionalArgument Jsonb_comparison_exp
    , name : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Templates_bool_exp` attributes. Note that this type
needs to use the `Templates_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Templates_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Templates_bool_exp))
    , not_ : OptionalArgument Templates_bool_exp
    , or_ : OptionalArgument (List (Maybe Templates_bool_exp))
    , config : OptionalArgument Jsonb_comparison_exp
    , name : OptionalArgument String_comparison_exp
    }


{-| Type for the Templates\_bool\_exp input object.
-}
type Templates_bool_exp
    = Templates_bool_exp Templates_bool_expRaw


{-| Encode a Templates\_bool\_exp into a value that can be used as an argument.
-}
encodeTemplates_bool_exp : Templates_bool_exp -> Value
encodeTemplates_bool_exp (Templates_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeTemplates_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeTemplates_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeTemplates_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "config", encodeJsonb_comparison_exp |> Encode.optional input.config ), ( "name", encodeString_comparison_exp |> Encode.optional input.name ) ]


buildTemplates_max_order_by : (Templates_max_order_byOptionalFields -> Templates_max_order_byOptionalFields) -> Templates_max_order_by
buildTemplates_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent }
    in
    { name = optionals.name }


type alias Templates_max_order_byOptionalFields =
    { name : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Templates\_max\_order\_by input object.
-}
type alias Templates_max_order_by =
    { name : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Templates\_max\_order\_by into a value that can be used as an argument.
-}
encodeTemplates_max_order_by : Templates_max_order_by -> Value
encodeTemplates_max_order_by input =
    Encode.maybeObject
        [ ( "name", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildTemplates_min_order_by : (Templates_min_order_byOptionalFields -> Templates_min_order_byOptionalFields) -> Templates_min_order_by
buildTemplates_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent }
    in
    { name = optionals.name }


type alias Templates_min_order_byOptionalFields =
    { name : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Templates\_min\_order\_by input object.
-}
type alias Templates_min_order_by =
    { name : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Templates\_min\_order\_by into a value that can be used as an argument.
-}
encodeTemplates_min_order_by : Templates_min_order_by -> Value
encodeTemplates_min_order_by input =
    Encode.maybeObject
        [ ( "name", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildTemplates_order_by : (Templates_order_byOptionalFields -> Templates_order_byOptionalFields) -> Templates_order_by
buildTemplates_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { config = Absent, name = Absent }
    in
    { config = optionals.config, name = optionals.name }


type alias Templates_order_byOptionalFields =
    { config : OptionalArgument DetQL.Enum.Order_by.Order_by
    , name : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Templates\_order\_by input object.
-}
type alias Templates_order_by =
    { config : OptionalArgument DetQL.Enum.Order_by.Order_by
    , name : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Templates\_order\_by into a value that can be used as an argument.
-}
encodeTemplates_order_by : Templates_order_by -> Value
encodeTemplates_order_by input =
    Encode.maybeObject
        [ ( "config", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.config ), ( "name", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildTimestamp_comparison_exp : (Timestamp_comparison_expOptionalFields -> Timestamp_comparison_expOptionalFields) -> Timestamp_comparison_exp
buildTimestamp_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Timestamp_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalarCodecs.Timestamp
    , gt_ : OptionalArgument CustomScalarCodecs.Timestamp
    , gte_ : OptionalArgument CustomScalarCodecs.Timestamp
    , in_ : OptionalArgument (List CustomScalarCodecs.Timestamp)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Timestamp
    , lte_ : OptionalArgument CustomScalarCodecs.Timestamp
    , neq_ : OptionalArgument CustomScalarCodecs.Timestamp
    , nin_ : OptionalArgument (List CustomScalarCodecs.Timestamp)
    }


{-| Type for the Timestamp\_comparison\_exp input object.
-}
type alias Timestamp_comparison_exp =
    { eq_ : OptionalArgument CustomScalarCodecs.Timestamp
    , gt_ : OptionalArgument CustomScalarCodecs.Timestamp
    , gte_ : OptionalArgument CustomScalarCodecs.Timestamp
    , in_ : OptionalArgument (List CustomScalarCodecs.Timestamp)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Timestamp
    , lte_ : OptionalArgument CustomScalarCodecs.Timestamp
    , neq_ : OptionalArgument CustomScalarCodecs.Timestamp
    , nin_ : OptionalArgument (List CustomScalarCodecs.Timestamp)
    }


{-| Encode a Timestamp\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamp_comparison_exp : Timestamp_comparison_exp -> Value
encodeTimestamp_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamp) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildTimestamptz_comparison_exp : (Timestamptz_comparison_expOptionalFields -> Timestamptz_comparison_expOptionalFields) -> Timestamptz_comparison_exp
buildTimestamptz_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Timestamptz_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , gt_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , gte_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List CustomScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , lte_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , neq_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List CustomScalarCodecs.Timestamptz)
    }


{-| Type for the Timestamptz\_comparison\_exp input object.
-}
type alias Timestamptz_comparison_exp =
    { eq_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , gt_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , gte_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List CustomScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , lte_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , neq_ : OptionalArgument CustomScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List CustomScalarCodecs.Timestamptz)
    }


{-| Encode a Timestamptz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamptz_comparison_exp : Timestamptz_comparison_exp -> Value
encodeTimestamptz_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildTrial_logs_aggregate_order_by : (Trial_logs_aggregate_order_byOptionalFields -> Trial_logs_aggregate_order_byOptionalFields) -> Trial_logs_aggregate_order_by
buildTrial_logs_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Trial_logs_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Trial_logs_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Trial_logs_max_order_by
    , min : OptionalArgument Trial_logs_min_order_by
    , stddev : OptionalArgument Trial_logs_stddev_order_by
    , stddev_pop : OptionalArgument Trial_logs_stddev_pop_order_by
    , stddev_samp : OptionalArgument Trial_logs_stddev_samp_order_by
    , sum : OptionalArgument Trial_logs_sum_order_by
    , var_pop : OptionalArgument Trial_logs_var_pop_order_by
    , var_samp : OptionalArgument Trial_logs_var_samp_order_by
    , variance : OptionalArgument Trial_logs_variance_order_by
    }


{-| Type for the Trial\_logs\_aggregate\_order\_by input object.
-}
type alias Trial_logs_aggregate_order_by =
    { avg : OptionalArgument Trial_logs_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Trial_logs_max_order_by
    , min : OptionalArgument Trial_logs_min_order_by
    , stddev : OptionalArgument Trial_logs_stddev_order_by
    , stddev_pop : OptionalArgument Trial_logs_stddev_pop_order_by
    , stddev_samp : OptionalArgument Trial_logs_stddev_samp_order_by
    , sum : OptionalArgument Trial_logs_sum_order_by
    , var_pop : OptionalArgument Trial_logs_var_pop_order_by
    , var_samp : OptionalArgument Trial_logs_var_samp_order_by
    , variance : OptionalArgument Trial_logs_variance_order_by
    }


{-| Encode a Trial\_logs\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeTrial_logs_aggregate_order_by : Trial_logs_aggregate_order_by -> Value
encodeTrial_logs_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeTrial_logs_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeTrial_logs_max_order_by |> Encode.optional input.max ), ( "min", encodeTrial_logs_min_order_by |> Encode.optional input.min ), ( "stddev", encodeTrial_logs_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeTrial_logs_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeTrial_logs_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeTrial_logs_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeTrial_logs_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeTrial_logs_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeTrial_logs_variance_order_by |> Encode.optional input.variance ) ]


buildTrial_logs_avg_order_by : (Trial_logs_avg_order_byOptionalFields -> Trial_logs_avg_order_byOptionalFields) -> Trial_logs_avg_order_by
buildTrial_logs_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Trial_logs_avg_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trial\_logs\_avg\_order\_by input object.
-}
type alias Trial_logs_avg_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trial\_logs\_avg\_order\_by into a value that can be used as an argument.
-}
encodeTrial_logs_avg_order_by : Trial_logs_avg_order_by -> Value
encodeTrial_logs_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildTrial_logs_bool_exp : (Trial_logs_bool_expOptionalFields -> Trial_logs_bool_expOptionalFields) -> Trial_logs_bool_exp
buildTrial_logs_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, message = Absent, trial = Absent, trial_id = Absent }
    in
    Trial_logs_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, id = optionals.id, message = optionals.message, trial = optionals.trial, trial_id = optionals.trial_id }


type alias Trial_logs_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Trial_logs_bool_exp))
    , not_ : OptionalArgument Trial_logs_bool_exp
    , or_ : OptionalArgument (List (Maybe Trial_logs_bool_exp))
    , id : OptionalArgument Int_comparison_exp
    , message : OptionalArgument Bytea_comparison_exp
    , trial : OptionalArgument Trials_bool_exp
    , trial_id : OptionalArgument Int_comparison_exp
    }


{-| Type alias for the `Trial_logs_bool_exp` attributes. Note that this type
needs to use the `Trial_logs_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Trial_logs_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Trial_logs_bool_exp))
    , not_ : OptionalArgument Trial_logs_bool_exp
    , or_ : OptionalArgument (List (Maybe Trial_logs_bool_exp))
    , id : OptionalArgument Int_comparison_exp
    , message : OptionalArgument Bytea_comparison_exp
    , trial : OptionalArgument Trials_bool_exp
    , trial_id : OptionalArgument Int_comparison_exp
    }


{-| Type for the Trial\_logs\_bool\_exp input object.
-}
type Trial_logs_bool_exp
    = Trial_logs_bool_exp Trial_logs_bool_expRaw


{-| Encode a Trial\_logs\_bool\_exp into a value that can be used as an argument.
-}
encodeTrial_logs_bool_exp : Trial_logs_bool_exp -> Value
encodeTrial_logs_bool_exp (Trial_logs_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeTrial_logs_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeTrial_logs_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeTrial_logs_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "message", encodeBytea_comparison_exp |> Encode.optional input.message ), ( "trial", encodeTrials_bool_exp |> Encode.optional input.trial ), ( "trial_id", encodeInt_comparison_exp |> Encode.optional input.trial_id ) ]


buildTrial_logs_max_order_by : (Trial_logs_max_order_byOptionalFields -> Trial_logs_max_order_byOptionalFields) -> Trial_logs_max_order_by
buildTrial_logs_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Trial_logs_max_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trial\_logs\_max\_order\_by input object.
-}
type alias Trial_logs_max_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trial\_logs\_max\_order\_by into a value that can be used as an argument.
-}
encodeTrial_logs_max_order_by : Trial_logs_max_order_by -> Value
encodeTrial_logs_max_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildTrial_logs_min_order_by : (Trial_logs_min_order_byOptionalFields -> Trial_logs_min_order_byOptionalFields) -> Trial_logs_min_order_by
buildTrial_logs_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Trial_logs_min_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trial\_logs\_min\_order\_by input object.
-}
type alias Trial_logs_min_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trial\_logs\_min\_order\_by into a value that can be used as an argument.
-}
encodeTrial_logs_min_order_by : Trial_logs_min_order_by -> Value
encodeTrial_logs_min_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildTrial_logs_order_by : (Trial_logs_order_byOptionalFields -> Trial_logs_order_byOptionalFields) -> Trial_logs_order_by
buildTrial_logs_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, message = Absent, trial = Absent, trial_id = Absent }
    in
    Trial_logs_order_by { id = optionals.id, message = optionals.message, trial = optionals.trial, trial_id = optionals.trial_id }


type alias Trial_logs_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , message : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial : OptionalArgument Trials_order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Trial_logs_order_by` attributes. Note that this type
needs to use the `Trial_logs_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Trial_logs_order_byRaw =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , message : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial : OptionalArgument Trials_order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trial\_logs\_order\_by input object.
-}
type Trial_logs_order_by
    = Trial_logs_order_by Trial_logs_order_byRaw


{-| Encode a Trial\_logs\_order\_by into a value that can be used as an argument.
-}
encodeTrial_logs_order_by : Trial_logs_order_by -> Value
encodeTrial_logs_order_by (Trial_logs_order_by input) =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "message", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.message ), ( "trial", encodeTrials_order_by |> Encode.optional input.trial ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildTrial_logs_stddev_order_by : (Trial_logs_stddev_order_byOptionalFields -> Trial_logs_stddev_order_byOptionalFields) -> Trial_logs_stddev_order_by
buildTrial_logs_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Trial_logs_stddev_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trial\_logs\_stddev\_order\_by input object.
-}
type alias Trial_logs_stddev_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trial\_logs\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeTrial_logs_stddev_order_by : Trial_logs_stddev_order_by -> Value
encodeTrial_logs_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildTrial_logs_stddev_pop_order_by : (Trial_logs_stddev_pop_order_byOptionalFields -> Trial_logs_stddev_pop_order_byOptionalFields) -> Trial_logs_stddev_pop_order_by
buildTrial_logs_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Trial_logs_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trial\_logs\_stddev\_pop\_order\_by input object.
-}
type alias Trial_logs_stddev_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trial\_logs\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeTrial_logs_stddev_pop_order_by : Trial_logs_stddev_pop_order_by -> Value
encodeTrial_logs_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildTrial_logs_stddev_samp_order_by : (Trial_logs_stddev_samp_order_byOptionalFields -> Trial_logs_stddev_samp_order_byOptionalFields) -> Trial_logs_stddev_samp_order_by
buildTrial_logs_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Trial_logs_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trial\_logs\_stddev\_samp\_order\_by input object.
-}
type alias Trial_logs_stddev_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trial\_logs\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeTrial_logs_stddev_samp_order_by : Trial_logs_stddev_samp_order_by -> Value
encodeTrial_logs_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildTrial_logs_sum_order_by : (Trial_logs_sum_order_byOptionalFields -> Trial_logs_sum_order_byOptionalFields) -> Trial_logs_sum_order_by
buildTrial_logs_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Trial_logs_sum_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trial\_logs\_sum\_order\_by input object.
-}
type alias Trial_logs_sum_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trial\_logs\_sum\_order\_by into a value that can be used as an argument.
-}
encodeTrial_logs_sum_order_by : Trial_logs_sum_order_by -> Value
encodeTrial_logs_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildTrial_logs_var_pop_order_by : (Trial_logs_var_pop_order_byOptionalFields -> Trial_logs_var_pop_order_byOptionalFields) -> Trial_logs_var_pop_order_by
buildTrial_logs_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Trial_logs_var_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trial\_logs\_var\_pop\_order\_by input object.
-}
type alias Trial_logs_var_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trial\_logs\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeTrial_logs_var_pop_order_by : Trial_logs_var_pop_order_by -> Value
encodeTrial_logs_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildTrial_logs_var_samp_order_by : (Trial_logs_var_samp_order_byOptionalFields -> Trial_logs_var_samp_order_byOptionalFields) -> Trial_logs_var_samp_order_by
buildTrial_logs_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Trial_logs_var_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trial\_logs\_var\_samp\_order\_by input object.
-}
type alias Trial_logs_var_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trial\_logs\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeTrial_logs_var_samp_order_by : Trial_logs_var_samp_order_by -> Value
encodeTrial_logs_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildTrial_logs_variance_order_by : (Trial_logs_variance_order_byOptionalFields -> Trial_logs_variance_order_byOptionalFields) -> Trial_logs_variance_order_by
buildTrial_logs_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, trial_id = Absent }
    in
    { id = optionals.id, trial_id = optionals.trial_id }


type alias Trial_logs_variance_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trial\_logs\_variance\_order\_by input object.
-}
type alias Trial_logs_variance_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trial\_logs\_variance\_order\_by into a value that can be used as an argument.
-}
encodeTrial_logs_variance_order_by : Trial_logs_variance_order_by -> Value
encodeTrial_logs_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildTrial_state_comparison_exp : (Trial_state_comparison_expOptionalFields -> Trial_state_comparison_expOptionalFields) -> Trial_state_comparison_exp
buildTrial_state_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Trial_state_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalarCodecs.Trial_state
    , gt_ : OptionalArgument CustomScalarCodecs.Trial_state
    , gte_ : OptionalArgument CustomScalarCodecs.Trial_state
    , in_ : OptionalArgument (List CustomScalarCodecs.Trial_state)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Trial_state
    , lte_ : OptionalArgument CustomScalarCodecs.Trial_state
    , neq_ : OptionalArgument CustomScalarCodecs.Trial_state
    , nin_ : OptionalArgument (List CustomScalarCodecs.Trial_state)
    }


{-| Type for the Trial\_state\_comparison\_exp input object.
-}
type alias Trial_state_comparison_exp =
    { eq_ : OptionalArgument CustomScalarCodecs.Trial_state
    , gt_ : OptionalArgument CustomScalarCodecs.Trial_state
    , gte_ : OptionalArgument CustomScalarCodecs.Trial_state
    , in_ : OptionalArgument (List CustomScalarCodecs.Trial_state)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Trial_state
    , lte_ : OptionalArgument CustomScalarCodecs.Trial_state
    , neq_ : OptionalArgument CustomScalarCodecs.Trial_state
    , nin_ : OptionalArgument (List CustomScalarCodecs.Trial_state)
    }


{-| Encode a Trial\_state\_comparison\_exp into a value that can be used as an argument.
-}
encodeTrial_state_comparison_exp : Trial_state_comparison_exp -> Value
encodeTrial_state_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTrial_state) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTrial_state) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTrial_state) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTrial_state) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTrial_state) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTrial_state) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTrial_state) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecTrial_state) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildTrials_aggregate_order_by : (Trials_aggregate_order_byOptionalFields -> Trials_aggregate_order_byOptionalFields) -> Trials_aggregate_order_by
buildTrials_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Trials_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Trials_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Trials_max_order_by
    , min : OptionalArgument Trials_min_order_by
    , stddev : OptionalArgument Trials_stddev_order_by
    , stddev_pop : OptionalArgument Trials_stddev_pop_order_by
    , stddev_samp : OptionalArgument Trials_stddev_samp_order_by
    , sum : OptionalArgument Trials_sum_order_by
    , var_pop : OptionalArgument Trials_var_pop_order_by
    , var_samp : OptionalArgument Trials_var_samp_order_by
    , variance : OptionalArgument Trials_variance_order_by
    }


{-| Type for the Trials\_aggregate\_order\_by input object.
-}
type alias Trials_aggregate_order_by =
    { avg : OptionalArgument Trials_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Trials_max_order_by
    , min : OptionalArgument Trials_min_order_by
    , stddev : OptionalArgument Trials_stddev_order_by
    , stddev_pop : OptionalArgument Trials_stddev_pop_order_by
    , stddev_samp : OptionalArgument Trials_stddev_samp_order_by
    , sum : OptionalArgument Trials_sum_order_by
    , var_pop : OptionalArgument Trials_var_pop_order_by
    , var_samp : OptionalArgument Trials_var_samp_order_by
    , variance : OptionalArgument Trials_variance_order_by
    }


{-| Encode a Trials\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeTrials_aggregate_order_by : Trials_aggregate_order_by -> Value
encodeTrials_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeTrials_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeTrials_max_order_by |> Encode.optional input.max ), ( "min", encodeTrials_min_order_by |> Encode.optional input.min ), ( "stddev", encodeTrials_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeTrials_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeTrials_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeTrials_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeTrials_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeTrials_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeTrials_variance_order_by |> Encode.optional input.variance ) ]


buildTrials_avg_order_by : (Trials_avg_order_byOptionalFields -> Trials_avg_order_byOptionalFields) -> Trials_avg_order_by
buildTrials_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent, seed = Absent, warm_start_checkpoint_id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id, seed = optionals.seed, warm_start_checkpoint_id = optionals.warm_start_checkpoint_id }


type alias Trials_avg_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trials\_avg\_order\_by input object.
-}
type alias Trials_avg_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trials\_avg\_order\_by into a value that can be used as an argument.
-}
encodeTrials_avg_order_by : Trials_avg_order_by -> Value
encodeTrials_avg_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "seed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.seed ), ( "warm_start_checkpoint_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.warm_start_checkpoint_id ) ]


buildTrials_bool_exp : (Trials_bool_expOptionalFields -> Trials_bool_expOptionalFields) -> Trials_bool_exp
buildTrials_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, checkpoint = Absent, checkpoints = Absent, end_time = Absent, experiment = Absent, experiment_id = Absent, hparams = Absent, id = Absent, seed = Absent, start_time = Absent, state = Absent, steps = Absent, trial_logs = Absent, validations = Absent, warm_start_checkpoint_id = Absent }
    in
    Trials_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, checkpoint = optionals.checkpoint, checkpoints = optionals.checkpoints, end_time = optionals.end_time, experiment = optionals.experiment, experiment_id = optionals.experiment_id, hparams = optionals.hparams, id = optionals.id, seed = optionals.seed, start_time = optionals.start_time, state = optionals.state, steps = optionals.steps, trial_logs = optionals.trial_logs, validations = optionals.validations, warm_start_checkpoint_id = optionals.warm_start_checkpoint_id }


type alias Trials_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Trials_bool_exp))
    , not_ : OptionalArgument Trials_bool_exp
    , or_ : OptionalArgument (List (Maybe Trials_bool_exp))
    , checkpoint : OptionalArgument Checkpoints_bool_exp
    , checkpoints : OptionalArgument Checkpoints_bool_exp
    , end_time : OptionalArgument Timestamptz_comparison_exp
    , experiment : OptionalArgument Experiments_bool_exp
    , experiment_id : OptionalArgument Int_comparison_exp
    , hparams : OptionalArgument Jsonb_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , seed : OptionalArgument Int_comparison_exp
    , start_time : OptionalArgument Timestamptz_comparison_exp
    , state : OptionalArgument Trial_state_comparison_exp
    , steps : OptionalArgument Steps_bool_exp
    , trial_logs : OptionalArgument Trial_logs_bool_exp
    , validations : OptionalArgument Validations_bool_exp
    , warm_start_checkpoint_id : OptionalArgument Int_comparison_exp
    }


{-| Type alias for the `Trials_bool_exp` attributes. Note that this type
needs to use the `Trials_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Trials_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Trials_bool_exp))
    , not_ : OptionalArgument Trials_bool_exp
    , or_ : OptionalArgument (List (Maybe Trials_bool_exp))
    , checkpoint : OptionalArgument Checkpoints_bool_exp
    , checkpoints : OptionalArgument Checkpoints_bool_exp
    , end_time : OptionalArgument Timestamptz_comparison_exp
    , experiment : OptionalArgument Experiments_bool_exp
    , experiment_id : OptionalArgument Int_comparison_exp
    , hparams : OptionalArgument Jsonb_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , seed : OptionalArgument Int_comparison_exp
    , start_time : OptionalArgument Timestamptz_comparison_exp
    , state : OptionalArgument Trial_state_comparison_exp
    , steps : OptionalArgument Steps_bool_exp
    , trial_logs : OptionalArgument Trial_logs_bool_exp
    , validations : OptionalArgument Validations_bool_exp
    , warm_start_checkpoint_id : OptionalArgument Int_comparison_exp
    }


{-| Type for the Trials\_bool\_exp input object.
-}
type Trials_bool_exp
    = Trials_bool_exp Trials_bool_expRaw


{-| Encode a Trials\_bool\_exp into a value that can be used as an argument.
-}
encodeTrials_bool_exp : Trials_bool_exp -> Value
encodeTrials_bool_exp (Trials_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeTrials_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeTrials_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeTrials_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "checkpoint", encodeCheckpoints_bool_exp |> Encode.optional input.checkpoint ), ( "checkpoints", encodeCheckpoints_bool_exp |> Encode.optional input.checkpoints ), ( "end_time", encodeTimestamptz_comparison_exp |> Encode.optional input.end_time ), ( "experiment", encodeExperiments_bool_exp |> Encode.optional input.experiment ), ( "experiment_id", encodeInt_comparison_exp |> Encode.optional input.experiment_id ), ( "hparams", encodeJsonb_comparison_exp |> Encode.optional input.hparams ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "seed", encodeInt_comparison_exp |> Encode.optional input.seed ), ( "start_time", encodeTimestamptz_comparison_exp |> Encode.optional input.start_time ), ( "state", encodeTrial_state_comparison_exp |> Encode.optional input.state ), ( "steps", encodeSteps_bool_exp |> Encode.optional input.steps ), ( "trial_logs", encodeTrial_logs_bool_exp |> Encode.optional input.trial_logs ), ( "validations", encodeValidations_bool_exp |> Encode.optional input.validations ), ( "warm_start_checkpoint_id", encodeInt_comparison_exp |> Encode.optional input.warm_start_checkpoint_id ) ]


buildTrials_max_order_by : (Trials_max_order_byOptionalFields -> Trials_max_order_byOptionalFields) -> Trials_max_order_by
buildTrials_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { end_time = Absent, experiment_id = Absent, id = Absent, seed = Absent, start_time = Absent, warm_start_checkpoint_id = Absent }
    in
    { end_time = optionals.end_time, experiment_id = optionals.experiment_id, id = optionals.id, seed = optionals.seed, start_time = optionals.start_time, warm_start_checkpoint_id = optionals.warm_start_checkpoint_id }


type alias Trials_max_order_byOptionalFields =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trials\_max\_order\_by input object.
-}
type alias Trials_max_order_by =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trials\_max\_order\_by into a value that can be used as an argument.
-}
encodeTrials_max_order_by : Trials_max_order_by -> Value
encodeTrials_max_order_by input =
    Encode.maybeObject
        [ ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "seed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.seed ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ), ( "warm_start_checkpoint_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.warm_start_checkpoint_id ) ]


buildTrials_min_order_by : (Trials_min_order_byOptionalFields -> Trials_min_order_byOptionalFields) -> Trials_min_order_by
buildTrials_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { end_time = Absent, experiment_id = Absent, id = Absent, seed = Absent, start_time = Absent, warm_start_checkpoint_id = Absent }
    in
    { end_time = optionals.end_time, experiment_id = optionals.experiment_id, id = optionals.id, seed = optionals.seed, start_time = optionals.start_time, warm_start_checkpoint_id = optionals.warm_start_checkpoint_id }


type alias Trials_min_order_byOptionalFields =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trials\_min\_order\_by input object.
-}
type alias Trials_min_order_by =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trials\_min\_order\_by into a value that can be used as an argument.
-}
encodeTrials_min_order_by : Trials_min_order_by -> Value
encodeTrials_min_order_by input =
    Encode.maybeObject
        [ ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "seed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.seed ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ), ( "warm_start_checkpoint_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.warm_start_checkpoint_id ) ]


buildTrials_order_by : (Trials_order_byOptionalFields -> Trials_order_byOptionalFields) -> Trials_order_by
buildTrials_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { checkpoint = Absent, checkpoints_aggregate = Absent, end_time = Absent, experiment = Absent, experiment_id = Absent, hparams = Absent, id = Absent, seed = Absent, start_time = Absent, state = Absent, steps_aggregate = Absent, trial_logs_aggregate = Absent, validations_aggregate = Absent, warm_start_checkpoint_id = Absent }
    in
    Trials_order_by { checkpoint = optionals.checkpoint, checkpoints_aggregate = optionals.checkpoints_aggregate, end_time = optionals.end_time, experiment = optionals.experiment, experiment_id = optionals.experiment_id, hparams = optionals.hparams, id = optionals.id, seed = optionals.seed, start_time = optionals.start_time, state = optionals.state, steps_aggregate = optionals.steps_aggregate, trial_logs_aggregate = optionals.trial_logs_aggregate, validations_aggregate = optionals.validations_aggregate, warm_start_checkpoint_id = optionals.warm_start_checkpoint_id }


type alias Trials_order_byOptionalFields =
    { checkpoint : OptionalArgument Checkpoints_order_by
    , checkpoints_aggregate : OptionalArgument Checkpoints_aggregate_order_by
    , end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , experiment : OptionalArgument Experiments_order_by
    , experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , hparams : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , state : OptionalArgument DetQL.Enum.Order_by.Order_by
    , steps_aggregate : OptionalArgument Steps_aggregate_order_by
    , trial_logs_aggregate : OptionalArgument Trial_logs_aggregate_order_by
    , validations_aggregate : OptionalArgument Validations_aggregate_order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Trials_order_by` attributes. Note that this type
needs to use the `Trials_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Trials_order_byRaw =
    { checkpoint : OptionalArgument Checkpoints_order_by
    , checkpoints_aggregate : OptionalArgument Checkpoints_aggregate_order_by
    , end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , experiment : OptionalArgument Experiments_order_by
    , experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , hparams : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , state : OptionalArgument DetQL.Enum.Order_by.Order_by
    , steps_aggregate : OptionalArgument Steps_aggregate_order_by
    , trial_logs_aggregate : OptionalArgument Trial_logs_aggregate_order_by
    , validations_aggregate : OptionalArgument Validations_aggregate_order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trials\_order\_by input object.
-}
type Trials_order_by
    = Trials_order_by Trials_order_byRaw


{-| Encode a Trials\_order\_by into a value that can be used as an argument.
-}
encodeTrials_order_by : Trials_order_by -> Value
encodeTrials_order_by (Trials_order_by input) =
    Encode.maybeObject
        [ ( "checkpoint", encodeCheckpoints_order_by |> Encode.optional input.checkpoint ), ( "checkpoints_aggregate", encodeCheckpoints_aggregate_order_by |> Encode.optional input.checkpoints_aggregate ), ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "experiment", encodeExperiments_order_by |> Encode.optional input.experiment ), ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "hparams", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.hparams ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "seed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.seed ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ), ( "state", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.state ), ( "steps_aggregate", encodeSteps_aggregate_order_by |> Encode.optional input.steps_aggregate ), ( "trial_logs_aggregate", encodeTrial_logs_aggregate_order_by |> Encode.optional input.trial_logs_aggregate ), ( "validations_aggregate", encodeValidations_aggregate_order_by |> Encode.optional input.validations_aggregate ), ( "warm_start_checkpoint_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.warm_start_checkpoint_id ) ]


buildTrials_stddev_order_by : (Trials_stddev_order_byOptionalFields -> Trials_stddev_order_byOptionalFields) -> Trials_stddev_order_by
buildTrials_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent, seed = Absent, warm_start_checkpoint_id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id, seed = optionals.seed, warm_start_checkpoint_id = optionals.warm_start_checkpoint_id }


type alias Trials_stddev_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trials\_stddev\_order\_by input object.
-}
type alias Trials_stddev_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trials\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeTrials_stddev_order_by : Trials_stddev_order_by -> Value
encodeTrials_stddev_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "seed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.seed ), ( "warm_start_checkpoint_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.warm_start_checkpoint_id ) ]


buildTrials_stddev_pop_order_by : (Trials_stddev_pop_order_byOptionalFields -> Trials_stddev_pop_order_byOptionalFields) -> Trials_stddev_pop_order_by
buildTrials_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent, seed = Absent, warm_start_checkpoint_id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id, seed = optionals.seed, warm_start_checkpoint_id = optionals.warm_start_checkpoint_id }


type alias Trials_stddev_pop_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trials\_stddev\_pop\_order\_by input object.
-}
type alias Trials_stddev_pop_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trials\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeTrials_stddev_pop_order_by : Trials_stddev_pop_order_by -> Value
encodeTrials_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "seed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.seed ), ( "warm_start_checkpoint_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.warm_start_checkpoint_id ) ]


buildTrials_stddev_samp_order_by : (Trials_stddev_samp_order_byOptionalFields -> Trials_stddev_samp_order_byOptionalFields) -> Trials_stddev_samp_order_by
buildTrials_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent, seed = Absent, warm_start_checkpoint_id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id, seed = optionals.seed, warm_start_checkpoint_id = optionals.warm_start_checkpoint_id }


type alias Trials_stddev_samp_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trials\_stddev\_samp\_order\_by input object.
-}
type alias Trials_stddev_samp_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trials\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeTrials_stddev_samp_order_by : Trials_stddev_samp_order_by -> Value
encodeTrials_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "seed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.seed ), ( "warm_start_checkpoint_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.warm_start_checkpoint_id ) ]


buildTrials_sum_order_by : (Trials_sum_order_byOptionalFields -> Trials_sum_order_byOptionalFields) -> Trials_sum_order_by
buildTrials_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent, seed = Absent, warm_start_checkpoint_id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id, seed = optionals.seed, warm_start_checkpoint_id = optionals.warm_start_checkpoint_id }


type alias Trials_sum_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trials\_sum\_order\_by input object.
-}
type alias Trials_sum_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trials\_sum\_order\_by into a value that can be used as an argument.
-}
encodeTrials_sum_order_by : Trials_sum_order_by -> Value
encodeTrials_sum_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "seed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.seed ), ( "warm_start_checkpoint_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.warm_start_checkpoint_id ) ]


buildTrials_var_pop_order_by : (Trials_var_pop_order_byOptionalFields -> Trials_var_pop_order_byOptionalFields) -> Trials_var_pop_order_by
buildTrials_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent, seed = Absent, warm_start_checkpoint_id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id, seed = optionals.seed, warm_start_checkpoint_id = optionals.warm_start_checkpoint_id }


type alias Trials_var_pop_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trials\_var\_pop\_order\_by input object.
-}
type alias Trials_var_pop_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trials\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeTrials_var_pop_order_by : Trials_var_pop_order_by -> Value
encodeTrials_var_pop_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "seed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.seed ), ( "warm_start_checkpoint_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.warm_start_checkpoint_id ) ]


buildTrials_var_samp_order_by : (Trials_var_samp_order_byOptionalFields -> Trials_var_samp_order_byOptionalFields) -> Trials_var_samp_order_by
buildTrials_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent, seed = Absent, warm_start_checkpoint_id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id, seed = optionals.seed, warm_start_checkpoint_id = optionals.warm_start_checkpoint_id }


type alias Trials_var_samp_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trials\_var\_samp\_order\_by input object.
-}
type alias Trials_var_samp_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trials\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeTrials_var_samp_order_by : Trials_var_samp_order_by -> Value
encodeTrials_var_samp_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "seed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.seed ), ( "warm_start_checkpoint_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.warm_start_checkpoint_id ) ]


buildTrials_variance_order_by : (Trials_variance_order_byOptionalFields -> Trials_variance_order_byOptionalFields) -> Trials_variance_order_by
buildTrials_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { experiment_id = Absent, id = Absent, seed = Absent, warm_start_checkpoint_id = Absent }
    in
    { experiment_id = optionals.experiment_id, id = optionals.id, seed = optionals.seed, warm_start_checkpoint_id = optionals.warm_start_checkpoint_id }


type alias Trials_variance_order_byOptionalFields =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Trials\_variance\_order\_by input object.
-}
type alias Trials_variance_order_by =
    { experiment_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , seed : OptionalArgument DetQL.Enum.Order_by.Order_by
    , warm_start_checkpoint_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Trials\_variance\_order\_by into a value that can be used as an argument.
-}
encodeTrials_variance_order_by : Trials_variance_order_by -> Value
encodeTrials_variance_order_by input =
    Encode.maybeObject
        [ ( "experiment_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.experiment_id ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "seed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.seed ), ( "warm_start_checkpoint_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.warm_start_checkpoint_id ) ]


buildUsers_aggregate_order_by : (Users_aggregate_order_byOptionalFields -> Users_aggregate_order_byOptionalFields) -> Users_aggregate_order_by
buildUsers_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Users_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Users_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Users_max_order_by
    , min : OptionalArgument Users_min_order_by
    , stddev : OptionalArgument Users_stddev_order_by
    , stddev_pop : OptionalArgument Users_stddev_pop_order_by
    , stddev_samp : OptionalArgument Users_stddev_samp_order_by
    , sum : OptionalArgument Users_sum_order_by
    , var_pop : OptionalArgument Users_var_pop_order_by
    , var_samp : OptionalArgument Users_var_samp_order_by
    , variance : OptionalArgument Users_variance_order_by
    }


{-| Type for the Users\_aggregate\_order\_by input object.
-}
type alias Users_aggregate_order_by =
    { avg : OptionalArgument Users_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Users_max_order_by
    , min : OptionalArgument Users_min_order_by
    , stddev : OptionalArgument Users_stddev_order_by
    , stddev_pop : OptionalArgument Users_stddev_pop_order_by
    , stddev_samp : OptionalArgument Users_stddev_samp_order_by
    , sum : OptionalArgument Users_sum_order_by
    , var_pop : OptionalArgument Users_var_pop_order_by
    , var_samp : OptionalArgument Users_var_samp_order_by
    , variance : OptionalArgument Users_variance_order_by
    }


{-| Encode a Users\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeUsers_aggregate_order_by : Users_aggregate_order_by -> Value
encodeUsers_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeUsers_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeUsers_max_order_by |> Encode.optional input.max ), ( "min", encodeUsers_min_order_by |> Encode.optional input.min ), ( "stddev", encodeUsers_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeUsers_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeUsers_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeUsers_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeUsers_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeUsers_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeUsers_variance_order_by |> Encode.optional input.variance ) ]


buildUsers_avg_order_by : (Users_avg_order_byOptionalFields -> Users_avg_order_byOptionalFields) -> Users_avg_order_by
buildUsers_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_avg_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Users\_avg\_order\_by input object.
-}
type alias Users_avg_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Users\_avg\_order\_by into a value that can be used as an argument.
-}
encodeUsers_avg_order_by : Users_avg_order_by -> Value
encodeUsers_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_bool_exp : (Users_bool_expOptionalFields -> Users_bool_expOptionalFields) -> Users_bool_exp
buildUsers_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, active = Absent, admin = Absent, agent_user_group = Absent, experiments = Absent, id = Absent, username = Absent }
    in
    Users_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, active = optionals.active, admin = optionals.admin, agent_user_group = optionals.agent_user_group, experiments = optionals.experiments, id = optionals.id, username = optionals.username }


type alias Users_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Users_bool_exp))
    , not_ : OptionalArgument Users_bool_exp
    , or_ : OptionalArgument (List (Maybe Users_bool_exp))
    , active : OptionalArgument Boolean_comparison_exp
    , admin : OptionalArgument Boolean_comparison_exp
    , agent_user_group : OptionalArgument Agent_user_groups_bool_exp
    , experiments : OptionalArgument Experiments_bool_exp
    , id : OptionalArgument Int_comparison_exp
    , username : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Users_bool_exp` attributes. Note that this type
needs to use the `Users_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Users_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Users_bool_exp))
    , not_ : OptionalArgument Users_bool_exp
    , or_ : OptionalArgument (List (Maybe Users_bool_exp))
    , active : OptionalArgument Boolean_comparison_exp
    , admin : OptionalArgument Boolean_comparison_exp
    , agent_user_group : OptionalArgument Agent_user_groups_bool_exp
    , experiments : OptionalArgument Experiments_bool_exp
    , id : OptionalArgument Int_comparison_exp
    , username : OptionalArgument String_comparison_exp
    }


{-| Type for the Users\_bool\_exp input object.
-}
type Users_bool_exp
    = Users_bool_exp Users_bool_expRaw


{-| Encode a Users\_bool\_exp into a value that can be used as an argument.
-}
encodeUsers_bool_exp : Users_bool_exp -> Value
encodeUsers_bool_exp (Users_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeUsers_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeUsers_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeUsers_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "active", encodeBoolean_comparison_exp |> Encode.optional input.active ), ( "admin", encodeBoolean_comparison_exp |> Encode.optional input.admin ), ( "agent_user_group", encodeAgent_user_groups_bool_exp |> Encode.optional input.agent_user_group ), ( "experiments", encodeExperiments_bool_exp |> Encode.optional input.experiments ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "username", encodeString_comparison_exp |> Encode.optional input.username ) ]


buildUsers_max_order_by : (Users_max_order_byOptionalFields -> Users_max_order_byOptionalFields) -> Users_max_order_by
buildUsers_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, username = Absent }
    in
    { id = optionals.id, username = optionals.username }


type alias Users_max_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , username : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Users\_max\_order\_by input object.
-}
type alias Users_max_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , username : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Users\_max\_order\_by into a value that can be used as an argument.
-}
encodeUsers_max_order_by : Users_max_order_by -> Value
encodeUsers_max_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "username", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildUsers_min_order_by : (Users_min_order_byOptionalFields -> Users_min_order_byOptionalFields) -> Users_min_order_by
buildUsers_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, username = Absent }
    in
    { id = optionals.id, username = optionals.username }


type alias Users_min_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , username : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Users\_min\_order\_by input object.
-}
type alias Users_min_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , username : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Users\_min\_order\_by into a value that can be used as an argument.
-}
encodeUsers_min_order_by : Users_min_order_by -> Value
encodeUsers_min_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "username", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildUsers_order_by : (Users_order_byOptionalFields -> Users_order_byOptionalFields) -> Users_order_by
buildUsers_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { active = Absent, admin = Absent, agent_user_group = Absent, experiments_aggregate = Absent, id = Absent, username = Absent }
    in
    Users_order_by { active = optionals.active, admin = optionals.admin, agent_user_group = optionals.agent_user_group, experiments_aggregate = optionals.experiments_aggregate, id = optionals.id, username = optionals.username }


type alias Users_order_byOptionalFields =
    { active : OptionalArgument DetQL.Enum.Order_by.Order_by
    , admin : OptionalArgument DetQL.Enum.Order_by.Order_by
    , agent_user_group : OptionalArgument Agent_user_groups_order_by
    , experiments_aggregate : OptionalArgument Experiments_aggregate_order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , username : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Users_order_by` attributes. Note that this type
needs to use the `Users_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Users_order_byRaw =
    { active : OptionalArgument DetQL.Enum.Order_by.Order_by
    , admin : OptionalArgument DetQL.Enum.Order_by.Order_by
    , agent_user_group : OptionalArgument Agent_user_groups_order_by
    , experiments_aggregate : OptionalArgument Experiments_aggregate_order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , username : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Users\_order\_by input object.
-}
type Users_order_by
    = Users_order_by Users_order_byRaw


{-| Encode a Users\_order\_by into a value that can be used as an argument.
-}
encodeUsers_order_by : Users_order_by -> Value
encodeUsers_order_by (Users_order_by input) =
    Encode.maybeObject
        [ ( "active", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.active ), ( "admin", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.admin ), ( "agent_user_group", encodeAgent_user_groups_order_by |> Encode.optional input.agent_user_group ), ( "experiments_aggregate", encodeExperiments_aggregate_order_by |> Encode.optional input.experiments_aggregate ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "username", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildUsers_stddev_order_by : (Users_stddev_order_byOptionalFields -> Users_stddev_order_byOptionalFields) -> Users_stddev_order_by
buildUsers_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_stddev_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Users\_stddev\_order\_by input object.
-}
type alias Users_stddev_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Users\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeUsers_stddev_order_by : Users_stddev_order_by -> Value
encodeUsers_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_stddev_pop_order_by : (Users_stddev_pop_order_byOptionalFields -> Users_stddev_pop_order_byOptionalFields) -> Users_stddev_pop_order_by
buildUsers_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Users\_stddev\_pop\_order\_by input object.
-}
type alias Users_stddev_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Users\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeUsers_stddev_pop_order_by : Users_stddev_pop_order_by -> Value
encodeUsers_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_stddev_samp_order_by : (Users_stddev_samp_order_byOptionalFields -> Users_stddev_samp_order_byOptionalFields) -> Users_stddev_samp_order_by
buildUsers_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Users\_stddev\_samp\_order\_by input object.
-}
type alias Users_stddev_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Users\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeUsers_stddev_samp_order_by : Users_stddev_samp_order_by -> Value
encodeUsers_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_sum_order_by : (Users_sum_order_byOptionalFields -> Users_sum_order_byOptionalFields) -> Users_sum_order_by
buildUsers_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_sum_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Users\_sum\_order\_by input object.
-}
type alias Users_sum_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Users\_sum\_order\_by into a value that can be used as an argument.
-}
encodeUsers_sum_order_by : Users_sum_order_by -> Value
encodeUsers_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_var_pop_order_by : (Users_var_pop_order_byOptionalFields -> Users_var_pop_order_byOptionalFields) -> Users_var_pop_order_by
buildUsers_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_var_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Users\_var\_pop\_order\_by input object.
-}
type alias Users_var_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Users\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeUsers_var_pop_order_by : Users_var_pop_order_by -> Value
encodeUsers_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_var_samp_order_by : (Users_var_samp_order_byOptionalFields -> Users_var_samp_order_byOptionalFields) -> Users_var_samp_order_by
buildUsers_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_var_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Users\_var\_samp\_order\_by input object.
-}
type alias Users_var_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Users\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeUsers_var_samp_order_by : Users_var_samp_order_by -> Value
encodeUsers_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_variance_order_by : (Users_variance_order_byOptionalFields -> Users_variance_order_byOptionalFields) -> Users_variance_order_by
buildUsers_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_variance_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Type for the Users\_variance\_order\_by input object.
-}
type alias Users_variance_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by }


{-| Encode a Users\_variance\_order\_by into a value that can be used as an argument.
-}
encodeUsers_variance_order_by : Users_variance_order_by -> Value
encodeUsers_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUuid_comparison_exp : (Uuid_comparison_expOptionalFields -> Uuid_comparison_expOptionalFields) -> Uuid_comparison_exp
buildUuid_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Uuid_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalarCodecs.Uuid
    , gt_ : OptionalArgument CustomScalarCodecs.Uuid
    , gte_ : OptionalArgument CustomScalarCodecs.Uuid
    , in_ : OptionalArgument (List CustomScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Uuid
    , lte_ : OptionalArgument CustomScalarCodecs.Uuid
    , neq_ : OptionalArgument CustomScalarCodecs.Uuid
    , nin_ : OptionalArgument (List CustomScalarCodecs.Uuid)
    }


{-| Type for the Uuid\_comparison\_exp input object.
-}
type alias Uuid_comparison_exp =
    { eq_ : OptionalArgument CustomScalarCodecs.Uuid
    , gt_ : OptionalArgument CustomScalarCodecs.Uuid
    , gte_ : OptionalArgument CustomScalarCodecs.Uuid
    , in_ : OptionalArgument (List CustomScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Uuid
    , lte_ : OptionalArgument CustomScalarCodecs.Uuid
    , neq_ : OptionalArgument CustomScalarCodecs.Uuid
    , nin_ : OptionalArgument (List CustomScalarCodecs.Uuid)
    }


{-| Encode a Uuid\_comparison\_exp into a value that can be used as an argument.
-}
encodeUuid_comparison_exp : Uuid_comparison_exp -> Value
encodeUuid_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildValidation_metrics_aggregate_order_by : (Validation_metrics_aggregate_order_byOptionalFields -> Validation_metrics_aggregate_order_byOptionalFields) -> Validation_metrics_aggregate_order_by
buildValidation_metrics_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Validation_metrics_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Validation_metrics_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Validation_metrics_max_order_by
    , min : OptionalArgument Validation_metrics_min_order_by
    , stddev : OptionalArgument Validation_metrics_stddev_order_by
    , stddev_pop : OptionalArgument Validation_metrics_stddev_pop_order_by
    , stddev_samp : OptionalArgument Validation_metrics_stddev_samp_order_by
    , sum : OptionalArgument Validation_metrics_sum_order_by
    , var_pop : OptionalArgument Validation_metrics_var_pop_order_by
    , var_samp : OptionalArgument Validation_metrics_var_samp_order_by
    , variance : OptionalArgument Validation_metrics_variance_order_by
    }


{-| Type for the Validation\_metrics\_aggregate\_order\_by input object.
-}
type alias Validation_metrics_aggregate_order_by =
    { avg : OptionalArgument Validation_metrics_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Validation_metrics_max_order_by
    , min : OptionalArgument Validation_metrics_min_order_by
    , stddev : OptionalArgument Validation_metrics_stddev_order_by
    , stddev_pop : OptionalArgument Validation_metrics_stddev_pop_order_by
    , stddev_samp : OptionalArgument Validation_metrics_stddev_samp_order_by
    , sum : OptionalArgument Validation_metrics_sum_order_by
    , var_pop : OptionalArgument Validation_metrics_var_pop_order_by
    , var_samp : OptionalArgument Validation_metrics_var_samp_order_by
    , variance : OptionalArgument Validation_metrics_variance_order_by
    }


{-| Encode a Validation\_metrics\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeValidation_metrics_aggregate_order_by : Validation_metrics_aggregate_order_by -> Value
encodeValidation_metrics_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeValidation_metrics_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeValidation_metrics_max_order_by |> Encode.optional input.max ), ( "min", encodeValidation_metrics_min_order_by |> Encode.optional input.min ), ( "stddev", encodeValidation_metrics_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeValidation_metrics_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeValidation_metrics_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeValidation_metrics_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeValidation_metrics_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeValidation_metrics_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeValidation_metrics_variance_order_by |> Encode.optional input.variance ) ]


buildValidation_metrics_avg_order_by : (Validation_metrics_avg_order_byOptionalFields -> Validation_metrics_avg_order_byOptionalFields) -> Validation_metrics_avg_order_by
buildValidation_metrics_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, raw = Absent, signed = Absent }
    in
    { id = optionals.id, raw = optionals.raw, signed = optionals.signed }


type alias Validation_metrics_avg_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validation\_metrics\_avg\_order\_by input object.
-}
type alias Validation_metrics_avg_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validation\_metrics\_avg\_order\_by into a value that can be used as an argument.
-}
encodeValidation_metrics_avg_order_by : Validation_metrics_avg_order_by -> Value
encodeValidation_metrics_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "raw", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.raw ), ( "signed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.signed ) ]


buildValidation_metrics_bool_exp : (Validation_metrics_bool_expOptionalFields -> Validation_metrics_bool_expOptionalFields) -> Validation_metrics_bool_exp
buildValidation_metrics_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, raw = Absent, signed = Absent }
    in
    Validation_metrics_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, id = optionals.id, raw = optionals.raw, signed = optionals.signed }


type alias Validation_metrics_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Validation_metrics_bool_exp))
    , not_ : OptionalArgument Validation_metrics_bool_exp
    , or_ : OptionalArgument (List (Maybe Validation_metrics_bool_exp))
    , id : OptionalArgument Int_comparison_exp
    , raw : OptionalArgument Float8_comparison_exp
    , signed : OptionalArgument Float8_comparison_exp
    }


{-| Type alias for the `Validation_metrics_bool_exp` attributes. Note that this type
needs to use the `Validation_metrics_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Validation_metrics_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Validation_metrics_bool_exp))
    , not_ : OptionalArgument Validation_metrics_bool_exp
    , or_ : OptionalArgument (List (Maybe Validation_metrics_bool_exp))
    , id : OptionalArgument Int_comparison_exp
    , raw : OptionalArgument Float8_comparison_exp
    , signed : OptionalArgument Float8_comparison_exp
    }


{-| Type for the Validation\_metrics\_bool\_exp input object.
-}
type Validation_metrics_bool_exp
    = Validation_metrics_bool_exp Validation_metrics_bool_expRaw


{-| Encode a Validation\_metrics\_bool\_exp into a value that can be used as an argument.
-}
encodeValidation_metrics_bool_exp : Validation_metrics_bool_exp -> Value
encodeValidation_metrics_bool_exp (Validation_metrics_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeValidation_metrics_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeValidation_metrics_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeValidation_metrics_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "raw", encodeFloat8_comparison_exp |> Encode.optional input.raw ), ( "signed", encodeFloat8_comparison_exp |> Encode.optional input.signed ) ]


buildValidation_metrics_max_order_by : (Validation_metrics_max_order_byOptionalFields -> Validation_metrics_max_order_byOptionalFields) -> Validation_metrics_max_order_by
buildValidation_metrics_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, raw = Absent, signed = Absent }
    in
    { id = optionals.id, raw = optionals.raw, signed = optionals.signed }


type alias Validation_metrics_max_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validation\_metrics\_max\_order\_by input object.
-}
type alias Validation_metrics_max_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validation\_metrics\_max\_order\_by into a value that can be used as an argument.
-}
encodeValidation_metrics_max_order_by : Validation_metrics_max_order_by -> Value
encodeValidation_metrics_max_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "raw", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.raw ), ( "signed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.signed ) ]


buildValidation_metrics_min_order_by : (Validation_metrics_min_order_byOptionalFields -> Validation_metrics_min_order_byOptionalFields) -> Validation_metrics_min_order_by
buildValidation_metrics_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, raw = Absent, signed = Absent }
    in
    { id = optionals.id, raw = optionals.raw, signed = optionals.signed }


type alias Validation_metrics_min_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validation\_metrics\_min\_order\_by input object.
-}
type alias Validation_metrics_min_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validation\_metrics\_min\_order\_by into a value that can be used as an argument.
-}
encodeValidation_metrics_min_order_by : Validation_metrics_min_order_by -> Value
encodeValidation_metrics_min_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "raw", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.raw ), ( "signed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.signed ) ]


buildValidation_metrics_order_by : (Validation_metrics_order_byOptionalFields -> Validation_metrics_order_byOptionalFields) -> Validation_metrics_order_by
buildValidation_metrics_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, raw = Absent, signed = Absent }
    in
    { id = optionals.id, raw = optionals.raw, signed = optionals.signed }


type alias Validation_metrics_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validation\_metrics\_order\_by input object.
-}
type alias Validation_metrics_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validation\_metrics\_order\_by into a value that can be used as an argument.
-}
encodeValidation_metrics_order_by : Validation_metrics_order_by -> Value
encodeValidation_metrics_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "raw", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.raw ), ( "signed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.signed ) ]


buildValidation_metrics_stddev_order_by : (Validation_metrics_stddev_order_byOptionalFields -> Validation_metrics_stddev_order_byOptionalFields) -> Validation_metrics_stddev_order_by
buildValidation_metrics_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, raw = Absent, signed = Absent }
    in
    { id = optionals.id, raw = optionals.raw, signed = optionals.signed }


type alias Validation_metrics_stddev_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validation\_metrics\_stddev\_order\_by input object.
-}
type alias Validation_metrics_stddev_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validation\_metrics\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeValidation_metrics_stddev_order_by : Validation_metrics_stddev_order_by -> Value
encodeValidation_metrics_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "raw", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.raw ), ( "signed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.signed ) ]


buildValidation_metrics_stddev_pop_order_by : (Validation_metrics_stddev_pop_order_byOptionalFields -> Validation_metrics_stddev_pop_order_byOptionalFields) -> Validation_metrics_stddev_pop_order_by
buildValidation_metrics_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, raw = Absent, signed = Absent }
    in
    { id = optionals.id, raw = optionals.raw, signed = optionals.signed }


type alias Validation_metrics_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validation\_metrics\_stddev\_pop\_order\_by input object.
-}
type alias Validation_metrics_stddev_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validation\_metrics\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeValidation_metrics_stddev_pop_order_by : Validation_metrics_stddev_pop_order_by -> Value
encodeValidation_metrics_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "raw", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.raw ), ( "signed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.signed ) ]


buildValidation_metrics_stddev_samp_order_by : (Validation_metrics_stddev_samp_order_byOptionalFields -> Validation_metrics_stddev_samp_order_byOptionalFields) -> Validation_metrics_stddev_samp_order_by
buildValidation_metrics_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, raw = Absent, signed = Absent }
    in
    { id = optionals.id, raw = optionals.raw, signed = optionals.signed }


type alias Validation_metrics_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validation\_metrics\_stddev\_samp\_order\_by input object.
-}
type alias Validation_metrics_stddev_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validation\_metrics\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeValidation_metrics_stddev_samp_order_by : Validation_metrics_stddev_samp_order_by -> Value
encodeValidation_metrics_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "raw", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.raw ), ( "signed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.signed ) ]


buildValidation_metrics_sum_order_by : (Validation_metrics_sum_order_byOptionalFields -> Validation_metrics_sum_order_byOptionalFields) -> Validation_metrics_sum_order_by
buildValidation_metrics_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, raw = Absent, signed = Absent }
    in
    { id = optionals.id, raw = optionals.raw, signed = optionals.signed }


type alias Validation_metrics_sum_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validation\_metrics\_sum\_order\_by input object.
-}
type alias Validation_metrics_sum_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validation\_metrics\_sum\_order\_by into a value that can be used as an argument.
-}
encodeValidation_metrics_sum_order_by : Validation_metrics_sum_order_by -> Value
encodeValidation_metrics_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "raw", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.raw ), ( "signed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.signed ) ]


buildValidation_metrics_var_pop_order_by : (Validation_metrics_var_pop_order_byOptionalFields -> Validation_metrics_var_pop_order_byOptionalFields) -> Validation_metrics_var_pop_order_by
buildValidation_metrics_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, raw = Absent, signed = Absent }
    in
    { id = optionals.id, raw = optionals.raw, signed = optionals.signed }


type alias Validation_metrics_var_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validation\_metrics\_var\_pop\_order\_by input object.
-}
type alias Validation_metrics_var_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validation\_metrics\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeValidation_metrics_var_pop_order_by : Validation_metrics_var_pop_order_by -> Value
encodeValidation_metrics_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "raw", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.raw ), ( "signed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.signed ) ]


buildValidation_metrics_var_samp_order_by : (Validation_metrics_var_samp_order_byOptionalFields -> Validation_metrics_var_samp_order_byOptionalFields) -> Validation_metrics_var_samp_order_by
buildValidation_metrics_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, raw = Absent, signed = Absent }
    in
    { id = optionals.id, raw = optionals.raw, signed = optionals.signed }


type alias Validation_metrics_var_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validation\_metrics\_var\_samp\_order\_by input object.
-}
type alias Validation_metrics_var_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validation\_metrics\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeValidation_metrics_var_samp_order_by : Validation_metrics_var_samp_order_by -> Value
encodeValidation_metrics_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "raw", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.raw ), ( "signed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.signed ) ]


buildValidation_metrics_variance_order_by : (Validation_metrics_variance_order_byOptionalFields -> Validation_metrics_variance_order_byOptionalFields) -> Validation_metrics_variance_order_by
buildValidation_metrics_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, raw = Absent, signed = Absent }
    in
    { id = optionals.id, raw = optionals.raw, signed = optionals.signed }


type alias Validation_metrics_variance_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validation\_metrics\_variance\_order\_by input object.
-}
type alias Validation_metrics_variance_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , raw : OptionalArgument DetQL.Enum.Order_by.Order_by
    , signed : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validation\_metrics\_variance\_order\_by into a value that can be used as an argument.
-}
encodeValidation_metrics_variance_order_by : Validation_metrics_variance_order_by -> Value
encodeValidation_metrics_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "raw", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.raw ), ( "signed", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.signed ) ]


buildValidation_state_comparison_exp : (Validation_state_comparison_expOptionalFields -> Validation_state_comparison_expOptionalFields) -> Validation_state_comparison_exp
buildValidation_state_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Validation_state_comparison_expOptionalFields =
    { eq_ : OptionalArgument CustomScalarCodecs.Validation_state
    , gt_ : OptionalArgument CustomScalarCodecs.Validation_state
    , gte_ : OptionalArgument CustomScalarCodecs.Validation_state
    , in_ : OptionalArgument (List CustomScalarCodecs.Validation_state)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Validation_state
    , lte_ : OptionalArgument CustomScalarCodecs.Validation_state
    , neq_ : OptionalArgument CustomScalarCodecs.Validation_state
    , nin_ : OptionalArgument (List CustomScalarCodecs.Validation_state)
    }


{-| Type for the Validation\_state\_comparison\_exp input object.
-}
type alias Validation_state_comparison_exp =
    { eq_ : OptionalArgument CustomScalarCodecs.Validation_state
    , gt_ : OptionalArgument CustomScalarCodecs.Validation_state
    , gte_ : OptionalArgument CustomScalarCodecs.Validation_state
    , in_ : OptionalArgument (List CustomScalarCodecs.Validation_state)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument CustomScalarCodecs.Validation_state
    , lte_ : OptionalArgument CustomScalarCodecs.Validation_state
    , neq_ : OptionalArgument CustomScalarCodecs.Validation_state
    , nin_ : OptionalArgument (List CustomScalarCodecs.Validation_state)
    }


{-| Encode a Validation\_state\_comparison\_exp into a value that can be used as an argument.
-}
encodeValidation_state_comparison_exp : Validation_state_comparison_exp -> Value
encodeValidation_state_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecValidation_state) |> Encode.optional input.eq_ ), ( "_gt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecValidation_state) |> Encode.optional input.gt_ ), ( "_gte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecValidation_state) |> Encode.optional input.gte_ ), ( "_in", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecValidation_state) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecValidation_state) |> Encode.optional input.lt_ ), ( "_lte", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecValidation_state) |> Encode.optional input.lte_ ), ( "_neq", (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecValidation_state) |> Encode.optional input.neq_ ), ( "_nin", ((CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapEncoder .codecValidation_state) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildValidations_aggregate_order_by : (Validations_aggregate_order_byOptionalFields -> Validations_aggregate_order_byOptionalFields) -> Validations_aggregate_order_by
buildValidations_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Validations_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Validations_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Validations_max_order_by
    , min : OptionalArgument Validations_min_order_by
    , stddev : OptionalArgument Validations_stddev_order_by
    , stddev_pop : OptionalArgument Validations_stddev_pop_order_by
    , stddev_samp : OptionalArgument Validations_stddev_samp_order_by
    , sum : OptionalArgument Validations_sum_order_by
    , var_pop : OptionalArgument Validations_var_pop_order_by
    , var_samp : OptionalArgument Validations_var_samp_order_by
    , variance : OptionalArgument Validations_variance_order_by
    }


{-| Type for the Validations\_aggregate\_order\_by input object.
-}
type alias Validations_aggregate_order_by =
    { avg : OptionalArgument Validations_avg_order_by
    , count : OptionalArgument DetQL.Enum.Order_by.Order_by
    , max : OptionalArgument Validations_max_order_by
    , min : OptionalArgument Validations_min_order_by
    , stddev : OptionalArgument Validations_stddev_order_by
    , stddev_pop : OptionalArgument Validations_stddev_pop_order_by
    , stddev_samp : OptionalArgument Validations_stddev_samp_order_by
    , sum : OptionalArgument Validations_sum_order_by
    , var_pop : OptionalArgument Validations_var_pop_order_by
    , var_samp : OptionalArgument Validations_var_samp_order_by
    , variance : OptionalArgument Validations_variance_order_by
    }


{-| Encode a Validations\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeValidations_aggregate_order_by : Validations_aggregate_order_by -> Value
encodeValidations_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeValidations_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeValidations_max_order_by |> Encode.optional input.max ), ( "min", encodeValidations_min_order_by |> Encode.optional input.min ), ( "stddev", encodeValidations_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeValidations_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeValidations_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeValidations_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeValidations_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeValidations_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeValidations_variance_order_by |> Encode.optional input.variance ) ]


buildValidations_avg_order_by : (Validations_avg_order_byOptionalFields -> Validations_avg_order_byOptionalFields) -> Validations_avg_order_by
buildValidations_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Validations_avg_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validations\_avg\_order\_by input object.
-}
type alias Validations_avg_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validations\_avg\_order\_by into a value that can be used as an argument.
-}
encodeValidations_avg_order_by : Validations_avg_order_by -> Value
encodeValidations_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildValidations_bool_exp : (Validations_bool_expOptionalFields -> Validations_bool_expOptionalFields) -> Validations_bool_exp
buildValidations_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, checkpoint = Absent, end_time = Absent, id = Absent, metric_values = Absent, metrics = Absent, start_time = Absent, state = Absent, step = Absent, step_id = Absent, trial_id = Absent }
    in
    Validations_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, checkpoint = optionals.checkpoint, end_time = optionals.end_time, id = optionals.id, metric_values = optionals.metric_values, metrics = optionals.metrics, start_time = optionals.start_time, state = optionals.state, step = optionals.step, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Validations_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Validations_bool_exp))
    , not_ : OptionalArgument Validations_bool_exp
    , or_ : OptionalArgument (List (Maybe Validations_bool_exp))
    , checkpoint : OptionalArgument Checkpoints_bool_exp
    , end_time : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , metric_values : OptionalArgument Validation_metrics_bool_exp
    , metrics : OptionalArgument Jsonb_comparison_exp
    , start_time : OptionalArgument Timestamptz_comparison_exp
    , state : OptionalArgument Validation_state_comparison_exp
    , step : OptionalArgument Steps_bool_exp
    , step_id : OptionalArgument Int_comparison_exp
    , trial_id : OptionalArgument Int_comparison_exp
    }


{-| Type alias for the `Validations_bool_exp` attributes. Note that this type
needs to use the `Validations_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Validations_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Validations_bool_exp))
    , not_ : OptionalArgument Validations_bool_exp
    , or_ : OptionalArgument (List (Maybe Validations_bool_exp))
    , checkpoint : OptionalArgument Checkpoints_bool_exp
    , end_time : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , metric_values : OptionalArgument Validation_metrics_bool_exp
    , metrics : OptionalArgument Jsonb_comparison_exp
    , start_time : OptionalArgument Timestamptz_comparison_exp
    , state : OptionalArgument Validation_state_comparison_exp
    , step : OptionalArgument Steps_bool_exp
    , step_id : OptionalArgument Int_comparison_exp
    , trial_id : OptionalArgument Int_comparison_exp
    }


{-| Type for the Validations\_bool\_exp input object.
-}
type Validations_bool_exp
    = Validations_bool_exp Validations_bool_expRaw


{-| Encode a Validations\_bool\_exp into a value that can be used as an argument.
-}
encodeValidations_bool_exp : Validations_bool_exp -> Value
encodeValidations_bool_exp (Validations_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeValidations_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeValidations_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeValidations_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "checkpoint", encodeCheckpoints_bool_exp |> Encode.optional input.checkpoint ), ( "end_time", encodeTimestamptz_comparison_exp |> Encode.optional input.end_time ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "metric_values", encodeValidation_metrics_bool_exp |> Encode.optional input.metric_values ), ( "metrics", encodeJsonb_comparison_exp |> Encode.optional input.metrics ), ( "start_time", encodeTimestamptz_comparison_exp |> Encode.optional input.start_time ), ( "state", encodeValidation_state_comparison_exp |> Encode.optional input.state ), ( "step", encodeSteps_bool_exp |> Encode.optional input.step ), ( "step_id", encodeInt_comparison_exp |> Encode.optional input.step_id ), ( "trial_id", encodeInt_comparison_exp |> Encode.optional input.trial_id ) ]


buildValidations_max_order_by : (Validations_max_order_byOptionalFields -> Validations_max_order_byOptionalFields) -> Validations_max_order_by
buildValidations_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { end_time = Absent, id = Absent, start_time = Absent, step_id = Absent, trial_id = Absent }
    in
    { end_time = optionals.end_time, id = optionals.id, start_time = optionals.start_time, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Validations_max_order_byOptionalFields =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validations\_max\_order\_by input object.
-}
type alias Validations_max_order_by =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validations\_max\_order\_by into a value that can be used as an argument.
-}
encodeValidations_max_order_by : Validations_max_order_by -> Value
encodeValidations_max_order_by input =
    Encode.maybeObject
        [ ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildValidations_min_order_by : (Validations_min_order_byOptionalFields -> Validations_min_order_byOptionalFields) -> Validations_min_order_by
buildValidations_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { end_time = Absent, id = Absent, start_time = Absent, step_id = Absent, trial_id = Absent }
    in
    { end_time = optionals.end_time, id = optionals.id, start_time = optionals.start_time, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Validations_min_order_byOptionalFields =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validations\_min\_order\_by input object.
-}
type alias Validations_min_order_by =
    { end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validations\_min\_order\_by into a value that can be used as an argument.
-}
encodeValidations_min_order_by : Validations_min_order_by -> Value
encodeValidations_min_order_by input =
    Encode.maybeObject
        [ ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildValidations_order_by : (Validations_order_byOptionalFields -> Validations_order_byOptionalFields) -> Validations_order_by
buildValidations_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { checkpoint = Absent, end_time = Absent, id = Absent, metric_values = Absent, metrics = Absent, start_time = Absent, state = Absent, step = Absent, step_id = Absent, trial_id = Absent }
    in
    Validations_order_by { checkpoint = optionals.checkpoint, end_time = optionals.end_time, id = optionals.id, metric_values = optionals.metric_values, metrics = optionals.metrics, start_time = optionals.start_time, state = optionals.state, step = optionals.step, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Validations_order_byOptionalFields =
    { checkpoint : OptionalArgument Checkpoints_order_by
    , end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , metric_values : OptionalArgument Validation_metrics_order_by
    , metrics : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , state : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step : OptionalArgument Steps_order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type alias for the `Validations_order_by` attributes. Note that this type
needs to use the `Validations_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Validations_order_byRaw =
    { checkpoint : OptionalArgument Checkpoints_order_by
    , end_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , metric_values : OptionalArgument Validation_metrics_order_by
    , metrics : OptionalArgument DetQL.Enum.Order_by.Order_by
    , start_time : OptionalArgument DetQL.Enum.Order_by.Order_by
    , state : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step : OptionalArgument Steps_order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validations\_order\_by input object.
-}
type Validations_order_by
    = Validations_order_by Validations_order_byRaw


{-| Encode a Validations\_order\_by into a value that can be used as an argument.
-}
encodeValidations_order_by : Validations_order_by -> Value
encodeValidations_order_by (Validations_order_by input) =
    Encode.maybeObject
        [ ( "checkpoint", encodeCheckpoints_order_by |> Encode.optional input.checkpoint ), ( "end_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.end_time ), ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "metric_values", encodeValidation_metrics_order_by |> Encode.optional input.metric_values ), ( "metrics", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.metrics ), ( "start_time", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.start_time ), ( "state", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.state ), ( "step", encodeSteps_order_by |> Encode.optional input.step ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildValidations_stddev_order_by : (Validations_stddev_order_byOptionalFields -> Validations_stddev_order_byOptionalFields) -> Validations_stddev_order_by
buildValidations_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Validations_stddev_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validations\_stddev\_order\_by input object.
-}
type alias Validations_stddev_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validations\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeValidations_stddev_order_by : Validations_stddev_order_by -> Value
encodeValidations_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildValidations_stddev_pop_order_by : (Validations_stddev_pop_order_byOptionalFields -> Validations_stddev_pop_order_byOptionalFields) -> Validations_stddev_pop_order_by
buildValidations_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Validations_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validations\_stddev\_pop\_order\_by input object.
-}
type alias Validations_stddev_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validations\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeValidations_stddev_pop_order_by : Validations_stddev_pop_order_by -> Value
encodeValidations_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildValidations_stddev_samp_order_by : (Validations_stddev_samp_order_byOptionalFields -> Validations_stddev_samp_order_byOptionalFields) -> Validations_stddev_samp_order_by
buildValidations_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Validations_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validations\_stddev\_samp\_order\_by input object.
-}
type alias Validations_stddev_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validations\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeValidations_stddev_samp_order_by : Validations_stddev_samp_order_by -> Value
encodeValidations_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildValidations_sum_order_by : (Validations_sum_order_byOptionalFields -> Validations_sum_order_byOptionalFields) -> Validations_sum_order_by
buildValidations_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Validations_sum_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validations\_sum\_order\_by input object.
-}
type alias Validations_sum_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validations\_sum\_order\_by into a value that can be used as an argument.
-}
encodeValidations_sum_order_by : Validations_sum_order_by -> Value
encodeValidations_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildValidations_var_pop_order_by : (Validations_var_pop_order_byOptionalFields -> Validations_var_pop_order_byOptionalFields) -> Validations_var_pop_order_by
buildValidations_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Validations_var_pop_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validations\_var\_pop\_order\_by input object.
-}
type alias Validations_var_pop_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validations\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeValidations_var_pop_order_by : Validations_var_pop_order_by -> Value
encodeValidations_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildValidations_var_samp_order_by : (Validations_var_samp_order_byOptionalFields -> Validations_var_samp_order_byOptionalFields) -> Validations_var_samp_order_by
buildValidations_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Validations_var_samp_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validations\_var\_samp\_order\_by input object.
-}
type alias Validations_var_samp_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validations\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeValidations_var_samp_order_by : Validations_var_samp_order_by -> Value
encodeValidations_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]


buildValidations_variance_order_by : (Validations_variance_order_byOptionalFields -> Validations_variance_order_byOptionalFields) -> Validations_variance_order_by
buildValidations_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, step_id = Absent, trial_id = Absent }
    in
    { id = optionals.id, step_id = optionals.step_id, trial_id = optionals.trial_id }


type alias Validations_variance_order_byOptionalFields =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Type for the Validations\_variance\_order\_by input object.
-}
type alias Validations_variance_order_by =
    { id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , step_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    , trial_id : OptionalArgument DetQL.Enum.Order_by.Order_by
    }


{-| Encode a Validations\_variance\_order\_by into a value that can be used as an argument.
-}
encodeValidations_variance_order_by : Validations_variance_order_by -> Value
encodeValidations_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.id ), ( "step_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.step_id ), ( "trial_id", Encode.enum DetQL.Enum.Order_by.toString |> Encode.optional input.trial_id ) ]
