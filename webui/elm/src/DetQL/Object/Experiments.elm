-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module DetQL.Object.Experiments exposing (..)

import CustomScalarCodecs
import DetQL.Enum.Checkpoints_select_column
import DetQL.Enum.Searcher_events_select_column
import DetQL.Enum.Trials_select_column
import DetQL.Enum.Validations_select_column
import DetQL.InputObject
import DetQL.Interface
import DetQL.Object
import DetQL.Scalar
import DetQL.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


archived : SelectionSet Bool DetQL.Object.Experiments
archived =
    Object.selectionForField "Bool" "archived" [] Decode.bool


type alias BestCheckpointsByMetricOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Checkpoints_select_column.Checkpoints_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Checkpoints_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Checkpoints_bool_exp
    }


type alias BestCheckpointsByMetricRequiredArguments =
    { args : DetQL.InputObject.Experiments_best_checkpoints_by_metric_args }


{-| A computed field, executes function "experiments\_best\_checkpoints\_by\_metric"

  - args - input parameters for function "experiments\_best\_checkpoints\_by\_metric"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
best_checkpoints_by_metric : (BestCheckpointsByMetricOptionalArguments -> BestCheckpointsByMetricOptionalArguments) -> BestCheckpointsByMetricRequiredArguments -> SelectionSet decodesTo DetQL.Object.Checkpoints -> SelectionSet (Maybe (List decodesTo)) DetQL.Object.Experiments
best_checkpoints_by_metric fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Checkpoints_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeCheckpoints_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeCheckpoints_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "best_checkpoints_by_metric" (optionalArgs ++ [ Argument.required "args" requiredArgs.args DetQL.InputObject.encodeExperiments_best_checkpoints_by_metric_args ]) object_ (identity >> Decode.list >> Decode.nullable)


type alias BestValidationHistoryOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Validations_select_column.Validations_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Validations_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Validations_bool_exp
    }


{-| A computed field, executes function "experiments\_best\_validation\_history"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
best_validation_history : (BestValidationHistoryOptionalArguments -> BestValidationHistoryOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Validations -> SelectionSet (Maybe (List decodesTo)) DetQL.Object.Experiments
best_validation_history fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Validations_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeValidations_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeValidations_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "best_validation_history" optionalArgs object_ (identity >> Decode.list >> Decode.nullable)


type alias ConfigOptionalArguments =
    { path : OptionalArgument String }


{-|

  - path - JSON select path

-}
config : (ConfigOptionalArguments -> ConfigOptionalArguments) -> SelectionSet CustomScalarCodecs.Jsonb DetQL.Object.Experiments
config fillInOptionals =
    let
        filledInOptionals =
            fillInOptionals { path = Absent }

        optionalArgs =
            [ Argument.optional "path" filledInOptionals.path Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionForField "CustomScalarCodecs.Jsonb" "config" optionalArgs (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecJsonb |> .decoder)


end_time : SelectionSet (Maybe CustomScalarCodecs.Timestamptz) DetQL.Object.Experiments
end_time =
    Object.selectionForField "(Maybe CustomScalarCodecs.Timestamptz)" "end_time" [] (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecTimestamptz |> .decoder |> Decode.nullable)


git_commit : SelectionSet (Maybe String) DetQL.Object.Experiments
git_commit =
    Object.selectionForField "(Maybe String)" "git_commit" [] (Decode.string |> Decode.nullable)


git_commit_date : SelectionSet (Maybe CustomScalarCodecs.Timestamp) DetQL.Object.Experiments
git_commit_date =
    Object.selectionForField "(Maybe CustomScalarCodecs.Timestamp)" "git_commit_date" [] (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecTimestamp |> .decoder |> Decode.nullable)


git_committer : SelectionSet (Maybe String) DetQL.Object.Experiments
git_committer =
    Object.selectionForField "(Maybe String)" "git_committer" [] (Decode.string |> Decode.nullable)


git_remote : SelectionSet (Maybe String) DetQL.Object.Experiments
git_remote =
    Object.selectionForField "(Maybe String)" "git_remote" [] (Decode.string |> Decode.nullable)


id : SelectionSet Int DetQL.Object.Experiments
id =
    Object.selectionForField "Int" "id" [] Decode.int


model_definition : SelectionSet CustomScalarCodecs.Bytea DetQL.Object.Experiments
model_definition =
    Object.selectionForField "CustomScalarCodecs.Bytea" "model_definition" [] (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecBytea |> .decoder)


model_packages : SelectionSet (Maybe CustomScalarCodecs.Bytea) DetQL.Object.Experiments
model_packages =
    Object.selectionForField "(Maybe CustomScalarCodecs.Bytea)" "model_packages" [] (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecBytea |> .decoder |> Decode.nullable)


{-| An object relationship
-}
owner : SelectionSet decodesTo DetQL.Object.Users -> SelectionSet decodesTo DetQL.Object.Experiments
owner object_ =
    Object.selectionForCompositeField "owner" [] object_ identity


owner_id : SelectionSet Int DetQL.Object.Experiments
owner_id =
    Object.selectionForField "Int" "owner_id" [] Decode.int


parent_id : SelectionSet (Maybe Int) DetQL.Object.Experiments
parent_id =
    Object.selectionForField "(Maybe Int)" "parent_id" [] (Decode.int |> Decode.nullable)


progress : SelectionSet (Maybe CustomScalarCodecs.Float8) DetQL.Object.Experiments
progress =
    Object.selectionForField "(Maybe CustomScalarCodecs.Float8)" "progress" [] (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecFloat8 |> .decoder |> Decode.nullable)


type alias SearcherEventsOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Searcher_events_select_column.Searcher_events_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Searcher_events_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Searcher_events_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
searcher_events : (SearcherEventsOptionalArguments -> SearcherEventsOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Searcher_events -> SelectionSet (List decodesTo) DetQL.Object.Experiments
searcher_events fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Searcher_events_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeSearcher_events_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeSearcher_events_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "searcher_events" optionalArgs object_ (identity >> Decode.list)


type alias SearcherEventsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Searcher_events_select_column.Searcher_events_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Searcher_events_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Searcher_events_bool_exp
    }


{-| An aggregated array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
searcher_events_aggregate : (SearcherEventsAggregateOptionalArguments -> SearcherEventsAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Searcher_events_aggregate -> SelectionSet decodesTo DetQL.Object.Experiments
searcher_events_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Searcher_events_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeSearcher_events_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeSearcher_events_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "searcher_events_aggregate" optionalArgs object_ identity


start_time : SelectionSet CustomScalarCodecs.Timestamptz DetQL.Object.Experiments
start_time =
    Object.selectionForField "CustomScalarCodecs.Timestamptz" "start_time" [] (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecTimestamptz |> .decoder)


state : SelectionSet CustomScalarCodecs.Experiment_state DetQL.Object.Experiments
state =
    Object.selectionForField "CustomScalarCodecs.Experiment_state" "state" [] (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecExperiment_state |> .decoder)


type alias TrialsOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Trials_select_column.Trials_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Trials_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Trials_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
trials : (TrialsOptionalArguments -> TrialsOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Trials -> SelectionSet (List decodesTo) DetQL.Object.Experiments
trials fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Trials_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeTrials_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeTrials_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "trials" optionalArgs object_ (identity >> Decode.list)


type alias TrialsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Trials_select_column.Trials_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Trials_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Trials_bool_exp
    }


{-| An aggregated array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
trials_aggregate : (TrialsAggregateOptionalArguments -> TrialsAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Trials_aggregate -> SelectionSet decodesTo DetQL.Object.Experiments
trials_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Trials_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeTrials_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeTrials_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "trials_aggregate" optionalArgs object_ identity
