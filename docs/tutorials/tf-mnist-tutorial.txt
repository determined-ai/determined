.. _tf-mnist-tutorial:

TensorFlow Keras MNIST Tutorial
====================================

This tutorial describes how to port an existing ``tf.keras`` MNIST model to Determined. MNIST is a dataset consisting of grayscale images of handwritten digits, commonly used to test image classification models. This tutorial is based on the official `TensorFlow Basic Image Classification Tutorial <https://www.tensorflow.org/tutorials/keras/classification>`__.

At the end of this tutorial, the reader should know:

#. Basic Concepts of ``TFKerasTrial``
#. Basic Understanding of ``TFKerasTrialContext``
#. How to Implement a ``tf.keras`` Model with ``TFKerasTrial``
#. How to Write a Determined YAML Experiment Configuration
#. A General Procedure of a Determined Workflow

The complete model code for this tutorial can be downloaded here: :download:`mnist_tf_keras.tgz </examples/mnist_tf_keras.tgz>`. We suggest you download that code and use it follow along as you read through this tutorial.

Prerequisites
-------------

- Access to a Determined cluster. If you have not yet installed Determined, refer to the :ref:`installation instructions <install-determined>`.
- The Determined CLI should be installed on your local machine. For installation instructions, see :ref:`here <install-cli>`. After installing the CLI, configure it to connect to your Determined cluster by setting the ``DET_MASTER`` environment variable to the hostname or IP address where Determined is running.

Overview
--------
`TensorFlow <https://www.tensorflow.org/>`_ is a popular deep learning framework. Although TensorFlow provides excellent capabilities for training research prototypes, it can be challenging to convert these prototypes into production-grade applications. Using Determined for your TensorFlow models maintains the TensorFlow user experience while unlocking production-grade features such as state-of-the-art distributed training and hyperparameter tuning, experiment tracking, log management, metrics visualization, reproducibility, dependency management, along with flexibility to share compute resources on the hardware of your choice. To unlock these features, users can leverage Determined's ``TFKerasTrial`` interface.

Determined's ``TFKerasTrial`` interface has the user define a compiled model and generate the data, similar to ``tf.keras``. However, Determined connects the pieces by handling the device management, initial training or ``.fit()`` call, and other training steps, so you can focus on the task at hand---training better models.

This tutorial walks through building a Determined ``TFKerasTrial`` class and the necessary steps to run an experiment. The core file will be ``model_def.py`` and contains the MNIST ``TFKerasTrial`` class. Additionally, the Determined system expects two files to be provided:

#. An entrypoint (``__init__.py``)
    - This file is our entrypoint. It imports the user-defined ``TFKerasTrial`` class.
#. An experiment configuration file (``.yaml``)
    - This file contains information on the hyperparameters and other details for model and experiment configuration used internally and by user code. This can include, but is not limited to: global_batch_size, learning_rate, and layer size.

To learn more about experiment configuration files, read: :ref:`topic-guides_yaml`. To learn more about the experiment configuration file, read: :ref:`experiment-configuration`.

The next sections will describe how to build a ``TFKerasTrial`` class.

Building a ``TFKerasTrial`` Class
---------------------------------
Determined's interface requires users to implement a class that inherits a Trial class based on the user's preferred framework. This tutorial uses the ``TFKerasTrial`` interface, which requires three specific functions to be overridden: ``build_training_data_loader``, ``build_validation_data_loader``, and ``build_model``.

Each of these functions should contain code resembling traditional ``tf.keras``. For example, the ``build_model`` function should return a traditional compiled ``tf.keras`` model. By overriding the three functions, Determined will manage these common training objects.

The code snippet below demonstrates the skeleton of ``TFKerasTrial``. In the next few sections, we will implement each function.

.. code:: python

    from determined.keras import InMemorySequence, TFKerasTrial

    class MNISTTrial(TFKerasTrial):
        def __init__(self, context: det.keras.TFKerasTrialContext):
            # required: store TFKerasTrialContext for later use
            self.context = context

        def build_model(self):
            # define and compile model
            return model

        def build_training_data_loader(self):
            # create the training data
            # Returns: a keras.Sequence Dataset
            return train

        def build_validation_data_loader(self):
            # create the validation data
            # Returns: a keras.Sequence Dataset
            return test

Initializing ``TFKerasTrial``
"""""""""""""""""""""""""""""
Determined's ``TFKerasTrial`` supports model development by having the machine learning developer focus on defining the main train objects. By inheriting the ``TFKerasTrial`` class, the user does not manually call each required function; instead, Determined will call each function at the appropriate time to manage resources and training steps. In other words, you really only state the data and model to use as Determined handles the object calls.

Also, Determined's ``TFKerasTrial.__init__`` is passed a single parameter: a :class:`TFKerasTrialContext <determined.keras.TFKerasTrialContext>`. The ``TFKerasTrialContext`` object, often stored as ``self.context``, contains a collection of runtime information for the particular trial, such as the hyperparameters in the experiment configuration file. Since it is highly encouraged to store all hyperparameters (i.e. batch size, learning rate) inside the experiment configuration file, the ``self.context`` object allows us to easily access the defined hyperparameters or data configurations.

The user must store the ``TFKerasTrialContext`` for later use, as shown in the code snippet below.

.. code:: python

    def __init__(self, context: det.keras.TFKerasTrialContext):
        self.context = context

The code snippet below shows how to access the defined variables from the experiment configuration file.

.. code:: python

    self.context.get_hparam(<variable name>)
    self.context.get_data_config()[<variable name>]


Download and Prepare MNIST Dataset
----------------------------------

First, we create our data objects. The data functions, ``build_training_data_loader`` and ``build_validation_data_loader`` expect a ` ``tf.keras.Sequence`` dataset https://keras.io/utils/>`_ to be returned.

For numpy data that can be loaded in memory, Determined provides a simple class to convert the data. The ``InMemorySequence`` class is a utility class for converting a simple in-memory supervised numpy dataset into a ``tf.keras.Sequence`` instance. This class has the user define the data, labels, and batch size, then converts the information into a ``tf.keras.Sequence`` object.

The code snippet below, we can directly access the MNIST through ``keras.datasets``. We load the data the same as in traditional ``tf.keras``. Next, we use the ``TFKerasTrialContext`` object to access the batch size and then convert the data into a ``InMemorySequence``.

.. code:: python

    def build_training_data_loader(self):
        mnist = keras.datasets.mnist
        (train_images, train_labels), (_, _) = mnist.load_data()

        global_batch_size = self.context.get_hparam('global_batch_size')
        train = data.InMemorySequence(data=train_images, labels=train_labels, batch_size=global_batch_size)
        return train

We then follow the same workflow for ``build_validation_data_loader``.

.. code:: python

    def build_validation_data_loader(self):
        mnist = keras.datasets.mnist
        (_, _), (test_images, test_labels) = mnist.load_data()

        batch_size = self.context.get_per_slot_batch_size()
        test = data.InMemorySequence(data=test_images, labels=test_labels, batch_size=batch_size)
        return test

Building the Model
""""""""""""""""""
Determined calls ``build_model`` to define our model. In ``build_model``, the model object is defined, compiled, and returned. The original ``tf.keras`` example uses the Sequential API to create the model. The ``build_model`` function below mimics the original model implementation.  However, the model needs to be wrapped with ``self.context.wrap_model`` to access Determined's multi-GPU capabilities.

.. code:: python

    def build_model(self):
        model = keras.Sequential(
            [
                keras.layers.Flatten(input_shape=(28, 28)),
                keras.layers.Dense(128, activation="relu"),
                keras.layers.Dense(10),
            ]
        )
        model = self.context.wrap_model(model)
        model.compile(
            optimizer="adam",
            loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
            metrics=[tf.keras.metrics.SparseCategoricalAccuracy(name="accuracy")],
        )
        return model

Training the Model
------------------
Now that we have ported our model code to Determined's API, we can use Determined to train a single instance of the model or to do a hyperparameter search. In Determined, a **trial** is a training task that consists of a dataset, a deep learning model, and values for all of the model's hyperparameters. An **experiment** is a collection of one or more trials: an experiment can either train a single model (with a single trial), or can define a search over a user-defined hyperparameter space.

To create an experiment, we start by writing an experiment configuration file which defines the kind of experiment we want to run. In this case, we want to train a single model for a fixed number of batches, using fixed values for the model's hyperparameters:

.. code:: yaml

    description: mnist_keras_const_simple
    hyperparameters:
        global_batch_size: 32
    searcher:
        name: single
        metric: val_accuracy
        max_steps: 40
    min_validation_period: 10
    entrypoint: model_def:MNISTTrial

Note that rather than specifying the number of batches to train for directly, we instead specify the number of "steps". By default, a step consists of 100 batches, so the config file above specifies that the model should be trained on 4000 batches of data.

For more information on experiment configuration, see the :ref:`experiment configuration reference <experiment-configuration>`.

Running an Experiment
---------------------
The Determined CLI can be used to create a new experiment, which will immediately start running on the cluster. To do this, we run:

.. code::

    det experiment create const.yaml .

Here, the first argument (``const.yaml``) is the name of the experiment configuration file and the second argument (``.``) is the location of the directory that contains our model definition files. You may need to configure the CLI with the network address where the Determined master is running, via the ``-m`` flag or the ``DET_MASTER`` environment variable. For more information, see the :ref:`CLI reference page <cli>`.

Once the experiment is started, you will see a notification:

.. code::

    Preparing files (../mnist_tf_keras) to send to master... 2.5KB and 4 files
    Created experiment xxx
    Activated experiment xxx

Evaluating the Model
--------------------
Model evaluation is done automatically for you by Determined.
To access information on both training and validation performance,
simply go to the WebUI by entering the address of the Determined master
in your web browser.

Once you are on the Determined landing page, you can find your experiment
either via the experiment ID (xxx) or via its description.

Next Steps
----------
- :ref:`experiment-configuration`
- :ref:`command-configuration`
- :ref:`topic-guides_yaml`
- :ref:`benefits-of-determined`
- :ref:`terminology-concepts`
