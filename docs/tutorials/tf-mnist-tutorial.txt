.. _tf-mnist-tutorial:

TensorFlow Keras MNIST Tutorial
====================================

This tutorial walks through how to implement an existing ``tf.keras`` MNIST model in Determined. MNIST consists of handwritten digits, commonly used to test image classification models. This tutorial is based on the official `TensorFlow Basic Image Classification Tutorial <https://www.tensorflow.org/tutorials/keras/classification>`__.

*This tutorial requires the Determined CLI. For installation procedures:* :ref:`install-cli`.
We will also use ``tensorflow`` and ``keras`` libraries to build and train our model.

At the end of this tutorial, the reader should know:

#. Basic Concepts of ``TFKerasTrial``
#. Basic Understanding of ``TFKerasTrialContext``
#. How to Implement a ``tf.keras`` Model with ``TFKerasTrial``
#. How to Write a Determined YAML Experiment Configuration.
#. A General Procedure of a Determined Workflow

Note: As we walk through the tutorial, some code has been omitted for demonstration purposes. A complete code example is available at :download:`MNIST TF.Keras </examples/mnist_tf_keras.tgz>`.

Overview
--------
`TensorFlow <https://www.tensorflow.org/>`_ is an end-to-end open source platform for machine learning. Although TensorFlow provides excellent capabilities for training research prototypes, it can be challenging to convert these prototypes into production-grade applications. Using Determined for your TensorFlow models maintains the TensorFlow user experience while unlocking production-grade features such as state-of-the-art distributed training and hyperparameter tuning, experiment tracking, log management, metrics visualization, reproducibility, dependency management, along with flexibility to share compute resources on the hardware of your choice. To unlock these features, users can leverage Determined's ``TFKerasTrial`` interface.

To learn more about the benefits of Determined, read: :ref:`benefits-of-determined`.

Determined's ``TFKerasTrial`` interface has the user define a compiled model and generate the data, similar to ``tf.keras``. However, Determined connects the pieces by handling the device management, initial training or ``.fit()`` call, and other training steps, so you can focus on the task at hand---training better models.

This tutorial walks through building a Determined ``TFKerasTrial`` class and the necessary steps to run an experiment. The core file will be ``model_def.py`` and contains the MNIST ``TFKerasTrial`` class. Additionally, the Determined system expects two files to be provided:

#. an entrypoint (``__init__.py``)
    - This file is our entrypoint. It imports the user defined ``TFKerasTrial`` class.
#. an experiment configuration file (``*.yaml``)
    - This file contains information on the hyperparameters and other details for model and experiment configuration used internally and by user code. This can include, but is not limited to: global_batch_size, learning_rate, and layer size.

To learn more about experiment configuration files, read: :ref:`topic-guides_yaml`. To learn more about the experiment configuration file, read: :ref:`experiment-configuration`.

The next sections will describe how to build a ``TFKerasTrial`` class.

Building a ``TFKerasTrial`` Class
---------------------------------
Determined's interface requires users to implement a class that inherits a Trial class based on the user's preferred framework. This tutorial uses the ``TFKerasTrial`` interface, which requires three specific functions to be overridden: ``build_training_data_loader``, ``build_validation_data_loader``, and ``build_model``.

Each of these functions should contain code resembling traditional ``tf.keras``. For example, the ``build_model`` function should return a traditional compiled ``tf.keras`` model. By overriding the three functions, Determined will manage these common training objects.

The code snippet below demonstrates the skeleton of ``TFKerasTrial``. In the next few sections, we will implement each function.

.. code:: python

    from determined.keras import InMemorySequence, TFKerasTrial

    class MNISTTrial(TFKerasTrial):
        def __init__(self, context: det.keras.TFKerasTrialContext):
            # declare class variables
            # required: declare TFKerasTrialContext as a class variable
            self.context = context

        def build_model(self):
            # define and compile model
            return model

        def build_training_data_loader(self):
            # create the training data
            # Returns: a keras.Sequence Dataset
            return train

        def build_validation_data_loader(self):
            # create the validation data
            # Returns: a keras.Sequence Dataset
            return test

Initializing ``TFKerasTrial``
"""""""""""""""""""""""""""""
Determined's ``TFKerasTrial`` supports model development by having the machine learning developer focus on defining the main train objects. By inheriting the ``TFKerasTrial`` class, the user does not instantiate each required function; instead, Determined will call each function at the appropriate time to manage resources and training steps. In other words, you really only state the data and model to use as Determined handles the object calls.

Also, Determined's ``TFKerasTrial.__init__`` is passed a single parameter: a :class:`TFKerasTrialContext <determined.keras.TFKerasTrialContext>`. The ``TFKerasTrialContext`` object, often stored as ``self.context``, contains a collection of runtime information for the particular trial, such as the hyperparameters in the experiment configuration file. Since it is highly encouraged to store all hyperparameters (i.e. batch size, learning rate) inside the experiment configuration file, the ``self.context`` object allows us to easily access the defined hyperparameters or data configurations.

The user must declare the ``TFKerasTrialContext`` as a class variable. The code snippet below show the required ``TFKerasTrialContext`` being initialized.

.. code:: python

    def __init__(self, context: det.keras.TFKerasTrialContext):
        self.context = context

The code snippet below shows how to access the defined variables from the experiment configuration file.

.. code:: python

    self.context.get_hparam(<variable name>)
    self.context.get_data_config()[<variable name>]


Download and Prepare MNIST Dataset
----------------------------------

First, we create our data objects. The data functions, ``build_training_data_loader`` and ``build_validation_data_loader`` expect to a ` ``tf.keras.Sequence`` dataset https://keras.io/utils/>`_ to be returned.

For numpy data that can be loaded in memory, Determined provides a simple class to convert the data. The ``InMemorySequence`` class is a utility class for converting a simple in-memory supervised numpy dataset into a ``tf.keras.Sequence`` instance. This class has the user define the data, labels, and batch size, then converts the information into a ``tf.keras.Sequence`` object.

The code snippet below, we can directly access the MNIST through ``keras.datasets``. We load the data the same as in traditional ``tf.keras``. Next, we use the ``TFKerasTrialContext`` object to access the batch size and then convert the data into a ``InMemorySequence``.
.. code:: python

    def build_training_data_loader(self):
        mnist = keras.datasets.mnist
        (train_images, train_labels), (_, _) = mnist.load_data()

        global_batch_size = self.context.get_hparam('global_batch_size')
        train = data.InMemorySequence(data=train_images, labels=train_labels, batch_size=global_batch_size)
        return train

We then follow the same workflow for ``build_validation_data_loader``.

.. code:: python

    def build_validation_data_loader(self):
        mnist = keras.datasets.mnist
        (_, _), (test_images, test_labels) = mnist.load_data()

        batch_size = self.context.get_per_slot_batch_size()
        test = data.InMemorySequence(data=test_images, labels=test_labels, batch_size=batch_size)
        return test

Building the Model
""""""""""""""""""
Determined calls ``build_model`` to define our model. In ``build_model``, the model object is defined, compiled and returned. The original ``tf.keras`` example uses the Sequential API to create the model. The ``build_model`` function below mimics the original model implementation.  However, the model needs to be wrapped with ``self.context.wrap_model`` to access Determined's multi-GPU capabilities.

.. code:: python

    def build_model(self):
        model = keras.Sequential(
            [
                keras.layers.Flatten(input_shape=(28, 28)),
                keras.layers.Dense(128, activation="relu"),
                keras.layers.Dense(10),
            ]
        )
        model = self.context.wrap_model(model)
        model.compile(
            optimizer="adam",
            loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
            metrics=[tf.keras.metrics.SparseCategoricalAccuracy(name="accuracy")],
        )
        return model

Training the Model
------------------
Lastly, we create a experiment configuration file that contains all the experiment information for Determined. We set the hyperparameters, along with the name or description of the experiment. In Determined, we define length of training based on the number of steps. One step consists of 100 batches by default. For this tutorial, we set ``max_steps`` to 40, so 4,000 batches will run.

More information on the experiment configuration file can be found: :ref:`experiment-configuration`.

.. code:: yaml

    description: mnist_keras_const_simple
    hyperparameters:
        global_batch_size: 32
    searcher:
        name: single
        metric: val_accuracy
        max_steps: 40
    min_validation_period: 10
    entrypoint: model_def:MNISTTrial


Running an Experiment
---------------------
When a user wants to run their model, they submit an experiment. **Experiment** is a collection of one or more trials. **Trial** is a training task with a dataset, a deep learning model, and a defined set of hyperparameters. An experiment corresponds to a set of trials that are exploring a user-defined hyperparameter space. For example, during a learning rate hyperparameter search, an experiment can consists of three trials with ``.001``, ``.01``, and ``.1`` learning rates.

More information on Determined's Terminologies can be found on the topic guide: :ref:`terminologies-concepts`

This tutorial will run an experiment with one trial because all the hyperparameter are specifically defined. To start the experiment, we run:

.. code::

    det experiment create const.yaml .

Here, the first argument (``const.yaml``) specifies the experiment configuration file and the second argument (``.``) the location of the directory that contains our model definition files. An optional flag ``-m`` allows the user to state the master's IP address inline. More information on the CLI can be found at the reference page: :ref:`cli`.

Once the experiment is started, you will see a notification:

.. code::

    Preparing files (../mnist_tf_keras) to send to master... 2.5KB and 4 files
    Created experiment xxx
    Activated experiment xxx

Evaluating the Model
--------------------

Model evaluation is done automatically for you by Determined.
To access information on both training and validation performance,
simply go to the WebUI by entering the address of your ``DETERMINED_MASTER``
in your web browser.

Once you are on the Determined landing page, you can find your experiment
either via the experiment ID (xxx) or via its description.

This code is also available at
:download:`MNIST tf.keras </examples/mnist_tf_keras.tgz>`.

Next Steps
----------
- :ref:`experiment-configuration`
- :ref:`command-configuration`
- :ref:`topic-guides_yaml`
- :ref:`benefits-of-determined`
- :ref:`terminologies-concepts`
