// Code generated by mockery v2.20.0. DO NOT EDIT.

package allocationmocks

import (
	context "context"

	actor "github.com/determined-ai/determined/master/pkg/actor"

	db "github.com/determined-ai/determined/master/internal/db"

	logger "github.com/determined-ai/determined/master/pkg/logger"

	mock "github.com/stretchr/testify/mock"

	model "github.com/determined-ai/determined/master/pkg/model"

	rm "github.com/determined-ai/determined/master/internal/rm"

	sproto "github.com/determined-ai/determined/master/internal/sproto"

	task "github.com/determined-ai/determined/master/internal/task"

	tasks "github.com/determined-ai/determined/master/pkg/tasks"

	trialv1 "github.com/determined-ai/determined/proto/pkg/trialv1"

	uuid "github.com/google/uuid"
)

// AllocationService is an autogenerated mock type for the AllocationService type
type AllocationService struct {
	mock.Mock
}

// AckPreemption provides a mock function with given fields: ctx, id
func (_m *AllocationService) AckPreemption(ctx context.Context, id model.AllocationID) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, model.AllocationID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AllGather provides a mock function with given fields: ctx, allocationID, id, numPeers, data
func (_m *AllocationService) AllGather(ctx context.Context, allocationID model.AllocationID, id uuid.UUID, numPeers int, data interface{}) ([]interface{}, error) {
	ret := _m.Called(ctx, allocationID, id, numPeers, data)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.AllocationID, uuid.UUID, int, interface{}) ([]interface{}, error)); ok {
		return rf(ctx, allocationID, id, numPeers, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.AllocationID, uuid.UUID, int, interface{}) []interface{}); ok {
		r0 = rf(ctx, allocationID, id, numPeers, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.AllocationID, uuid.UUID, int, interface{}) error); ok {
		r1 = rf(ctx, allocationID, id, numPeers, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AwaitTermination provides a mock function with given fields: id
func (_m *AllocationService) AwaitTermination(id model.AllocationID) {
	_m.Called(id)
}

// GetAllAllocationIDs provides a mock function with given fields:
func (_m *AllocationService) GetAllAllocationIDs() []model.AllocationID {
	ret := _m.Called()

	var r0 []model.AllocationID
	if rf, ok := ret.Get(0).(func() []model.AllocationID); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.AllocationID)
		}
	}

	return r0
}

// SendLog provides a mock function with given fields: ctx, id, log
func (_m *AllocationService) SendLog(ctx context.Context, id model.AllocationID, log *sproto.ContainerLog) {
	_m.Called(ctx, id, log)
}

// SetProxyAddress provides a mock function with given fields: ctx, id, addr
func (_m *AllocationService) SetProxyAddress(ctx context.Context, id model.AllocationID, addr string) error {
	ret := _m.Called(ctx, id, addr)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, model.AllocationID, string) error); ok {
		r0 = rf(ctx, id, addr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetReady provides a mock function with given fields: ctx, id
func (_m *AllocationService) SetReady(ctx context.Context, id model.AllocationID) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, model.AllocationID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetResourcesAsDaemon provides a mock function with given fields: ctx, id, rID
func (_m *AllocationService) SetResourcesAsDaemon(ctx context.Context, id model.AllocationID, rID sproto.ResourcesID) error {
	ret := _m.Called(ctx, id, rID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, model.AllocationID, sproto.ResourcesID) error); ok {
		r0 = rf(ctx, id, rID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetWaiting provides a mock function with given fields: ctx, id
func (_m *AllocationService) SetWaiting(ctx context.Context, id model.AllocationID) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, model.AllocationID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Signal provides a mock function with given fields: id, sig, reason
func (_m *AllocationService) Signal(id model.AllocationID, sig task.AllocationSignal, reason string) error {
	ret := _m.Called(id, sig, reason)

	var r0 error
	if rf, ok := ret.Get(0).(func(model.AllocationID, task.AllocationSignal, string) error); ok {
		r0 = rf(id, sig, reason)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StartAllocation provides a mock function with given fields: logCtx, req, _a2, _a3, specifier, system, onExit
func (_m *AllocationService) StartAllocation(logCtx logger.Context, req sproto.AllocateRequest, _a2 db.DB, _a3 rm.ResourceManager, specifier tasks.TaskSpecifier, system *actor.System, onExit func(*task.AllocationExited)) error {
	ret := _m.Called(logCtx, req, _a2, _a3, specifier, system, onExit)

	var r0 error
	if rf, ok := ret.Get(0).(func(logger.Context, sproto.AllocateRequest, db.DB, rm.ResourceManager, tasks.TaskSpecifier, *actor.System, func(*task.AllocationExited)) error); ok {
		r0 = rf(logCtx, req, _a2, _a3, specifier, system, onExit)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// State provides a mock function with given fields: id
func (_m *AllocationService) State(id model.AllocationID) (task.AllocationState, error) {
	ret := _m.Called(id)

	var r0 task.AllocationState
	var r1 error
	if rf, ok := ret.Get(0).(func(model.AllocationID) (task.AllocationState, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(model.AllocationID) task.AllocationState); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(task.AllocationState)
	}

	if rf, ok := ret.Get(1).(func(model.AllocationID) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchPreemption provides a mock function with given fields: ctx, id
func (_m *AllocationService) WatchPreemption(ctx context.Context, id model.AllocationID) (bool, error) {
	ret := _m.Called(ctx, id)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.AllocationID) (bool, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.AllocationID) bool); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.AllocationID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchRendezvous provides a mock function with given fields: ctx, id, rID
func (_m *AllocationService) WatchRendezvous(ctx context.Context, id model.AllocationID, rID sproto.ResourcesID) (*trialv1.RendezvousInfo, error) {
	ret := _m.Called(ctx, id, rID)

	var r0 *trialv1.RendezvousInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.AllocationID, sproto.ResourcesID) (*trialv1.RendezvousInfo, error)); ok {
		return rf(ctx, id, rID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.AllocationID, sproto.ResourcesID) *trialv1.RendezvousInfo); ok {
		r0 = rf(ctx, id, rID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*trialv1.RendezvousInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.AllocationID, sproto.ResourcesID) error); ok {
		r1 = rf(ctx, id, rID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewAllocationService interface {
	mock.TestingT
	Cleanup(func())
}

// NewAllocationService creates a new instance of AllocationService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewAllocationService(t mockConstructorTestingTNewAllocationService) *AllocationService {
	mock := &AllocationService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
