# Code generated by generate_bindings.py. DO NOT EDIT.
import enum
import json
import math
import typing

import requests

if typing.TYPE_CHECKING:
    from determined.common import api

# flake8: noqa
Json = typing.Any


# Unset is a type to distinguish between things not set and things set to None.
class Unset:
    pass


_unset = Unset()


def dump_float(val: typing.Any) -> typing.Any:
    if math.isnan(val):
        return "Nan"
    if math.isinf(val):
        return "Infinity" if val > 0 else "-Infinity"
    return val


class APIHttpError(Exception):
    # APIHttpError is used if an HTTP(s) API request fails.
    def __init__(self, operation_name: str, response: requests.Response) -> None:
        self.response = response
        self.operation_name = operation_name
        self.message = (
            f"API Error: {operation_name} failed: {response.reason}."
        )

    def __str__(self) -> str:
        return self.message


class APIHttpStreamError(APIHttpError):
    # APIHttpStreamError is used if an streaming API request fails mid-stream.
    def __init__(self, operation_name: str, error: "runtimeStreamError") -> None:
        self.operation_name = operation_name
        self.error = error
        self.message = (
            f"Stream Error during {operation_name}: {error.message}"
        )

    def __str__(self) -> str:
        return self.message


class ExpCompareTrialsSampleResponseExpTrial:

    def __init__(
        self,
        *,
        data: "typing.Sequence[v1DataPoint]",
        experimentId: int,
        hparams: "typing.Dict[str, typing.Any]",
        trialId: int,
    ):
        self.data = data
        self.experimentId = experimentId
        self.hparams = hparams
        self.trialId = trialId

    @classmethod
    def from_json(cls, obj: Json) -> "ExpCompareTrialsSampleResponseExpTrial":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "data": [v1DataPoint.from_json(x) for x in obj["data"]],
            "experimentId": obj["experimentId"],
            "hparams": obj["hparams"],
            "trialId": obj["trialId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "data": [x.to_json(omit_unset) for x in self.data],
            "experimentId": self.experimentId,
            "hparams": self.hparams,
            "trialId": self.trialId,
        }
        return out

class GetHPImportanceResponseMetricHPImportance:
    error: "typing.Optional[str]" = None
    experimentProgress: "typing.Optional[float]" = None
    hpImportance: "typing.Optional[typing.Dict[str, float]]" = None
    inProgress: "typing.Optional[bool]" = None
    pending: "typing.Optional[bool]" = None

    def __init__(
        self,
        *,
        error: "typing.Union[str, None, Unset]" = _unset,
        experimentProgress: "typing.Union[float, None, Unset]" = _unset,
        hpImportance: "typing.Union[typing.Dict[str, float], None, Unset]" = _unset,
        inProgress: "typing.Union[bool, None, Unset]" = _unset,
        pending: "typing.Union[bool, None, Unset]" = _unset,
    ):
        if not isinstance(error, Unset):
            self.error = error
        if not isinstance(experimentProgress, Unset):
            self.experimentProgress = experimentProgress
        if not isinstance(hpImportance, Unset):
            self.hpImportance = hpImportance
        if not isinstance(inProgress, Unset):
            self.inProgress = inProgress
        if not isinstance(pending, Unset):
            self.pending = pending

    @classmethod
    def from_json(cls, obj: Json) -> "GetHPImportanceResponseMetricHPImportance":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "error" in obj:
            kwargs["error"] = obj["error"]
        if "experimentProgress" in obj:
            kwargs["experimentProgress"] = float(obj["experimentProgress"]) if obj["experimentProgress"] is not None else None
        if "hpImportance" in obj:
            kwargs["hpImportance"] = {k: float(v) for k, v in obj["hpImportance"].items()} if obj["hpImportance"] is not None else None
        if "inProgress" in obj:
            kwargs["inProgress"] = obj["inProgress"]
        if "pending" in obj:
            kwargs["pending"] = obj["pending"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "error" in vars(self):
            out["error"] = self.error
        if not omit_unset or "experimentProgress" in vars(self):
            out["experimentProgress"] = None if self.experimentProgress is None else dump_float(self.experimentProgress)
        if not omit_unset or "hpImportance" in vars(self):
            out["hpImportance"] = None if self.hpImportance is None else {k: dump_float(v) for k, v in self.hpImportance.items()}
        if not omit_unset or "inProgress" in vars(self):
            out["inProgress"] = self.inProgress
        if not omit_unset or "pending" in vars(self):
            out["pending"] = self.pending
        return out

class GetMasterResponseProduct(enum.Enum):
    PRODUCT_UNSPECIFIED = "PRODUCT_UNSPECIFIED"
    PRODUCT_COMMUNITY = "PRODUCT_COMMUNITY"

class GetTrialWorkloadsRequestFilterOption(enum.Enum):
    FILTER_OPTION_UNSPECIFIED = "FILTER_OPTION_UNSPECIFIED"
    FILTER_OPTION_CHECKPOINT = "FILTER_OPTION_CHECKPOINT"
    FILTER_OPTION_VALIDATION = "FILTER_OPTION_VALIDATION"
    FILTER_OPTION_CHECKPOINT_OR_VALIDATION = "FILTER_OPTION_CHECKPOINT_OR_VALIDATION"

class TrialFiltersRankWithinExp:
    rank: "typing.Optional[int]" = None
    sorter: "typing.Optional[v1TrialSorter]" = None

    def __init__(
        self,
        *,
        rank: "typing.Union[int, None, Unset]" = _unset,
        sorter: "typing.Union[v1TrialSorter, None, Unset]" = _unset,
    ):
        if not isinstance(rank, Unset):
            self.rank = rank
        if not isinstance(sorter, Unset):
            self.sorter = sorter

    @classmethod
    def from_json(cls, obj: Json) -> "TrialFiltersRankWithinExp":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "rank" in obj:
            kwargs["rank"] = obj["rank"]
        if "sorter" in obj:
            kwargs["sorter"] = v1TrialSorter.from_json(obj["sorter"]) if obj["sorter"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "rank" in vars(self):
            out["rank"] = self.rank
        if not omit_unset or "sorter" in vars(self):
            out["sorter"] = None if self.sorter is None else self.sorter.to_json(omit_unset)
        return out

class TrialProfilerMetricLabelsProfilerMetricType(enum.Enum):
    PROFILER_METRIC_TYPE_UNSPECIFIED = "PROFILER_METRIC_TYPE_UNSPECIFIED"
    PROFILER_METRIC_TYPE_SYSTEM = "PROFILER_METRIC_TYPE_SYSTEM"
    PROFILER_METRIC_TYPE_TIMING = "PROFILER_METRIC_TYPE_TIMING"
    PROFILER_METRIC_TYPE_MISC = "PROFILER_METRIC_TYPE_MISC"

class TrialSorterNamespace(enum.Enum):
    NAMESPACE_UNSPECIFIED = "NAMESPACE_UNSPECIFIED"
    NAMESPACE_HPARAMS = "NAMESPACE_HPARAMS"
    NAMESPACE_TRAINING_METRICS = "NAMESPACE_TRAINING_METRICS"
    NAMESPACE_VALIDATION_METRICS = "NAMESPACE_VALIDATION_METRICS"

class UpdateTrialTagsRequestIds:
    ids: "typing.Optional[typing.Sequence[int]]" = None

    def __init__(
        self,
        *,
        ids: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
    ):
        if not isinstance(ids, Unset):
            self.ids = ids

    @classmethod
    def from_json(cls, obj: Json) -> "UpdateTrialTagsRequestIds":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "ids" in obj:
            kwargs["ids"] = obj["ids"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "ids" in vars(self):
            out["ids"] = self.ids
        return out

class determinedcheckpointv1State(enum.Enum):
    STATE_UNSPECIFIED = "STATE_UNSPECIFIED"
    STATE_ACTIVE = "STATE_ACTIVE"
    STATE_COMPLETED = "STATE_COMPLETED"
    STATE_ERROR = "STATE_ERROR"
    STATE_DELETED = "STATE_DELETED"

class determinedcontainerv1State(enum.Enum):
    STATE_UNSPECIFIED = "STATE_UNSPECIFIED"
    STATE_ASSIGNED = "STATE_ASSIGNED"
    STATE_PULLING = "STATE_PULLING"
    STATE_STARTING = "STATE_STARTING"
    STATE_RUNNING = "STATE_RUNNING"
    STATE_TERMINATED = "STATE_TERMINATED"

class determineddevicev1Type(enum.Enum):
    TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED"
    TYPE_CPU = "TYPE_CPU"
    TYPE_CUDA = "TYPE_CUDA"
    TYPE_ROCM = "TYPE_ROCM"

class determinedexperimentv1State(enum.Enum):
    STATE_UNSPECIFIED = "STATE_UNSPECIFIED"
    STATE_ACTIVE = "STATE_ACTIVE"
    STATE_PAUSED = "STATE_PAUSED"
    STATE_STOPPING_COMPLETED = "STATE_STOPPING_COMPLETED"
    STATE_STOPPING_CANCELED = "STATE_STOPPING_CANCELED"
    STATE_STOPPING_ERROR = "STATE_STOPPING_ERROR"
    STATE_COMPLETED = "STATE_COMPLETED"
    STATE_CANCELED = "STATE_CANCELED"
    STATE_ERROR = "STATE_ERROR"
    STATE_DELETED = "STATE_DELETED"
    STATE_DELETING = "STATE_DELETING"
    STATE_DELETE_FAILED = "STATE_DELETE_FAILED"
    STATE_STOPPING_KILLED = "STATE_STOPPING_KILLED"
    STATE_QUEUED = "STATE_QUEUED"
    STATE_PULLING = "STATE_PULLING"
    STATE_STARTING = "STATE_STARTING"
    STATE_RUNNING = "STATE_RUNNING"

class determinedjobv1State(enum.Enum):
    STATE_UNSPECIFIED = "STATE_UNSPECIFIED"
    STATE_QUEUED = "STATE_QUEUED"
    STATE_SCHEDULED = "STATE_SCHEDULED"
    STATE_SCHEDULED_BACKFILLED = "STATE_SCHEDULED_BACKFILLED"

class determinedjobv1Type(enum.Enum):
    TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED"
    TYPE_EXPERIMENT = "TYPE_EXPERIMENT"
    TYPE_NOTEBOOK = "TYPE_NOTEBOOK"
    TYPE_TENSORBOARD = "TYPE_TENSORBOARD"
    TYPE_SHELL = "TYPE_SHELL"
    TYPE_COMMAND = "TYPE_COMMAND"
    TYPE_CHECKPOINT_GC = "TYPE_CHECKPOINT_GC"

class determinedtaskv1State(enum.Enum):
    STATE_UNSPECIFIED = "STATE_UNSPECIFIED"
    STATE_PULLING = "STATE_PULLING"
    STATE_STARTING = "STATE_STARTING"
    STATE_RUNNING = "STATE_RUNNING"
    STATE_TERMINATED = "STATE_TERMINATED"
    STATE_TERMINATING = "STATE_TERMINATING"
    STATE_WAITING = "STATE_WAITING"
    STATE_QUEUED = "STATE_QUEUED"

class determinedtrialv1State(enum.Enum):
    STATE_UNSPECIFIED = "STATE_UNSPECIFIED"
    STATE_ACTIVE = "STATE_ACTIVE"
    STATE_PAUSED = "STATE_PAUSED"
    STATE_STOPPING_CANCELED = "STATE_STOPPING_CANCELED"
    STATE_STOPPING_KILLED = "STATE_STOPPING_KILLED"
    STATE_STOPPING_COMPLETED = "STATE_STOPPING_COMPLETED"
    STATE_STOPPING_ERROR = "STATE_STOPPING_ERROR"
    STATE_CANCELED = "STATE_CANCELED"
    STATE_COMPLETED = "STATE_COMPLETED"
    STATE_ERROR = "STATE_ERROR"

class protobufAny:
    typeUrl: "typing.Optional[str]" = None
    value: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        typeUrl: "typing.Union[str, None, Unset]" = _unset,
        value: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(typeUrl, Unset):
            self.typeUrl = typeUrl
        if not isinstance(value, Unset):
            self.value = value

    @classmethod
    def from_json(cls, obj: Json) -> "protobufAny":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "typeUrl" in obj:
            kwargs["typeUrl"] = obj["typeUrl"]
        if "value" in obj:
            kwargs["value"] = obj["value"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "typeUrl" in vars(self):
            out["typeUrl"] = self.typeUrl
        if not omit_unset or "value" in vars(self):
            out["value"] = self.value
        return out

class protobufNullValue(enum.Enum):
    NULL_VALUE = "NULL_VALUE"

class runtimeError:
    code: "typing.Optional[int]" = None
    details: "typing.Optional[typing.Sequence[protobufAny]]" = None
    error: "typing.Optional[str]" = None
    message: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        code: "typing.Union[int, None, Unset]" = _unset,
        details: "typing.Union[typing.Sequence[protobufAny], None, Unset]" = _unset,
        error: "typing.Union[str, None, Unset]" = _unset,
        message: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(code, Unset):
            self.code = code
        if not isinstance(details, Unset):
            self.details = details
        if not isinstance(error, Unset):
            self.error = error
        if not isinstance(message, Unset):
            self.message = message

    @classmethod
    def from_json(cls, obj: Json) -> "runtimeError":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "code" in obj:
            kwargs["code"] = obj["code"]
        if "details" in obj:
            kwargs["details"] = [protobufAny.from_json(x) for x in obj["details"]] if obj["details"] is not None else None
        if "error" in obj:
            kwargs["error"] = obj["error"]
        if "message" in obj:
            kwargs["message"] = obj["message"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "code" in vars(self):
            out["code"] = self.code
        if not omit_unset or "details" in vars(self):
            out["details"] = None if self.details is None else [x.to_json(omit_unset) for x in self.details]
        if not omit_unset or "error" in vars(self):
            out["error"] = self.error
        if not omit_unset or "message" in vars(self):
            out["message"] = self.message
        return out

class runtimeStreamError:
    details: "typing.Optional[typing.Sequence[protobufAny]]" = None
    grpcCode: "typing.Optional[int]" = None
    httpCode: "typing.Optional[int]" = None
    httpStatus: "typing.Optional[str]" = None
    message: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        details: "typing.Union[typing.Sequence[protobufAny], None, Unset]" = _unset,
        grpcCode: "typing.Union[int, None, Unset]" = _unset,
        httpCode: "typing.Union[int, None, Unset]" = _unset,
        httpStatus: "typing.Union[str, None, Unset]" = _unset,
        message: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(details, Unset):
            self.details = details
        if not isinstance(grpcCode, Unset):
            self.grpcCode = grpcCode
        if not isinstance(httpCode, Unset):
            self.httpCode = httpCode
        if not isinstance(httpStatus, Unset):
            self.httpStatus = httpStatus
        if not isinstance(message, Unset):
            self.message = message

    @classmethod
    def from_json(cls, obj: Json) -> "runtimeStreamError":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "details" in obj:
            kwargs["details"] = [protobufAny.from_json(x) for x in obj["details"]] if obj["details"] is not None else None
        if "grpcCode" in obj:
            kwargs["grpcCode"] = obj["grpcCode"]
        if "httpCode" in obj:
            kwargs["httpCode"] = obj["httpCode"]
        if "httpStatus" in obj:
            kwargs["httpStatus"] = obj["httpStatus"]
        if "message" in obj:
            kwargs["message"] = obj["message"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "details" in vars(self):
            out["details"] = None if self.details is None else [x.to_json(omit_unset) for x in self.details]
        if not omit_unset or "grpcCode" in vars(self):
            out["grpcCode"] = self.grpcCode
        if not omit_unset or "httpCode" in vars(self):
            out["httpCode"] = self.httpCode
        if not omit_unset or "httpStatus" in vars(self):
            out["httpStatus"] = self.httpStatus
        if not omit_unset or "message" in vars(self):
            out["message"] = self.message
        return out

class trialv1Trial:
    bestCheckpoint: "typing.Optional[v1CheckpointWorkload]" = None
    bestValidation: "typing.Optional[v1MetricsWorkload]" = None
    checkpointCount: "typing.Optional[int]" = None
    endTime: "typing.Optional[str]" = None
    latestTraining: "typing.Optional[v1MetricsWorkload]" = None
    latestValidation: "typing.Optional[v1MetricsWorkload]" = None
    runnerState: "typing.Optional[str]" = None
    taskId: "typing.Optional[str]" = None
    totalCheckpointSize: "typing.Optional[str]" = None
    wallClockTime: "typing.Optional[float]" = None
    warmStartCheckpointUuid: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        experimentId: int,
        hparams: "typing.Dict[str, typing.Any]",
        id: int,
        restarts: int,
        startTime: str,
        state: "determinedexperimentv1State",
        totalBatchesProcessed: int,
        bestCheckpoint: "typing.Union[v1CheckpointWorkload, None, Unset]" = _unset,
        bestValidation: "typing.Union[v1MetricsWorkload, None, Unset]" = _unset,
        checkpointCount: "typing.Union[int, None, Unset]" = _unset,
        endTime: "typing.Union[str, None, Unset]" = _unset,
        latestTraining: "typing.Union[v1MetricsWorkload, None, Unset]" = _unset,
        latestValidation: "typing.Union[v1MetricsWorkload, None, Unset]" = _unset,
        runnerState: "typing.Union[str, None, Unset]" = _unset,
        taskId: "typing.Union[str, None, Unset]" = _unset,
        totalCheckpointSize: "typing.Union[str, None, Unset]" = _unset,
        wallClockTime: "typing.Union[float, None, Unset]" = _unset,
        warmStartCheckpointUuid: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.experimentId = experimentId
        self.hparams = hparams
        self.id = id
        self.restarts = restarts
        self.startTime = startTime
        self.state = state
        self.totalBatchesProcessed = totalBatchesProcessed
        if not isinstance(bestCheckpoint, Unset):
            self.bestCheckpoint = bestCheckpoint
        if not isinstance(bestValidation, Unset):
            self.bestValidation = bestValidation
        if not isinstance(checkpointCount, Unset):
            self.checkpointCount = checkpointCount
        if not isinstance(endTime, Unset):
            self.endTime = endTime
        if not isinstance(latestTraining, Unset):
            self.latestTraining = latestTraining
        if not isinstance(latestValidation, Unset):
            self.latestValidation = latestValidation
        if not isinstance(runnerState, Unset):
            self.runnerState = runnerState
        if not isinstance(taskId, Unset):
            self.taskId = taskId
        if not isinstance(totalCheckpointSize, Unset):
            self.totalCheckpointSize = totalCheckpointSize
        if not isinstance(wallClockTime, Unset):
            self.wallClockTime = wallClockTime
        if not isinstance(warmStartCheckpointUuid, Unset):
            self.warmStartCheckpointUuid = warmStartCheckpointUuid

    @classmethod
    def from_json(cls, obj: Json) -> "trialv1Trial":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "experimentId": obj["experimentId"],
            "hparams": obj["hparams"],
            "id": obj["id"],
            "restarts": obj["restarts"],
            "startTime": obj["startTime"],
            "state": determinedexperimentv1State(obj["state"]),
            "totalBatchesProcessed": obj["totalBatchesProcessed"],
        }
        if "bestCheckpoint" in obj:
            kwargs["bestCheckpoint"] = v1CheckpointWorkload.from_json(obj["bestCheckpoint"]) if obj["bestCheckpoint"] is not None else None
        if "bestValidation" in obj:
            kwargs["bestValidation"] = v1MetricsWorkload.from_json(obj["bestValidation"]) if obj["bestValidation"] is not None else None
        if "checkpointCount" in obj:
            kwargs["checkpointCount"] = obj["checkpointCount"]
        if "endTime" in obj:
            kwargs["endTime"] = obj["endTime"]
        if "latestTraining" in obj:
            kwargs["latestTraining"] = v1MetricsWorkload.from_json(obj["latestTraining"]) if obj["latestTraining"] is not None else None
        if "latestValidation" in obj:
            kwargs["latestValidation"] = v1MetricsWorkload.from_json(obj["latestValidation"]) if obj["latestValidation"] is not None else None
        if "runnerState" in obj:
            kwargs["runnerState"] = obj["runnerState"]
        if "taskId" in obj:
            kwargs["taskId"] = obj["taskId"]
        if "totalCheckpointSize" in obj:
            kwargs["totalCheckpointSize"] = obj["totalCheckpointSize"]
        if "wallClockTime" in obj:
            kwargs["wallClockTime"] = float(obj["wallClockTime"]) if obj["wallClockTime"] is not None else None
        if "warmStartCheckpointUuid" in obj:
            kwargs["warmStartCheckpointUuid"] = obj["warmStartCheckpointUuid"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "experimentId": self.experimentId,
            "hparams": self.hparams,
            "id": self.id,
            "restarts": self.restarts,
            "startTime": self.startTime,
            "state": self.state.value,
            "totalBatchesProcessed": self.totalBatchesProcessed,
        }
        if not omit_unset or "bestCheckpoint" in vars(self):
            out["bestCheckpoint"] = None if self.bestCheckpoint is None else self.bestCheckpoint.to_json(omit_unset)
        if not omit_unset or "bestValidation" in vars(self):
            out["bestValidation"] = None if self.bestValidation is None else self.bestValidation.to_json(omit_unset)
        if not omit_unset or "checkpointCount" in vars(self):
            out["checkpointCount"] = self.checkpointCount
        if not omit_unset or "endTime" in vars(self):
            out["endTime"] = self.endTime
        if not omit_unset or "latestTraining" in vars(self):
            out["latestTraining"] = None if self.latestTraining is None else self.latestTraining.to_json(omit_unset)
        if not omit_unset or "latestValidation" in vars(self):
            out["latestValidation"] = None if self.latestValidation is None else self.latestValidation.to_json(omit_unset)
        if not omit_unset or "runnerState" in vars(self):
            out["runnerState"] = self.runnerState
        if not omit_unset or "taskId" in vars(self):
            out["taskId"] = self.taskId
        if not omit_unset or "totalCheckpointSize" in vars(self):
            out["totalCheckpointSize"] = self.totalCheckpointSize
        if not omit_unset or "wallClockTime" in vars(self):
            out["wallClockTime"] = None if self.wallClockTime is None else dump_float(self.wallClockTime)
        if not omit_unset or "warmStartCheckpointUuid" in vars(self):
            out["warmStartCheckpointUuid"] = self.warmStartCheckpointUuid
        return out

class v1AckAllocationPreemptionSignalRequest:

    def __init__(
        self,
        *,
        allocationId: str,
    ):
        self.allocationId = allocationId

    @classmethod
    def from_json(cls, obj: Json) -> "v1AckAllocationPreemptionSignalRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "allocationId": obj["allocationId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "allocationId": self.allocationId,
        }
        return out

class v1ActivityType(enum.Enum):
    ACTIVITY_TYPE_UNSPECIFIED = "ACTIVITY_TYPE_UNSPECIFIED"
    ACTIVITY_TYPE_GET = "ACTIVITY_TYPE_GET"

class v1AddProjectNoteResponse:

    def __init__(
        self,
        *,
        notes: "typing.Sequence[v1Note]",
    ):
        self.notes = notes

    @classmethod
    def from_json(cls, obj: Json) -> "v1AddProjectNoteResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "notes": [v1Note.from_json(x) for x in obj["notes"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "notes": [x.to_json(omit_unset) for x in self.notes],
        }
        return out

class v1Agent:
    addresses: "typing.Optional[typing.Sequence[str]]" = None
    containers: "typing.Optional[typing.Dict[str, v1Container]]" = None
    draining: "typing.Optional[bool]" = None
    enabled: "typing.Optional[bool]" = None
    label: "typing.Optional[str]" = None
    registeredTime: "typing.Optional[str]" = None
    resourcePools: "typing.Optional[typing.Sequence[str]]" = None
    slots: "typing.Optional[typing.Dict[str, v1Slot]]" = None
    version: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        id: str,
        addresses: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        containers: "typing.Union[typing.Dict[str, v1Container], None, Unset]" = _unset,
        draining: "typing.Union[bool, None, Unset]" = _unset,
        enabled: "typing.Union[bool, None, Unset]" = _unset,
        label: "typing.Union[str, None, Unset]" = _unset,
        registeredTime: "typing.Union[str, None, Unset]" = _unset,
        resourcePools: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        slots: "typing.Union[typing.Dict[str, v1Slot], None, Unset]" = _unset,
        version: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.id = id
        if not isinstance(addresses, Unset):
            self.addresses = addresses
        if not isinstance(containers, Unset):
            self.containers = containers
        if not isinstance(draining, Unset):
            self.draining = draining
        if not isinstance(enabled, Unset):
            self.enabled = enabled
        if not isinstance(label, Unset):
            self.label = label
        if not isinstance(registeredTime, Unset):
            self.registeredTime = registeredTime
        if not isinstance(resourcePools, Unset):
            self.resourcePools = resourcePools
        if not isinstance(slots, Unset):
            self.slots = slots
        if not isinstance(version, Unset):
            self.version = version

    @classmethod
    def from_json(cls, obj: Json) -> "v1Agent":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "id": obj["id"],
        }
        if "addresses" in obj:
            kwargs["addresses"] = obj["addresses"]
        if "containers" in obj:
            kwargs["containers"] = {k: v1Container.from_json(v) for k, v in obj["containers"].items()} if obj["containers"] is not None else None
        if "draining" in obj:
            kwargs["draining"] = obj["draining"]
        if "enabled" in obj:
            kwargs["enabled"] = obj["enabled"]
        if "label" in obj:
            kwargs["label"] = obj["label"]
        if "registeredTime" in obj:
            kwargs["registeredTime"] = obj["registeredTime"]
        if "resourcePools" in obj:
            kwargs["resourcePools"] = obj["resourcePools"]
        if "slots" in obj:
            kwargs["slots"] = {k: v1Slot.from_json(v) for k, v in obj["slots"].items()} if obj["slots"] is not None else None
        if "version" in obj:
            kwargs["version"] = obj["version"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "id": self.id,
        }
        if not omit_unset or "addresses" in vars(self):
            out["addresses"] = self.addresses
        if not omit_unset or "containers" in vars(self):
            out["containers"] = None if self.containers is None else {k: v.to_json(omit_unset) for k, v in self.containers.items()}
        if not omit_unset or "draining" in vars(self):
            out["draining"] = self.draining
        if not omit_unset or "enabled" in vars(self):
            out["enabled"] = self.enabled
        if not omit_unset or "label" in vars(self):
            out["label"] = self.label
        if not omit_unset or "registeredTime" in vars(self):
            out["registeredTime"] = self.registeredTime
        if not omit_unset or "resourcePools" in vars(self):
            out["resourcePools"] = self.resourcePools
        if not omit_unset or "slots" in vars(self):
            out["slots"] = None if self.slots is None else {k: v.to_json(omit_unset) for k, v in self.slots.items()}
        if not omit_unset or "version" in vars(self):
            out["version"] = self.version
        return out

class v1AgentUserGroup:
    agentGid: "typing.Optional[int]" = None
    agentGroup: "typing.Optional[str]" = None
    agentUid: "typing.Optional[int]" = None
    agentUser: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        agentGid: "typing.Union[int, None, Unset]" = _unset,
        agentGroup: "typing.Union[str, None, Unset]" = _unset,
        agentUid: "typing.Union[int, None, Unset]" = _unset,
        agentUser: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(agentGid, Unset):
            self.agentGid = agentGid
        if not isinstance(agentGroup, Unset):
            self.agentGroup = agentGroup
        if not isinstance(agentUid, Unset):
            self.agentUid = agentUid
        if not isinstance(agentUser, Unset):
            self.agentUser = agentUser

    @classmethod
    def from_json(cls, obj: Json) -> "v1AgentUserGroup":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "agentGid" in obj:
            kwargs["agentGid"] = obj["agentGid"]
        if "agentGroup" in obj:
            kwargs["agentGroup"] = obj["agentGroup"]
        if "agentUid" in obj:
            kwargs["agentUid"] = obj["agentUid"]
        if "agentUser" in obj:
            kwargs["agentUser"] = obj["agentUser"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "agentGid" in vars(self):
            out["agentGid"] = self.agentGid
        if not omit_unset or "agentGroup" in vars(self):
            out["agentGroup"] = self.agentGroup
        if not omit_unset or "agentUid" in vars(self):
            out["agentUid"] = self.agentUid
        if not omit_unset or "agentUser" in vars(self):
            out["agentUser"] = self.agentUser
        return out

class v1AggregateQueueStats:

    def __init__(
        self,
        *,
        periodStart: str,
        seconds: float,
    ):
        self.periodStart = periodStart
        self.seconds = seconds

    @classmethod
    def from_json(cls, obj: Json) -> "v1AggregateQueueStats":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "periodStart": obj["periodStart"],
            "seconds": float(obj["seconds"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "periodStart": self.periodStart,
            "seconds": dump_float(self.seconds),
        }
        return out

class v1Allocation:
    allocationId: "typing.Optional[str]" = None
    endTime: "typing.Optional[str]" = None
    isReady: "typing.Optional[bool]" = None
    startTime: "typing.Optional[str]" = None
    state: "typing.Optional[determinedtaskv1State]" = None
    taskId: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        allocationId: "typing.Union[str, None, Unset]" = _unset,
        endTime: "typing.Union[str, None, Unset]" = _unset,
        isReady: "typing.Union[bool, None, Unset]" = _unset,
        startTime: "typing.Union[str, None, Unset]" = _unset,
        state: "typing.Union[determinedtaskv1State, None, Unset]" = _unset,
        taskId: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(allocationId, Unset):
            self.allocationId = allocationId
        if not isinstance(endTime, Unset):
            self.endTime = endTime
        if not isinstance(isReady, Unset):
            self.isReady = isReady
        if not isinstance(startTime, Unset):
            self.startTime = startTime
        if not isinstance(state, Unset):
            self.state = state
        if not isinstance(taskId, Unset):
            self.taskId = taskId

    @classmethod
    def from_json(cls, obj: Json) -> "v1Allocation":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "allocationId" in obj:
            kwargs["allocationId"] = obj["allocationId"]
        if "endTime" in obj:
            kwargs["endTime"] = obj["endTime"]
        if "isReady" in obj:
            kwargs["isReady"] = obj["isReady"]
        if "startTime" in obj:
            kwargs["startTime"] = obj["startTime"]
        if "state" in obj:
            kwargs["state"] = determinedtaskv1State(obj["state"]) if obj["state"] is not None else None
        if "taskId" in obj:
            kwargs["taskId"] = obj["taskId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "allocationId" in vars(self):
            out["allocationId"] = self.allocationId
        if not omit_unset or "endTime" in vars(self):
            out["endTime"] = self.endTime
        if not omit_unset or "isReady" in vars(self):
            out["isReady"] = self.isReady
        if not omit_unset or "startTime" in vars(self):
            out["startTime"] = self.startTime
        if not omit_unset or "state" in vars(self):
            out["state"] = None if self.state is None else self.state.value
        if not omit_unset or "taskId" in vars(self):
            out["taskId"] = self.taskId
        return out

class v1AllocationAllGatherRequest:
    numPeers: "typing.Optional[int]" = None
    requestUuid: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        allocationId: str,
        data: "typing.Dict[str, typing.Any]",
        numPeers: "typing.Union[int, None, Unset]" = _unset,
        requestUuid: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.allocationId = allocationId
        self.data = data
        if not isinstance(numPeers, Unset):
            self.numPeers = numPeers
        if not isinstance(requestUuid, Unset):
            self.requestUuid = requestUuid

    @classmethod
    def from_json(cls, obj: Json) -> "v1AllocationAllGatherRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "allocationId": obj["allocationId"],
            "data": obj["data"],
        }
        if "numPeers" in obj:
            kwargs["numPeers"] = obj["numPeers"]
        if "requestUuid" in obj:
            kwargs["requestUuid"] = obj["requestUuid"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "allocationId": self.allocationId,
            "data": self.data,
        }
        if not omit_unset or "numPeers" in vars(self):
            out["numPeers"] = self.numPeers
        if not omit_unset or "requestUuid" in vars(self):
            out["requestUuid"] = self.requestUuid
        return out

class v1AllocationAllGatherResponse:

    def __init__(
        self,
        *,
        data: "typing.Sequence[typing.Dict[str, typing.Any]]",
    ):
        self.data = data

    @classmethod
    def from_json(cls, obj: Json) -> "v1AllocationAllGatherResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "data": obj["data"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "data": self.data,
        }
        return out

class v1AllocationPendingPreemptionSignalRequest:

    def __init__(
        self,
        *,
        allocationId: str,
    ):
        self.allocationId = allocationId

    @classmethod
    def from_json(cls, obj: Json) -> "v1AllocationPendingPreemptionSignalRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "allocationId": obj["allocationId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "allocationId": self.allocationId,
        }
        return out

class v1AllocationPreemptionSignalResponse:
    preempt: "typing.Optional[bool]" = None

    def __init__(
        self,
        *,
        preempt: "typing.Union[bool, None, Unset]" = _unset,
    ):
        if not isinstance(preempt, Unset):
            self.preempt = preempt

    @classmethod
    def from_json(cls, obj: Json) -> "v1AllocationPreemptionSignalResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "preempt" in obj:
            kwargs["preempt"] = obj["preempt"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "preempt" in vars(self):
            out["preempt"] = self.preempt
        return out

class v1AllocationReadyRequest:
    allocationId: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        allocationId: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(allocationId, Unset):
            self.allocationId = allocationId

    @classmethod
    def from_json(cls, obj: Json) -> "v1AllocationReadyRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "allocationId" in obj:
            kwargs["allocationId"] = obj["allocationId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "allocationId" in vars(self):
            out["allocationId"] = self.allocationId
        return out

class v1AllocationRendezvousInfoResponse:

    def __init__(
        self,
        *,
        rendezvousInfo: "v1RendezvousInfo",
    ):
        self.rendezvousInfo = rendezvousInfo

    @classmethod
    def from_json(cls, obj: Json) -> "v1AllocationRendezvousInfoResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "rendezvousInfo": v1RendezvousInfo.from_json(obj["rendezvousInfo"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "rendezvousInfo": self.rendezvousInfo.to_json(omit_unset),
        }
        return out

class v1AllocationWaitingRequest:
    allocationId: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        allocationId: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(allocationId, Unset):
            self.allocationId = allocationId

    @classmethod
    def from_json(cls, obj: Json) -> "v1AllocationWaitingRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "allocationId" in obj:
            kwargs["allocationId"] = obj["allocationId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "allocationId" in vars(self):
            out["allocationId"] = self.allocationId
        return out

class v1AssignRolesRequest:
    groupRoleAssignments: "typing.Optional[typing.Sequence[v1GroupRoleAssignment]]" = None
    userRoleAssignments: "typing.Optional[typing.Sequence[v1UserRoleAssignment]]" = None

    def __init__(
        self,
        *,
        groupRoleAssignments: "typing.Union[typing.Sequence[v1GroupRoleAssignment], None, Unset]" = _unset,
        userRoleAssignments: "typing.Union[typing.Sequence[v1UserRoleAssignment], None, Unset]" = _unset,
    ):
        if not isinstance(groupRoleAssignments, Unset):
            self.groupRoleAssignments = groupRoleAssignments
        if not isinstance(userRoleAssignments, Unset):
            self.userRoleAssignments = userRoleAssignments

    @classmethod
    def from_json(cls, obj: Json) -> "v1AssignRolesRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "groupRoleAssignments" in obj:
            kwargs["groupRoleAssignments"] = [v1GroupRoleAssignment.from_json(x) for x in obj["groupRoleAssignments"]] if obj["groupRoleAssignments"] is not None else None
        if "userRoleAssignments" in obj:
            kwargs["userRoleAssignments"] = [v1UserRoleAssignment.from_json(x) for x in obj["userRoleAssignments"]] if obj["userRoleAssignments"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "groupRoleAssignments" in vars(self):
            out["groupRoleAssignments"] = None if self.groupRoleAssignments is None else [x.to_json(omit_unset) for x in self.groupRoleAssignments]
        if not omit_unset or "userRoleAssignments" in vars(self):
            out["userRoleAssignments"] = None if self.userRoleAssignments is None else [x.to_json(omit_unset) for x in self.userRoleAssignments]
        return out

class v1AugmentedTrial:
    rankWithinExp: "typing.Optional[int]" = None
    searcherMetric: "typing.Optional[str]" = None
    searcherMetricLoss: "typing.Optional[float]" = None
    searcherMetricValue: "typing.Optional[float]" = None

    def __init__(
        self,
        *,
        endTime: str,
        experimentDescription: str,
        experimentId: int,
        experimentLabels: "typing.Sequence[str]",
        experimentName: str,
        hparams: "typing.Dict[str, typing.Any]",
        projectId: int,
        searcherType: str,
        startTime: str,
        state: "determinedtrialv1State",
        tags: "typing.Dict[str, typing.Any]",
        totalBatches: int,
        trainingMetrics: "typing.Dict[str, typing.Any]",
        trialId: int,
        userId: int,
        validationMetrics: "typing.Dict[str, typing.Any]",
        workspaceId: int,
        rankWithinExp: "typing.Union[int, None, Unset]" = _unset,
        searcherMetric: "typing.Union[str, None, Unset]" = _unset,
        searcherMetricLoss: "typing.Union[float, None, Unset]" = _unset,
        searcherMetricValue: "typing.Union[float, None, Unset]" = _unset,
    ):
        self.endTime = endTime
        self.experimentDescription = experimentDescription
        self.experimentId = experimentId
        self.experimentLabels = experimentLabels
        self.experimentName = experimentName
        self.hparams = hparams
        self.projectId = projectId
        self.searcherType = searcherType
        self.startTime = startTime
        self.state = state
        self.tags = tags
        self.totalBatches = totalBatches
        self.trainingMetrics = trainingMetrics
        self.trialId = trialId
        self.userId = userId
        self.validationMetrics = validationMetrics
        self.workspaceId = workspaceId
        if not isinstance(rankWithinExp, Unset):
            self.rankWithinExp = rankWithinExp
        if not isinstance(searcherMetric, Unset):
            self.searcherMetric = searcherMetric
        if not isinstance(searcherMetricLoss, Unset):
            self.searcherMetricLoss = searcherMetricLoss
        if not isinstance(searcherMetricValue, Unset):
            self.searcherMetricValue = searcherMetricValue

    @classmethod
    def from_json(cls, obj: Json) -> "v1AugmentedTrial":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "endTime": obj["endTime"],
            "experimentDescription": obj["experimentDescription"],
            "experimentId": obj["experimentId"],
            "experimentLabels": obj["experimentLabels"],
            "experimentName": obj["experimentName"],
            "hparams": obj["hparams"],
            "projectId": obj["projectId"],
            "searcherType": obj["searcherType"],
            "startTime": obj["startTime"],
            "state": determinedtrialv1State(obj["state"]),
            "tags": obj["tags"],
            "totalBatches": obj["totalBatches"],
            "trainingMetrics": obj["trainingMetrics"],
            "trialId": obj["trialId"],
            "userId": obj["userId"],
            "validationMetrics": obj["validationMetrics"],
            "workspaceId": obj["workspaceId"],
        }
        if "rankWithinExp" in obj:
            kwargs["rankWithinExp"] = obj["rankWithinExp"]
        if "searcherMetric" in obj:
            kwargs["searcherMetric"] = obj["searcherMetric"]
        if "searcherMetricLoss" in obj:
            kwargs["searcherMetricLoss"] = float(obj["searcherMetricLoss"]) if obj["searcherMetricLoss"] is not None else None
        if "searcherMetricValue" in obj:
            kwargs["searcherMetricValue"] = float(obj["searcherMetricValue"]) if obj["searcherMetricValue"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "endTime": self.endTime,
            "experimentDescription": self.experimentDescription,
            "experimentId": self.experimentId,
            "experimentLabels": self.experimentLabels,
            "experimentName": self.experimentName,
            "hparams": self.hparams,
            "projectId": self.projectId,
            "searcherType": self.searcherType,
            "startTime": self.startTime,
            "state": self.state.value,
            "tags": self.tags,
            "totalBatches": self.totalBatches,
            "trainingMetrics": self.trainingMetrics,
            "trialId": self.trialId,
            "userId": self.userId,
            "validationMetrics": self.validationMetrics,
            "workspaceId": self.workspaceId,
        }
        if not omit_unset or "rankWithinExp" in vars(self):
            out["rankWithinExp"] = self.rankWithinExp
        if not omit_unset or "searcherMetric" in vars(self):
            out["searcherMetric"] = self.searcherMetric
        if not omit_unset or "searcherMetricLoss" in vars(self):
            out["searcherMetricLoss"] = None if self.searcherMetricLoss is None else dump_float(self.searcherMetricLoss)
        if not omit_unset or "searcherMetricValue" in vars(self):
            out["searcherMetricValue"] = None if self.searcherMetricValue is None else dump_float(self.searcherMetricValue)
        return out

class v1AwsCustomTag:

    def __init__(
        self,
        *,
        key: str,
        value: str,
    ):
        self.key = key
        self.value = value

    @classmethod
    def from_json(cls, obj: Json) -> "v1AwsCustomTag":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "key": obj["key"],
            "value": obj["value"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "key": self.key,
            "value": self.value,
        }
        return out

class v1Checkpoint:
    allocationId: "typing.Optional[str]" = None
    reportTime: "typing.Optional[str]" = None
    taskId: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        metadata: "typing.Dict[str, typing.Any]",
        resources: "typing.Dict[str, str]",
        state: "determinedcheckpointv1State",
        training: "v1CheckpointTrainingMetadata",
        uuid: str,
        allocationId: "typing.Union[str, None, Unset]" = _unset,
        reportTime: "typing.Union[str, None, Unset]" = _unset,
        taskId: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.metadata = metadata
        self.resources = resources
        self.state = state
        self.training = training
        self.uuid = uuid
        if not isinstance(allocationId, Unset):
            self.allocationId = allocationId
        if not isinstance(reportTime, Unset):
            self.reportTime = reportTime
        if not isinstance(taskId, Unset):
            self.taskId = taskId

    @classmethod
    def from_json(cls, obj: Json) -> "v1Checkpoint":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "metadata": obj["metadata"],
            "resources": obj["resources"],
            "state": determinedcheckpointv1State(obj["state"]),
            "training": v1CheckpointTrainingMetadata.from_json(obj["training"]),
            "uuid": obj["uuid"],
        }
        if "allocationId" in obj:
            kwargs["allocationId"] = obj["allocationId"]
        if "reportTime" in obj:
            kwargs["reportTime"] = obj["reportTime"]
        if "taskId" in obj:
            kwargs["taskId"] = obj["taskId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "metadata": self.metadata,
            "resources": self.resources,
            "state": self.state.value,
            "training": self.training.to_json(omit_unset),
            "uuid": self.uuid,
        }
        if not omit_unset or "allocationId" in vars(self):
            out["allocationId"] = self.allocationId
        if not omit_unset or "reportTime" in vars(self):
            out["reportTime"] = self.reportTime
        if not omit_unset or "taskId" in vars(self):
            out["taskId"] = self.taskId
        return out

class v1CheckpointTrainingMetadata:
    experimentConfig: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    experimentId: "typing.Optional[int]" = None
    hparams: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    searcherMetric: "typing.Optional[float]" = None
    trainingMetrics: "typing.Optional[v1Metrics]" = None
    trialId: "typing.Optional[int]" = None
    validationMetrics: "typing.Optional[v1Metrics]" = None

    def __init__(
        self,
        *,
        experimentConfig: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        experimentId: "typing.Union[int, None, Unset]" = _unset,
        hparams: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        searcherMetric: "typing.Union[float, None, Unset]" = _unset,
        trainingMetrics: "typing.Union[v1Metrics, None, Unset]" = _unset,
        trialId: "typing.Union[int, None, Unset]" = _unset,
        validationMetrics: "typing.Union[v1Metrics, None, Unset]" = _unset,
    ):
        if not isinstance(experimentConfig, Unset):
            self.experimentConfig = experimentConfig
        if not isinstance(experimentId, Unset):
            self.experimentId = experimentId
        if not isinstance(hparams, Unset):
            self.hparams = hparams
        if not isinstance(searcherMetric, Unset):
            self.searcherMetric = searcherMetric
        if not isinstance(trainingMetrics, Unset):
            self.trainingMetrics = trainingMetrics
        if not isinstance(trialId, Unset):
            self.trialId = trialId
        if not isinstance(validationMetrics, Unset):
            self.validationMetrics = validationMetrics

    @classmethod
    def from_json(cls, obj: Json) -> "v1CheckpointTrainingMetadata":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "experimentConfig" in obj:
            kwargs["experimentConfig"] = obj["experimentConfig"]
        if "experimentId" in obj:
            kwargs["experimentId"] = obj["experimentId"]
        if "hparams" in obj:
            kwargs["hparams"] = obj["hparams"]
        if "searcherMetric" in obj:
            kwargs["searcherMetric"] = float(obj["searcherMetric"]) if obj["searcherMetric"] is not None else None
        if "trainingMetrics" in obj:
            kwargs["trainingMetrics"] = v1Metrics.from_json(obj["trainingMetrics"]) if obj["trainingMetrics"] is not None else None
        if "trialId" in obj:
            kwargs["trialId"] = obj["trialId"]
        if "validationMetrics" in obj:
            kwargs["validationMetrics"] = v1Metrics.from_json(obj["validationMetrics"]) if obj["validationMetrics"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "experimentConfig" in vars(self):
            out["experimentConfig"] = self.experimentConfig
        if not omit_unset or "experimentId" in vars(self):
            out["experimentId"] = self.experimentId
        if not omit_unset or "hparams" in vars(self):
            out["hparams"] = self.hparams
        if not omit_unset or "searcherMetric" in vars(self):
            out["searcherMetric"] = None if self.searcherMetric is None else dump_float(self.searcherMetric)
        if not omit_unset or "trainingMetrics" in vars(self):
            out["trainingMetrics"] = None if self.trainingMetrics is None else self.trainingMetrics.to_json(omit_unset)
        if not omit_unset or "trialId" in vars(self):
            out["trialId"] = self.trialId
        if not omit_unset or "validationMetrics" in vars(self):
            out["validationMetrics"] = None if self.validationMetrics is None else self.validationMetrics.to_json(omit_unset)
        return out

class v1CheckpointWorkload:
    endTime: "typing.Optional[str]" = None
    metadata: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    resources: "typing.Optional[typing.Dict[str, str]]" = None
    uuid: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        state: "determinedcheckpointv1State",
        totalBatches: int,
        endTime: "typing.Union[str, None, Unset]" = _unset,
        metadata: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        resources: "typing.Union[typing.Dict[str, str], None, Unset]" = _unset,
        uuid: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.state = state
        self.totalBatches = totalBatches
        if not isinstance(endTime, Unset):
            self.endTime = endTime
        if not isinstance(metadata, Unset):
            self.metadata = metadata
        if not isinstance(resources, Unset):
            self.resources = resources
        if not isinstance(uuid, Unset):
            self.uuid = uuid

    @classmethod
    def from_json(cls, obj: Json) -> "v1CheckpointWorkload":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "state": determinedcheckpointv1State(obj["state"]),
            "totalBatches": obj["totalBatches"],
        }
        if "endTime" in obj:
            kwargs["endTime"] = obj["endTime"]
        if "metadata" in obj:
            kwargs["metadata"] = obj["metadata"]
        if "resources" in obj:
            kwargs["resources"] = obj["resources"]
        if "uuid" in obj:
            kwargs["uuid"] = obj["uuid"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "state": self.state.value,
            "totalBatches": self.totalBatches,
        }
        if not omit_unset or "endTime" in vars(self):
            out["endTime"] = self.endTime
        if not omit_unset or "metadata" in vars(self):
            out["metadata"] = self.metadata
        if not omit_unset or "resources" in vars(self):
            out["resources"] = self.resources
        if not omit_unset or "uuid" in vars(self):
            out["uuid"] = self.uuid
        return out

class v1CloseTrialOperation:
    requestId: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        requestId: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(requestId, Unset):
            self.requestId = requestId

    @classmethod
    def from_json(cls, obj: Json) -> "v1CloseTrialOperation":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "requestId" in obj:
            kwargs["requestId"] = obj["requestId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "requestId" in vars(self):
            out["requestId"] = self.requestId
        return out

class v1ColumnFilter:
    filter: "typing.Optional[v1DoubleFieldFilter]" = None
    name: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        filter: "typing.Union[v1DoubleFieldFilter, None, Unset]" = _unset,
        name: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(filter, Unset):
            self.filter = filter
        if not isinstance(name, Unset):
            self.name = name

    @classmethod
    def from_json(cls, obj: Json) -> "v1ColumnFilter":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "filter" in obj:
            kwargs["filter"] = v1DoubleFieldFilter.from_json(obj["filter"]) if obj["filter"] is not None else None
        if "name" in obj:
            kwargs["name"] = obj["name"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "filter" in vars(self):
            out["filter"] = None if self.filter is None else self.filter.to_json(omit_unset)
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        return out

class v1Command:
    container: "typing.Optional[v1Container]" = None
    displayName: "typing.Optional[str]" = None
    exitStatus: "typing.Optional[str]" = None
    userId: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        description: str,
        id: str,
        jobId: str,
        resourcePool: str,
        startTime: str,
        state: "determinedtaskv1State",
        username: str,
        container: "typing.Union[v1Container, None, Unset]" = _unset,
        displayName: "typing.Union[str, None, Unset]" = _unset,
        exitStatus: "typing.Union[str, None, Unset]" = _unset,
        userId: "typing.Union[int, None, Unset]" = _unset,
    ):
        self.description = description
        self.id = id
        self.jobId = jobId
        self.resourcePool = resourcePool
        self.startTime = startTime
        self.state = state
        self.username = username
        if not isinstance(container, Unset):
            self.container = container
        if not isinstance(displayName, Unset):
            self.displayName = displayName
        if not isinstance(exitStatus, Unset):
            self.exitStatus = exitStatus
        if not isinstance(userId, Unset):
            self.userId = userId

    @classmethod
    def from_json(cls, obj: Json) -> "v1Command":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "description": obj["description"],
            "id": obj["id"],
            "jobId": obj["jobId"],
            "resourcePool": obj["resourcePool"],
            "startTime": obj["startTime"],
            "state": determinedtaskv1State(obj["state"]),
            "username": obj["username"],
        }
        if "container" in obj:
            kwargs["container"] = v1Container.from_json(obj["container"]) if obj["container"] is not None else None
        if "displayName" in obj:
            kwargs["displayName"] = obj["displayName"]
        if "exitStatus" in obj:
            kwargs["exitStatus"] = obj["exitStatus"]
        if "userId" in obj:
            kwargs["userId"] = obj["userId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "description": self.description,
            "id": self.id,
            "jobId": self.jobId,
            "resourcePool": self.resourcePool,
            "startTime": self.startTime,
            "state": self.state.value,
            "username": self.username,
        }
        if not omit_unset or "container" in vars(self):
            out["container"] = None if self.container is None else self.container.to_json(omit_unset)
        if not omit_unset or "displayName" in vars(self):
            out["displayName"] = self.displayName
        if not omit_unset or "exitStatus" in vars(self):
            out["exitStatus"] = self.exitStatus
        if not omit_unset or "userId" in vars(self):
            out["userId"] = self.userId
        return out

class v1ComparableTrial:

    def __init__(
        self,
        *,
        metrics: "typing.Sequence[v1SummarizedMetric]",
        trial: "trialv1Trial",
    ):
        self.metrics = metrics
        self.trial = trial

    @classmethod
    def from_json(cls, obj: Json) -> "v1ComparableTrial":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "metrics": [v1SummarizedMetric.from_json(x) for x in obj["metrics"]],
            "trial": trialv1Trial.from_json(obj["trial"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "metrics": [x.to_json(omit_unset) for x in self.metrics],
            "trial": self.trial.to_json(omit_unset),
        }
        return out

class v1CompareTrialsResponse:

    def __init__(
        self,
        *,
        trials: "typing.Sequence[v1ComparableTrial]",
    ):
        self.trials = trials

    @classmethod
    def from_json(cls, obj: Json) -> "v1CompareTrialsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "trials": [v1ComparableTrial.from_json(x) for x in obj["trials"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "trials": [x.to_json(omit_unset) for x in self.trials],
        }
        return out

class v1CompleteValidateAfterOperation:
    op: "typing.Optional[v1ValidateAfterOperation]" = None
    searcherMetric: "typing.Optional[float]" = None

    def __init__(
        self,
        *,
        op: "typing.Union[v1ValidateAfterOperation, None, Unset]" = _unset,
        searcherMetric: "typing.Union[float, None, Unset]" = _unset,
    ):
        if not isinstance(op, Unset):
            self.op = op
        if not isinstance(searcherMetric, Unset):
            self.searcherMetric = searcherMetric

    @classmethod
    def from_json(cls, obj: Json) -> "v1CompleteValidateAfterOperation":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "op" in obj:
            kwargs["op"] = v1ValidateAfterOperation.from_json(obj["op"]) if obj["op"] is not None else None
        if "searcherMetric" in obj:
            kwargs["searcherMetric"] = float(obj["searcherMetric"]) if obj["searcherMetric"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "op" in vars(self):
            out["op"] = None if self.op is None else self.op.to_json(omit_unset)
        if not omit_unset or "searcherMetric" in vars(self):
            out["searcherMetric"] = None if self.searcherMetric is None else dump_float(self.searcherMetric)
        return out

class v1Container:
    devices: "typing.Optional[typing.Sequence[v1Device]]" = None
    parent: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        id: str,
        state: "determinedcontainerv1State",
        devices: "typing.Union[typing.Sequence[v1Device], None, Unset]" = _unset,
        parent: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.id = id
        self.state = state
        if not isinstance(devices, Unset):
            self.devices = devices
        if not isinstance(parent, Unset):
            self.parent = parent

    @classmethod
    def from_json(cls, obj: Json) -> "v1Container":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "id": obj["id"],
            "state": determinedcontainerv1State(obj["state"]),
        }
        if "devices" in obj:
            kwargs["devices"] = [v1Device.from_json(x) for x in obj["devices"]] if obj["devices"] is not None else None
        if "parent" in obj:
            kwargs["parent"] = obj["parent"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "id": self.id,
            "state": self.state.value,
        }
        if not omit_unset or "devices" in vars(self):
            out["devices"] = None if self.devices is None else [x.to_json(omit_unset) for x in self.devices]
        if not omit_unset or "parent" in vars(self):
            out["parent"] = self.parent
        return out

class v1CreateExperimentRequest:
    activate: "typing.Optional[bool]" = None
    config: "typing.Optional[str]" = None
    gitCommit: "typing.Optional[str]" = None
    gitCommitDate: "typing.Optional[str]" = None
    gitCommitter: "typing.Optional[str]" = None
    gitRemote: "typing.Optional[str]" = None
    modelDefinition: "typing.Optional[typing.Sequence[v1File]]" = None
    parentId: "typing.Optional[int]" = None
    projectId: "typing.Optional[int]" = None
    template: "typing.Optional[str]" = None
    validateOnly: "typing.Optional[bool]" = None

    def __init__(
        self,
        *,
        activate: "typing.Union[bool, None, Unset]" = _unset,
        config: "typing.Union[str, None, Unset]" = _unset,
        gitCommit: "typing.Union[str, None, Unset]" = _unset,
        gitCommitDate: "typing.Union[str, None, Unset]" = _unset,
        gitCommitter: "typing.Union[str, None, Unset]" = _unset,
        gitRemote: "typing.Union[str, None, Unset]" = _unset,
        modelDefinition: "typing.Union[typing.Sequence[v1File], None, Unset]" = _unset,
        parentId: "typing.Union[int, None, Unset]" = _unset,
        projectId: "typing.Union[int, None, Unset]" = _unset,
        template: "typing.Union[str, None, Unset]" = _unset,
        validateOnly: "typing.Union[bool, None, Unset]" = _unset,
    ):
        if not isinstance(activate, Unset):
            self.activate = activate
        if not isinstance(config, Unset):
            self.config = config
        if not isinstance(gitCommit, Unset):
            self.gitCommit = gitCommit
        if not isinstance(gitCommitDate, Unset):
            self.gitCommitDate = gitCommitDate
        if not isinstance(gitCommitter, Unset):
            self.gitCommitter = gitCommitter
        if not isinstance(gitRemote, Unset):
            self.gitRemote = gitRemote
        if not isinstance(modelDefinition, Unset):
            self.modelDefinition = modelDefinition
        if not isinstance(parentId, Unset):
            self.parentId = parentId
        if not isinstance(projectId, Unset):
            self.projectId = projectId
        if not isinstance(template, Unset):
            self.template = template
        if not isinstance(validateOnly, Unset):
            self.validateOnly = validateOnly

    @classmethod
    def from_json(cls, obj: Json) -> "v1CreateExperimentRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "activate" in obj:
            kwargs["activate"] = obj["activate"]
        if "config" in obj:
            kwargs["config"] = obj["config"]
        if "gitCommit" in obj:
            kwargs["gitCommit"] = obj["gitCommit"]
        if "gitCommitDate" in obj:
            kwargs["gitCommitDate"] = obj["gitCommitDate"]
        if "gitCommitter" in obj:
            kwargs["gitCommitter"] = obj["gitCommitter"]
        if "gitRemote" in obj:
            kwargs["gitRemote"] = obj["gitRemote"]
        if "modelDefinition" in obj:
            kwargs["modelDefinition"] = [v1File.from_json(x) for x in obj["modelDefinition"]] if obj["modelDefinition"] is not None else None
        if "parentId" in obj:
            kwargs["parentId"] = obj["parentId"]
        if "projectId" in obj:
            kwargs["projectId"] = obj["projectId"]
        if "template" in obj:
            kwargs["template"] = obj["template"]
        if "validateOnly" in obj:
            kwargs["validateOnly"] = obj["validateOnly"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "activate" in vars(self):
            out["activate"] = self.activate
        if not omit_unset or "config" in vars(self):
            out["config"] = self.config
        if not omit_unset or "gitCommit" in vars(self):
            out["gitCommit"] = self.gitCommit
        if not omit_unset or "gitCommitDate" in vars(self):
            out["gitCommitDate"] = self.gitCommitDate
        if not omit_unset or "gitCommitter" in vars(self):
            out["gitCommitter"] = self.gitCommitter
        if not omit_unset or "gitRemote" in vars(self):
            out["gitRemote"] = self.gitRemote
        if not omit_unset or "modelDefinition" in vars(self):
            out["modelDefinition"] = None if self.modelDefinition is None else [x.to_json(omit_unset) for x in self.modelDefinition]
        if not omit_unset or "parentId" in vars(self):
            out["parentId"] = self.parentId
        if not omit_unset or "projectId" in vars(self):
            out["projectId"] = self.projectId
        if not omit_unset or "template" in vars(self):
            out["template"] = self.template
        if not omit_unset or "validateOnly" in vars(self):
            out["validateOnly"] = self.validateOnly
        return out

class v1CreateExperimentResponse:
    warnings: "typing.Optional[typing.Sequence[v1LaunchWarning]]" = None

    def __init__(
        self,
        *,
        config: "typing.Dict[str, typing.Any]",
        experiment: "v1Experiment",
        warnings: "typing.Union[typing.Sequence[v1LaunchWarning], None, Unset]" = _unset,
    ):
        self.config = config
        self.experiment = experiment
        if not isinstance(warnings, Unset):
            self.warnings = warnings

    @classmethod
    def from_json(cls, obj: Json) -> "v1CreateExperimentResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "config": obj["config"],
            "experiment": v1Experiment.from_json(obj["experiment"]),
        }
        if "warnings" in obj:
            kwargs["warnings"] = [v1LaunchWarning(x) for x in obj["warnings"]] if obj["warnings"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "config": self.config,
            "experiment": self.experiment.to_json(omit_unset),
        }
        if not omit_unset or "warnings" in vars(self):
            out["warnings"] = None if self.warnings is None else [x.value for x in self.warnings]
        return out

class v1CreateGroupRequest:
    addUsers: "typing.Optional[typing.Sequence[int]]" = None

    def __init__(
        self,
        *,
        name: str,
        addUsers: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
    ):
        self.name = name
        if not isinstance(addUsers, Unset):
            self.addUsers = addUsers

    @classmethod
    def from_json(cls, obj: Json) -> "v1CreateGroupRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "name": obj["name"],
        }
        if "addUsers" in obj:
            kwargs["addUsers"] = obj["addUsers"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "name": self.name,
        }
        if not omit_unset or "addUsers" in vars(self):
            out["addUsers"] = self.addUsers
        return out

class v1CreateGroupResponse:

    def __init__(
        self,
        *,
        group: "v1GroupDetails",
    ):
        self.group = group

    @classmethod
    def from_json(cls, obj: Json) -> "v1CreateGroupResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "group": v1GroupDetails.from_json(obj["group"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "group": self.group.to_json(omit_unset),
        }
        return out

class v1CreateTrialOperation:
    hyperparams: "typing.Optional[str]" = None
    requestId: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        hyperparams: "typing.Union[str, None, Unset]" = _unset,
        requestId: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(hyperparams, Unset):
            self.hyperparams = hyperparams
        if not isinstance(requestId, Unset):
            self.requestId = requestId

    @classmethod
    def from_json(cls, obj: Json) -> "v1CreateTrialOperation":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "hyperparams" in obj:
            kwargs["hyperparams"] = obj["hyperparams"]
        if "requestId" in obj:
            kwargs["requestId"] = obj["requestId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "hyperparams" in vars(self):
            out["hyperparams"] = self.hyperparams
        if not omit_unset or "requestId" in vars(self):
            out["requestId"] = self.requestId
        return out

class v1CreateTrialsCollectionRequest:

    def __init__(
        self,
        *,
        filters: "v1TrialFilters",
        name: str,
        projectId: int,
        sorter: "v1TrialSorter",
    ):
        self.filters = filters
        self.name = name
        self.projectId = projectId
        self.sorter = sorter

    @classmethod
    def from_json(cls, obj: Json) -> "v1CreateTrialsCollectionRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "filters": v1TrialFilters.from_json(obj["filters"]),
            "name": obj["name"],
            "projectId": obj["projectId"],
            "sorter": v1TrialSorter.from_json(obj["sorter"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "filters": self.filters.to_json(omit_unset),
            "name": self.name,
            "projectId": self.projectId,
            "sorter": self.sorter.to_json(omit_unset),
        }
        return out

class v1CreateTrialsCollectionResponse:
    collection: "typing.Optional[v1TrialsCollection]" = None

    def __init__(
        self,
        *,
        collection: "typing.Union[v1TrialsCollection, None, Unset]" = _unset,
    ):
        if not isinstance(collection, Unset):
            self.collection = collection

    @classmethod
    def from_json(cls, obj: Json) -> "v1CreateTrialsCollectionResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "collection" in obj:
            kwargs["collection"] = v1TrialsCollection.from_json(obj["collection"]) if obj["collection"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "collection" in vars(self):
            out["collection"] = None if self.collection is None else self.collection.to_json(omit_unset)
        return out

class v1CurrentUserResponse:

    def __init__(
        self,
        *,
        user: "v1User",
    ):
        self.user = user

    @classmethod
    def from_json(cls, obj: Json) -> "v1CurrentUserResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "user": v1User.from_json(obj["user"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "user": self.user.to_json(omit_unset),
        }
        return out

class v1DataPoint:

    def __init__(
        self,
        *,
        batches: int,
        value: float,
    ):
        self.batches = batches
        self.value = value

    @classmethod
    def from_json(cls, obj: Json) -> "v1DataPoint":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "batches": obj["batches"],
            "value": float(obj["value"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "batches": self.batches,
            "value": dump_float(self.value),
        }
        return out

class v1DeleteCheckpointsRequest:

    def __init__(
        self,
        *,
        checkpointUuids: "typing.Sequence[str]",
    ):
        self.checkpointUuids = checkpointUuids

    @classmethod
    def from_json(cls, obj: Json) -> "v1DeleteCheckpointsRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "checkpointUuids": obj["checkpointUuids"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "checkpointUuids": self.checkpointUuids,
        }
        return out

class v1DeleteProjectResponse:

    def __init__(
        self,
        *,
        completed: bool,
    ):
        self.completed = completed

    @classmethod
    def from_json(cls, obj: Json) -> "v1DeleteProjectResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "completed": obj["completed"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "completed": self.completed,
        }
        return out

class v1DeleteWorkspaceResponse:

    def __init__(
        self,
        *,
        completed: bool,
    ):
        self.completed = completed

    @classmethod
    def from_json(cls, obj: Json) -> "v1DeleteWorkspaceResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "completed": obj["completed"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "completed": self.completed,
        }
        return out

class v1Device:
    brand: "typing.Optional[str]" = None
    id: "typing.Optional[int]" = None
    type: "typing.Optional[determineddevicev1Type]" = None
    uuid: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        brand: "typing.Union[str, None, Unset]" = _unset,
        id: "typing.Union[int, None, Unset]" = _unset,
        type: "typing.Union[determineddevicev1Type, None, Unset]" = _unset,
        uuid: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(brand, Unset):
            self.brand = brand
        if not isinstance(id, Unset):
            self.id = id
        if not isinstance(type, Unset):
            self.type = type
        if not isinstance(uuid, Unset):
            self.uuid = uuid

    @classmethod
    def from_json(cls, obj: Json) -> "v1Device":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "brand" in obj:
            kwargs["brand"] = obj["brand"]
        if "id" in obj:
            kwargs["id"] = obj["id"]
        if "type" in obj:
            kwargs["type"] = determineddevicev1Type(obj["type"]) if obj["type"] is not None else None
        if "uuid" in obj:
            kwargs["uuid"] = obj["uuid"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "brand" in vars(self):
            out["brand"] = self.brand
        if not omit_unset or "id" in vars(self):
            out["id"] = self.id
        if not omit_unset or "type" in vars(self):
            out["type"] = None if self.type is None else self.type.value
        if not omit_unset or "uuid" in vars(self):
            out["uuid"] = self.uuid
        return out

class v1DisableAgentRequest:
    agentId: "typing.Optional[str]" = None
    drain: "typing.Optional[bool]" = None

    def __init__(
        self,
        *,
        agentId: "typing.Union[str, None, Unset]" = _unset,
        drain: "typing.Union[bool, None, Unset]" = _unset,
    ):
        if not isinstance(agentId, Unset):
            self.agentId = agentId
        if not isinstance(drain, Unset):
            self.drain = drain

    @classmethod
    def from_json(cls, obj: Json) -> "v1DisableAgentRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "agentId" in obj:
            kwargs["agentId"] = obj["agentId"]
        if "drain" in obj:
            kwargs["drain"] = obj["drain"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "agentId" in vars(self):
            out["agentId"] = self.agentId
        if not omit_unset or "drain" in vars(self):
            out["drain"] = self.drain
        return out

class v1DisableAgentResponse:
    agent: "typing.Optional[v1Agent]" = None

    def __init__(
        self,
        *,
        agent: "typing.Union[v1Agent, None, Unset]" = _unset,
    ):
        if not isinstance(agent, Unset):
            self.agent = agent

    @classmethod
    def from_json(cls, obj: Json) -> "v1DisableAgentResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "agent" in obj:
            kwargs["agent"] = v1Agent.from_json(obj["agent"]) if obj["agent"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "agent" in vars(self):
            out["agent"] = None if self.agent is None else self.agent.to_json(omit_unset)
        return out

class v1DisableSlotResponse:
    slot: "typing.Optional[v1Slot]" = None

    def __init__(
        self,
        *,
        slot: "typing.Union[v1Slot, None, Unset]" = _unset,
    ):
        if not isinstance(slot, Unset):
            self.slot = slot

    @classmethod
    def from_json(cls, obj: Json) -> "v1DisableSlotResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "slot" in obj:
            kwargs["slot"] = v1Slot.from_json(obj["slot"]) if obj["slot"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "slot" in vars(self):
            out["slot"] = None if self.slot is None else self.slot.to_json(omit_unset)
        return out

class v1DoubleFieldFilter:
    gt: "typing.Optional[float]" = None
    gte: "typing.Optional[float]" = None
    lt: "typing.Optional[float]" = None
    lte: "typing.Optional[float]" = None

    def __init__(
        self,
        *,
        gt: "typing.Union[float, None, Unset]" = _unset,
        gte: "typing.Union[float, None, Unset]" = _unset,
        lt: "typing.Union[float, None, Unset]" = _unset,
        lte: "typing.Union[float, None, Unset]" = _unset,
    ):
        if not isinstance(gt, Unset):
            self.gt = gt
        if not isinstance(gte, Unset):
            self.gte = gte
        if not isinstance(lt, Unset):
            self.lt = lt
        if not isinstance(lte, Unset):
            self.lte = lte

    @classmethod
    def from_json(cls, obj: Json) -> "v1DoubleFieldFilter":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "gt" in obj:
            kwargs["gt"] = float(obj["gt"]) if obj["gt"] is not None else None
        if "gte" in obj:
            kwargs["gte"] = float(obj["gte"]) if obj["gte"] is not None else None
        if "lt" in obj:
            kwargs["lt"] = float(obj["lt"]) if obj["lt"] is not None else None
        if "lte" in obj:
            kwargs["lte"] = float(obj["lte"]) if obj["lte"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "gt" in vars(self):
            out["gt"] = None if self.gt is None else dump_float(self.gt)
        if not omit_unset or "gte" in vars(self):
            out["gte"] = None if self.gte is None else dump_float(self.gte)
        if not omit_unset or "lt" in vars(self):
            out["lt"] = None if self.lt is None else dump_float(self.lt)
        if not omit_unset or "lte" in vars(self):
            out["lte"] = None if self.lte is None else dump_float(self.lte)
        return out

class v1EnableAgentResponse:
    agent: "typing.Optional[v1Agent]" = None

    def __init__(
        self,
        *,
        agent: "typing.Union[v1Agent, None, Unset]" = _unset,
    ):
        if not isinstance(agent, Unset):
            self.agent = agent

    @classmethod
    def from_json(cls, obj: Json) -> "v1EnableAgentResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "agent" in obj:
            kwargs["agent"] = v1Agent.from_json(obj["agent"]) if obj["agent"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "agent" in vars(self):
            out["agent"] = None if self.agent is None else self.agent.to_json(omit_unset)
        return out

class v1EnableSlotResponse:
    slot: "typing.Optional[v1Slot]" = None

    def __init__(
        self,
        *,
        slot: "typing.Union[v1Slot, None, Unset]" = _unset,
    ):
        if not isinstance(slot, Unset):
            self.slot = slot

    @classmethod
    def from_json(cls, obj: Json) -> "v1EnableSlotResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "slot" in obj:
            kwargs["slot"] = v1Slot.from_json(obj["slot"]) if obj["slot"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "slot" in vars(self):
            out["slot"] = None if self.slot is None else self.slot.to_json(omit_unset)
        return out

class v1EntityType(enum.Enum):
    ENTITY_TYPE_UNSPECIFIED = "ENTITY_TYPE_UNSPECIFIED"
    ENTITY_TYPE_PROJECT = "ENTITY_TYPE_PROJECT"

class v1ExpCompareMetricNamesResponse:
    trainingMetrics: "typing.Optional[typing.Sequence[str]]" = None
    validationMetrics: "typing.Optional[typing.Sequence[str]]" = None

    def __init__(
        self,
        *,
        trainingMetrics: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        validationMetrics: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
    ):
        if not isinstance(trainingMetrics, Unset):
            self.trainingMetrics = trainingMetrics
        if not isinstance(validationMetrics, Unset):
            self.validationMetrics = validationMetrics

    @classmethod
    def from_json(cls, obj: Json) -> "v1ExpCompareMetricNamesResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "trainingMetrics" in obj:
            kwargs["trainingMetrics"] = obj["trainingMetrics"]
        if "validationMetrics" in obj:
            kwargs["validationMetrics"] = obj["validationMetrics"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "trainingMetrics" in vars(self):
            out["trainingMetrics"] = self.trainingMetrics
        if not omit_unset or "validationMetrics" in vars(self):
            out["validationMetrics"] = self.validationMetrics
        return out

class v1ExpCompareTrialsSampleResponse:

    def __init__(
        self,
        *,
        demotedTrials: "typing.Sequence[int]",
        promotedTrials: "typing.Sequence[int]",
        trials: "typing.Sequence[ExpCompareTrialsSampleResponseExpTrial]",
    ):
        self.demotedTrials = demotedTrials
        self.promotedTrials = promotedTrials
        self.trials = trials

    @classmethod
    def from_json(cls, obj: Json) -> "v1ExpCompareTrialsSampleResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "demotedTrials": obj["demotedTrials"],
            "promotedTrials": obj["promotedTrials"],
            "trials": [ExpCompareTrialsSampleResponseExpTrial.from_json(x) for x in obj["trials"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "demotedTrials": self.demotedTrials,
            "promotedTrials": self.promotedTrials,
            "trials": [x.to_json(omit_unset) for x in self.trials],
        }
        return out

class v1Experiment:
    checkpointCount: "typing.Optional[int]" = None
    checkpointSize: "typing.Optional[str]" = None
    description: "typing.Optional[str]" = None
    displayName: "typing.Optional[str]" = None
    endTime: "typing.Optional[str]" = None
    forkedFrom: "typing.Optional[int]" = None
    labels: "typing.Optional[typing.Sequence[str]]" = None
    notes: "typing.Optional[str]" = None
    parentArchived: "typing.Optional[bool]" = None
    progress: "typing.Optional[float]" = None
    projectName: "typing.Optional[str]" = None
    resourcePool: "typing.Optional[str]" = None
    trialIds: "typing.Optional[typing.Sequence[int]]" = None
    userId: "typing.Optional[int]" = None
    workspaceId: "typing.Optional[int]" = None
    workspaceName: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        archived: bool,
        config: "typing.Dict[str, typing.Any]",
        id: int,
        jobId: str,
        name: str,
        numTrials: int,
        originalConfig: str,
        projectId: int,
        projectOwnerId: int,
        searcherType: str,
        startTime: str,
        state: "determinedexperimentv1State",
        username: str,
        checkpointCount: "typing.Union[int, None, Unset]" = _unset,
        checkpointSize: "typing.Union[str, None, Unset]" = _unset,
        description: "typing.Union[str, None, Unset]" = _unset,
        displayName: "typing.Union[str, None, Unset]" = _unset,
        endTime: "typing.Union[str, None, Unset]" = _unset,
        forkedFrom: "typing.Union[int, None, Unset]" = _unset,
        labels: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        notes: "typing.Union[str, None, Unset]" = _unset,
        parentArchived: "typing.Union[bool, None, Unset]" = _unset,
        progress: "typing.Union[float, None, Unset]" = _unset,
        projectName: "typing.Union[str, None, Unset]" = _unset,
        resourcePool: "typing.Union[str, None, Unset]" = _unset,
        trialIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
        userId: "typing.Union[int, None, Unset]" = _unset,
        workspaceId: "typing.Union[int, None, Unset]" = _unset,
        workspaceName: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.archived = archived
        self.config = config
        self.id = id
        self.jobId = jobId
        self.name = name
        self.numTrials = numTrials
        self.originalConfig = originalConfig
        self.projectId = projectId
        self.projectOwnerId = projectOwnerId
        self.searcherType = searcherType
        self.startTime = startTime
        self.state = state
        self.username = username
        if not isinstance(checkpointCount, Unset):
            self.checkpointCount = checkpointCount
        if not isinstance(checkpointSize, Unset):
            self.checkpointSize = checkpointSize
        if not isinstance(description, Unset):
            self.description = description
        if not isinstance(displayName, Unset):
            self.displayName = displayName
        if not isinstance(endTime, Unset):
            self.endTime = endTime
        if not isinstance(forkedFrom, Unset):
            self.forkedFrom = forkedFrom
        if not isinstance(labels, Unset):
            self.labels = labels
        if not isinstance(notes, Unset):
            self.notes = notes
        if not isinstance(parentArchived, Unset):
            self.parentArchived = parentArchived
        if not isinstance(progress, Unset):
            self.progress = progress
        if not isinstance(projectName, Unset):
            self.projectName = projectName
        if not isinstance(resourcePool, Unset):
            self.resourcePool = resourcePool
        if not isinstance(trialIds, Unset):
            self.trialIds = trialIds
        if not isinstance(userId, Unset):
            self.userId = userId
        if not isinstance(workspaceId, Unset):
            self.workspaceId = workspaceId
        if not isinstance(workspaceName, Unset):
            self.workspaceName = workspaceName

    @classmethod
    def from_json(cls, obj: Json) -> "v1Experiment":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "archived": obj["archived"],
            "config": obj["config"],
            "id": obj["id"],
            "jobId": obj["jobId"],
            "name": obj["name"],
            "numTrials": obj["numTrials"],
            "originalConfig": obj["originalConfig"],
            "projectId": obj["projectId"],
            "projectOwnerId": obj["projectOwnerId"],
            "searcherType": obj["searcherType"],
            "startTime": obj["startTime"],
            "state": determinedexperimentv1State(obj["state"]),
            "username": obj["username"],
        }
        if "checkpointCount" in obj:
            kwargs["checkpointCount"] = obj["checkpointCount"]
        if "checkpointSize" in obj:
            kwargs["checkpointSize"] = obj["checkpointSize"]
        if "description" in obj:
            kwargs["description"] = obj["description"]
        if "displayName" in obj:
            kwargs["displayName"] = obj["displayName"]
        if "endTime" in obj:
            kwargs["endTime"] = obj["endTime"]
        if "forkedFrom" in obj:
            kwargs["forkedFrom"] = obj["forkedFrom"]
        if "labels" in obj:
            kwargs["labels"] = obj["labels"]
        if "notes" in obj:
            kwargs["notes"] = obj["notes"]
        if "parentArchived" in obj:
            kwargs["parentArchived"] = obj["parentArchived"]
        if "progress" in obj:
            kwargs["progress"] = float(obj["progress"]) if obj["progress"] is not None else None
        if "projectName" in obj:
            kwargs["projectName"] = obj["projectName"]
        if "resourcePool" in obj:
            kwargs["resourcePool"] = obj["resourcePool"]
        if "trialIds" in obj:
            kwargs["trialIds"] = obj["trialIds"]
        if "userId" in obj:
            kwargs["userId"] = obj["userId"]
        if "workspaceId" in obj:
            kwargs["workspaceId"] = obj["workspaceId"]
        if "workspaceName" in obj:
            kwargs["workspaceName"] = obj["workspaceName"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "archived": self.archived,
            "config": self.config,
            "id": self.id,
            "jobId": self.jobId,
            "name": self.name,
            "numTrials": self.numTrials,
            "originalConfig": self.originalConfig,
            "projectId": self.projectId,
            "projectOwnerId": self.projectOwnerId,
            "searcherType": self.searcherType,
            "startTime": self.startTime,
            "state": self.state.value,
            "username": self.username,
        }
        if not omit_unset or "checkpointCount" in vars(self):
            out["checkpointCount"] = self.checkpointCount
        if not omit_unset or "checkpointSize" in vars(self):
            out["checkpointSize"] = self.checkpointSize
        if not omit_unset or "description" in vars(self):
            out["description"] = self.description
        if not omit_unset or "displayName" in vars(self):
            out["displayName"] = self.displayName
        if not omit_unset or "endTime" in vars(self):
            out["endTime"] = self.endTime
        if not omit_unset or "forkedFrom" in vars(self):
            out["forkedFrom"] = self.forkedFrom
        if not omit_unset or "labels" in vars(self):
            out["labels"] = self.labels
        if not omit_unset or "notes" in vars(self):
            out["notes"] = self.notes
        if not omit_unset or "parentArchived" in vars(self):
            out["parentArchived"] = self.parentArchived
        if not omit_unset or "progress" in vars(self):
            out["progress"] = None if self.progress is None else dump_float(self.progress)
        if not omit_unset or "projectName" in vars(self):
            out["projectName"] = self.projectName
        if not omit_unset or "resourcePool" in vars(self):
            out["resourcePool"] = self.resourcePool
        if not omit_unset or "trialIds" in vars(self):
            out["trialIds"] = self.trialIds
        if not omit_unset or "userId" in vars(self):
            out["userId"] = self.userId
        if not omit_unset or "workspaceId" in vars(self):
            out["workspaceId"] = self.workspaceId
        if not omit_unset or "workspaceName" in vars(self):
            out["workspaceName"] = self.workspaceName
        return out

class v1ExperimentInactive:

    def __init__(
        self,
        *,
        experimentState: "determinedexperimentv1State",
    ):
        self.experimentState = experimentState

    @classmethod
    def from_json(cls, obj: Json) -> "v1ExperimentInactive":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "experimentState": determinedexperimentv1State(obj["experimentState"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "experimentState": self.experimentState.value,
        }
        return out

class v1ExperimentSimulation:
    config: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    seed: "typing.Optional[int]" = None
    trials: "typing.Optional[typing.Sequence[v1TrialSimulation]]" = None

    def __init__(
        self,
        *,
        config: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        seed: "typing.Union[int, None, Unset]" = _unset,
        trials: "typing.Union[typing.Sequence[v1TrialSimulation], None, Unset]" = _unset,
    ):
        if not isinstance(config, Unset):
            self.config = config
        if not isinstance(seed, Unset):
            self.seed = seed
        if not isinstance(trials, Unset):
            self.trials = trials

    @classmethod
    def from_json(cls, obj: Json) -> "v1ExperimentSimulation":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "config" in obj:
            kwargs["config"] = obj["config"]
        if "seed" in obj:
            kwargs["seed"] = obj["seed"]
        if "trials" in obj:
            kwargs["trials"] = [v1TrialSimulation.from_json(x) for x in obj["trials"]] if obj["trials"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "config" in vars(self):
            out["config"] = self.config
        if not omit_unset or "seed" in vars(self):
            out["seed"] = self.seed
        if not omit_unset or "trials" in vars(self):
            out["trials"] = None if self.trials is None else [x.to_json(omit_unset) for x in self.trials]
        return out

class v1File:

    def __init__(
        self,
        *,
        content: str,
        gid: int,
        mode: int,
        mtime: str,
        path: str,
        type: int,
        uid: int,
    ):
        self.content = content
        self.gid = gid
        self.mode = mode
        self.mtime = mtime
        self.path = path
        self.type = type
        self.uid = uid

    @classmethod
    def from_json(cls, obj: Json) -> "v1File":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "content": obj["content"],
            "gid": obj["gid"],
            "mode": obj["mode"],
            "mtime": obj["mtime"],
            "path": obj["path"],
            "type": obj["type"],
            "uid": obj["uid"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "content": self.content,
            "gid": self.gid,
            "mode": self.mode,
            "mtime": self.mtime,
            "path": self.path,
            "type": self.type,
            "uid": self.uid,
        }
        return out

class v1FileNode:
    contentLength: "typing.Optional[int]" = None
    contentType: "typing.Optional[str]" = None
    files: "typing.Optional[typing.Sequence[v1FileNode]]" = None
    isDir: "typing.Optional[bool]" = None
    modifiedTime: "typing.Optional[str]" = None
    name: "typing.Optional[str]" = None
    path: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        contentLength: "typing.Union[int, None, Unset]" = _unset,
        contentType: "typing.Union[str, None, Unset]" = _unset,
        files: "typing.Union[typing.Sequence[v1FileNode], None, Unset]" = _unset,
        isDir: "typing.Union[bool, None, Unset]" = _unset,
        modifiedTime: "typing.Union[str, None, Unset]" = _unset,
        name: "typing.Union[str, None, Unset]" = _unset,
        path: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(contentLength, Unset):
            self.contentLength = contentLength
        if not isinstance(contentType, Unset):
            self.contentType = contentType
        if not isinstance(files, Unset):
            self.files = files
        if not isinstance(isDir, Unset):
            self.isDir = isDir
        if not isinstance(modifiedTime, Unset):
            self.modifiedTime = modifiedTime
        if not isinstance(name, Unset):
            self.name = name
        if not isinstance(path, Unset):
            self.path = path

    @classmethod
    def from_json(cls, obj: Json) -> "v1FileNode":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "contentLength" in obj:
            kwargs["contentLength"] = obj["contentLength"]
        if "contentType" in obj:
            kwargs["contentType"] = obj["contentType"]
        if "files" in obj:
            kwargs["files"] = [v1FileNode.from_json(x) for x in obj["files"]] if obj["files"] is not None else None
        if "isDir" in obj:
            kwargs["isDir"] = obj["isDir"]
        if "modifiedTime" in obj:
            kwargs["modifiedTime"] = obj["modifiedTime"]
        if "name" in obj:
            kwargs["name"] = obj["name"]
        if "path" in obj:
            kwargs["path"] = obj["path"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "contentLength" in vars(self):
            out["contentLength"] = self.contentLength
        if not omit_unset or "contentType" in vars(self):
            out["contentType"] = self.contentType
        if not omit_unset or "files" in vars(self):
            out["files"] = None if self.files is None else [x.to_json(omit_unset) for x in self.files]
        if not omit_unset or "isDir" in vars(self):
            out["isDir"] = self.isDir
        if not omit_unset or "modifiedTime" in vars(self):
            out["modifiedTime"] = self.modifiedTime
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        if not omit_unset or "path" in vars(self):
            out["path"] = self.path
        return out

class v1FittingPolicy(enum.Enum):
    FITTING_POLICY_UNSPECIFIED = "FITTING_POLICY_UNSPECIFIED"
    FITTING_POLICY_BEST = "FITTING_POLICY_BEST"
    FITTING_POLICY_WORST = "FITTING_POLICY_WORST"
    FITTING_POLICY_KUBERNETES = "FITTING_POLICY_KUBERNETES"
    FITTING_POLICY_SLURM = "FITTING_POLICY_SLURM"
    FITTING_POLICY_PBS = "FITTING_POLICY_PBS"

class v1GetActiveTasksCountResponse:

    def __init__(
        self,
        *,
        commands: int,
        notebooks: int,
        shells: int,
        tensorboards: int,
    ):
        self.commands = commands
        self.notebooks = notebooks
        self.shells = shells
        self.tensorboards = tensorboards

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetActiveTasksCountResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "commands": obj["commands"],
            "notebooks": obj["notebooks"],
            "shells": obj["shells"],
            "tensorboards": obj["tensorboards"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "commands": self.commands,
            "notebooks": self.notebooks,
            "shells": self.shells,
            "tensorboards": self.tensorboards,
        }
        return out

class v1GetAgentResponse:
    agent: "typing.Optional[v1Agent]" = None

    def __init__(
        self,
        *,
        agent: "typing.Union[v1Agent, None, Unset]" = _unset,
    ):
        if not isinstance(agent, Unset):
            self.agent = agent

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetAgentResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "agent" in obj:
            kwargs["agent"] = v1Agent.from_json(obj["agent"]) if obj["agent"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "agent" in vars(self):
            out["agent"] = None if self.agent is None else self.agent.to_json(omit_unset)
        return out

class v1GetAgentsRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_ID = "SORT_BY_ID"
    SORT_BY_TIME = "SORT_BY_TIME"

class v1GetAgentsResponse:
    agents: "typing.Optional[typing.Sequence[v1Agent]]" = None
    pagination: "typing.Optional[v1Pagination]" = None

    def __init__(
        self,
        *,
        agents: "typing.Union[typing.Sequence[v1Agent], None, Unset]" = _unset,
        pagination: "typing.Union[v1Pagination, None, Unset]" = _unset,
    ):
        if not isinstance(agents, Unset):
            self.agents = agents
        if not isinstance(pagination, Unset):
            self.pagination = pagination

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetAgentsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "agents" in obj:
            kwargs["agents"] = [v1Agent.from_json(x) for x in obj["agents"]] if obj["agents"] is not None else None
        if "pagination" in obj:
            kwargs["pagination"] = v1Pagination.from_json(obj["pagination"]) if obj["pagination"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "agents" in vars(self):
            out["agents"] = None if self.agents is None else [x.to_json(omit_unset) for x in self.agents]
        if not omit_unset or "pagination" in vars(self):
            out["pagination"] = None if self.pagination is None else self.pagination.to_json(omit_unset)
        return out

class v1GetBestSearcherValidationMetricResponse:
    metric: "typing.Optional[float]" = None

    def __init__(
        self,
        *,
        metric: "typing.Union[float, None, Unset]" = _unset,
    ):
        if not isinstance(metric, Unset):
            self.metric = metric

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetBestSearcherValidationMetricResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "metric" in obj:
            kwargs["metric"] = float(obj["metric"]) if obj["metric"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "metric" in vars(self):
            out["metric"] = None if self.metric is None else dump_float(self.metric)
        return out

class v1GetCheckpointResponse:

    def __init__(
        self,
        *,
        checkpoint: "v1Checkpoint",
    ):
        self.checkpoint = checkpoint

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetCheckpointResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "checkpoint": v1Checkpoint.from_json(obj["checkpoint"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "checkpoint": self.checkpoint.to_json(omit_unset),
        }
        return out

class v1GetCommandResponse:

    def __init__(
        self,
        *,
        command: "v1Command",
        config: "typing.Dict[str, typing.Any]",
    ):
        self.command = command
        self.config = config

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetCommandResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "command": v1Command.from_json(obj["command"]),
            "config": obj["config"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "command": self.command.to_json(omit_unset),
            "config": self.config,
        }
        return out

class v1GetCommandsRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_ID = "SORT_BY_ID"
    SORT_BY_DESCRIPTION = "SORT_BY_DESCRIPTION"
    SORT_BY_START_TIME = "SORT_BY_START_TIME"

class v1GetCommandsResponse:
    pagination: "typing.Optional[v1Pagination]" = None

    def __init__(
        self,
        *,
        commands: "typing.Sequence[v1Command]",
        pagination: "typing.Union[v1Pagination, None, Unset]" = _unset,
    ):
        self.commands = commands
        if not isinstance(pagination, Unset):
            self.pagination = pagination

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetCommandsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "commands": [v1Command.from_json(x) for x in obj["commands"]],
        }
        if "pagination" in obj:
            kwargs["pagination"] = v1Pagination.from_json(obj["pagination"]) if obj["pagination"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "commands": [x.to_json(omit_unset) for x in self.commands],
        }
        if not omit_unset or "pagination" in vars(self):
            out["pagination"] = None if self.pagination is None else self.pagination.to_json(omit_unset)
        return out

class v1GetCurrentTrialSearcherOperationResponse:
    completed: "typing.Optional[bool]" = None
    op: "typing.Optional[v1TrialOperation]" = None

    def __init__(
        self,
        *,
        completed: "typing.Union[bool, None, Unset]" = _unset,
        op: "typing.Union[v1TrialOperation, None, Unset]" = _unset,
    ):
        if not isinstance(completed, Unset):
            self.completed = completed
        if not isinstance(op, Unset):
            self.op = op

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetCurrentTrialSearcherOperationResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "completed" in obj:
            kwargs["completed"] = obj["completed"]
        if "op" in obj:
            kwargs["op"] = v1TrialOperation.from_json(obj["op"]) if obj["op"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "completed" in vars(self):
            out["completed"] = self.completed
        if not omit_unset or "op" in vars(self):
            out["op"] = None if self.op is None else self.op.to_json(omit_unset)
        return out

class v1GetExperimentCheckpointsRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_UUID = "SORT_BY_UUID"
    SORT_BY_TRIAL_ID = "SORT_BY_TRIAL_ID"
    SORT_BY_BATCH_NUMBER = "SORT_BY_BATCH_NUMBER"
    SORT_BY_END_TIME = "SORT_BY_END_TIME"
    SORT_BY_STATE = "SORT_BY_STATE"
    SORT_BY_SEARCHER_METRIC = "SORT_BY_SEARCHER_METRIC"

class v1GetExperimentCheckpointsResponse:

    def __init__(
        self,
        *,
        checkpoints: "typing.Sequence[v1Checkpoint]",
        pagination: "v1Pagination",
    ):
        self.checkpoints = checkpoints
        self.pagination = pagination

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetExperimentCheckpointsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "checkpoints": [v1Checkpoint.from_json(x) for x in obj["checkpoints"]],
            "pagination": v1Pagination.from_json(obj["pagination"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "checkpoints": [x.to_json(omit_unset) for x in self.checkpoints],
            "pagination": self.pagination.to_json(omit_unset),
        }
        return out

class v1GetExperimentLabelsResponse:
    labels: "typing.Optional[typing.Sequence[str]]" = None

    def __init__(
        self,
        *,
        labels: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
    ):
        if not isinstance(labels, Unset):
            self.labels = labels

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetExperimentLabelsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "labels" in obj:
            kwargs["labels"] = obj["labels"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "labels" in vars(self):
            out["labels"] = self.labels
        return out

class v1GetExperimentResponse:
    jobSummary: "typing.Optional[v1JobSummary]" = None

    def __init__(
        self,
        *,
        experiment: "v1Experiment",
        jobSummary: "typing.Union[v1JobSummary, None, Unset]" = _unset,
    ):
        self.experiment = experiment
        if not isinstance(jobSummary, Unset):
            self.jobSummary = jobSummary

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetExperimentResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "experiment": v1Experiment.from_json(obj["experiment"]),
        }
        if "jobSummary" in obj:
            kwargs["jobSummary"] = v1JobSummary.from_json(obj["jobSummary"]) if obj["jobSummary"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "experiment": self.experiment.to_json(omit_unset),
        }
        if not omit_unset or "jobSummary" in vars(self):
            out["jobSummary"] = None if self.jobSummary is None else self.jobSummary.to_json(omit_unset)
        return out

class v1GetExperimentTrialsRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_ID = "SORT_BY_ID"
    SORT_BY_START_TIME = "SORT_BY_START_TIME"
    SORT_BY_END_TIME = "SORT_BY_END_TIME"
    SORT_BY_STATE = "SORT_BY_STATE"
    SORT_BY_BEST_VALIDATION_METRIC = "SORT_BY_BEST_VALIDATION_METRIC"
    SORT_BY_LATEST_VALIDATION_METRIC = "SORT_BY_LATEST_VALIDATION_METRIC"
    SORT_BY_BATCHES_PROCESSED = "SORT_BY_BATCHES_PROCESSED"
    SORT_BY_DURATION = "SORT_BY_DURATION"
    SORT_BY_RESTARTS = "SORT_BY_RESTARTS"
    SORT_BY_CHECKPOINT_SIZE = "SORT_BY_CHECKPOINT_SIZE"

class v1GetExperimentTrialsResponse:

    def __init__(
        self,
        *,
        pagination: "v1Pagination",
        trials: "typing.Sequence[trialv1Trial]",
    ):
        self.pagination = pagination
        self.trials = trials

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetExperimentTrialsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "pagination": v1Pagination.from_json(obj["pagination"]),
            "trials": [trialv1Trial.from_json(x) for x in obj["trials"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "pagination": self.pagination.to_json(omit_unset),
            "trials": [x.to_json(omit_unset) for x in self.trials],
        }
        return out

class v1GetExperimentValidationHistoryResponse:
    validationHistory: "typing.Optional[typing.Sequence[v1ValidationHistoryEntry]]" = None

    def __init__(
        self,
        *,
        validationHistory: "typing.Union[typing.Sequence[v1ValidationHistoryEntry], None, Unset]" = _unset,
    ):
        if not isinstance(validationHistory, Unset):
            self.validationHistory = validationHistory

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetExperimentValidationHistoryResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "validationHistory" in obj:
            kwargs["validationHistory"] = [v1ValidationHistoryEntry.from_json(x) for x in obj["validationHistory"]] if obj["validationHistory"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "validationHistory" in vars(self):
            out["validationHistory"] = None if self.validationHistory is None else [x.to_json(omit_unset) for x in self.validationHistory]
        return out

class v1GetExperimentsRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_ID = "SORT_BY_ID"
    SORT_BY_DESCRIPTION = "SORT_BY_DESCRIPTION"
    SORT_BY_START_TIME = "SORT_BY_START_TIME"
    SORT_BY_END_TIME = "SORT_BY_END_TIME"
    SORT_BY_STATE = "SORT_BY_STATE"
    SORT_BY_NUM_TRIALS = "SORT_BY_NUM_TRIALS"
    SORT_BY_PROGRESS = "SORT_BY_PROGRESS"
    SORT_BY_USER = "SORT_BY_USER"
    SORT_BY_NAME = "SORT_BY_NAME"
    SORT_BY_FORKED_FROM = "SORT_BY_FORKED_FROM"
    SORT_BY_RESOURCE_POOL = "SORT_BY_RESOURCE_POOL"
    SORT_BY_PROJECT_ID = "SORT_BY_PROJECT_ID"
    SORT_BY_CHECKPOINT_SIZE = "SORT_BY_CHECKPOINT_SIZE"
    SORT_BY_CHECKPOINT_COUNT = "SORT_BY_CHECKPOINT_COUNT"

class v1GetExperimentsResponse:

    def __init__(
        self,
        *,
        experiments: "typing.Sequence[v1Experiment]",
        pagination: "v1Pagination",
    ):
        self.experiments = experiments
        self.pagination = pagination

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetExperimentsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "experiments": [v1Experiment.from_json(x) for x in obj["experiments"]],
            "pagination": v1Pagination.from_json(obj["pagination"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "experiments": [x.to_json(omit_unset) for x in self.experiments],
            "pagination": self.pagination.to_json(omit_unset),
        }
        return out

class v1GetGroupResponse:

    def __init__(
        self,
        *,
        group: "v1GroupDetails",
    ):
        self.group = group

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetGroupResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "group": v1GroupDetails.from_json(obj["group"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "group": self.group.to_json(omit_unset),
        }
        return out

class v1GetGroupsAndUsersAssignedToWorkspaceResponse:

    def __init__(
        self,
        *,
        assignments: "typing.Sequence[v1RoleWithAssignments]",
        groups: "typing.Sequence[v1GroupDetails]",
        usersAssignedDirectly: "typing.Sequence[v1User]",
    ):
        self.assignments = assignments
        self.groups = groups
        self.usersAssignedDirectly = usersAssignedDirectly

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetGroupsAndUsersAssignedToWorkspaceResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "assignments": [v1RoleWithAssignments.from_json(x) for x in obj["assignments"]],
            "groups": [v1GroupDetails.from_json(x) for x in obj["groups"]],
            "usersAssignedDirectly": [v1User.from_json(x) for x in obj["usersAssignedDirectly"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "assignments": [x.to_json(omit_unset) for x in self.assignments],
            "groups": [x.to_json(omit_unset) for x in self.groups],
            "usersAssignedDirectly": [x.to_json(omit_unset) for x in self.usersAssignedDirectly],
        }
        return out

class v1GetGroupsRequest:
    name: "typing.Optional[str]" = None
    offset: "typing.Optional[int]" = None
    userId: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        limit: int,
        name: "typing.Union[str, None, Unset]" = _unset,
        offset: "typing.Union[int, None, Unset]" = _unset,
        userId: "typing.Union[int, None, Unset]" = _unset,
    ):
        self.limit = limit
        if not isinstance(name, Unset):
            self.name = name
        if not isinstance(offset, Unset):
            self.offset = offset
        if not isinstance(userId, Unset):
            self.userId = userId

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetGroupsRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "limit": obj["limit"],
        }
        if "name" in obj:
            kwargs["name"] = obj["name"]
        if "offset" in obj:
            kwargs["offset"] = obj["offset"]
        if "userId" in obj:
            kwargs["userId"] = obj["userId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "limit": self.limit,
        }
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        if not omit_unset or "offset" in vars(self):
            out["offset"] = self.offset
        if not omit_unset or "userId" in vars(self):
            out["userId"] = self.userId
        return out

class v1GetGroupsResponse:
    groups: "typing.Optional[typing.Sequence[v1GroupSearchResult]]" = None
    pagination: "typing.Optional[v1Pagination]" = None

    def __init__(
        self,
        *,
        groups: "typing.Union[typing.Sequence[v1GroupSearchResult], None, Unset]" = _unset,
        pagination: "typing.Union[v1Pagination, None, Unset]" = _unset,
    ):
        if not isinstance(groups, Unset):
            self.groups = groups
        if not isinstance(pagination, Unset):
            self.pagination = pagination

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetGroupsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "groups" in obj:
            kwargs["groups"] = [v1GroupSearchResult.from_json(x) for x in obj["groups"]] if obj["groups"] is not None else None
        if "pagination" in obj:
            kwargs["pagination"] = v1Pagination.from_json(obj["pagination"]) if obj["pagination"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "groups" in vars(self):
            out["groups"] = None if self.groups is None else [x.to_json(omit_unset) for x in self.groups]
        if not omit_unset or "pagination" in vars(self):
            out["pagination"] = None if self.pagination is None else self.pagination.to_json(omit_unset)
        return out

class v1GetHPImportanceResponse:

    def __init__(
        self,
        *,
        trainingMetrics: "typing.Dict[str, GetHPImportanceResponseMetricHPImportance]",
        validationMetrics: "typing.Dict[str, GetHPImportanceResponseMetricHPImportance]",
    ):
        self.trainingMetrics = trainingMetrics
        self.validationMetrics = validationMetrics

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetHPImportanceResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "trainingMetrics": {k: GetHPImportanceResponseMetricHPImportance.from_json(v) for k, v in obj["trainingMetrics"].items()},
            "validationMetrics": {k: GetHPImportanceResponseMetricHPImportance.from_json(v) for k, v in obj["validationMetrics"].items()},
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "trainingMetrics": {k: v.to_json(omit_unset) for k, v in self.trainingMetrics.items()},
            "validationMetrics": {k: v.to_json(omit_unset) for k, v in self.validationMetrics.items()},
        }
        return out

class v1GetJobQueueStatsResponse:

    def __init__(
        self,
        *,
        results: "typing.Sequence[v1RPQueueStat]",
    ):
        self.results = results

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetJobQueueStatsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "results": [v1RPQueueStat.from_json(x) for x in obj["results"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "results": [x.to_json(omit_unset) for x in self.results],
        }
        return out

class v1GetJobsResponse:

    def __init__(
        self,
        *,
        jobs: "typing.Sequence[v1Job]",
        pagination: "v1Pagination",
    ):
        self.jobs = jobs
        self.pagination = pagination

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetJobsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "jobs": [v1Job.from_json(x) for x in obj["jobs"]],
            "pagination": v1Pagination.from_json(obj["pagination"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "jobs": [x.to_json(omit_unset) for x in self.jobs],
            "pagination": self.pagination.to_json(omit_unset),
        }
        return out

class v1GetMasterConfigResponse:

    def __init__(
        self,
        *,
        config: "typing.Dict[str, typing.Any]",
    ):
        self.config = config

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetMasterConfigResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "config": obj["config"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "config": self.config,
        }
        return out

class v1GetMasterResponse:
    branding: "typing.Optional[str]" = None
    externalLoginUri: "typing.Optional[str]" = None
    externalLogoutUri: "typing.Optional[str]" = None
    featureSwitches: "typing.Optional[typing.Sequence[str]]" = None
    product: "typing.Optional[GetMasterResponseProduct]" = None
    rbacEnabled: "typing.Optional[bool]" = None
    ssoProviders: "typing.Optional[typing.Sequence[v1SSOProvider]]" = None
    telemetryEnabled: "typing.Optional[bool]" = None

    def __init__(
        self,
        *,
        clusterId: str,
        clusterName: str,
        masterId: str,
        version: str,
        branding: "typing.Union[str, None, Unset]" = _unset,
        externalLoginUri: "typing.Union[str, None, Unset]" = _unset,
        externalLogoutUri: "typing.Union[str, None, Unset]" = _unset,
        featureSwitches: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        product: "typing.Union[GetMasterResponseProduct, None, Unset]" = _unset,
        rbacEnabled: "typing.Union[bool, None, Unset]" = _unset,
        ssoProviders: "typing.Union[typing.Sequence[v1SSOProvider], None, Unset]" = _unset,
        telemetryEnabled: "typing.Union[bool, None, Unset]" = _unset,
    ):
        self.clusterId = clusterId
        self.clusterName = clusterName
        self.masterId = masterId
        self.version = version
        if not isinstance(branding, Unset):
            self.branding = branding
        if not isinstance(externalLoginUri, Unset):
            self.externalLoginUri = externalLoginUri
        if not isinstance(externalLogoutUri, Unset):
            self.externalLogoutUri = externalLogoutUri
        if not isinstance(featureSwitches, Unset):
            self.featureSwitches = featureSwitches
        if not isinstance(product, Unset):
            self.product = product
        if not isinstance(rbacEnabled, Unset):
            self.rbacEnabled = rbacEnabled
        if not isinstance(ssoProviders, Unset):
            self.ssoProviders = ssoProviders
        if not isinstance(telemetryEnabled, Unset):
            self.telemetryEnabled = telemetryEnabled

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetMasterResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "clusterId": obj["clusterId"],
            "clusterName": obj["clusterName"],
            "masterId": obj["masterId"],
            "version": obj["version"],
        }
        if "branding" in obj:
            kwargs["branding"] = obj["branding"]
        if "externalLoginUri" in obj:
            kwargs["externalLoginUri"] = obj["externalLoginUri"]
        if "externalLogoutUri" in obj:
            kwargs["externalLogoutUri"] = obj["externalLogoutUri"]
        if "featureSwitches" in obj:
            kwargs["featureSwitches"] = obj["featureSwitches"]
        if "product" in obj:
            kwargs["product"] = GetMasterResponseProduct(obj["product"]) if obj["product"] is not None else None
        if "rbacEnabled" in obj:
            kwargs["rbacEnabled"] = obj["rbacEnabled"]
        if "ssoProviders" in obj:
            kwargs["ssoProviders"] = [v1SSOProvider.from_json(x) for x in obj["ssoProviders"]] if obj["ssoProviders"] is not None else None
        if "telemetryEnabled" in obj:
            kwargs["telemetryEnabled"] = obj["telemetryEnabled"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "clusterId": self.clusterId,
            "clusterName": self.clusterName,
            "masterId": self.masterId,
            "version": self.version,
        }
        if not omit_unset or "branding" in vars(self):
            out["branding"] = self.branding
        if not omit_unset or "externalLoginUri" in vars(self):
            out["externalLoginUri"] = self.externalLoginUri
        if not omit_unset or "externalLogoutUri" in vars(self):
            out["externalLogoutUri"] = self.externalLogoutUri
        if not omit_unset or "featureSwitches" in vars(self):
            out["featureSwitches"] = self.featureSwitches
        if not omit_unset or "product" in vars(self):
            out["product"] = None if self.product is None else self.product.value
        if not omit_unset or "rbacEnabled" in vars(self):
            out["rbacEnabled"] = self.rbacEnabled
        if not omit_unset or "ssoProviders" in vars(self):
            out["ssoProviders"] = None if self.ssoProviders is None else [x.to_json(omit_unset) for x in self.ssoProviders]
        if not omit_unset or "telemetryEnabled" in vars(self):
            out["telemetryEnabled"] = self.telemetryEnabled
        return out

class v1GetMeResponse:

    def __init__(
        self,
        *,
        user: "v1User",
    ):
        self.user = user

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetMeResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "user": v1User.from_json(obj["user"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "user": self.user.to_json(omit_unset),
        }
        return out

class v1GetModelDefFileRequest:
    experimentId: "typing.Optional[int]" = None
    path: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        experimentId: "typing.Union[int, None, Unset]" = _unset,
        path: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(experimentId, Unset):
            self.experimentId = experimentId
        if not isinstance(path, Unset):
            self.path = path

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetModelDefFileRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "experimentId" in obj:
            kwargs["experimentId"] = obj["experimentId"]
        if "path" in obj:
            kwargs["path"] = obj["path"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "experimentId" in vars(self):
            out["experimentId"] = self.experimentId
        if not omit_unset or "path" in vars(self):
            out["path"] = self.path
        return out

class v1GetModelDefFileResponse:
    file: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        file: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(file, Unset):
            self.file = file

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetModelDefFileResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "file" in obj:
            kwargs["file"] = obj["file"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "file" in vars(self):
            out["file"] = self.file
        return out

class v1GetModelDefResponse:

    def __init__(
        self,
        *,
        b64Tgz: str,
    ):
        self.b64Tgz = b64Tgz

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetModelDefResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "b64Tgz": obj["b64Tgz"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "b64Tgz": self.b64Tgz,
        }
        return out

class v1GetModelDefTreeResponse:
    files: "typing.Optional[typing.Sequence[v1FileNode]]" = None

    def __init__(
        self,
        *,
        files: "typing.Union[typing.Sequence[v1FileNode], None, Unset]" = _unset,
    ):
        if not isinstance(files, Unset):
            self.files = files

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetModelDefTreeResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "files" in obj:
            kwargs["files"] = [v1FileNode.from_json(x) for x in obj["files"]] if obj["files"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "files" in vars(self):
            out["files"] = None if self.files is None else [x.to_json(omit_unset) for x in self.files]
        return out

class v1GetModelLabelsResponse:

    def __init__(
        self,
        *,
        labels: "typing.Sequence[str]",
    ):
        self.labels = labels

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetModelLabelsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "labels": obj["labels"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "labels": self.labels,
        }
        return out

class v1GetModelResponse:

    def __init__(
        self,
        *,
        model: "v1Model",
    ):
        self.model = model

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetModelResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "model": v1Model.from_json(obj["model"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "model": self.model.to_json(omit_unset),
        }
        return out

class v1GetModelVersionResponse:

    def __init__(
        self,
        *,
        modelVersion: "v1ModelVersion",
    ):
        self.modelVersion = modelVersion

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetModelVersionResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "modelVersion": v1ModelVersion.from_json(obj["modelVersion"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "modelVersion": self.modelVersion.to_json(omit_unset),
        }
        return out

class v1GetModelVersionsRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_VERSION = "SORT_BY_VERSION"
    SORT_BY_CREATION_TIME = "SORT_BY_CREATION_TIME"

class v1GetModelVersionsResponse:

    def __init__(
        self,
        *,
        model: "v1Model",
        modelVersions: "typing.Sequence[v1ModelVersion]",
        pagination: "v1Pagination",
    ):
        self.model = model
        self.modelVersions = modelVersions
        self.pagination = pagination

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetModelVersionsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "model": v1Model.from_json(obj["model"]),
            "modelVersions": [v1ModelVersion.from_json(x) for x in obj["modelVersions"]],
            "pagination": v1Pagination.from_json(obj["pagination"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "model": self.model.to_json(omit_unset),
            "modelVersions": [x.to_json(omit_unset) for x in self.modelVersions],
            "pagination": self.pagination.to_json(omit_unset),
        }
        return out

class v1GetModelsRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_NAME = "SORT_BY_NAME"
    SORT_BY_DESCRIPTION = "SORT_BY_DESCRIPTION"
    SORT_BY_CREATION_TIME = "SORT_BY_CREATION_TIME"
    SORT_BY_LAST_UPDATED_TIME = "SORT_BY_LAST_UPDATED_TIME"
    SORT_BY_NUM_VERSIONS = "SORT_BY_NUM_VERSIONS"

class v1GetModelsResponse:

    def __init__(
        self,
        *,
        models: "typing.Sequence[v1Model]",
        pagination: "v1Pagination",
    ):
        self.models = models
        self.pagination = pagination

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetModelsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "models": [v1Model.from_json(x) for x in obj["models"]],
            "pagination": v1Pagination.from_json(obj["pagination"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "models": [x.to_json(omit_unset) for x in self.models],
            "pagination": self.pagination.to_json(omit_unset),
        }
        return out

class v1GetNotebookResponse:

    def __init__(
        self,
        *,
        config: "typing.Dict[str, typing.Any]",
        notebook: "v1Notebook",
    ):
        self.config = config
        self.notebook = notebook

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetNotebookResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "config": obj["config"],
            "notebook": v1Notebook.from_json(obj["notebook"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "config": self.config,
            "notebook": self.notebook.to_json(omit_unset),
        }
        return out

class v1GetNotebooksRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_ID = "SORT_BY_ID"
    SORT_BY_DESCRIPTION = "SORT_BY_DESCRIPTION"
    SORT_BY_START_TIME = "SORT_BY_START_TIME"

class v1GetNotebooksResponse:
    pagination: "typing.Optional[v1Pagination]" = None

    def __init__(
        self,
        *,
        notebooks: "typing.Sequence[v1Notebook]",
        pagination: "typing.Union[v1Pagination, None, Unset]" = _unset,
    ):
        self.notebooks = notebooks
        if not isinstance(pagination, Unset):
            self.pagination = pagination

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetNotebooksResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "notebooks": [v1Notebook.from_json(x) for x in obj["notebooks"]],
        }
        if "pagination" in obj:
            kwargs["pagination"] = v1Pagination.from_json(obj["pagination"]) if obj["pagination"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "notebooks": [x.to_json(omit_unset) for x in self.notebooks],
        }
        if not omit_unset or "pagination" in vars(self):
            out["pagination"] = None if self.pagination is None else self.pagination.to_json(omit_unset)
        return out

class v1GetPermissionsSummaryResponse:

    def __init__(
        self,
        *,
        assignments: "typing.Sequence[v1RoleAssignmentSummary]",
        roles: "typing.Sequence[v1Role]",
    ):
        self.assignments = assignments
        self.roles = roles

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetPermissionsSummaryResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "assignments": [v1RoleAssignmentSummary.from_json(x) for x in obj["assignments"]],
            "roles": [v1Role.from_json(x) for x in obj["roles"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "assignments": [x.to_json(omit_unset) for x in self.assignments],
            "roles": [x.to_json(omit_unset) for x in self.roles],
        }
        return out

class v1GetProjectResponse:

    def __init__(
        self,
        *,
        project: "v1Project",
    ):
        self.project = project

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetProjectResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "project": v1Project.from_json(obj["project"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "project": self.project.to_json(omit_unset),
        }
        return out

class v1GetProjectsByUserActivityResponse:
    projects: "typing.Optional[typing.Sequence[v1Project]]" = None

    def __init__(
        self,
        *,
        projects: "typing.Union[typing.Sequence[v1Project], None, Unset]" = _unset,
    ):
        if not isinstance(projects, Unset):
            self.projects = projects

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetProjectsByUserActivityResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "projects" in obj:
            kwargs["projects"] = [v1Project.from_json(x) for x in obj["projects"]] if obj["projects"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "projects" in vars(self):
            out["projects"] = None if self.projects is None else [x.to_json(omit_unset) for x in self.projects]
        return out

class v1GetResourcePoolsResponse:
    pagination: "typing.Optional[v1Pagination]" = None
    resourcePools: "typing.Optional[typing.Sequence[v1ResourcePool]]" = None

    def __init__(
        self,
        *,
        pagination: "typing.Union[v1Pagination, None, Unset]" = _unset,
        resourcePools: "typing.Union[typing.Sequence[v1ResourcePool], None, Unset]" = _unset,
    ):
        if not isinstance(pagination, Unset):
            self.pagination = pagination
        if not isinstance(resourcePools, Unset):
            self.resourcePools = resourcePools

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetResourcePoolsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "pagination" in obj:
            kwargs["pagination"] = v1Pagination.from_json(obj["pagination"]) if obj["pagination"] is not None else None
        if "resourcePools" in obj:
            kwargs["resourcePools"] = [v1ResourcePool.from_json(x) for x in obj["resourcePools"]] if obj["resourcePools"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "pagination" in vars(self):
            out["pagination"] = None if self.pagination is None else self.pagination.to_json(omit_unset)
        if not omit_unset or "resourcePools" in vars(self):
            out["resourcePools"] = None if self.resourcePools is None else [x.to_json(omit_unset) for x in self.resourcePools]
        return out

class v1GetRolesAssignedToGroupResponse:

    def __init__(
        self,
        *,
        assignments: "typing.Sequence[v1RoleAssignmentSummary]",
        roles: "typing.Sequence[v1Role]",
    ):
        self.assignments = assignments
        self.roles = roles

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetRolesAssignedToGroupResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "assignments": [v1RoleAssignmentSummary.from_json(x) for x in obj["assignments"]],
            "roles": [v1Role.from_json(x) for x in obj["roles"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "assignments": [x.to_json(omit_unset) for x in self.assignments],
            "roles": [x.to_json(omit_unset) for x in self.roles],
        }
        return out

class v1GetRolesAssignedToUserResponse:

    def __init__(
        self,
        *,
        roles: "typing.Sequence[v1RoleWithAssignments]",
    ):
        self.roles = roles

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetRolesAssignedToUserResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "roles": [v1RoleWithAssignments.from_json(x) for x in obj["roles"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "roles": [x.to_json(omit_unset) for x in self.roles],
        }
        return out

class v1GetRolesByIDRequest:
    roleIds: "typing.Optional[typing.Sequence[int]]" = None

    def __init__(
        self,
        *,
        roleIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
    ):
        if not isinstance(roleIds, Unset):
            self.roleIds = roleIds

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetRolesByIDRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "roleIds" in obj:
            kwargs["roleIds"] = obj["roleIds"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "roleIds" in vars(self):
            out["roleIds"] = self.roleIds
        return out

class v1GetRolesByIDResponse:
    roles: "typing.Optional[typing.Sequence[v1RoleWithAssignments]]" = None

    def __init__(
        self,
        *,
        roles: "typing.Union[typing.Sequence[v1RoleWithAssignments], None, Unset]" = _unset,
    ):
        if not isinstance(roles, Unset):
            self.roles = roles

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetRolesByIDResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "roles" in obj:
            kwargs["roles"] = [v1RoleWithAssignments.from_json(x) for x in obj["roles"]] if obj["roles"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "roles" in vars(self):
            out["roles"] = None if self.roles is None else [x.to_json(omit_unset) for x in self.roles]
        return out

class v1GetSearcherEventsResponse:
    searcherEvents: "typing.Optional[typing.Sequence[v1SearcherEvent]]" = None

    def __init__(
        self,
        *,
        searcherEvents: "typing.Union[typing.Sequence[v1SearcherEvent], None, Unset]" = _unset,
    ):
        if not isinstance(searcherEvents, Unset):
            self.searcherEvents = searcherEvents

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetSearcherEventsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "searcherEvents" in obj:
            kwargs["searcherEvents"] = [v1SearcherEvent.from_json(x) for x in obj["searcherEvents"]] if obj["searcherEvents"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "searcherEvents" in vars(self):
            out["searcherEvents"] = None if self.searcherEvents is None else [x.to_json(omit_unset) for x in self.searcherEvents]
        return out

class v1GetShellResponse:

    def __init__(
        self,
        *,
        config: "typing.Dict[str, typing.Any]",
        shell: "v1Shell",
    ):
        self.config = config
        self.shell = shell

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetShellResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "config": obj["config"],
            "shell": v1Shell.from_json(obj["shell"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "config": self.config,
            "shell": self.shell.to_json(omit_unset),
        }
        return out

class v1GetShellsRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_ID = "SORT_BY_ID"
    SORT_BY_DESCRIPTION = "SORT_BY_DESCRIPTION"
    SORT_BY_START_TIME = "SORT_BY_START_TIME"

class v1GetShellsResponse:
    pagination: "typing.Optional[v1Pagination]" = None

    def __init__(
        self,
        *,
        shells: "typing.Sequence[v1Shell]",
        pagination: "typing.Union[v1Pagination, None, Unset]" = _unset,
    ):
        self.shells = shells
        if not isinstance(pagination, Unset):
            self.pagination = pagination

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetShellsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "shells": [v1Shell.from_json(x) for x in obj["shells"]],
        }
        if "pagination" in obj:
            kwargs["pagination"] = v1Pagination.from_json(obj["pagination"]) if obj["pagination"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "shells": [x.to_json(omit_unset) for x in self.shells],
        }
        if not omit_unset or "pagination" in vars(self):
            out["pagination"] = None if self.pagination is None else self.pagination.to_json(omit_unset)
        return out

class v1GetSlotResponse:
    slot: "typing.Optional[v1Slot]" = None

    def __init__(
        self,
        *,
        slot: "typing.Union[v1Slot, None, Unset]" = _unset,
    ):
        if not isinstance(slot, Unset):
            self.slot = slot

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetSlotResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "slot" in obj:
            kwargs["slot"] = v1Slot.from_json(obj["slot"]) if obj["slot"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "slot" in vars(self):
            out["slot"] = None if self.slot is None else self.slot.to_json(omit_unset)
        return out

class v1GetSlotsResponse:
    slots: "typing.Optional[typing.Sequence[v1Slot]]" = None

    def __init__(
        self,
        *,
        slots: "typing.Union[typing.Sequence[v1Slot], None, Unset]" = _unset,
    ):
        if not isinstance(slots, Unset):
            self.slots = slots

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetSlotsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "slots" in obj:
            kwargs["slots"] = [v1Slot.from_json(x) for x in obj["slots"]] if obj["slots"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "slots" in vars(self):
            out["slots"] = None if self.slots is None else [x.to_json(omit_unset) for x in self.slots]
        return out

class v1GetTaskResponse:
    task: "typing.Optional[v1Task]" = None

    def __init__(
        self,
        *,
        task: "typing.Union[v1Task, None, Unset]" = _unset,
    ):
        if not isinstance(task, Unset):
            self.task = task

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetTaskResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "task" in obj:
            kwargs["task"] = v1Task.from_json(obj["task"]) if obj["task"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "task" in vars(self):
            out["task"] = None if self.task is None else self.task.to_json(omit_unset)
        return out

class v1GetTelemetryResponse:
    segmentKey: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        enabled: bool,
        segmentKey: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.enabled = enabled
        if not isinstance(segmentKey, Unset):
            self.segmentKey = segmentKey

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetTelemetryResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "enabled": obj["enabled"],
        }
        if "segmentKey" in obj:
            kwargs["segmentKey"] = obj["segmentKey"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "enabled": self.enabled,
        }
        if not omit_unset or "segmentKey" in vars(self):
            out["segmentKey"] = self.segmentKey
        return out

class v1GetTemplateResponse:
    template: "typing.Optional[v1Template]" = None

    def __init__(
        self,
        *,
        template: "typing.Union[v1Template, None, Unset]" = _unset,
    ):
        if not isinstance(template, Unset):
            self.template = template

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetTemplateResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "template" in obj:
            kwargs["template"] = v1Template.from_json(obj["template"]) if obj["template"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "template" in vars(self):
            out["template"] = None if self.template is None else self.template.to_json(omit_unset)
        return out

class v1GetTemplatesRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_NAME = "SORT_BY_NAME"

class v1GetTemplatesResponse:
    pagination: "typing.Optional[v1Pagination]" = None
    templates: "typing.Optional[typing.Sequence[v1Template]]" = None

    def __init__(
        self,
        *,
        pagination: "typing.Union[v1Pagination, None, Unset]" = _unset,
        templates: "typing.Union[typing.Sequence[v1Template], None, Unset]" = _unset,
    ):
        if not isinstance(pagination, Unset):
            self.pagination = pagination
        if not isinstance(templates, Unset):
            self.templates = templates

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetTemplatesResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "pagination" in obj:
            kwargs["pagination"] = v1Pagination.from_json(obj["pagination"]) if obj["pagination"] is not None else None
        if "templates" in obj:
            kwargs["templates"] = [v1Template.from_json(x) for x in obj["templates"]] if obj["templates"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "pagination" in vars(self):
            out["pagination"] = None if self.pagination is None else self.pagination.to_json(omit_unset)
        if not omit_unset or "templates" in vars(self):
            out["templates"] = None if self.templates is None else [x.to_json(omit_unset) for x in self.templates]
        return out

class v1GetTensorboardResponse:

    def __init__(
        self,
        *,
        config: "typing.Dict[str, typing.Any]",
        tensorboard: "v1Tensorboard",
    ):
        self.config = config
        self.tensorboard = tensorboard

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetTensorboardResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "config": obj["config"],
            "tensorboard": v1Tensorboard.from_json(obj["tensorboard"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "config": self.config,
            "tensorboard": self.tensorboard.to_json(omit_unset),
        }
        return out

class v1GetTensorboardsRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_ID = "SORT_BY_ID"
    SORT_BY_DESCRIPTION = "SORT_BY_DESCRIPTION"
    SORT_BY_START_TIME = "SORT_BY_START_TIME"

class v1GetTensorboardsResponse:
    pagination: "typing.Optional[v1Pagination]" = None

    def __init__(
        self,
        *,
        tensorboards: "typing.Sequence[v1Tensorboard]",
        pagination: "typing.Union[v1Pagination, None, Unset]" = _unset,
    ):
        self.tensorboards = tensorboards
        if not isinstance(pagination, Unset):
            self.pagination = pagination

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetTensorboardsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "tensorboards": [v1Tensorboard.from_json(x) for x in obj["tensorboards"]],
        }
        if "pagination" in obj:
            kwargs["pagination"] = v1Pagination.from_json(obj["pagination"]) if obj["pagination"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "tensorboards": [x.to_json(omit_unset) for x in self.tensorboards],
        }
        if not omit_unset or "pagination" in vars(self):
            out["pagination"] = None if self.pagination is None else self.pagination.to_json(omit_unset)
        return out

class v1GetTrialCheckpointsRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_UUID = "SORT_BY_UUID"
    SORT_BY_BATCH_NUMBER = "SORT_BY_BATCH_NUMBER"
    SORT_BY_END_TIME = "SORT_BY_END_TIME"
    SORT_BY_STATE = "SORT_BY_STATE"

class v1GetTrialCheckpointsResponse:

    def __init__(
        self,
        *,
        checkpoints: "typing.Sequence[v1Checkpoint]",
        pagination: "v1Pagination",
    ):
        self.checkpoints = checkpoints
        self.pagination = pagination

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetTrialCheckpointsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "checkpoints": [v1Checkpoint.from_json(x) for x in obj["checkpoints"]],
            "pagination": v1Pagination.from_json(obj["pagination"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "checkpoints": [x.to_json(omit_unset) for x in self.checkpoints],
            "pagination": self.pagination.to_json(omit_unset),
        }
        return out

class v1GetTrialProfilerAvailableSeriesResponse:

    def __init__(
        self,
        *,
        labels: "typing.Sequence[v1TrialProfilerMetricLabels]",
    ):
        self.labels = labels

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetTrialProfilerAvailableSeriesResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "labels": [v1TrialProfilerMetricLabels.from_json(x) for x in obj["labels"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "labels": [x.to_json(omit_unset) for x in self.labels],
        }
        return out

class v1GetTrialProfilerMetricsResponse:

    def __init__(
        self,
        *,
        batch: "v1TrialProfilerMetricsBatch",
    ):
        self.batch = batch

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetTrialProfilerMetricsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "batch": v1TrialProfilerMetricsBatch.from_json(obj["batch"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "batch": self.batch.to_json(omit_unset),
        }
        return out

class v1GetTrialResponse:

    def __init__(
        self,
        *,
        trial: "trialv1Trial",
    ):
        self.trial = trial

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetTrialResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "trial": trialv1Trial.from_json(obj["trial"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "trial": self.trial.to_json(omit_unset),
        }
        return out

class v1GetTrialWorkloadsResponse:

    def __init__(
        self,
        *,
        pagination: "v1Pagination",
        workloads: "typing.Sequence[v1WorkloadContainer]",
    ):
        self.pagination = pagination
        self.workloads = workloads

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetTrialWorkloadsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "pagination": v1Pagination.from_json(obj["pagination"]),
            "workloads": [v1WorkloadContainer.from_json(x) for x in obj["workloads"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "pagination": self.pagination.to_json(omit_unset),
            "workloads": [x.to_json(omit_unset) for x in self.workloads],
        }
        return out

class v1GetTrialsCollectionsResponse:
    collections: "typing.Optional[typing.Sequence[v1TrialsCollection]]" = None

    def __init__(
        self,
        *,
        collections: "typing.Union[typing.Sequence[v1TrialsCollection], None, Unset]" = _unset,
    ):
        if not isinstance(collections, Unset):
            self.collections = collections

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetTrialsCollectionsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "collections" in obj:
            kwargs["collections"] = [v1TrialsCollection.from_json(x) for x in obj["collections"]] if obj["collections"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "collections" in vars(self):
            out["collections"] = None if self.collections is None else [x.to_json(omit_unset) for x in self.collections]
        return out

class v1GetUserByUsernameResponse:

    def __init__(
        self,
        *,
        user: "v1User",
    ):
        self.user = user

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetUserByUsernameResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "user": v1User.from_json(obj["user"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "user": self.user.to_json(omit_unset),
        }
        return out

class v1GetUserResponse:

    def __init__(
        self,
        *,
        user: "v1User",
    ):
        self.user = user

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetUserResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "user": v1User.from_json(obj["user"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "user": self.user.to_json(omit_unset),
        }
        return out

class v1GetUserSettingResponse:

    def __init__(
        self,
        *,
        settings: "typing.Sequence[v1UserWebSetting]",
    ):
        self.settings = settings

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetUserSettingResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "settings": [v1UserWebSetting.from_json(x) for x in obj["settings"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "settings": [x.to_json(omit_unset) for x in self.settings],
        }
        return out

class v1GetUsersRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_DISPLAY_NAME = "SORT_BY_DISPLAY_NAME"
    SORT_BY_USER_NAME = "SORT_BY_USER_NAME"
    SORT_BY_ADMIN = "SORT_BY_ADMIN"
    SORT_BY_ACTIVE = "SORT_BY_ACTIVE"
    SORT_BY_MODIFIED_TIME = "SORT_BY_MODIFIED_TIME"
    SORT_BY_NAME = "SORT_BY_NAME"

class v1GetUsersResponse:
    pagination: "typing.Optional[v1Pagination]" = None
    users: "typing.Optional[typing.Sequence[v1User]]" = None

    def __init__(
        self,
        *,
        pagination: "typing.Union[v1Pagination, None, Unset]" = _unset,
        users: "typing.Union[typing.Sequence[v1User], None, Unset]" = _unset,
    ):
        if not isinstance(pagination, Unset):
            self.pagination = pagination
        if not isinstance(users, Unset):
            self.users = users

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetUsersResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "pagination" in obj:
            kwargs["pagination"] = v1Pagination.from_json(obj["pagination"]) if obj["pagination"] is not None else None
        if "users" in obj:
            kwargs["users"] = [v1User.from_json(x) for x in obj["users"]] if obj["users"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "pagination" in vars(self):
            out["pagination"] = None if self.pagination is None else self.pagination.to_json(omit_unset)
        if not omit_unset or "users" in vars(self):
            out["users"] = None if self.users is None else [x.to_json(omit_unset) for x in self.users]
        return out

class v1GetWebhooksResponse:

    def __init__(
        self,
        *,
        webhooks: "typing.Sequence[v1Webhook]",
    ):
        self.webhooks = webhooks

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetWebhooksResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "webhooks": [v1Webhook.from_json(x) for x in obj["webhooks"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "webhooks": [x.to_json(omit_unset) for x in self.webhooks],
        }
        return out

class v1GetWorkspaceProjectsRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_CREATION_TIME = "SORT_BY_CREATION_TIME"
    SORT_BY_LAST_EXPERIMENT_START_TIME = "SORT_BY_LAST_EXPERIMENT_START_TIME"
    SORT_BY_NAME = "SORT_BY_NAME"
    SORT_BY_DESCRIPTION = "SORT_BY_DESCRIPTION"
    SORT_BY_ID = "SORT_BY_ID"

class v1GetWorkspaceProjectsResponse:

    def __init__(
        self,
        *,
        pagination: "v1Pagination",
        projects: "typing.Sequence[v1Project]",
    ):
        self.pagination = pagination
        self.projects = projects

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetWorkspaceProjectsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "pagination": v1Pagination.from_json(obj["pagination"]),
            "projects": [v1Project.from_json(x) for x in obj["projects"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "pagination": self.pagination.to_json(omit_unset),
            "projects": [x.to_json(omit_unset) for x in self.projects],
        }
        return out

class v1GetWorkspaceResponse:

    def __init__(
        self,
        *,
        workspace: "v1Workspace",
    ):
        self.workspace = workspace

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetWorkspaceResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "workspace": v1Workspace.from_json(obj["workspace"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "workspace": self.workspace.to_json(omit_unset),
        }
        return out

class v1GetWorkspacesRequestSortBy(enum.Enum):
    SORT_BY_UNSPECIFIED = "SORT_BY_UNSPECIFIED"
    SORT_BY_ID = "SORT_BY_ID"
    SORT_BY_NAME = "SORT_BY_NAME"

class v1GetWorkspacesResponse:

    def __init__(
        self,
        *,
        pagination: "v1Pagination",
        workspaces: "typing.Sequence[v1Workspace]",
    ):
        self.pagination = pagination
        self.workspaces = workspaces

    @classmethod
    def from_json(cls, obj: Json) -> "v1GetWorkspacesResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "pagination": v1Pagination.from_json(obj["pagination"]),
            "workspaces": [v1Workspace.from_json(x) for x in obj["workspaces"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "pagination": self.pagination.to_json(omit_unset),
            "workspaces": [x.to_json(omit_unset) for x in self.workspaces],
        }
        return out

class v1Group:
    groupId: "typing.Optional[int]" = None
    name: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        groupId: "typing.Union[int, None, Unset]" = _unset,
        name: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(groupId, Unset):
            self.groupId = groupId
        if not isinstance(name, Unset):
            self.name = name

    @classmethod
    def from_json(cls, obj: Json) -> "v1Group":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "groupId" in obj:
            kwargs["groupId"] = obj["groupId"]
        if "name" in obj:
            kwargs["name"] = obj["name"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "groupId" in vars(self):
            out["groupId"] = self.groupId
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        return out

class v1GroupDetails:
    groupId: "typing.Optional[int]" = None
    name: "typing.Optional[str]" = None
    users: "typing.Optional[typing.Sequence[v1User]]" = None

    def __init__(
        self,
        *,
        groupId: "typing.Union[int, None, Unset]" = _unset,
        name: "typing.Union[str, None, Unset]" = _unset,
        users: "typing.Union[typing.Sequence[v1User], None, Unset]" = _unset,
    ):
        if not isinstance(groupId, Unset):
            self.groupId = groupId
        if not isinstance(name, Unset):
            self.name = name
        if not isinstance(users, Unset):
            self.users = users

    @classmethod
    def from_json(cls, obj: Json) -> "v1GroupDetails":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "groupId" in obj:
            kwargs["groupId"] = obj["groupId"]
        if "name" in obj:
            kwargs["name"] = obj["name"]
        if "users" in obj:
            kwargs["users"] = [v1User.from_json(x) for x in obj["users"]] if obj["users"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "groupId" in vars(self):
            out["groupId"] = self.groupId
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        if not omit_unset or "users" in vars(self):
            out["users"] = None if self.users is None else [x.to_json(omit_unset) for x in self.users]
        return out

class v1GroupRoleAssignment:

    def __init__(
        self,
        *,
        groupId: int,
        roleAssignment: "v1RoleAssignment",
    ):
        self.groupId = groupId
        self.roleAssignment = roleAssignment

    @classmethod
    def from_json(cls, obj: Json) -> "v1GroupRoleAssignment":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "groupId": obj["groupId"],
            "roleAssignment": v1RoleAssignment.from_json(obj["roleAssignment"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "groupId": self.groupId,
            "roleAssignment": self.roleAssignment.to_json(omit_unset),
        }
        return out

class v1GroupSearchResult:

    def __init__(
        self,
        *,
        group: "v1Group",
        numMembers: int,
    ):
        self.group = group
        self.numMembers = numMembers

    @classmethod
    def from_json(cls, obj: Json) -> "v1GroupSearchResult":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "group": v1Group.from_json(obj["group"]),
            "numMembers": obj["numMembers"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "group": self.group.to_json(omit_unset),
            "numMembers": self.numMembers,
        }
        return out

class v1IdleNotebookRequest:
    idle: "typing.Optional[bool]" = None
    notebookId: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        idle: "typing.Union[bool, None, Unset]" = _unset,
        notebookId: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(idle, Unset):
            self.idle = idle
        if not isinstance(notebookId, Unset):
            self.notebookId = notebookId

    @classmethod
    def from_json(cls, obj: Json) -> "v1IdleNotebookRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "idle" in obj:
            kwargs["idle"] = obj["idle"]
        if "notebookId" in obj:
            kwargs["notebookId"] = obj["notebookId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "idle" in vars(self):
            out["idle"] = self.idle
        if not omit_unset or "notebookId" in vars(self):
            out["notebookId"] = self.notebookId
        return out

class v1InitialOperations:
    placeholder: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        placeholder: "typing.Union[int, None, Unset]" = _unset,
    ):
        if not isinstance(placeholder, Unset):
            self.placeholder = placeholder

    @classmethod
    def from_json(cls, obj: Json) -> "v1InitialOperations":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "placeholder" in obj:
            kwargs["placeholder"] = obj["placeholder"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "placeholder" in vars(self):
            out["placeholder"] = self.placeholder
        return out

class v1Int32FieldFilter:
    gt: "typing.Optional[int]" = None
    gte: "typing.Optional[int]" = None
    incl: "typing.Optional[typing.Sequence[int]]" = None
    lt: "typing.Optional[int]" = None
    lte: "typing.Optional[int]" = None
    notIn: "typing.Optional[typing.Sequence[int]]" = None

    def __init__(
        self,
        *,
        gt: "typing.Union[int, None, Unset]" = _unset,
        gte: "typing.Union[int, None, Unset]" = _unset,
        incl: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
        lt: "typing.Union[int, None, Unset]" = _unset,
        lte: "typing.Union[int, None, Unset]" = _unset,
        notIn: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
    ):
        if not isinstance(gt, Unset):
            self.gt = gt
        if not isinstance(gte, Unset):
            self.gte = gte
        if not isinstance(incl, Unset):
            self.incl = incl
        if not isinstance(lt, Unset):
            self.lt = lt
        if not isinstance(lte, Unset):
            self.lte = lte
        if not isinstance(notIn, Unset):
            self.notIn = notIn

    @classmethod
    def from_json(cls, obj: Json) -> "v1Int32FieldFilter":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "gt" in obj:
            kwargs["gt"] = obj["gt"]
        if "gte" in obj:
            kwargs["gte"] = obj["gte"]
        if "incl" in obj:
            kwargs["incl"] = obj["incl"]
        if "lt" in obj:
            kwargs["lt"] = obj["lt"]
        if "lte" in obj:
            kwargs["lte"] = obj["lte"]
        if "notIn" in obj:
            kwargs["notIn"] = obj["notIn"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "gt" in vars(self):
            out["gt"] = self.gt
        if not omit_unset or "gte" in vars(self):
            out["gte"] = self.gte
        if not omit_unset or "incl" in vars(self):
            out["incl"] = self.incl
        if not omit_unset or "lt" in vars(self):
            out["lt"] = self.lt
        if not omit_unset or "lte" in vars(self):
            out["lte"] = self.lte
        if not omit_unset or "notIn" in vars(self):
            out["notIn"] = self.notIn
        return out

class v1Job:
    priority: "typing.Optional[int]" = None
    progress: "typing.Optional[float]" = None
    summary: "typing.Optional[v1JobSummary]" = None
    userId: "typing.Optional[int]" = None
    weight: "typing.Optional[float]" = None

    def __init__(
        self,
        *,
        allocatedSlots: int,
        entityId: str,
        isPreemptible: bool,
        jobId: str,
        name: str,
        requestedSlots: int,
        resourcePool: str,
        submissionTime: str,
        type: "determinedjobv1Type",
        username: str,
        priority: "typing.Union[int, None, Unset]" = _unset,
        progress: "typing.Union[float, None, Unset]" = _unset,
        summary: "typing.Union[v1JobSummary, None, Unset]" = _unset,
        userId: "typing.Union[int, None, Unset]" = _unset,
        weight: "typing.Union[float, None, Unset]" = _unset,
    ):
        self.allocatedSlots = allocatedSlots
        self.entityId = entityId
        self.isPreemptible = isPreemptible
        self.jobId = jobId
        self.name = name
        self.requestedSlots = requestedSlots
        self.resourcePool = resourcePool
        self.submissionTime = submissionTime
        self.type = type
        self.username = username
        if not isinstance(priority, Unset):
            self.priority = priority
        if not isinstance(progress, Unset):
            self.progress = progress
        if not isinstance(summary, Unset):
            self.summary = summary
        if not isinstance(userId, Unset):
            self.userId = userId
        if not isinstance(weight, Unset):
            self.weight = weight

    @classmethod
    def from_json(cls, obj: Json) -> "v1Job":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "allocatedSlots": obj["allocatedSlots"],
            "entityId": obj["entityId"],
            "isPreemptible": obj["isPreemptible"],
            "jobId": obj["jobId"],
            "name": obj["name"],
            "requestedSlots": obj["requestedSlots"],
            "resourcePool": obj["resourcePool"],
            "submissionTime": obj["submissionTime"],
            "type": determinedjobv1Type(obj["type"]),
            "username": obj["username"],
        }
        if "priority" in obj:
            kwargs["priority"] = obj["priority"]
        if "progress" in obj:
            kwargs["progress"] = float(obj["progress"]) if obj["progress"] is not None else None
        if "summary" in obj:
            kwargs["summary"] = v1JobSummary.from_json(obj["summary"]) if obj["summary"] is not None else None
        if "userId" in obj:
            kwargs["userId"] = obj["userId"]
        if "weight" in obj:
            kwargs["weight"] = float(obj["weight"]) if obj["weight"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "allocatedSlots": self.allocatedSlots,
            "entityId": self.entityId,
            "isPreemptible": self.isPreemptible,
            "jobId": self.jobId,
            "name": self.name,
            "requestedSlots": self.requestedSlots,
            "resourcePool": self.resourcePool,
            "submissionTime": self.submissionTime,
            "type": self.type.value,
            "username": self.username,
        }
        if not omit_unset or "priority" in vars(self):
            out["priority"] = self.priority
        if not omit_unset or "progress" in vars(self):
            out["progress"] = None if self.progress is None else dump_float(self.progress)
        if not omit_unset or "summary" in vars(self):
            out["summary"] = None if self.summary is None else self.summary.to_json(omit_unset)
        if not omit_unset or "userId" in vars(self):
            out["userId"] = self.userId
        if not omit_unset or "weight" in vars(self):
            out["weight"] = None if self.weight is None else dump_float(self.weight)
        return out

class v1JobSummary:

    def __init__(
        self,
        *,
        jobsAhead: int,
        state: "determinedjobv1State",
    ):
        self.jobsAhead = jobsAhead
        self.state = state

    @classmethod
    def from_json(cls, obj: Json) -> "v1JobSummary":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "jobsAhead": obj["jobsAhead"],
            "state": determinedjobv1State(obj["state"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "jobsAhead": self.jobsAhead,
            "state": self.state.value,
        }
        return out

class v1K8PriorityClass:
    priorityClass: "typing.Optional[str]" = None
    priorityValue: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        priorityClass: "typing.Union[str, None, Unset]" = _unset,
        priorityValue: "typing.Union[int, None, Unset]" = _unset,
    ):
        if not isinstance(priorityClass, Unset):
            self.priorityClass = priorityClass
        if not isinstance(priorityValue, Unset):
            self.priorityValue = priorityValue

    @classmethod
    def from_json(cls, obj: Json) -> "v1K8PriorityClass":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "priorityClass" in obj:
            kwargs["priorityClass"] = obj["priorityClass"]
        if "priorityValue" in obj:
            kwargs["priorityValue"] = obj["priorityValue"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "priorityClass" in vars(self):
            out["priorityClass"] = self.priorityClass
        if not omit_unset or "priorityValue" in vars(self):
            out["priorityValue"] = self.priorityValue
        return out

class v1KillCommandResponse:
    command: "typing.Optional[v1Command]" = None

    def __init__(
        self,
        *,
        command: "typing.Union[v1Command, None, Unset]" = _unset,
    ):
        if not isinstance(command, Unset):
            self.command = command

    @classmethod
    def from_json(cls, obj: Json) -> "v1KillCommandResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "command" in obj:
            kwargs["command"] = v1Command.from_json(obj["command"]) if obj["command"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "command" in vars(self):
            out["command"] = None if self.command is None else self.command.to_json(omit_unset)
        return out

class v1KillNotebookResponse:
    notebook: "typing.Optional[v1Notebook]" = None

    def __init__(
        self,
        *,
        notebook: "typing.Union[v1Notebook, None, Unset]" = _unset,
    ):
        if not isinstance(notebook, Unset):
            self.notebook = notebook

    @classmethod
    def from_json(cls, obj: Json) -> "v1KillNotebookResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "notebook" in obj:
            kwargs["notebook"] = v1Notebook.from_json(obj["notebook"]) if obj["notebook"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "notebook" in vars(self):
            out["notebook"] = None if self.notebook is None else self.notebook.to_json(omit_unset)
        return out

class v1KillShellResponse:
    shell: "typing.Optional[v1Shell]" = None

    def __init__(
        self,
        *,
        shell: "typing.Union[v1Shell, None, Unset]" = _unset,
    ):
        if not isinstance(shell, Unset):
            self.shell = shell

    @classmethod
    def from_json(cls, obj: Json) -> "v1KillShellResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "shell" in obj:
            kwargs["shell"] = v1Shell.from_json(obj["shell"]) if obj["shell"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "shell" in vars(self):
            out["shell"] = None if self.shell is None else self.shell.to_json(omit_unset)
        return out

class v1KillTensorboardResponse:
    tensorboard: "typing.Optional[v1Tensorboard]" = None

    def __init__(
        self,
        *,
        tensorboard: "typing.Union[v1Tensorboard, None, Unset]" = _unset,
    ):
        if not isinstance(tensorboard, Unset):
            self.tensorboard = tensorboard

    @classmethod
    def from_json(cls, obj: Json) -> "v1KillTensorboardResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "tensorboard" in obj:
            kwargs["tensorboard"] = v1Tensorboard.from_json(obj["tensorboard"]) if obj["tensorboard"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "tensorboard" in vars(self):
            out["tensorboard"] = None if self.tensorboard is None else self.tensorboard.to_json(omit_unset)
        return out

class v1LaunchCommandRequest:
    config: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    data: "typing.Optional[str]" = None
    files: "typing.Optional[typing.Sequence[v1File]]" = None
    templateName: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        config: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        data: "typing.Union[str, None, Unset]" = _unset,
        files: "typing.Union[typing.Sequence[v1File], None, Unset]" = _unset,
        templateName: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(config, Unset):
            self.config = config
        if not isinstance(data, Unset):
            self.data = data
        if not isinstance(files, Unset):
            self.files = files
        if not isinstance(templateName, Unset):
            self.templateName = templateName

    @classmethod
    def from_json(cls, obj: Json) -> "v1LaunchCommandRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "config" in obj:
            kwargs["config"] = obj["config"]
        if "data" in obj:
            kwargs["data"] = obj["data"]
        if "files" in obj:
            kwargs["files"] = [v1File.from_json(x) for x in obj["files"]] if obj["files"] is not None else None
        if "templateName" in obj:
            kwargs["templateName"] = obj["templateName"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "config" in vars(self):
            out["config"] = self.config
        if not omit_unset or "data" in vars(self):
            out["data"] = self.data
        if not omit_unset or "files" in vars(self):
            out["files"] = None if self.files is None else [x.to_json(omit_unset) for x in self.files]
        if not omit_unset or "templateName" in vars(self):
            out["templateName"] = self.templateName
        return out

class v1LaunchCommandResponse:
    warnings: "typing.Optional[typing.Sequence[v1LaunchWarning]]" = None

    def __init__(
        self,
        *,
        command: "v1Command",
        config: "typing.Dict[str, typing.Any]",
        warnings: "typing.Union[typing.Sequence[v1LaunchWarning], None, Unset]" = _unset,
    ):
        self.command = command
        self.config = config
        if not isinstance(warnings, Unset):
            self.warnings = warnings

    @classmethod
    def from_json(cls, obj: Json) -> "v1LaunchCommandResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "command": v1Command.from_json(obj["command"]),
            "config": obj["config"],
        }
        if "warnings" in obj:
            kwargs["warnings"] = [v1LaunchWarning(x) for x in obj["warnings"]] if obj["warnings"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "command": self.command.to_json(omit_unset),
            "config": self.config,
        }
        if not omit_unset or "warnings" in vars(self):
            out["warnings"] = None if self.warnings is None else [x.value for x in self.warnings]
        return out

class v1LaunchNotebookRequest:
    config: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    files: "typing.Optional[typing.Sequence[v1File]]" = None
    preview: "typing.Optional[bool]" = None
    templateName: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        config: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        files: "typing.Union[typing.Sequence[v1File], None, Unset]" = _unset,
        preview: "typing.Union[bool, None, Unset]" = _unset,
        templateName: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(config, Unset):
            self.config = config
        if not isinstance(files, Unset):
            self.files = files
        if not isinstance(preview, Unset):
            self.preview = preview
        if not isinstance(templateName, Unset):
            self.templateName = templateName

    @classmethod
    def from_json(cls, obj: Json) -> "v1LaunchNotebookRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "config" in obj:
            kwargs["config"] = obj["config"]
        if "files" in obj:
            kwargs["files"] = [v1File.from_json(x) for x in obj["files"]] if obj["files"] is not None else None
        if "preview" in obj:
            kwargs["preview"] = obj["preview"]
        if "templateName" in obj:
            kwargs["templateName"] = obj["templateName"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "config" in vars(self):
            out["config"] = self.config
        if not omit_unset or "files" in vars(self):
            out["files"] = None if self.files is None else [x.to_json(omit_unset) for x in self.files]
        if not omit_unset or "preview" in vars(self):
            out["preview"] = self.preview
        if not omit_unset or "templateName" in vars(self):
            out["templateName"] = self.templateName
        return out

class v1LaunchNotebookResponse:
    warnings: "typing.Optional[typing.Sequence[v1LaunchWarning]]" = None

    def __init__(
        self,
        *,
        config: "typing.Dict[str, typing.Any]",
        notebook: "v1Notebook",
        warnings: "typing.Union[typing.Sequence[v1LaunchWarning], None, Unset]" = _unset,
    ):
        self.config = config
        self.notebook = notebook
        if not isinstance(warnings, Unset):
            self.warnings = warnings

    @classmethod
    def from_json(cls, obj: Json) -> "v1LaunchNotebookResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "config": obj["config"],
            "notebook": v1Notebook.from_json(obj["notebook"]),
        }
        if "warnings" in obj:
            kwargs["warnings"] = [v1LaunchWarning(x) for x in obj["warnings"]] if obj["warnings"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "config": self.config,
            "notebook": self.notebook.to_json(omit_unset),
        }
        if not omit_unset or "warnings" in vars(self):
            out["warnings"] = None if self.warnings is None else [x.value for x in self.warnings]
        return out

class v1LaunchShellRequest:
    config: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    data: "typing.Optional[str]" = None
    files: "typing.Optional[typing.Sequence[v1File]]" = None
    templateName: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        config: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        data: "typing.Union[str, None, Unset]" = _unset,
        files: "typing.Union[typing.Sequence[v1File], None, Unset]" = _unset,
        templateName: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(config, Unset):
            self.config = config
        if not isinstance(data, Unset):
            self.data = data
        if not isinstance(files, Unset):
            self.files = files
        if not isinstance(templateName, Unset):
            self.templateName = templateName

    @classmethod
    def from_json(cls, obj: Json) -> "v1LaunchShellRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "config" in obj:
            kwargs["config"] = obj["config"]
        if "data" in obj:
            kwargs["data"] = obj["data"]
        if "files" in obj:
            kwargs["files"] = [v1File.from_json(x) for x in obj["files"]] if obj["files"] is not None else None
        if "templateName" in obj:
            kwargs["templateName"] = obj["templateName"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "config" in vars(self):
            out["config"] = self.config
        if not omit_unset or "data" in vars(self):
            out["data"] = self.data
        if not omit_unset or "files" in vars(self):
            out["files"] = None if self.files is None else [x.to_json(omit_unset) for x in self.files]
        if not omit_unset or "templateName" in vars(self):
            out["templateName"] = self.templateName
        return out

class v1LaunchShellResponse:
    warnings: "typing.Optional[typing.Sequence[v1LaunchWarning]]" = None

    def __init__(
        self,
        *,
        config: "typing.Dict[str, typing.Any]",
        shell: "v1Shell",
        warnings: "typing.Union[typing.Sequence[v1LaunchWarning], None, Unset]" = _unset,
    ):
        self.config = config
        self.shell = shell
        if not isinstance(warnings, Unset):
            self.warnings = warnings

    @classmethod
    def from_json(cls, obj: Json) -> "v1LaunchShellResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "config": obj["config"],
            "shell": v1Shell.from_json(obj["shell"]),
        }
        if "warnings" in obj:
            kwargs["warnings"] = [v1LaunchWarning(x) for x in obj["warnings"]] if obj["warnings"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "config": self.config,
            "shell": self.shell.to_json(omit_unset),
        }
        if not omit_unset or "warnings" in vars(self):
            out["warnings"] = None if self.warnings is None else [x.value for x in self.warnings]
        return out

class v1LaunchTensorboardRequest:
    config: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    experimentIds: "typing.Optional[typing.Sequence[int]]" = None
    files: "typing.Optional[typing.Sequence[v1File]]" = None
    templateName: "typing.Optional[str]" = None
    trialIds: "typing.Optional[typing.Sequence[int]]" = None

    def __init__(
        self,
        *,
        config: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        experimentIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
        files: "typing.Union[typing.Sequence[v1File], None, Unset]" = _unset,
        templateName: "typing.Union[str, None, Unset]" = _unset,
        trialIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
    ):
        if not isinstance(config, Unset):
            self.config = config
        if not isinstance(experimentIds, Unset):
            self.experimentIds = experimentIds
        if not isinstance(files, Unset):
            self.files = files
        if not isinstance(templateName, Unset):
            self.templateName = templateName
        if not isinstance(trialIds, Unset):
            self.trialIds = trialIds

    @classmethod
    def from_json(cls, obj: Json) -> "v1LaunchTensorboardRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "config" in obj:
            kwargs["config"] = obj["config"]
        if "experimentIds" in obj:
            kwargs["experimentIds"] = obj["experimentIds"]
        if "files" in obj:
            kwargs["files"] = [v1File.from_json(x) for x in obj["files"]] if obj["files"] is not None else None
        if "templateName" in obj:
            kwargs["templateName"] = obj["templateName"]
        if "trialIds" in obj:
            kwargs["trialIds"] = obj["trialIds"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "config" in vars(self):
            out["config"] = self.config
        if not omit_unset or "experimentIds" in vars(self):
            out["experimentIds"] = self.experimentIds
        if not omit_unset or "files" in vars(self):
            out["files"] = None if self.files is None else [x.to_json(omit_unset) for x in self.files]
        if not omit_unset or "templateName" in vars(self):
            out["templateName"] = self.templateName
        if not omit_unset or "trialIds" in vars(self):
            out["trialIds"] = self.trialIds
        return out

class v1LaunchTensorboardResponse:
    warnings: "typing.Optional[typing.Sequence[v1LaunchWarning]]" = None

    def __init__(
        self,
        *,
        config: "typing.Dict[str, typing.Any]",
        tensorboard: "v1Tensorboard",
        warnings: "typing.Union[typing.Sequence[v1LaunchWarning], None, Unset]" = _unset,
    ):
        self.config = config
        self.tensorboard = tensorboard
        if not isinstance(warnings, Unset):
            self.warnings = warnings

    @classmethod
    def from_json(cls, obj: Json) -> "v1LaunchTensorboardResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "config": obj["config"],
            "tensorboard": v1Tensorboard.from_json(obj["tensorboard"]),
        }
        if "warnings" in obj:
            kwargs["warnings"] = [v1LaunchWarning(x) for x in obj["warnings"]] if obj["warnings"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "config": self.config,
            "tensorboard": self.tensorboard.to_json(omit_unset),
        }
        if not omit_unset or "warnings" in vars(self):
            out["warnings"] = None if self.warnings is None else [x.value for x in self.warnings]
        return out

class v1LaunchWarning(enum.Enum):
    LAUNCH_WARNING_UNSPECIFIED = "LAUNCH_WARNING_UNSPECIFIED"
    LAUNCH_WARNING_CURRENT_SLOTS_EXCEEDED = "LAUNCH_WARNING_CURRENT_SLOTS_EXCEEDED"

class v1ListRolesRequest:
    offset: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        limit: int,
        offset: "typing.Union[int, None, Unset]" = _unset,
    ):
        self.limit = limit
        if not isinstance(offset, Unset):
            self.offset = offset

    @classmethod
    def from_json(cls, obj: Json) -> "v1ListRolesRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "limit": obj["limit"],
        }
        if "offset" in obj:
            kwargs["offset"] = obj["offset"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "limit": self.limit,
        }
        if not omit_unset or "offset" in vars(self):
            out["offset"] = self.offset
        return out

class v1ListRolesResponse:

    def __init__(
        self,
        *,
        pagination: "v1Pagination",
        roles: "typing.Sequence[v1Role]",
    ):
        self.pagination = pagination
        self.roles = roles

    @classmethod
    def from_json(cls, obj: Json) -> "v1ListRolesResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "pagination": v1Pagination.from_json(obj["pagination"]),
            "roles": [v1Role.from_json(x) for x in obj["roles"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "pagination": self.pagination.to_json(omit_unset),
            "roles": [x.to_json(omit_unset) for x in self.roles],
        }
        return out

class v1LogEntry:
    level: "typing.Optional[v1LogLevel]" = None
    message: "typing.Optional[str]" = None
    timestamp: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        id: int,
        level: "typing.Union[v1LogLevel, None, Unset]" = _unset,
        message: "typing.Union[str, None, Unset]" = _unset,
        timestamp: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.id = id
        if not isinstance(level, Unset):
            self.level = level
        if not isinstance(message, Unset):
            self.message = message
        if not isinstance(timestamp, Unset):
            self.timestamp = timestamp

    @classmethod
    def from_json(cls, obj: Json) -> "v1LogEntry":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "id": obj["id"],
        }
        if "level" in obj:
            kwargs["level"] = v1LogLevel(obj["level"]) if obj["level"] is not None else None
        if "message" in obj:
            kwargs["message"] = obj["message"]
        if "timestamp" in obj:
            kwargs["timestamp"] = obj["timestamp"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "id": self.id,
        }
        if not omit_unset or "level" in vars(self):
            out["level"] = None if self.level is None else self.level.value
        if not omit_unset or "message" in vars(self):
            out["message"] = self.message
        if not omit_unset or "timestamp" in vars(self):
            out["timestamp"] = self.timestamp
        return out

class v1LogLevel(enum.Enum):
    LOG_LEVEL_UNSPECIFIED = "LOG_LEVEL_UNSPECIFIED"
    LOG_LEVEL_TRACE = "LOG_LEVEL_TRACE"
    LOG_LEVEL_DEBUG = "LOG_LEVEL_DEBUG"
    LOG_LEVEL_INFO = "LOG_LEVEL_INFO"
    LOG_LEVEL_WARNING = "LOG_LEVEL_WARNING"
    LOG_LEVEL_ERROR = "LOG_LEVEL_ERROR"
    LOG_LEVEL_CRITICAL = "LOG_LEVEL_CRITICAL"

class v1LoginRequest:
    isHashed: "typing.Optional[bool]" = None

    def __init__(
        self,
        *,
        password: str,
        username: str,
        isHashed: "typing.Union[bool, None, Unset]" = _unset,
    ):
        self.password = password
        self.username = username
        if not isinstance(isHashed, Unset):
            self.isHashed = isHashed

    @classmethod
    def from_json(cls, obj: Json) -> "v1LoginRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "password": obj["password"],
            "username": obj["username"],
        }
        if "isHashed" in obj:
            kwargs["isHashed"] = obj["isHashed"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "password": self.password,
            "username": self.username,
        }
        if not omit_unset or "isHashed" in vars(self):
            out["isHashed"] = self.isHashed
        return out

class v1LoginResponse:

    def __init__(
        self,
        *,
        token: str,
        user: "v1User",
    ):
        self.token = token
        self.user = user

    @classmethod
    def from_json(cls, obj: Json) -> "v1LoginResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "token": obj["token"],
            "user": v1User.from_json(obj["user"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "token": self.token,
            "user": self.user.to_json(omit_unset),
        }
        return out

class v1MarkAllocationResourcesDaemonRequest:
    resourcesId: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        allocationId: str,
        resourcesId: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.allocationId = allocationId
        if not isinstance(resourcesId, Unset):
            self.resourcesId = resourcesId

    @classmethod
    def from_json(cls, obj: Json) -> "v1MarkAllocationResourcesDaemonRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "allocationId": obj["allocationId"],
        }
        if "resourcesId" in obj:
            kwargs["resourcesId"] = obj["resourcesId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "allocationId": self.allocationId,
        }
        if not omit_unset or "resourcesId" in vars(self):
            out["resourcesId"] = self.resourcesId
        return out

class v1MasterLogsResponse:
    logEntry: "typing.Optional[v1LogEntry]" = None

    def __init__(
        self,
        *,
        logEntry: "typing.Union[v1LogEntry, None, Unset]" = _unset,
    ):
        if not isinstance(logEntry, Unset):
            self.logEntry = logEntry

    @classmethod
    def from_json(cls, obj: Json) -> "v1MasterLogsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "logEntry" in obj:
            kwargs["logEntry"] = v1LogEntry.from_json(obj["logEntry"]) if obj["logEntry"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "logEntry" in vars(self):
            out["logEntry"] = None if self.logEntry is None else self.logEntry.to_json(omit_unset)
        return out

class v1MetricBatchesResponse:
    batches: "typing.Optional[typing.Sequence[int]]" = None

    def __init__(
        self,
        *,
        batches: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
    ):
        if not isinstance(batches, Unset):
            self.batches = batches

    @classmethod
    def from_json(cls, obj: Json) -> "v1MetricBatchesResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "batches" in obj:
            kwargs["batches"] = obj["batches"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "batches" in vars(self):
            out["batches"] = self.batches
        return out

class v1MetricNamesResponse:
    searcherMetric: "typing.Optional[str]" = None
    trainingMetrics: "typing.Optional[typing.Sequence[str]]" = None
    validationMetrics: "typing.Optional[typing.Sequence[str]]" = None

    def __init__(
        self,
        *,
        searcherMetric: "typing.Union[str, None, Unset]" = _unset,
        trainingMetrics: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        validationMetrics: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
    ):
        if not isinstance(searcherMetric, Unset):
            self.searcherMetric = searcherMetric
        if not isinstance(trainingMetrics, Unset):
            self.trainingMetrics = trainingMetrics
        if not isinstance(validationMetrics, Unset):
            self.validationMetrics = validationMetrics

    @classmethod
    def from_json(cls, obj: Json) -> "v1MetricNamesResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "searcherMetric" in obj:
            kwargs["searcherMetric"] = obj["searcherMetric"]
        if "trainingMetrics" in obj:
            kwargs["trainingMetrics"] = obj["trainingMetrics"]
        if "validationMetrics" in obj:
            kwargs["validationMetrics"] = obj["validationMetrics"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "searcherMetric" in vars(self):
            out["searcherMetric"] = self.searcherMetric
        if not omit_unset or "trainingMetrics" in vars(self):
            out["trainingMetrics"] = self.trainingMetrics
        if not omit_unset or "validationMetrics" in vars(self):
            out["validationMetrics"] = self.validationMetrics
        return out

class v1MetricType(enum.Enum):
    METRIC_TYPE_UNSPECIFIED = "METRIC_TYPE_UNSPECIFIED"
    METRIC_TYPE_TRAINING = "METRIC_TYPE_TRAINING"
    METRIC_TYPE_VALIDATION = "METRIC_TYPE_VALIDATION"

class v1Metrics:
    batchMetrics: "typing.Optional[typing.Sequence[typing.Dict[str, typing.Any]]]" = None

    def __init__(
        self,
        *,
        avgMetrics: "typing.Dict[str, typing.Any]",
        batchMetrics: "typing.Union[typing.Sequence[typing.Dict[str, typing.Any]], None, Unset]" = _unset,
    ):
        self.avgMetrics = avgMetrics
        if not isinstance(batchMetrics, Unset):
            self.batchMetrics = batchMetrics

    @classmethod
    def from_json(cls, obj: Json) -> "v1Metrics":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "avgMetrics": obj["avgMetrics"],
        }
        if "batchMetrics" in obj:
            kwargs["batchMetrics"] = obj["batchMetrics"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "avgMetrics": self.avgMetrics,
        }
        if not omit_unset or "batchMetrics" in vars(self):
            out["batchMetrics"] = self.batchMetrics
        return out

class v1MetricsWorkload:
    endTime: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        metrics: "v1Metrics",
        numInputs: int,
        state: "determinedexperimentv1State",
        totalBatches: int,
        endTime: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.metrics = metrics
        self.numInputs = numInputs
        self.state = state
        self.totalBatches = totalBatches
        if not isinstance(endTime, Unset):
            self.endTime = endTime

    @classmethod
    def from_json(cls, obj: Json) -> "v1MetricsWorkload":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "metrics": v1Metrics.from_json(obj["metrics"]),
            "numInputs": obj["numInputs"],
            "state": determinedexperimentv1State(obj["state"]),
            "totalBatches": obj["totalBatches"],
        }
        if "endTime" in obj:
            kwargs["endTime"] = obj["endTime"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "metrics": self.metrics.to_json(omit_unset),
            "numInputs": self.numInputs,
            "state": self.state.value,
            "totalBatches": self.totalBatches,
        }
        if not omit_unset or "endTime" in vars(self):
            out["endTime"] = self.endTime
        return out

class v1Model:
    description: "typing.Optional[str]" = None
    labels: "typing.Optional[typing.Sequence[str]]" = None
    notes: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        archived: bool,
        creationTime: str,
        id: int,
        lastUpdatedTime: str,
        metadata: "typing.Dict[str, typing.Any]",
        name: str,
        numVersions: int,
        userId: int,
        username: str,
        description: "typing.Union[str, None, Unset]" = _unset,
        labels: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        notes: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.archived = archived
        self.creationTime = creationTime
        self.id = id
        self.lastUpdatedTime = lastUpdatedTime
        self.metadata = metadata
        self.name = name
        self.numVersions = numVersions
        self.userId = userId
        self.username = username
        if not isinstance(description, Unset):
            self.description = description
        if not isinstance(labels, Unset):
            self.labels = labels
        if not isinstance(notes, Unset):
            self.notes = notes

    @classmethod
    def from_json(cls, obj: Json) -> "v1Model":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "archived": obj["archived"],
            "creationTime": obj["creationTime"],
            "id": obj["id"],
            "lastUpdatedTime": obj["lastUpdatedTime"],
            "metadata": obj["metadata"],
            "name": obj["name"],
            "numVersions": obj["numVersions"],
            "userId": obj["userId"],
            "username": obj["username"],
        }
        if "description" in obj:
            kwargs["description"] = obj["description"]
        if "labels" in obj:
            kwargs["labels"] = obj["labels"]
        if "notes" in obj:
            kwargs["notes"] = obj["notes"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "archived": self.archived,
            "creationTime": self.creationTime,
            "id": self.id,
            "lastUpdatedTime": self.lastUpdatedTime,
            "metadata": self.metadata,
            "name": self.name,
            "numVersions": self.numVersions,
            "userId": self.userId,
            "username": self.username,
        }
        if not omit_unset or "description" in vars(self):
            out["description"] = self.description
        if not omit_unset or "labels" in vars(self):
            out["labels"] = self.labels
        if not omit_unset or "notes" in vars(self):
            out["notes"] = self.notes
        return out

class v1ModelVersion:
    comment: "typing.Optional[str]" = None
    labels: "typing.Optional[typing.Sequence[str]]" = None
    metadata: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    name: "typing.Optional[str]" = None
    notes: "typing.Optional[str]" = None
    userId: "typing.Optional[int]" = None
    username: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        checkpoint: "v1Checkpoint",
        creationTime: str,
        id: int,
        lastUpdatedTime: str,
        model: "v1Model",
        version: int,
        comment: "typing.Union[str, None, Unset]" = _unset,
        labels: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        metadata: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        name: "typing.Union[str, None, Unset]" = _unset,
        notes: "typing.Union[str, None, Unset]" = _unset,
        userId: "typing.Union[int, None, Unset]" = _unset,
        username: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.checkpoint = checkpoint
        self.creationTime = creationTime
        self.id = id
        self.lastUpdatedTime = lastUpdatedTime
        self.model = model
        self.version = version
        if not isinstance(comment, Unset):
            self.comment = comment
        if not isinstance(labels, Unset):
            self.labels = labels
        if not isinstance(metadata, Unset):
            self.metadata = metadata
        if not isinstance(name, Unset):
            self.name = name
        if not isinstance(notes, Unset):
            self.notes = notes
        if not isinstance(userId, Unset):
            self.userId = userId
        if not isinstance(username, Unset):
            self.username = username

    @classmethod
    def from_json(cls, obj: Json) -> "v1ModelVersion":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "checkpoint": v1Checkpoint.from_json(obj["checkpoint"]),
            "creationTime": obj["creationTime"],
            "id": obj["id"],
            "lastUpdatedTime": obj["lastUpdatedTime"],
            "model": v1Model.from_json(obj["model"]),
            "version": obj["version"],
        }
        if "comment" in obj:
            kwargs["comment"] = obj["comment"]
        if "labels" in obj:
            kwargs["labels"] = obj["labels"]
        if "metadata" in obj:
            kwargs["metadata"] = obj["metadata"]
        if "name" in obj:
            kwargs["name"] = obj["name"]
        if "notes" in obj:
            kwargs["notes"] = obj["notes"]
        if "userId" in obj:
            kwargs["userId"] = obj["userId"]
        if "username" in obj:
            kwargs["username"] = obj["username"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "checkpoint": self.checkpoint.to_json(omit_unset),
            "creationTime": self.creationTime,
            "id": self.id,
            "lastUpdatedTime": self.lastUpdatedTime,
            "model": self.model.to_json(omit_unset),
            "version": self.version,
        }
        if not omit_unset or "comment" in vars(self):
            out["comment"] = self.comment
        if not omit_unset or "labels" in vars(self):
            out["labels"] = self.labels
        if not omit_unset or "metadata" in vars(self):
            out["metadata"] = self.metadata
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        if not omit_unset or "notes" in vars(self):
            out["notes"] = self.notes
        if not omit_unset or "userId" in vars(self):
            out["userId"] = self.userId
        if not omit_unset or "username" in vars(self):
            out["username"] = self.username
        return out

class v1MoveExperimentRequest:

    def __init__(
        self,
        *,
        destinationProjectId: int,
        experimentId: int,
    ):
        self.destinationProjectId = destinationProjectId
        self.experimentId = experimentId

    @classmethod
    def from_json(cls, obj: Json) -> "v1MoveExperimentRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "destinationProjectId": obj["destinationProjectId"],
            "experimentId": obj["experimentId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "destinationProjectId": self.destinationProjectId,
            "experimentId": self.experimentId,
        }
        return out

class v1MoveProjectRequest:

    def __init__(
        self,
        *,
        destinationWorkspaceId: int,
        projectId: int,
    ):
        self.destinationWorkspaceId = destinationWorkspaceId
        self.projectId = projectId

    @classmethod
    def from_json(cls, obj: Json) -> "v1MoveProjectRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "destinationWorkspaceId": obj["destinationWorkspaceId"],
            "projectId": obj["projectId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "destinationWorkspaceId": self.destinationWorkspaceId,
            "projectId": self.projectId,
        }
        return out

class v1Note:

    def __init__(
        self,
        *,
        contents: str,
        name: str,
    ):
        self.contents = contents
        self.name = name

    @classmethod
    def from_json(cls, obj: Json) -> "v1Note":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "contents": obj["contents"],
            "name": obj["name"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "contents": self.contents,
            "name": self.name,
        }
        return out

class v1Notebook:
    container: "typing.Optional[v1Container]" = None
    displayName: "typing.Optional[str]" = None
    exitStatus: "typing.Optional[str]" = None
    serviceAddress: "typing.Optional[str]" = None
    userId: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        description: str,
        id: str,
        jobId: str,
        resourcePool: str,
        startTime: str,
        state: "determinedtaskv1State",
        username: str,
        container: "typing.Union[v1Container, None, Unset]" = _unset,
        displayName: "typing.Union[str, None, Unset]" = _unset,
        exitStatus: "typing.Union[str, None, Unset]" = _unset,
        serviceAddress: "typing.Union[str, None, Unset]" = _unset,
        userId: "typing.Union[int, None, Unset]" = _unset,
    ):
        self.description = description
        self.id = id
        self.jobId = jobId
        self.resourcePool = resourcePool
        self.startTime = startTime
        self.state = state
        self.username = username
        if not isinstance(container, Unset):
            self.container = container
        if not isinstance(displayName, Unset):
            self.displayName = displayName
        if not isinstance(exitStatus, Unset):
            self.exitStatus = exitStatus
        if not isinstance(serviceAddress, Unset):
            self.serviceAddress = serviceAddress
        if not isinstance(userId, Unset):
            self.userId = userId

    @classmethod
    def from_json(cls, obj: Json) -> "v1Notebook":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "description": obj["description"],
            "id": obj["id"],
            "jobId": obj["jobId"],
            "resourcePool": obj["resourcePool"],
            "startTime": obj["startTime"],
            "state": determinedtaskv1State(obj["state"]),
            "username": obj["username"],
        }
        if "container" in obj:
            kwargs["container"] = v1Container.from_json(obj["container"]) if obj["container"] is not None else None
        if "displayName" in obj:
            kwargs["displayName"] = obj["displayName"]
        if "exitStatus" in obj:
            kwargs["exitStatus"] = obj["exitStatus"]
        if "serviceAddress" in obj:
            kwargs["serviceAddress"] = obj["serviceAddress"]
        if "userId" in obj:
            kwargs["userId"] = obj["userId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "description": self.description,
            "id": self.id,
            "jobId": self.jobId,
            "resourcePool": self.resourcePool,
            "startTime": self.startTime,
            "state": self.state.value,
            "username": self.username,
        }
        if not omit_unset or "container" in vars(self):
            out["container"] = None if self.container is None else self.container.to_json(omit_unset)
        if not omit_unset or "displayName" in vars(self):
            out["displayName"] = self.displayName
        if not omit_unset or "exitStatus" in vars(self):
            out["exitStatus"] = self.exitStatus
        if not omit_unset or "serviceAddress" in vars(self):
            out["serviceAddress"] = self.serviceAddress
        if not omit_unset or "userId" in vars(self):
            out["userId"] = self.userId
        return out

class v1NotifyContainerRunningRequest:
    nodeName: "typing.Optional[str]" = None
    numPeers: "typing.Optional[int]" = None
    rank: "typing.Optional[int]" = None
    requestUuid: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        allocationId: str,
        data: "typing.Dict[str, typing.Any]",
        nodeName: "typing.Union[str, None, Unset]" = _unset,
        numPeers: "typing.Union[int, None, Unset]" = _unset,
        rank: "typing.Union[int, None, Unset]" = _unset,
        requestUuid: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.allocationId = allocationId
        self.data = data
        if not isinstance(nodeName, Unset):
            self.nodeName = nodeName
        if not isinstance(numPeers, Unset):
            self.numPeers = numPeers
        if not isinstance(rank, Unset):
            self.rank = rank
        if not isinstance(requestUuid, Unset):
            self.requestUuid = requestUuid

    @classmethod
    def from_json(cls, obj: Json) -> "v1NotifyContainerRunningRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "allocationId": obj["allocationId"],
            "data": obj["data"],
        }
        if "nodeName" in obj:
            kwargs["nodeName"] = obj["nodeName"]
        if "numPeers" in obj:
            kwargs["numPeers"] = obj["numPeers"]
        if "rank" in obj:
            kwargs["rank"] = obj["rank"]
        if "requestUuid" in obj:
            kwargs["requestUuid"] = obj["requestUuid"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "allocationId": self.allocationId,
            "data": self.data,
        }
        if not omit_unset or "nodeName" in vars(self):
            out["nodeName"] = self.nodeName
        if not omit_unset or "numPeers" in vars(self):
            out["numPeers"] = self.numPeers
        if not omit_unset or "rank" in vars(self):
            out["rank"] = self.rank
        if not omit_unset or "requestUuid" in vars(self):
            out["requestUuid"] = self.requestUuid
        return out

class v1NotifyContainerRunningResponse:

    def __init__(
        self,
        *,
        data: "typing.Sequence[typing.Dict[str, typing.Any]]",
    ):
        self.data = data

    @classmethod
    def from_json(cls, obj: Json) -> "v1NotifyContainerRunningResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "data": obj["data"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "data": self.data,
        }
        return out

class v1OrderBy(enum.Enum):
    ORDER_BY_UNSPECIFIED = "ORDER_BY_UNSPECIFIED"
    ORDER_BY_ASC = "ORDER_BY_ASC"
    ORDER_BY_DESC = "ORDER_BY_DESC"

class v1Pagination:
    endIndex: "typing.Optional[int]" = None
    limit: "typing.Optional[int]" = None
    offset: "typing.Optional[int]" = None
    startIndex: "typing.Optional[int]" = None
    total: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        endIndex: "typing.Union[int, None, Unset]" = _unset,
        limit: "typing.Union[int, None, Unset]" = _unset,
        offset: "typing.Union[int, None, Unset]" = _unset,
        startIndex: "typing.Union[int, None, Unset]" = _unset,
        total: "typing.Union[int, None, Unset]" = _unset,
    ):
        if not isinstance(endIndex, Unset):
            self.endIndex = endIndex
        if not isinstance(limit, Unset):
            self.limit = limit
        if not isinstance(offset, Unset):
            self.offset = offset
        if not isinstance(startIndex, Unset):
            self.startIndex = startIndex
        if not isinstance(total, Unset):
            self.total = total

    @classmethod
    def from_json(cls, obj: Json) -> "v1Pagination":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "endIndex" in obj:
            kwargs["endIndex"] = obj["endIndex"]
        if "limit" in obj:
            kwargs["limit"] = obj["limit"]
        if "offset" in obj:
            kwargs["offset"] = obj["offset"]
        if "startIndex" in obj:
            kwargs["startIndex"] = obj["startIndex"]
        if "total" in obj:
            kwargs["total"] = obj["total"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "endIndex" in vars(self):
            out["endIndex"] = self.endIndex
        if not omit_unset or "limit" in vars(self):
            out["limit"] = self.limit
        if not omit_unset or "offset" in vars(self):
            out["offset"] = self.offset
        if not omit_unset or "startIndex" in vars(self):
            out["startIndex"] = self.startIndex
        if not omit_unset or "total" in vars(self):
            out["total"] = self.total
        return out

class v1PatchExperiment:
    description: "typing.Optional[str]" = None
    labels: "typing.Optional[typing.Sequence[str]]" = None
    name: "typing.Optional[str]" = None
    notes: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        id: int,
        description: "typing.Union[str, None, Unset]" = _unset,
        labels: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        name: "typing.Union[str, None, Unset]" = _unset,
        notes: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.id = id
        if not isinstance(description, Unset):
            self.description = description
        if not isinstance(labels, Unset):
            self.labels = labels
        if not isinstance(name, Unset):
            self.name = name
        if not isinstance(notes, Unset):
            self.notes = notes

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchExperiment":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "id": obj["id"],
        }
        if "description" in obj:
            kwargs["description"] = obj["description"]
        if "labels" in obj:
            kwargs["labels"] = obj["labels"]
        if "name" in obj:
            kwargs["name"] = obj["name"]
        if "notes" in obj:
            kwargs["notes"] = obj["notes"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "id": self.id,
        }
        if not omit_unset or "description" in vars(self):
            out["description"] = self.description
        if not omit_unset or "labels" in vars(self):
            out["labels"] = self.labels
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        if not omit_unset or "notes" in vars(self):
            out["notes"] = self.notes
        return out

class v1PatchExperimentResponse:
    experiment: "typing.Optional[v1Experiment]" = None

    def __init__(
        self,
        *,
        experiment: "typing.Union[v1Experiment, None, Unset]" = _unset,
    ):
        if not isinstance(experiment, Unset):
            self.experiment = experiment

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchExperimentResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "experiment" in obj:
            kwargs["experiment"] = v1Experiment.from_json(obj["experiment"]) if obj["experiment"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "experiment" in vars(self):
            out["experiment"] = None if self.experiment is None else self.experiment.to_json(omit_unset)
        return out

class v1PatchModel:
    description: "typing.Optional[str]" = None
    labels: "typing.Optional[typing.Sequence[str]]" = None
    metadata: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    name: "typing.Optional[str]" = None
    notes: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        description: "typing.Union[str, None, Unset]" = _unset,
        labels: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        metadata: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        name: "typing.Union[str, None, Unset]" = _unset,
        notes: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(description, Unset):
            self.description = description
        if not isinstance(labels, Unset):
            self.labels = labels
        if not isinstance(metadata, Unset):
            self.metadata = metadata
        if not isinstance(name, Unset):
            self.name = name
        if not isinstance(notes, Unset):
            self.notes = notes

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchModel":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "description" in obj:
            kwargs["description"] = obj["description"]
        if "labels" in obj:
            kwargs["labels"] = obj["labels"]
        if "metadata" in obj:
            kwargs["metadata"] = obj["metadata"]
        if "name" in obj:
            kwargs["name"] = obj["name"]
        if "notes" in obj:
            kwargs["notes"] = obj["notes"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "description" in vars(self):
            out["description"] = self.description
        if not omit_unset or "labels" in vars(self):
            out["labels"] = self.labels
        if not omit_unset or "metadata" in vars(self):
            out["metadata"] = self.metadata
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        if not omit_unset or "notes" in vars(self):
            out["notes"] = self.notes
        return out

class v1PatchModelResponse:

    def __init__(
        self,
        *,
        model: "v1Model",
    ):
        self.model = model

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchModelResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "model": v1Model.from_json(obj["model"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "model": self.model.to_json(omit_unset),
        }
        return out

class v1PatchModelVersion:
    checkpoint: "typing.Optional[v1Checkpoint]" = None
    comment: "typing.Optional[str]" = None
    labels: "typing.Optional[typing.Sequence[str]]" = None
    metadata: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    name: "typing.Optional[str]" = None
    notes: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        checkpoint: "typing.Union[v1Checkpoint, None, Unset]" = _unset,
        comment: "typing.Union[str, None, Unset]" = _unset,
        labels: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        metadata: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        name: "typing.Union[str, None, Unset]" = _unset,
        notes: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(checkpoint, Unset):
            self.checkpoint = checkpoint
        if not isinstance(comment, Unset):
            self.comment = comment
        if not isinstance(labels, Unset):
            self.labels = labels
        if not isinstance(metadata, Unset):
            self.metadata = metadata
        if not isinstance(name, Unset):
            self.name = name
        if not isinstance(notes, Unset):
            self.notes = notes

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchModelVersion":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "checkpoint" in obj:
            kwargs["checkpoint"] = v1Checkpoint.from_json(obj["checkpoint"]) if obj["checkpoint"] is not None else None
        if "comment" in obj:
            kwargs["comment"] = obj["comment"]
        if "labels" in obj:
            kwargs["labels"] = obj["labels"]
        if "metadata" in obj:
            kwargs["metadata"] = obj["metadata"]
        if "name" in obj:
            kwargs["name"] = obj["name"]
        if "notes" in obj:
            kwargs["notes"] = obj["notes"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "checkpoint" in vars(self):
            out["checkpoint"] = None if self.checkpoint is None else self.checkpoint.to_json(omit_unset)
        if not omit_unset or "comment" in vars(self):
            out["comment"] = self.comment
        if not omit_unset or "labels" in vars(self):
            out["labels"] = self.labels
        if not omit_unset or "metadata" in vars(self):
            out["metadata"] = self.metadata
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        if not omit_unset or "notes" in vars(self):
            out["notes"] = self.notes
        return out

class v1PatchModelVersionResponse:

    def __init__(
        self,
        *,
        modelVersion: "v1ModelVersion",
    ):
        self.modelVersion = modelVersion

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchModelVersionResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "modelVersion": v1ModelVersion.from_json(obj["modelVersion"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "modelVersion": self.modelVersion.to_json(omit_unset),
        }
        return out

class v1PatchProject:
    description: "typing.Optional[str]" = None
    name: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        description: "typing.Union[str, None, Unset]" = _unset,
        name: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(description, Unset):
            self.description = description
        if not isinstance(name, Unset):
            self.name = name

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchProject":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "description" in obj:
            kwargs["description"] = obj["description"]
        if "name" in obj:
            kwargs["name"] = obj["name"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "description" in vars(self):
            out["description"] = self.description
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        return out

class v1PatchProjectResponse:

    def __init__(
        self,
        *,
        project: "v1Project",
    ):
        self.project = project

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchProjectResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "project": v1Project.from_json(obj["project"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "project": self.project.to_json(omit_unset),
        }
        return out

class v1PatchTrialsCollectionRequest:
    filters: "typing.Optional[v1TrialFilters]" = None
    name: "typing.Optional[str]" = None
    sorter: "typing.Optional[v1TrialSorter]" = None

    def __init__(
        self,
        *,
        id: int,
        filters: "typing.Union[v1TrialFilters, None, Unset]" = _unset,
        name: "typing.Union[str, None, Unset]" = _unset,
        sorter: "typing.Union[v1TrialSorter, None, Unset]" = _unset,
    ):
        self.id = id
        if not isinstance(filters, Unset):
            self.filters = filters
        if not isinstance(name, Unset):
            self.name = name
        if not isinstance(sorter, Unset):
            self.sorter = sorter

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchTrialsCollectionRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "id": obj["id"],
        }
        if "filters" in obj:
            kwargs["filters"] = v1TrialFilters.from_json(obj["filters"]) if obj["filters"] is not None else None
        if "name" in obj:
            kwargs["name"] = obj["name"]
        if "sorter" in obj:
            kwargs["sorter"] = v1TrialSorter.from_json(obj["sorter"]) if obj["sorter"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "id": self.id,
        }
        if not omit_unset or "filters" in vars(self):
            out["filters"] = None if self.filters is None else self.filters.to_json(omit_unset)
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        if not omit_unset or "sorter" in vars(self):
            out["sorter"] = None if self.sorter is None else self.sorter.to_json(omit_unset)
        return out

class v1PatchTrialsCollectionResponse:
    collection: "typing.Optional[v1TrialsCollection]" = None

    def __init__(
        self,
        *,
        collection: "typing.Union[v1TrialsCollection, None, Unset]" = _unset,
    ):
        if not isinstance(collection, Unset):
            self.collection = collection

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchTrialsCollectionResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "collection" in obj:
            kwargs["collection"] = v1TrialsCollection.from_json(obj["collection"]) if obj["collection"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "collection" in vars(self):
            out["collection"] = None if self.collection is None else self.collection.to_json(omit_unset)
        return out

class v1PatchUser:
    active: "typing.Optional[bool]" = None
    admin: "typing.Optional[bool]" = None
    agentUserGroup: "typing.Optional[v1AgentUserGroup]" = None
    displayName: "typing.Optional[str]" = None
    isHashed: "typing.Optional[bool]" = None
    password: "typing.Optional[str]" = None
    username: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        active: "typing.Union[bool, None, Unset]" = _unset,
        admin: "typing.Union[bool, None, Unset]" = _unset,
        agentUserGroup: "typing.Union[v1AgentUserGroup, None, Unset]" = _unset,
        displayName: "typing.Union[str, None, Unset]" = _unset,
        isHashed: "typing.Union[bool, None, Unset]" = _unset,
        password: "typing.Union[str, None, Unset]" = _unset,
        username: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(active, Unset):
            self.active = active
        if not isinstance(admin, Unset):
            self.admin = admin
        if not isinstance(agentUserGroup, Unset):
            self.agentUserGroup = agentUserGroup
        if not isinstance(displayName, Unset):
            self.displayName = displayName
        if not isinstance(isHashed, Unset):
            self.isHashed = isHashed
        if not isinstance(password, Unset):
            self.password = password
        if not isinstance(username, Unset):
            self.username = username

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchUser":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "active" in obj:
            kwargs["active"] = obj["active"]
        if "admin" in obj:
            kwargs["admin"] = obj["admin"]
        if "agentUserGroup" in obj:
            kwargs["agentUserGroup"] = v1AgentUserGroup.from_json(obj["agentUserGroup"]) if obj["agentUserGroup"] is not None else None
        if "displayName" in obj:
            kwargs["displayName"] = obj["displayName"]
        if "isHashed" in obj:
            kwargs["isHashed"] = obj["isHashed"]
        if "password" in obj:
            kwargs["password"] = obj["password"]
        if "username" in obj:
            kwargs["username"] = obj["username"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "active" in vars(self):
            out["active"] = self.active
        if not omit_unset or "admin" in vars(self):
            out["admin"] = self.admin
        if not omit_unset or "agentUserGroup" in vars(self):
            out["agentUserGroup"] = None if self.agentUserGroup is None else self.agentUserGroup.to_json(omit_unset)
        if not omit_unset or "displayName" in vars(self):
            out["displayName"] = self.displayName
        if not omit_unset or "isHashed" in vars(self):
            out["isHashed"] = self.isHashed
        if not omit_unset or "password" in vars(self):
            out["password"] = self.password
        if not omit_unset or "username" in vars(self):
            out["username"] = self.username
        return out

class v1PatchUserResponse:

    def __init__(
        self,
        *,
        user: "v1User",
    ):
        self.user = user

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchUserResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "user": v1User.from_json(obj["user"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "user": self.user.to_json(omit_unset),
        }
        return out

class v1PatchWorkspace:
    agentUserGroup: "typing.Optional[v1AgentUserGroup]" = None
    checkpointStorageConfig: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    name: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        agentUserGroup: "typing.Union[v1AgentUserGroup, None, Unset]" = _unset,
        checkpointStorageConfig: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        name: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(agentUserGroup, Unset):
            self.agentUserGroup = agentUserGroup
        if not isinstance(checkpointStorageConfig, Unset):
            self.checkpointStorageConfig = checkpointStorageConfig
        if not isinstance(name, Unset):
            self.name = name

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchWorkspace":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "agentUserGroup" in obj:
            kwargs["agentUserGroup"] = v1AgentUserGroup.from_json(obj["agentUserGroup"]) if obj["agentUserGroup"] is not None else None
        if "checkpointStorageConfig" in obj:
            kwargs["checkpointStorageConfig"] = obj["checkpointStorageConfig"]
        if "name" in obj:
            kwargs["name"] = obj["name"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "agentUserGroup" in vars(self):
            out["agentUserGroup"] = None if self.agentUserGroup is None else self.agentUserGroup.to_json(omit_unset)
        if not omit_unset or "checkpointStorageConfig" in vars(self):
            out["checkpointStorageConfig"] = self.checkpointStorageConfig
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        return out

class v1PatchWorkspaceResponse:

    def __init__(
        self,
        *,
        workspace: "v1Workspace",
    ):
        self.workspace = workspace

    @classmethod
    def from_json(cls, obj: Json) -> "v1PatchWorkspaceResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "workspace": v1Workspace.from_json(obj["workspace"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "workspace": self.workspace.to_json(omit_unset),
        }
        return out

class v1Permission:
    name: "typing.Optional[str]" = None
    scopeTypeMask: "typing.Optional[v1ScopeTypeMask]" = None

    def __init__(
        self,
        *,
        id: "v1PermissionType",
        name: "typing.Union[str, None, Unset]" = _unset,
        scopeTypeMask: "typing.Union[v1ScopeTypeMask, None, Unset]" = _unset,
    ):
        self.id = id
        if not isinstance(name, Unset):
            self.name = name
        if not isinstance(scopeTypeMask, Unset):
            self.scopeTypeMask = scopeTypeMask

    @classmethod
    def from_json(cls, obj: Json) -> "v1Permission":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "id": v1PermissionType(obj["id"]),
        }
        if "name" in obj:
            kwargs["name"] = obj["name"]
        if "scopeTypeMask" in obj:
            kwargs["scopeTypeMask"] = v1ScopeTypeMask.from_json(obj["scopeTypeMask"]) if obj["scopeTypeMask"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "id": self.id.value,
        }
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        if not omit_unset or "scopeTypeMask" in vars(self):
            out["scopeTypeMask"] = None if self.scopeTypeMask is None else self.scopeTypeMask.to_json(omit_unset)
        return out

class v1PermissionType(enum.Enum):
    PERMISSION_TYPE_UNSPECIFIED = "PERMISSION_TYPE_UNSPECIFIED"
    PERMISSION_TYPE_ADMINISTRATE_USER = "PERMISSION_TYPE_ADMINISTRATE_USER"
    PERMISSION_TYPE_CREATE_EXPERIMENT = "PERMISSION_TYPE_CREATE_EXPERIMENT"
    PERMISSION_TYPE_VIEW_EXPERIMENT_ARTIFACTS = "PERMISSION_TYPE_VIEW_EXPERIMENT_ARTIFACTS"
    PERMISSION_TYPE_VIEW_EXPERIMENT_METADATA = "PERMISSION_TYPE_VIEW_EXPERIMENT_METADATA"
    PERMISSION_TYPE_UPDATE_EXPERIMENT = "PERMISSION_TYPE_UPDATE_EXPERIMENT"
    PERMISSION_TYPE_UPDATE_EXPERIMENT_METADATA = "PERMISSION_TYPE_UPDATE_EXPERIMENT_METADATA"
    PERMISSION_TYPE_DELETE_EXPERIMENT = "PERMISSION_TYPE_DELETE_EXPERIMENT"
    PERMISSION_TYPE_UPDATE_GROUP = "PERMISSION_TYPE_UPDATE_GROUP"
    PERMISSION_TYPE_CREATE_WORKSPACE = "PERMISSION_TYPE_CREATE_WORKSPACE"
    PERMISSION_TYPE_VIEW_WORKSPACE = "PERMISSION_TYPE_VIEW_WORKSPACE"
    PERMISSION_TYPE_UPDATE_WORKSPACE = "PERMISSION_TYPE_UPDATE_WORKSPACE"
    PERMISSION_TYPE_DELETE_WORKSPACE = "PERMISSION_TYPE_DELETE_WORKSPACE"
    PERMISSION_TYPE_SET_WORKSPACE_AGENT_USER_GROUP = "PERMISSION_TYPE_SET_WORKSPACE_AGENT_USER_GROUP"
    PERMISSION_TYPE_SET_WORKSPACE_CHECKPOINT_STORAGE_CONFIG = "PERMISSION_TYPE_SET_WORKSPACE_CHECKPOINT_STORAGE_CONFIG"
    PERMISSION_TYPE_CREATE_PROJECT = "PERMISSION_TYPE_CREATE_PROJECT"
    PERMISSION_TYPE_VIEW_PROJECT = "PERMISSION_TYPE_VIEW_PROJECT"
    PERMISSION_TYPE_UPDATE_PROJECT = "PERMISSION_TYPE_UPDATE_PROJECT"
    PERMISSION_TYPE_DELETE_PROJECT = "PERMISSION_TYPE_DELETE_PROJECT"
    PERMISSION_TYPE_UPDATE_ROLES = "PERMISSION_TYPE_UPDATE_ROLES"
    PERMISSION_TYPE_ASSIGN_ROLES = "PERMISSION_TYPE_ASSIGN_ROLES"
    PERMISSION_TYPE_EDIT_WEBHOOKS = "PERMISSION_TYPE_EDIT_WEBHOOKS"

class v1PostAllocationProxyAddressRequest:
    allocationId: "typing.Optional[str]" = None
    proxyAddress: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        allocationId: "typing.Union[str, None, Unset]" = _unset,
        proxyAddress: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(allocationId, Unset):
            self.allocationId = allocationId
        if not isinstance(proxyAddress, Unset):
            self.proxyAddress = proxyAddress

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostAllocationProxyAddressRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "allocationId" in obj:
            kwargs["allocationId"] = obj["allocationId"]
        if "proxyAddress" in obj:
            kwargs["proxyAddress"] = obj["proxyAddress"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "allocationId" in vars(self):
            out["allocationId"] = self.allocationId
        if not omit_unset or "proxyAddress" in vars(self):
            out["proxyAddress"] = self.proxyAddress
        return out

class v1PostCheckpointMetadataRequest:
    checkpoint: "typing.Optional[v1Checkpoint]" = None

    def __init__(
        self,
        *,
        checkpoint: "typing.Union[v1Checkpoint, None, Unset]" = _unset,
    ):
        if not isinstance(checkpoint, Unset):
            self.checkpoint = checkpoint

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostCheckpointMetadataRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "checkpoint" in obj:
            kwargs["checkpoint"] = v1Checkpoint.from_json(obj["checkpoint"]) if obj["checkpoint"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "checkpoint" in vars(self):
            out["checkpoint"] = None if self.checkpoint is None else self.checkpoint.to_json(omit_unset)
        return out

class v1PostCheckpointMetadataResponse:
    checkpoint: "typing.Optional[v1Checkpoint]" = None

    def __init__(
        self,
        *,
        checkpoint: "typing.Union[v1Checkpoint, None, Unset]" = _unset,
    ):
        if not isinstance(checkpoint, Unset):
            self.checkpoint = checkpoint

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostCheckpointMetadataResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "checkpoint" in obj:
            kwargs["checkpoint"] = v1Checkpoint.from_json(obj["checkpoint"]) if obj["checkpoint"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "checkpoint" in vars(self):
            out["checkpoint"] = None if self.checkpoint is None else self.checkpoint.to_json(omit_unset)
        return out

class v1PostModelRequest:
    description: "typing.Optional[str]" = None
    labels: "typing.Optional[typing.Sequence[str]]" = None
    metadata: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    notes: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        name: str,
        description: "typing.Union[str, None, Unset]" = _unset,
        labels: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        metadata: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        notes: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.name = name
        if not isinstance(description, Unset):
            self.description = description
        if not isinstance(labels, Unset):
            self.labels = labels
        if not isinstance(metadata, Unset):
            self.metadata = metadata
        if not isinstance(notes, Unset):
            self.notes = notes

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostModelRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "name": obj["name"],
        }
        if "description" in obj:
            kwargs["description"] = obj["description"]
        if "labels" in obj:
            kwargs["labels"] = obj["labels"]
        if "metadata" in obj:
            kwargs["metadata"] = obj["metadata"]
        if "notes" in obj:
            kwargs["notes"] = obj["notes"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "name": self.name,
        }
        if not omit_unset or "description" in vars(self):
            out["description"] = self.description
        if not omit_unset or "labels" in vars(self):
            out["labels"] = self.labels
        if not omit_unset or "metadata" in vars(self):
            out["metadata"] = self.metadata
        if not omit_unset or "notes" in vars(self):
            out["notes"] = self.notes
        return out

class v1PostModelResponse:

    def __init__(
        self,
        *,
        model: "v1Model",
    ):
        self.model = model

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostModelResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "model": v1Model.from_json(obj["model"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "model": self.model.to_json(omit_unset),
        }
        return out

class v1PostModelVersionRequest:
    comment: "typing.Optional[str]" = None
    labels: "typing.Optional[typing.Sequence[str]]" = None
    metadata: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    name: "typing.Optional[str]" = None
    notes: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        checkpointUuid: str,
        modelName: str,
        comment: "typing.Union[str, None, Unset]" = _unset,
        labels: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        metadata: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        name: "typing.Union[str, None, Unset]" = _unset,
        notes: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.checkpointUuid = checkpointUuid
        self.modelName = modelName
        if not isinstance(comment, Unset):
            self.comment = comment
        if not isinstance(labels, Unset):
            self.labels = labels
        if not isinstance(metadata, Unset):
            self.metadata = metadata
        if not isinstance(name, Unset):
            self.name = name
        if not isinstance(notes, Unset):
            self.notes = notes

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostModelVersionRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "checkpointUuid": obj["checkpointUuid"],
            "modelName": obj["modelName"],
        }
        if "comment" in obj:
            kwargs["comment"] = obj["comment"]
        if "labels" in obj:
            kwargs["labels"] = obj["labels"]
        if "metadata" in obj:
            kwargs["metadata"] = obj["metadata"]
        if "name" in obj:
            kwargs["name"] = obj["name"]
        if "notes" in obj:
            kwargs["notes"] = obj["notes"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "checkpointUuid": self.checkpointUuid,
            "modelName": self.modelName,
        }
        if not omit_unset or "comment" in vars(self):
            out["comment"] = self.comment
        if not omit_unset or "labels" in vars(self):
            out["labels"] = self.labels
        if not omit_unset or "metadata" in vars(self):
            out["metadata"] = self.metadata
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        if not omit_unset or "notes" in vars(self):
            out["notes"] = self.notes
        return out

class v1PostModelVersionResponse:

    def __init__(
        self,
        *,
        modelVersion: "v1ModelVersion",
    ):
        self.modelVersion = modelVersion

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostModelVersionResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "modelVersion": v1ModelVersion.from_json(obj["modelVersion"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "modelVersion": self.modelVersion.to_json(omit_unset),
        }
        return out

class v1PostProjectRequest:
    description: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        name: str,
        workspaceId: int,
        description: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.name = name
        self.workspaceId = workspaceId
        if not isinstance(description, Unset):
            self.description = description

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostProjectRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "name": obj["name"],
            "workspaceId": obj["workspaceId"],
        }
        if "description" in obj:
            kwargs["description"] = obj["description"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "name": self.name,
            "workspaceId": self.workspaceId,
        }
        if not omit_unset or "description" in vars(self):
            out["description"] = self.description
        return out

class v1PostProjectResponse:

    def __init__(
        self,
        *,
        project: "v1Project",
    ):
        self.project = project

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostProjectResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "project": v1Project.from_json(obj["project"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "project": self.project.to_json(omit_unset),
        }
        return out

class v1PostSearcherOperationsRequest:
    experimentId: "typing.Optional[int]" = None
    searcherOperations: "typing.Optional[typing.Sequence[v1SearcherOperation]]" = None
    triggeredByEvent: "typing.Optional[v1SearcherEvent]" = None

    def __init__(
        self,
        *,
        experimentId: "typing.Union[int, None, Unset]" = _unset,
        searcherOperations: "typing.Union[typing.Sequence[v1SearcherOperation], None, Unset]" = _unset,
        triggeredByEvent: "typing.Union[v1SearcherEvent, None, Unset]" = _unset,
    ):
        if not isinstance(experimentId, Unset):
            self.experimentId = experimentId
        if not isinstance(searcherOperations, Unset):
            self.searcherOperations = searcherOperations
        if not isinstance(triggeredByEvent, Unset):
            self.triggeredByEvent = triggeredByEvent

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostSearcherOperationsRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "experimentId" in obj:
            kwargs["experimentId"] = obj["experimentId"]
        if "searcherOperations" in obj:
            kwargs["searcherOperations"] = [v1SearcherOperation.from_json(x) for x in obj["searcherOperations"]] if obj["searcherOperations"] is not None else None
        if "triggeredByEvent" in obj:
            kwargs["triggeredByEvent"] = v1SearcherEvent.from_json(obj["triggeredByEvent"]) if obj["triggeredByEvent"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "experimentId" in vars(self):
            out["experimentId"] = self.experimentId
        if not omit_unset or "searcherOperations" in vars(self):
            out["searcherOperations"] = None if self.searcherOperations is None else [x.to_json(omit_unset) for x in self.searcherOperations]
        if not omit_unset or "triggeredByEvent" in vars(self):
            out["triggeredByEvent"] = None if self.triggeredByEvent is None else self.triggeredByEvent.to_json(omit_unset)
        return out

class v1PostTrialProfilerMetricsBatchRequest:
    batches: "typing.Optional[typing.Sequence[v1TrialProfilerMetricsBatch]]" = None

    def __init__(
        self,
        *,
        batches: "typing.Union[typing.Sequence[v1TrialProfilerMetricsBatch], None, Unset]" = _unset,
    ):
        if not isinstance(batches, Unset):
            self.batches = batches

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostTrialProfilerMetricsBatchRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "batches" in obj:
            kwargs["batches"] = [v1TrialProfilerMetricsBatch.from_json(x) for x in obj["batches"]] if obj["batches"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "batches" in vars(self):
            out["batches"] = None if self.batches is None else [x.to_json(omit_unset) for x in self.batches]
        return out

class v1PostUserActivityRequest:

    def __init__(
        self,
        *,
        activityType: "v1ActivityType",
        entityId: int,
        entityType: "v1EntityType",
    ):
        self.activityType = activityType
        self.entityId = entityId
        self.entityType = entityType

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostUserActivityRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "activityType": v1ActivityType(obj["activityType"]),
            "entityId": obj["entityId"],
            "entityType": v1EntityType(obj["entityType"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "activityType": self.activityType.value,
            "entityId": self.entityId,
            "entityType": self.entityType.value,
        }
        return out

class v1PostUserRequest:
    isHashed: "typing.Optional[bool]" = None
    password: "typing.Optional[str]" = None
    user: "typing.Optional[v1User]" = None

    def __init__(
        self,
        *,
        isHashed: "typing.Union[bool, None, Unset]" = _unset,
        password: "typing.Union[str, None, Unset]" = _unset,
        user: "typing.Union[v1User, None, Unset]" = _unset,
    ):
        if not isinstance(isHashed, Unset):
            self.isHashed = isHashed
        if not isinstance(password, Unset):
            self.password = password
        if not isinstance(user, Unset):
            self.user = user

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostUserRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "isHashed" in obj:
            kwargs["isHashed"] = obj["isHashed"]
        if "password" in obj:
            kwargs["password"] = obj["password"]
        if "user" in obj:
            kwargs["user"] = v1User.from_json(obj["user"]) if obj["user"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "isHashed" in vars(self):
            out["isHashed"] = self.isHashed
        if not omit_unset or "password" in vars(self):
            out["password"] = self.password
        if not omit_unset or "user" in vars(self):
            out["user"] = None if self.user is None else self.user.to_json(omit_unset)
        return out

class v1PostUserResponse:
    user: "typing.Optional[v1User]" = None

    def __init__(
        self,
        *,
        user: "typing.Union[v1User, None, Unset]" = _unset,
    ):
        if not isinstance(user, Unset):
            self.user = user

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostUserResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "user" in obj:
            kwargs["user"] = v1User.from_json(obj["user"]) if obj["user"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "user" in vars(self):
            out["user"] = None if self.user is None else self.user.to_json(omit_unset)
        return out

class v1PostUserSettingRequest:

    def __init__(
        self,
        *,
        setting: "v1UserWebSetting",
        storagePath: str,
    ):
        self.setting = setting
        self.storagePath = storagePath

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostUserSettingRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "setting": v1UserWebSetting.from_json(obj["setting"]),
            "storagePath": obj["storagePath"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "setting": self.setting.to_json(omit_unset),
            "storagePath": self.storagePath,
        }
        return out

class v1PostWebhookResponse:

    def __init__(
        self,
        *,
        webhook: "v1Webhook",
    ):
        self.webhook = webhook

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostWebhookResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "webhook": v1Webhook.from_json(obj["webhook"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "webhook": self.webhook.to_json(omit_unset),
        }
        return out

class v1PostWorkspaceRequest:
    agentUserGroup: "typing.Optional[v1AgentUserGroup]" = None
    checkpointStorageConfig: "typing.Optional[typing.Dict[str, typing.Any]]" = None

    def __init__(
        self,
        *,
        name: str,
        agentUserGroup: "typing.Union[v1AgentUserGroup, None, Unset]" = _unset,
        checkpointStorageConfig: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
    ):
        self.name = name
        if not isinstance(agentUserGroup, Unset):
            self.agentUserGroup = agentUserGroup
        if not isinstance(checkpointStorageConfig, Unset):
            self.checkpointStorageConfig = checkpointStorageConfig

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostWorkspaceRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "name": obj["name"],
        }
        if "agentUserGroup" in obj:
            kwargs["agentUserGroup"] = v1AgentUserGroup.from_json(obj["agentUserGroup"]) if obj["agentUserGroup"] is not None else None
        if "checkpointStorageConfig" in obj:
            kwargs["checkpointStorageConfig"] = obj["checkpointStorageConfig"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "name": self.name,
        }
        if not omit_unset or "agentUserGroup" in vars(self):
            out["agentUserGroup"] = None if self.agentUserGroup is None else self.agentUserGroup.to_json(omit_unset)
        if not omit_unset or "checkpointStorageConfig" in vars(self):
            out["checkpointStorageConfig"] = self.checkpointStorageConfig
        return out

class v1PostWorkspaceResponse:

    def __init__(
        self,
        *,
        workspace: "v1Workspace",
    ):
        self.workspace = workspace

    @classmethod
    def from_json(cls, obj: Json) -> "v1PostWorkspaceResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "workspace": v1Workspace.from_json(obj["workspace"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "workspace": self.workspace.to_json(omit_unset),
        }
        return out

class v1PreviewHPSearchRequest:
    config: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    seed: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        config: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        seed: "typing.Union[int, None, Unset]" = _unset,
    ):
        if not isinstance(config, Unset):
            self.config = config
        if not isinstance(seed, Unset):
            self.seed = seed

    @classmethod
    def from_json(cls, obj: Json) -> "v1PreviewHPSearchRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "config" in obj:
            kwargs["config"] = obj["config"]
        if "seed" in obj:
            kwargs["seed"] = obj["seed"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "config" in vars(self):
            out["config"] = self.config
        if not omit_unset or "seed" in vars(self):
            out["seed"] = self.seed
        return out

class v1PreviewHPSearchResponse:
    simulation: "typing.Optional[v1ExperimentSimulation]" = None

    def __init__(
        self,
        *,
        simulation: "typing.Union[v1ExperimentSimulation, None, Unset]" = _unset,
    ):
        if not isinstance(simulation, Unset):
            self.simulation = simulation

    @classmethod
    def from_json(cls, obj: Json) -> "v1PreviewHPSearchResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "simulation" in obj:
            kwargs["simulation"] = v1ExperimentSimulation.from_json(obj["simulation"]) if obj["simulation"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "simulation" in vars(self):
            out["simulation"] = None if self.simulation is None else self.simulation.to_json(omit_unset)
        return out

class v1Project:
    description: "typing.Optional[str]" = None
    lastExperimentStartedAt: "typing.Optional[str]" = None
    workspaceName: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        archived: bool,
        errorMessage: str,
        id: int,
        immutable: bool,
        name: str,
        notes: "typing.Sequence[v1Note]",
        numActiveExperiments: int,
        numExperiments: int,
        state: "v1WorkspaceState",
        userId: int,
        username: str,
        workspaceId: int,
        description: "typing.Union[str, None, Unset]" = _unset,
        lastExperimentStartedAt: "typing.Union[str, None, Unset]" = _unset,
        workspaceName: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.archived = archived
        self.errorMessage = errorMessage
        self.id = id
        self.immutable = immutable
        self.name = name
        self.notes = notes
        self.numActiveExperiments = numActiveExperiments
        self.numExperiments = numExperiments
        self.state = state
        self.userId = userId
        self.username = username
        self.workspaceId = workspaceId
        if not isinstance(description, Unset):
            self.description = description
        if not isinstance(lastExperimentStartedAt, Unset):
            self.lastExperimentStartedAt = lastExperimentStartedAt
        if not isinstance(workspaceName, Unset):
            self.workspaceName = workspaceName

    @classmethod
    def from_json(cls, obj: Json) -> "v1Project":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "archived": obj["archived"],
            "errorMessage": obj["errorMessage"],
            "id": obj["id"],
            "immutable": obj["immutable"],
            "name": obj["name"],
            "notes": [v1Note.from_json(x) for x in obj["notes"]],
            "numActiveExperiments": obj["numActiveExperiments"],
            "numExperiments": obj["numExperiments"],
            "state": v1WorkspaceState(obj["state"]),
            "userId": obj["userId"],
            "username": obj["username"],
            "workspaceId": obj["workspaceId"],
        }
        if "description" in obj:
            kwargs["description"] = obj["description"]
        if "lastExperimentStartedAt" in obj:
            kwargs["lastExperimentStartedAt"] = obj["lastExperimentStartedAt"]
        if "workspaceName" in obj:
            kwargs["workspaceName"] = obj["workspaceName"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "archived": self.archived,
            "errorMessage": self.errorMessage,
            "id": self.id,
            "immutable": self.immutable,
            "name": self.name,
            "notes": [x.to_json(omit_unset) for x in self.notes],
            "numActiveExperiments": self.numActiveExperiments,
            "numExperiments": self.numExperiments,
            "state": self.state.value,
            "userId": self.userId,
            "username": self.username,
            "workspaceId": self.workspaceId,
        }
        if not omit_unset or "description" in vars(self):
            out["description"] = self.description
        if not omit_unset or "lastExperimentStartedAt" in vars(self):
            out["lastExperimentStartedAt"] = self.lastExperimentStartedAt
        if not omit_unset or "workspaceName" in vars(self):
            out["workspaceName"] = self.workspaceName
        return out

class v1PutProjectNotesRequest:

    def __init__(
        self,
        *,
        notes: "typing.Sequence[v1Note]",
        projectId: int,
    ):
        self.notes = notes
        self.projectId = projectId

    @classmethod
    def from_json(cls, obj: Json) -> "v1PutProjectNotesRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "notes": [v1Note.from_json(x) for x in obj["notes"]],
            "projectId": obj["projectId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "notes": [x.to_json(omit_unset) for x in self.notes],
            "projectId": self.projectId,
        }
        return out

class v1PutProjectNotesResponse:

    def __init__(
        self,
        *,
        notes: "typing.Sequence[v1Note]",
    ):
        self.notes = notes

    @classmethod
    def from_json(cls, obj: Json) -> "v1PutProjectNotesResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "notes": [v1Note.from_json(x) for x in obj["notes"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "notes": [x.to_json(omit_unset) for x in self.notes],
        }
        return out

class v1PutTemplateResponse:
    template: "typing.Optional[v1Template]" = None

    def __init__(
        self,
        *,
        template: "typing.Union[v1Template, None, Unset]" = _unset,
    ):
        if not isinstance(template, Unset):
            self.template = template

    @classmethod
    def from_json(cls, obj: Json) -> "v1PutTemplateResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "template" in obj:
            kwargs["template"] = v1Template.from_json(obj["template"]) if obj["template"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "template" in vars(self):
            out["template"] = None if self.template is None else self.template.to_json(omit_unset)
        return out

class v1QueryTrialsRequest:
    limit: "typing.Optional[int]" = None
    offset: "typing.Optional[int]" = None
    sorter: "typing.Optional[v1TrialSorter]" = None

    def __init__(
        self,
        *,
        filters: "v1TrialFilters",
        limit: "typing.Union[int, None, Unset]" = _unset,
        offset: "typing.Union[int, None, Unset]" = _unset,
        sorter: "typing.Union[v1TrialSorter, None, Unset]" = _unset,
    ):
        self.filters = filters
        if not isinstance(limit, Unset):
            self.limit = limit
        if not isinstance(offset, Unset):
            self.offset = offset
        if not isinstance(sorter, Unset):
            self.sorter = sorter

    @classmethod
    def from_json(cls, obj: Json) -> "v1QueryTrialsRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "filters": v1TrialFilters.from_json(obj["filters"]),
        }
        if "limit" in obj:
            kwargs["limit"] = obj["limit"]
        if "offset" in obj:
            kwargs["offset"] = obj["offset"]
        if "sorter" in obj:
            kwargs["sorter"] = v1TrialSorter.from_json(obj["sorter"]) if obj["sorter"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "filters": self.filters.to_json(omit_unset),
        }
        if not omit_unset or "limit" in vars(self):
            out["limit"] = self.limit
        if not omit_unset or "offset" in vars(self):
            out["offset"] = self.offset
        if not omit_unset or "sorter" in vars(self):
            out["sorter"] = None if self.sorter is None else self.sorter.to_json(omit_unset)
        return out

class v1QueryTrialsResponse:

    def __init__(
        self,
        *,
        trials: "typing.Sequence[v1AugmentedTrial]",
    ):
        self.trials = trials

    @classmethod
    def from_json(cls, obj: Json) -> "v1QueryTrialsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "trials": [v1AugmentedTrial.from_json(x) for x in obj["trials"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "trials": [x.to_json(omit_unset) for x in self.trials],
        }
        return out

class v1QueueControl:
    aheadOf: "typing.Optional[str]" = None
    behindOf: "typing.Optional[str]" = None
    priority: "typing.Optional[int]" = None
    resourcePool: "typing.Optional[str]" = None
    weight: "typing.Optional[float]" = None

    def __init__(
        self,
        *,
        jobId: str,
        aheadOf: "typing.Union[str, None, Unset]" = _unset,
        behindOf: "typing.Union[str, None, Unset]" = _unset,
        priority: "typing.Union[int, None, Unset]" = _unset,
        resourcePool: "typing.Union[str, None, Unset]" = _unset,
        weight: "typing.Union[float, None, Unset]" = _unset,
    ):
        self.jobId = jobId
        if not isinstance(aheadOf, Unset):
            self.aheadOf = aheadOf
        if not isinstance(behindOf, Unset):
            self.behindOf = behindOf
        if not isinstance(priority, Unset):
            self.priority = priority
        if not isinstance(resourcePool, Unset):
            self.resourcePool = resourcePool
        if not isinstance(weight, Unset):
            self.weight = weight

    @classmethod
    def from_json(cls, obj: Json) -> "v1QueueControl":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "jobId": obj["jobId"],
        }
        if "aheadOf" in obj:
            kwargs["aheadOf"] = obj["aheadOf"]
        if "behindOf" in obj:
            kwargs["behindOf"] = obj["behindOf"]
        if "priority" in obj:
            kwargs["priority"] = obj["priority"]
        if "resourcePool" in obj:
            kwargs["resourcePool"] = obj["resourcePool"]
        if "weight" in obj:
            kwargs["weight"] = float(obj["weight"]) if obj["weight"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "jobId": self.jobId,
        }
        if not omit_unset or "aheadOf" in vars(self):
            out["aheadOf"] = self.aheadOf
        if not omit_unset or "behindOf" in vars(self):
            out["behindOf"] = self.behindOf
        if not omit_unset or "priority" in vars(self):
            out["priority"] = self.priority
        if not omit_unset or "resourcePool" in vars(self):
            out["resourcePool"] = self.resourcePool
        if not omit_unset or "weight" in vars(self):
            out["weight"] = None if self.weight is None else dump_float(self.weight)
        return out

class v1QueueStats:

    def __init__(
        self,
        *,
        queuedCount: int,
        scheduledCount: int,
    ):
        self.queuedCount = queuedCount
        self.scheduledCount = scheduledCount

    @classmethod
    def from_json(cls, obj: Json) -> "v1QueueStats":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "queuedCount": obj["queuedCount"],
            "scheduledCount": obj["scheduledCount"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "queuedCount": self.queuedCount,
            "scheduledCount": self.scheduledCount,
        }
        return out

class v1RPQueueStat:
    aggregates: "typing.Optional[typing.Sequence[v1AggregateQueueStats]]" = None

    def __init__(
        self,
        *,
        resourcePool: str,
        stats: "v1QueueStats",
        aggregates: "typing.Union[typing.Sequence[v1AggregateQueueStats], None, Unset]" = _unset,
    ):
        self.resourcePool = resourcePool
        self.stats = stats
        if not isinstance(aggregates, Unset):
            self.aggregates = aggregates

    @classmethod
    def from_json(cls, obj: Json) -> "v1RPQueueStat":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "resourcePool": obj["resourcePool"],
            "stats": v1QueueStats.from_json(obj["stats"]),
        }
        if "aggregates" in obj:
            kwargs["aggregates"] = [v1AggregateQueueStats.from_json(x) for x in obj["aggregates"]] if obj["aggregates"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "resourcePool": self.resourcePool,
            "stats": self.stats.to_json(omit_unset),
        }
        if not omit_unset or "aggregates" in vars(self):
            out["aggregates"] = None if self.aggregates is None else [x.to_json(omit_unset) for x in self.aggregates]
        return out

class v1RemoveAssignmentsRequest:
    groupRoleAssignments: "typing.Optional[typing.Sequence[v1GroupRoleAssignment]]" = None
    userRoleAssignments: "typing.Optional[typing.Sequence[v1UserRoleAssignment]]" = None

    def __init__(
        self,
        *,
        groupRoleAssignments: "typing.Union[typing.Sequence[v1GroupRoleAssignment], None, Unset]" = _unset,
        userRoleAssignments: "typing.Union[typing.Sequence[v1UserRoleAssignment], None, Unset]" = _unset,
    ):
        if not isinstance(groupRoleAssignments, Unset):
            self.groupRoleAssignments = groupRoleAssignments
        if not isinstance(userRoleAssignments, Unset):
            self.userRoleAssignments = userRoleAssignments

    @classmethod
    def from_json(cls, obj: Json) -> "v1RemoveAssignmentsRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "groupRoleAssignments" in obj:
            kwargs["groupRoleAssignments"] = [v1GroupRoleAssignment.from_json(x) for x in obj["groupRoleAssignments"]] if obj["groupRoleAssignments"] is not None else None
        if "userRoleAssignments" in obj:
            kwargs["userRoleAssignments"] = [v1UserRoleAssignment.from_json(x) for x in obj["userRoleAssignments"]] if obj["userRoleAssignments"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "groupRoleAssignments" in vars(self):
            out["groupRoleAssignments"] = None if self.groupRoleAssignments is None else [x.to_json(omit_unset) for x in self.groupRoleAssignments]
        if not omit_unset or "userRoleAssignments" in vars(self):
            out["userRoleAssignments"] = None if self.userRoleAssignments is None else [x.to_json(omit_unset) for x in self.userRoleAssignments]
        return out

class v1RendezvousInfo:

    def __init__(
        self,
        *,
        addresses: "typing.Sequence[str]",
        rank: int,
    ):
        self.addresses = addresses
        self.rank = rank

    @classmethod
    def from_json(cls, obj: Json) -> "v1RendezvousInfo":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "addresses": obj["addresses"],
            "rank": obj["rank"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "addresses": self.addresses,
            "rank": self.rank,
        }
        return out

class v1ResourceAllocationAggregatedEntry:

    def __init__(
        self,
        *,
        byAgentLabel: "typing.Dict[str, float]",
        byExperimentLabel: "typing.Dict[str, float]",
        byResourcePool: "typing.Dict[str, float]",
        byUsername: "typing.Dict[str, float]",
        period: "v1ResourceAllocationAggregationPeriod",
        periodStart: str,
        seconds: float,
    ):
        self.byAgentLabel = byAgentLabel
        self.byExperimentLabel = byExperimentLabel
        self.byResourcePool = byResourcePool
        self.byUsername = byUsername
        self.period = period
        self.periodStart = periodStart
        self.seconds = seconds

    @classmethod
    def from_json(cls, obj: Json) -> "v1ResourceAllocationAggregatedEntry":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "byAgentLabel": {k: float(v) for k, v in obj["byAgentLabel"].items()},
            "byExperimentLabel": {k: float(v) for k, v in obj["byExperimentLabel"].items()},
            "byResourcePool": {k: float(v) for k, v in obj["byResourcePool"].items()},
            "byUsername": {k: float(v) for k, v in obj["byUsername"].items()},
            "period": v1ResourceAllocationAggregationPeriod(obj["period"]),
            "periodStart": obj["periodStart"],
            "seconds": float(obj["seconds"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "byAgentLabel": {k: dump_float(v) for k, v in self.byAgentLabel.items()},
            "byExperimentLabel": {k: dump_float(v) for k, v in self.byExperimentLabel.items()},
            "byResourcePool": {k: dump_float(v) for k, v in self.byResourcePool.items()},
            "byUsername": {k: dump_float(v) for k, v in self.byUsername.items()},
            "period": self.period.value,
            "periodStart": self.periodStart,
            "seconds": dump_float(self.seconds),
        }
        return out

class v1ResourceAllocationAggregatedResponse:

    def __init__(
        self,
        *,
        resourceEntries: "typing.Sequence[v1ResourceAllocationAggregatedEntry]",
    ):
        self.resourceEntries = resourceEntries

    @classmethod
    def from_json(cls, obj: Json) -> "v1ResourceAllocationAggregatedResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "resourceEntries": [v1ResourceAllocationAggregatedEntry.from_json(x) for x in obj["resourceEntries"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "resourceEntries": [x.to_json(omit_unset) for x in self.resourceEntries],
        }
        return out

class v1ResourceAllocationAggregationPeriod(enum.Enum):
    RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED = "RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED"
    RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY = "RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY"
    RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY = "RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY"

class v1ResourceAllocationRawEntry:
    endTime: "typing.Optional[str]" = None
    experimentId: "typing.Optional[int]" = None
    kind: "typing.Optional[str]" = None
    labels: "typing.Optional[typing.Sequence[str]]" = None
    seconds: "typing.Optional[float]" = None
    slots: "typing.Optional[int]" = None
    startTime: "typing.Optional[str]" = None
    userId: "typing.Optional[int]" = None
    username: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        endTime: "typing.Union[str, None, Unset]" = _unset,
        experimentId: "typing.Union[int, None, Unset]" = _unset,
        kind: "typing.Union[str, None, Unset]" = _unset,
        labels: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        seconds: "typing.Union[float, None, Unset]" = _unset,
        slots: "typing.Union[int, None, Unset]" = _unset,
        startTime: "typing.Union[str, None, Unset]" = _unset,
        userId: "typing.Union[int, None, Unset]" = _unset,
        username: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(endTime, Unset):
            self.endTime = endTime
        if not isinstance(experimentId, Unset):
            self.experimentId = experimentId
        if not isinstance(kind, Unset):
            self.kind = kind
        if not isinstance(labels, Unset):
            self.labels = labels
        if not isinstance(seconds, Unset):
            self.seconds = seconds
        if not isinstance(slots, Unset):
            self.slots = slots
        if not isinstance(startTime, Unset):
            self.startTime = startTime
        if not isinstance(userId, Unset):
            self.userId = userId
        if not isinstance(username, Unset):
            self.username = username

    @classmethod
    def from_json(cls, obj: Json) -> "v1ResourceAllocationRawEntry":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "endTime" in obj:
            kwargs["endTime"] = obj["endTime"]
        if "experimentId" in obj:
            kwargs["experimentId"] = obj["experimentId"]
        if "kind" in obj:
            kwargs["kind"] = obj["kind"]
        if "labels" in obj:
            kwargs["labels"] = obj["labels"]
        if "seconds" in obj:
            kwargs["seconds"] = float(obj["seconds"]) if obj["seconds"] is not None else None
        if "slots" in obj:
            kwargs["slots"] = obj["slots"]
        if "startTime" in obj:
            kwargs["startTime"] = obj["startTime"]
        if "userId" in obj:
            kwargs["userId"] = obj["userId"]
        if "username" in obj:
            kwargs["username"] = obj["username"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "endTime" in vars(self):
            out["endTime"] = self.endTime
        if not omit_unset or "experimentId" in vars(self):
            out["experimentId"] = self.experimentId
        if not omit_unset or "kind" in vars(self):
            out["kind"] = self.kind
        if not omit_unset or "labels" in vars(self):
            out["labels"] = self.labels
        if not omit_unset or "seconds" in vars(self):
            out["seconds"] = None if self.seconds is None else dump_float(self.seconds)
        if not omit_unset or "slots" in vars(self):
            out["slots"] = self.slots
        if not omit_unset or "startTime" in vars(self):
            out["startTime"] = self.startTime
        if not omit_unset or "userId" in vars(self):
            out["userId"] = self.userId
        if not omit_unset or "username" in vars(self):
            out["username"] = self.username
        return out

class v1ResourceAllocationRawResponse:
    resourceEntries: "typing.Optional[typing.Sequence[v1ResourceAllocationRawEntry]]" = None

    def __init__(
        self,
        *,
        resourceEntries: "typing.Union[typing.Sequence[v1ResourceAllocationRawEntry], None, Unset]" = _unset,
    ):
        if not isinstance(resourceEntries, Unset):
            self.resourceEntries = resourceEntries

    @classmethod
    def from_json(cls, obj: Json) -> "v1ResourceAllocationRawResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "resourceEntries" in obj:
            kwargs["resourceEntries"] = [v1ResourceAllocationRawEntry.from_json(x) for x in obj["resourceEntries"]] if obj["resourceEntries"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "resourceEntries" in vars(self):
            out["resourceEntries"] = None if self.resourceEntries is None else [x.to_json(omit_unset) for x in self.resourceEntries]
        return out

class v1ResourcePool:
    accelerator: "typing.Optional[str]" = None
    slotsPerAgent: "typing.Optional[int]" = None
    stats: "typing.Optional[v1QueueStats]" = None

    def __init__(
        self,
        *,
        agentDockerImage: str,
        agentDockerNetwork: str,
        agentDockerRuntime: str,
        agentFluentImage: str,
        auxContainerCapacity: int,
        auxContainerCapacityPerAgent: int,
        auxContainersRunning: int,
        containerStartupScript: str,
        defaultAuxPool: bool,
        defaultComputePool: bool,
        description: str,
        details: "v1ResourcePoolDetail",
        imageId: str,
        instanceType: str,
        location: str,
        masterCertName: str,
        masterUrl: str,
        maxAgentStartingPeriod: float,
        maxAgents: int,
        maxIdleAgentPeriod: float,
        minAgents: int,
        name: str,
        numAgents: int,
        preemptible: bool,
        schedulerFittingPolicy: "v1FittingPolicy",
        schedulerType: "v1SchedulerType",
        slotType: "determineddevicev1Type",
        slotsAvailable: int,
        slotsUsed: int,
        startupScript: str,
        type: "v1ResourcePoolType",
        accelerator: "typing.Union[str, None, Unset]" = _unset,
        slotsPerAgent: "typing.Union[int, None, Unset]" = _unset,
        stats: "typing.Union[v1QueueStats, None, Unset]" = _unset,
    ):
        self.agentDockerImage = agentDockerImage
        self.agentDockerNetwork = agentDockerNetwork
        self.agentDockerRuntime = agentDockerRuntime
        self.agentFluentImage = agentFluentImage
        self.auxContainerCapacity = auxContainerCapacity
        self.auxContainerCapacityPerAgent = auxContainerCapacityPerAgent
        self.auxContainersRunning = auxContainersRunning
        self.containerStartupScript = containerStartupScript
        self.defaultAuxPool = defaultAuxPool
        self.defaultComputePool = defaultComputePool
        self.description = description
        self.details = details
        self.imageId = imageId
        self.instanceType = instanceType
        self.location = location
        self.masterCertName = masterCertName
        self.masterUrl = masterUrl
        self.maxAgentStartingPeriod = maxAgentStartingPeriod
        self.maxAgents = maxAgents
        self.maxIdleAgentPeriod = maxIdleAgentPeriod
        self.minAgents = minAgents
        self.name = name
        self.numAgents = numAgents
        self.preemptible = preemptible
        self.schedulerFittingPolicy = schedulerFittingPolicy
        self.schedulerType = schedulerType
        self.slotType = slotType
        self.slotsAvailable = slotsAvailable
        self.slotsUsed = slotsUsed
        self.startupScript = startupScript
        self.type = type
        if not isinstance(accelerator, Unset):
            self.accelerator = accelerator
        if not isinstance(slotsPerAgent, Unset):
            self.slotsPerAgent = slotsPerAgent
        if not isinstance(stats, Unset):
            self.stats = stats

    @classmethod
    def from_json(cls, obj: Json) -> "v1ResourcePool":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "agentDockerImage": obj["agentDockerImage"],
            "agentDockerNetwork": obj["agentDockerNetwork"],
            "agentDockerRuntime": obj["agentDockerRuntime"],
            "agentFluentImage": obj["agentFluentImage"],
            "auxContainerCapacity": obj["auxContainerCapacity"],
            "auxContainerCapacityPerAgent": obj["auxContainerCapacityPerAgent"],
            "auxContainersRunning": obj["auxContainersRunning"],
            "containerStartupScript": obj["containerStartupScript"],
            "defaultAuxPool": obj["defaultAuxPool"],
            "defaultComputePool": obj["defaultComputePool"],
            "description": obj["description"],
            "details": v1ResourcePoolDetail.from_json(obj["details"]),
            "imageId": obj["imageId"],
            "instanceType": obj["instanceType"],
            "location": obj["location"],
            "masterCertName": obj["masterCertName"],
            "masterUrl": obj["masterUrl"],
            "maxAgentStartingPeriod": float(obj["maxAgentStartingPeriod"]),
            "maxAgents": obj["maxAgents"],
            "maxIdleAgentPeriod": float(obj["maxIdleAgentPeriod"]),
            "minAgents": obj["minAgents"],
            "name": obj["name"],
            "numAgents": obj["numAgents"],
            "preemptible": obj["preemptible"],
            "schedulerFittingPolicy": v1FittingPolicy(obj["schedulerFittingPolicy"]),
            "schedulerType": v1SchedulerType(obj["schedulerType"]),
            "slotType": determineddevicev1Type(obj["slotType"]),
            "slotsAvailable": obj["slotsAvailable"],
            "slotsUsed": obj["slotsUsed"],
            "startupScript": obj["startupScript"],
            "type": v1ResourcePoolType(obj["type"]),
        }
        if "accelerator" in obj:
            kwargs["accelerator"] = obj["accelerator"]
        if "slotsPerAgent" in obj:
            kwargs["slotsPerAgent"] = obj["slotsPerAgent"]
        if "stats" in obj:
            kwargs["stats"] = v1QueueStats.from_json(obj["stats"]) if obj["stats"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "agentDockerImage": self.agentDockerImage,
            "agentDockerNetwork": self.agentDockerNetwork,
            "agentDockerRuntime": self.agentDockerRuntime,
            "agentFluentImage": self.agentFluentImage,
            "auxContainerCapacity": self.auxContainerCapacity,
            "auxContainerCapacityPerAgent": self.auxContainerCapacityPerAgent,
            "auxContainersRunning": self.auxContainersRunning,
            "containerStartupScript": self.containerStartupScript,
            "defaultAuxPool": self.defaultAuxPool,
            "defaultComputePool": self.defaultComputePool,
            "description": self.description,
            "details": self.details.to_json(omit_unset),
            "imageId": self.imageId,
            "instanceType": self.instanceType,
            "location": self.location,
            "masterCertName": self.masterCertName,
            "masterUrl": self.masterUrl,
            "maxAgentStartingPeriod": dump_float(self.maxAgentStartingPeriod),
            "maxAgents": self.maxAgents,
            "maxIdleAgentPeriod": dump_float(self.maxIdleAgentPeriod),
            "minAgents": self.minAgents,
            "name": self.name,
            "numAgents": self.numAgents,
            "preemptible": self.preemptible,
            "schedulerFittingPolicy": self.schedulerFittingPolicy.value,
            "schedulerType": self.schedulerType.value,
            "slotType": self.slotType.value,
            "slotsAvailable": self.slotsAvailable,
            "slotsUsed": self.slotsUsed,
            "startupScript": self.startupScript,
            "type": self.type.value,
        }
        if not omit_unset or "accelerator" in vars(self):
            out["accelerator"] = self.accelerator
        if not omit_unset or "slotsPerAgent" in vars(self):
            out["slotsPerAgent"] = self.slotsPerAgent
        if not omit_unset or "stats" in vars(self):
            out["stats"] = None if self.stats is None else self.stats.to_json(omit_unset)
        return out

class v1ResourcePoolAwsDetail:
    customTags: "typing.Optional[typing.Sequence[v1AwsCustomTag]]" = None
    instanceType: "typing.Optional[str]" = None
    logGroup: "typing.Optional[str]" = None
    logStream: "typing.Optional[str]" = None
    spotMaxPrice: "typing.Optional[str]" = None
    subnetId: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        iamInstanceProfileArn: str,
        imageId: str,
        instanceName: str,
        publicIp: bool,
        region: str,
        rootVolumeSize: int,
        securityGroupId: str,
        spotEnabled: bool,
        sshKeyName: str,
        tagKey: str,
        tagValue: str,
        customTags: "typing.Union[typing.Sequence[v1AwsCustomTag], None, Unset]" = _unset,
        instanceType: "typing.Union[str, None, Unset]" = _unset,
        logGroup: "typing.Union[str, None, Unset]" = _unset,
        logStream: "typing.Union[str, None, Unset]" = _unset,
        spotMaxPrice: "typing.Union[str, None, Unset]" = _unset,
        subnetId: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.iamInstanceProfileArn = iamInstanceProfileArn
        self.imageId = imageId
        self.instanceName = instanceName
        self.publicIp = publicIp
        self.region = region
        self.rootVolumeSize = rootVolumeSize
        self.securityGroupId = securityGroupId
        self.spotEnabled = spotEnabled
        self.sshKeyName = sshKeyName
        self.tagKey = tagKey
        self.tagValue = tagValue
        if not isinstance(customTags, Unset):
            self.customTags = customTags
        if not isinstance(instanceType, Unset):
            self.instanceType = instanceType
        if not isinstance(logGroup, Unset):
            self.logGroup = logGroup
        if not isinstance(logStream, Unset):
            self.logStream = logStream
        if not isinstance(spotMaxPrice, Unset):
            self.spotMaxPrice = spotMaxPrice
        if not isinstance(subnetId, Unset):
            self.subnetId = subnetId

    @classmethod
    def from_json(cls, obj: Json) -> "v1ResourcePoolAwsDetail":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "iamInstanceProfileArn": obj["iamInstanceProfileArn"],
            "imageId": obj["imageId"],
            "instanceName": obj["instanceName"],
            "publicIp": obj["publicIp"],
            "region": obj["region"],
            "rootVolumeSize": obj["rootVolumeSize"],
            "securityGroupId": obj["securityGroupId"],
            "spotEnabled": obj["spotEnabled"],
            "sshKeyName": obj["sshKeyName"],
            "tagKey": obj["tagKey"],
            "tagValue": obj["tagValue"],
        }
        if "customTags" in obj:
            kwargs["customTags"] = [v1AwsCustomTag.from_json(x) for x in obj["customTags"]] if obj["customTags"] is not None else None
        if "instanceType" in obj:
            kwargs["instanceType"] = obj["instanceType"]
        if "logGroup" in obj:
            kwargs["logGroup"] = obj["logGroup"]
        if "logStream" in obj:
            kwargs["logStream"] = obj["logStream"]
        if "spotMaxPrice" in obj:
            kwargs["spotMaxPrice"] = obj["spotMaxPrice"]
        if "subnetId" in obj:
            kwargs["subnetId"] = obj["subnetId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "iamInstanceProfileArn": self.iamInstanceProfileArn,
            "imageId": self.imageId,
            "instanceName": self.instanceName,
            "publicIp": self.publicIp,
            "region": self.region,
            "rootVolumeSize": self.rootVolumeSize,
            "securityGroupId": self.securityGroupId,
            "spotEnabled": self.spotEnabled,
            "sshKeyName": self.sshKeyName,
            "tagKey": self.tagKey,
            "tagValue": self.tagValue,
        }
        if not omit_unset or "customTags" in vars(self):
            out["customTags"] = None if self.customTags is None else [x.to_json(omit_unset) for x in self.customTags]
        if not omit_unset or "instanceType" in vars(self):
            out["instanceType"] = self.instanceType
        if not omit_unset or "logGroup" in vars(self):
            out["logGroup"] = self.logGroup
        if not omit_unset or "logStream" in vars(self):
            out["logStream"] = self.logStream
        if not omit_unset or "spotMaxPrice" in vars(self):
            out["spotMaxPrice"] = self.spotMaxPrice
        if not omit_unset or "subnetId" in vars(self):
            out["subnetId"] = self.subnetId
        return out

class v1ResourcePoolDetail:
    aws: "typing.Optional[v1ResourcePoolAwsDetail]" = None
    gcp: "typing.Optional[v1ResourcePoolGcpDetail]" = None
    priorityScheduler: "typing.Optional[v1ResourcePoolPrioritySchedulerDetail]" = None

    def __init__(
        self,
        *,
        aws: "typing.Union[v1ResourcePoolAwsDetail, None, Unset]" = _unset,
        gcp: "typing.Union[v1ResourcePoolGcpDetail, None, Unset]" = _unset,
        priorityScheduler: "typing.Union[v1ResourcePoolPrioritySchedulerDetail, None, Unset]" = _unset,
    ):
        if not isinstance(aws, Unset):
            self.aws = aws
        if not isinstance(gcp, Unset):
            self.gcp = gcp
        if not isinstance(priorityScheduler, Unset):
            self.priorityScheduler = priorityScheduler

    @classmethod
    def from_json(cls, obj: Json) -> "v1ResourcePoolDetail":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "aws" in obj:
            kwargs["aws"] = v1ResourcePoolAwsDetail.from_json(obj["aws"]) if obj["aws"] is not None else None
        if "gcp" in obj:
            kwargs["gcp"] = v1ResourcePoolGcpDetail.from_json(obj["gcp"]) if obj["gcp"] is not None else None
        if "priorityScheduler" in obj:
            kwargs["priorityScheduler"] = v1ResourcePoolPrioritySchedulerDetail.from_json(obj["priorityScheduler"]) if obj["priorityScheduler"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "aws" in vars(self):
            out["aws"] = None if self.aws is None else self.aws.to_json(omit_unset)
        if not omit_unset or "gcp" in vars(self):
            out["gcp"] = None if self.gcp is None else self.gcp.to_json(omit_unset)
        if not omit_unset or "priorityScheduler" in vars(self):
            out["priorityScheduler"] = None if self.priorityScheduler is None else self.priorityScheduler.to_json(omit_unset)
        return out

class v1ResourcePoolGcpDetail:
    networkTags: "typing.Optional[typing.Sequence[str]]" = None
    subnetwork: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        bootDiskSize: int,
        bootDiskSourceImage: str,
        externalIp: bool,
        gpuNum: int,
        gpuType: str,
        labelKey: str,
        labelValue: str,
        machineType: str,
        namePrefix: str,
        network: str,
        operationTimeoutPeriod: float,
        preemptible: bool,
        project: str,
        serviceAccountEmail: str,
        serviceAccountScopes: "typing.Sequence[str]",
        zone: str,
        networkTags: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        subnetwork: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.bootDiskSize = bootDiskSize
        self.bootDiskSourceImage = bootDiskSourceImage
        self.externalIp = externalIp
        self.gpuNum = gpuNum
        self.gpuType = gpuType
        self.labelKey = labelKey
        self.labelValue = labelValue
        self.machineType = machineType
        self.namePrefix = namePrefix
        self.network = network
        self.operationTimeoutPeriod = operationTimeoutPeriod
        self.preemptible = preemptible
        self.project = project
        self.serviceAccountEmail = serviceAccountEmail
        self.serviceAccountScopes = serviceAccountScopes
        self.zone = zone
        if not isinstance(networkTags, Unset):
            self.networkTags = networkTags
        if not isinstance(subnetwork, Unset):
            self.subnetwork = subnetwork

    @classmethod
    def from_json(cls, obj: Json) -> "v1ResourcePoolGcpDetail":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "bootDiskSize": obj["bootDiskSize"],
            "bootDiskSourceImage": obj["bootDiskSourceImage"],
            "externalIp": obj["externalIp"],
            "gpuNum": obj["gpuNum"],
            "gpuType": obj["gpuType"],
            "labelKey": obj["labelKey"],
            "labelValue": obj["labelValue"],
            "machineType": obj["machineType"],
            "namePrefix": obj["namePrefix"],
            "network": obj["network"],
            "operationTimeoutPeriod": float(obj["operationTimeoutPeriod"]),
            "preemptible": obj["preemptible"],
            "project": obj["project"],
            "serviceAccountEmail": obj["serviceAccountEmail"],
            "serviceAccountScopes": obj["serviceAccountScopes"],
            "zone": obj["zone"],
        }
        if "networkTags" in obj:
            kwargs["networkTags"] = obj["networkTags"]
        if "subnetwork" in obj:
            kwargs["subnetwork"] = obj["subnetwork"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "bootDiskSize": self.bootDiskSize,
            "bootDiskSourceImage": self.bootDiskSourceImage,
            "externalIp": self.externalIp,
            "gpuNum": self.gpuNum,
            "gpuType": self.gpuType,
            "labelKey": self.labelKey,
            "labelValue": self.labelValue,
            "machineType": self.machineType,
            "namePrefix": self.namePrefix,
            "network": self.network,
            "operationTimeoutPeriod": dump_float(self.operationTimeoutPeriod),
            "preemptible": self.preemptible,
            "project": self.project,
            "serviceAccountEmail": self.serviceAccountEmail,
            "serviceAccountScopes": self.serviceAccountScopes,
            "zone": self.zone,
        }
        if not omit_unset or "networkTags" in vars(self):
            out["networkTags"] = self.networkTags
        if not omit_unset or "subnetwork" in vars(self):
            out["subnetwork"] = self.subnetwork
        return out

class v1ResourcePoolPrioritySchedulerDetail:
    k8Priorities: "typing.Optional[typing.Sequence[v1K8PriorityClass]]" = None

    def __init__(
        self,
        *,
        defaultPriority: int,
        preemption: bool,
        k8Priorities: "typing.Union[typing.Sequence[v1K8PriorityClass], None, Unset]" = _unset,
    ):
        self.defaultPriority = defaultPriority
        self.preemption = preemption
        if not isinstance(k8Priorities, Unset):
            self.k8Priorities = k8Priorities

    @classmethod
    def from_json(cls, obj: Json) -> "v1ResourcePoolPrioritySchedulerDetail":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "defaultPriority": obj["defaultPriority"],
            "preemption": obj["preemption"],
        }
        if "k8Priorities" in obj:
            kwargs["k8Priorities"] = [v1K8PriorityClass.from_json(x) for x in obj["k8Priorities"]] if obj["k8Priorities"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "defaultPriority": self.defaultPriority,
            "preemption": self.preemption,
        }
        if not omit_unset or "k8Priorities" in vars(self):
            out["k8Priorities"] = None if self.k8Priorities is None else [x.to_json(omit_unset) for x in self.k8Priorities]
        return out

class v1ResourcePoolType(enum.Enum):
    RESOURCE_POOL_TYPE_UNSPECIFIED = "RESOURCE_POOL_TYPE_UNSPECIFIED"
    RESOURCE_POOL_TYPE_AWS = "RESOURCE_POOL_TYPE_AWS"
    RESOURCE_POOL_TYPE_GCP = "RESOURCE_POOL_TYPE_GCP"
    RESOURCE_POOL_TYPE_STATIC = "RESOURCE_POOL_TYPE_STATIC"
    RESOURCE_POOL_TYPE_K8S = "RESOURCE_POOL_TYPE_K8S"

class v1Role:
    name: "typing.Optional[str]" = None
    permissions: "typing.Optional[typing.Sequence[v1Permission]]" = None
    scopeTypeMask: "typing.Optional[v1ScopeTypeMask]" = None

    def __init__(
        self,
        *,
        roleId: int,
        name: "typing.Union[str, None, Unset]" = _unset,
        permissions: "typing.Union[typing.Sequence[v1Permission], None, Unset]" = _unset,
        scopeTypeMask: "typing.Union[v1ScopeTypeMask, None, Unset]" = _unset,
    ):
        self.roleId = roleId
        if not isinstance(name, Unset):
            self.name = name
        if not isinstance(permissions, Unset):
            self.permissions = permissions
        if not isinstance(scopeTypeMask, Unset):
            self.scopeTypeMask = scopeTypeMask

    @classmethod
    def from_json(cls, obj: Json) -> "v1Role":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "roleId": obj["roleId"],
        }
        if "name" in obj:
            kwargs["name"] = obj["name"]
        if "permissions" in obj:
            kwargs["permissions"] = [v1Permission.from_json(x) for x in obj["permissions"]] if obj["permissions"] is not None else None
        if "scopeTypeMask" in obj:
            kwargs["scopeTypeMask"] = v1ScopeTypeMask.from_json(obj["scopeTypeMask"]) if obj["scopeTypeMask"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "roleId": self.roleId,
        }
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        if not omit_unset or "permissions" in vars(self):
            out["permissions"] = None if self.permissions is None else [x.to_json(omit_unset) for x in self.permissions]
        if not omit_unset or "scopeTypeMask" in vars(self):
            out["scopeTypeMask"] = None if self.scopeTypeMask is None else self.scopeTypeMask.to_json(omit_unset)
        return out

class v1RoleAssignment:
    scopeCluster: "typing.Optional[bool]" = None
    scopeWorkspaceId: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        role: "v1Role",
        scopeCluster: "typing.Union[bool, None, Unset]" = _unset,
        scopeWorkspaceId: "typing.Union[int, None, Unset]" = _unset,
    ):
        self.role = role
        if not isinstance(scopeCluster, Unset):
            self.scopeCluster = scopeCluster
        if not isinstance(scopeWorkspaceId, Unset):
            self.scopeWorkspaceId = scopeWorkspaceId

    @classmethod
    def from_json(cls, obj: Json) -> "v1RoleAssignment":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "role": v1Role.from_json(obj["role"]),
        }
        if "scopeCluster" in obj:
            kwargs["scopeCluster"] = obj["scopeCluster"]
        if "scopeWorkspaceId" in obj:
            kwargs["scopeWorkspaceId"] = obj["scopeWorkspaceId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "role": self.role.to_json(omit_unset),
        }
        if not omit_unset or "scopeCluster" in vars(self):
            out["scopeCluster"] = self.scopeCluster
        if not omit_unset or "scopeWorkspaceId" in vars(self):
            out["scopeWorkspaceId"] = self.scopeWorkspaceId
        return out

class v1RoleAssignmentSummary:
    scopeCluster: "typing.Optional[bool]" = None
    scopeWorkspaceIds: "typing.Optional[typing.Sequence[int]]" = None

    def __init__(
        self,
        *,
        roleId: int,
        scopeCluster: "typing.Union[bool, None, Unset]" = _unset,
        scopeWorkspaceIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
    ):
        self.roleId = roleId
        if not isinstance(scopeCluster, Unset):
            self.scopeCluster = scopeCluster
        if not isinstance(scopeWorkspaceIds, Unset):
            self.scopeWorkspaceIds = scopeWorkspaceIds

    @classmethod
    def from_json(cls, obj: Json) -> "v1RoleAssignmentSummary":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "roleId": obj["roleId"],
        }
        if "scopeCluster" in obj:
            kwargs["scopeCluster"] = obj["scopeCluster"]
        if "scopeWorkspaceIds" in obj:
            kwargs["scopeWorkspaceIds"] = obj["scopeWorkspaceIds"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "roleId": self.roleId,
        }
        if not omit_unset or "scopeCluster" in vars(self):
            out["scopeCluster"] = self.scopeCluster
        if not omit_unset or "scopeWorkspaceIds" in vars(self):
            out["scopeWorkspaceIds"] = self.scopeWorkspaceIds
        return out

class v1RoleWithAssignments:
    groupRoleAssignments: "typing.Optional[typing.Sequence[v1GroupRoleAssignment]]" = None
    role: "typing.Optional[v1Role]" = None
    userRoleAssignments: "typing.Optional[typing.Sequence[v1UserRoleAssignment]]" = None

    def __init__(
        self,
        *,
        groupRoleAssignments: "typing.Union[typing.Sequence[v1GroupRoleAssignment], None, Unset]" = _unset,
        role: "typing.Union[v1Role, None, Unset]" = _unset,
        userRoleAssignments: "typing.Union[typing.Sequence[v1UserRoleAssignment], None, Unset]" = _unset,
    ):
        if not isinstance(groupRoleAssignments, Unset):
            self.groupRoleAssignments = groupRoleAssignments
        if not isinstance(role, Unset):
            self.role = role
        if not isinstance(userRoleAssignments, Unset):
            self.userRoleAssignments = userRoleAssignments

    @classmethod
    def from_json(cls, obj: Json) -> "v1RoleWithAssignments":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "groupRoleAssignments" in obj:
            kwargs["groupRoleAssignments"] = [v1GroupRoleAssignment.from_json(x) for x in obj["groupRoleAssignments"]] if obj["groupRoleAssignments"] is not None else None
        if "role" in obj:
            kwargs["role"] = v1Role.from_json(obj["role"]) if obj["role"] is not None else None
        if "userRoleAssignments" in obj:
            kwargs["userRoleAssignments"] = [v1UserRoleAssignment.from_json(x) for x in obj["userRoleAssignments"]] if obj["userRoleAssignments"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "groupRoleAssignments" in vars(self):
            out["groupRoleAssignments"] = None if self.groupRoleAssignments is None else [x.to_json(omit_unset) for x in self.groupRoleAssignments]
        if not omit_unset or "role" in vars(self):
            out["role"] = None if self.role is None else self.role.to_json(omit_unset)
        if not omit_unset or "userRoleAssignments" in vars(self):
            out["userRoleAssignments"] = None if self.userRoleAssignments is None else [x.to_json(omit_unset) for x in self.userRoleAssignments]
        return out

class v1RunnableOperation:
    length: "typing.Optional[str]" = None
    type: "typing.Optional[v1RunnableType]" = None

    def __init__(
        self,
        *,
        length: "typing.Union[str, None, Unset]" = _unset,
        type: "typing.Union[v1RunnableType, None, Unset]" = _unset,
    ):
        if not isinstance(length, Unset):
            self.length = length
        if not isinstance(type, Unset):
            self.type = type

    @classmethod
    def from_json(cls, obj: Json) -> "v1RunnableOperation":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "length" in obj:
            kwargs["length"] = obj["length"]
        if "type" in obj:
            kwargs["type"] = v1RunnableType(obj["type"]) if obj["type"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "length" in vars(self):
            out["length"] = self.length
        if not omit_unset or "type" in vars(self):
            out["type"] = None if self.type is None else self.type.value
        return out

class v1RunnableType(enum.Enum):
    RUNNABLE_TYPE_UNSPECIFIED = "RUNNABLE_TYPE_UNSPECIFIED"
    RUNNABLE_TYPE_TRAIN = "RUNNABLE_TYPE_TRAIN"
    RUNNABLE_TYPE_VALIDATE = "RUNNABLE_TYPE_VALIDATE"

class v1SSOProvider:

    def __init__(
        self,
        *,
        name: str,
        ssoUrl: str,
    ):
        self.name = name
        self.ssoUrl = ssoUrl

    @classmethod
    def from_json(cls, obj: Json) -> "v1SSOProvider":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "name": obj["name"],
            "ssoUrl": obj["ssoUrl"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "name": self.name,
            "ssoUrl": self.ssoUrl,
        }
        return out

class v1Scale(enum.Enum):
    SCALE_UNSPECIFIED = "SCALE_UNSPECIFIED"
    SCALE_LINEAR = "SCALE_LINEAR"
    SCALE_LOG = "SCALE_LOG"

class v1SchedulerType(enum.Enum):
    SCHEDULER_TYPE_UNSPECIFIED = "SCHEDULER_TYPE_UNSPECIFIED"
    SCHEDULER_TYPE_PRIORITY = "SCHEDULER_TYPE_PRIORITY"
    SCHEDULER_TYPE_FAIR_SHARE = "SCHEDULER_TYPE_FAIR_SHARE"
    SCHEDULER_TYPE_ROUND_ROBIN = "SCHEDULER_TYPE_ROUND_ROBIN"
    SCHEDULER_TYPE_KUBERNETES = "SCHEDULER_TYPE_KUBERNETES"
    SCHEDULER_TYPE_SLURM = "SCHEDULER_TYPE_SLURM"
    SCHEDULER_TYPE_PBS = "SCHEDULER_TYPE_PBS"

class v1ScopeTypeMask:
    cluster: "typing.Optional[bool]" = None
    workspace: "typing.Optional[bool]" = None

    def __init__(
        self,
        *,
        cluster: "typing.Union[bool, None, Unset]" = _unset,
        workspace: "typing.Union[bool, None, Unset]" = _unset,
    ):
        if not isinstance(cluster, Unset):
            self.cluster = cluster
        if not isinstance(workspace, Unset):
            self.workspace = workspace

    @classmethod
    def from_json(cls, obj: Json) -> "v1ScopeTypeMask":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "cluster" in obj:
            kwargs["cluster"] = obj["cluster"]
        if "workspace" in obj:
            kwargs["workspace"] = obj["workspace"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "cluster" in vars(self):
            out["cluster"] = self.cluster
        if not omit_unset or "workspace" in vars(self):
            out["workspace"] = self.workspace
        return out

class v1SearchRolesAssignableToScopeRequest:
    offset: "typing.Optional[int]" = None
    workspaceId: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        limit: int,
        offset: "typing.Union[int, None, Unset]" = _unset,
        workspaceId: "typing.Union[int, None, Unset]" = _unset,
    ):
        self.limit = limit
        if not isinstance(offset, Unset):
            self.offset = offset
        if not isinstance(workspaceId, Unset):
            self.workspaceId = workspaceId

    @classmethod
    def from_json(cls, obj: Json) -> "v1SearchRolesAssignableToScopeRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "limit": obj["limit"],
        }
        if "offset" in obj:
            kwargs["offset"] = obj["offset"]
        if "workspaceId" in obj:
            kwargs["workspaceId"] = obj["workspaceId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "limit": self.limit,
        }
        if not omit_unset or "offset" in vars(self):
            out["offset"] = self.offset
        if not omit_unset or "workspaceId" in vars(self):
            out["workspaceId"] = self.workspaceId
        return out

class v1SearchRolesAssignableToScopeResponse:
    pagination: "typing.Optional[v1Pagination]" = None
    roles: "typing.Optional[typing.Sequence[v1Role]]" = None

    def __init__(
        self,
        *,
        pagination: "typing.Union[v1Pagination, None, Unset]" = _unset,
        roles: "typing.Union[typing.Sequence[v1Role], None, Unset]" = _unset,
    ):
        if not isinstance(pagination, Unset):
            self.pagination = pagination
        if not isinstance(roles, Unset):
            self.roles = roles

    @classmethod
    def from_json(cls, obj: Json) -> "v1SearchRolesAssignableToScopeResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "pagination" in obj:
            kwargs["pagination"] = v1Pagination.from_json(obj["pagination"]) if obj["pagination"] is not None else None
        if "roles" in obj:
            kwargs["roles"] = [v1Role.from_json(x) for x in obj["roles"]] if obj["roles"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "pagination" in vars(self):
            out["pagination"] = None if self.pagination is None else self.pagination.to_json(omit_unset)
        if not omit_unset or "roles" in vars(self):
            out["roles"] = None if self.roles is None else [x.to_json(omit_unset) for x in self.roles]
        return out

class v1SearcherEvent:
    experimentInactive: "typing.Optional[v1ExperimentInactive]" = None
    initialOperations: "typing.Optional[v1InitialOperations]" = None
    trialClosed: "typing.Optional[v1TrialClosed]" = None
    trialCreated: "typing.Optional[v1TrialCreated]" = None
    trialExitedEarly: "typing.Optional[v1TrialExitedEarly]" = None
    trialProgress: "typing.Optional[v1TrialProgress]" = None
    validationCompleted: "typing.Optional[v1ValidationCompleted]" = None

    def __init__(
        self,
        *,
        id: int,
        experimentInactive: "typing.Union[v1ExperimentInactive, None, Unset]" = _unset,
        initialOperations: "typing.Union[v1InitialOperations, None, Unset]" = _unset,
        trialClosed: "typing.Union[v1TrialClosed, None, Unset]" = _unset,
        trialCreated: "typing.Union[v1TrialCreated, None, Unset]" = _unset,
        trialExitedEarly: "typing.Union[v1TrialExitedEarly, None, Unset]" = _unset,
        trialProgress: "typing.Union[v1TrialProgress, None, Unset]" = _unset,
        validationCompleted: "typing.Union[v1ValidationCompleted, None, Unset]" = _unset,
    ):
        self.id = id
        if not isinstance(experimentInactive, Unset):
            self.experimentInactive = experimentInactive
        if not isinstance(initialOperations, Unset):
            self.initialOperations = initialOperations
        if not isinstance(trialClosed, Unset):
            self.trialClosed = trialClosed
        if not isinstance(trialCreated, Unset):
            self.trialCreated = trialCreated
        if not isinstance(trialExitedEarly, Unset):
            self.trialExitedEarly = trialExitedEarly
        if not isinstance(trialProgress, Unset):
            self.trialProgress = trialProgress
        if not isinstance(validationCompleted, Unset):
            self.validationCompleted = validationCompleted

    @classmethod
    def from_json(cls, obj: Json) -> "v1SearcherEvent":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "id": obj["id"],
        }
        if "experimentInactive" in obj:
            kwargs["experimentInactive"] = v1ExperimentInactive.from_json(obj["experimentInactive"]) if obj["experimentInactive"] is not None else None
        if "initialOperations" in obj:
            kwargs["initialOperations"] = v1InitialOperations.from_json(obj["initialOperations"]) if obj["initialOperations"] is not None else None
        if "trialClosed" in obj:
            kwargs["trialClosed"] = v1TrialClosed.from_json(obj["trialClosed"]) if obj["trialClosed"] is not None else None
        if "trialCreated" in obj:
            kwargs["trialCreated"] = v1TrialCreated.from_json(obj["trialCreated"]) if obj["trialCreated"] is not None else None
        if "trialExitedEarly" in obj:
            kwargs["trialExitedEarly"] = v1TrialExitedEarly.from_json(obj["trialExitedEarly"]) if obj["trialExitedEarly"] is not None else None
        if "trialProgress" in obj:
            kwargs["trialProgress"] = v1TrialProgress.from_json(obj["trialProgress"]) if obj["trialProgress"] is not None else None
        if "validationCompleted" in obj:
            kwargs["validationCompleted"] = v1ValidationCompleted.from_json(obj["validationCompleted"]) if obj["validationCompleted"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "id": self.id,
        }
        if not omit_unset or "experimentInactive" in vars(self):
            out["experimentInactive"] = None if self.experimentInactive is None else self.experimentInactive.to_json(omit_unset)
        if not omit_unset or "initialOperations" in vars(self):
            out["initialOperations"] = None if self.initialOperations is None else self.initialOperations.to_json(omit_unset)
        if not omit_unset or "trialClosed" in vars(self):
            out["trialClosed"] = None if self.trialClosed is None else self.trialClosed.to_json(omit_unset)
        if not omit_unset or "trialCreated" in vars(self):
            out["trialCreated"] = None if self.trialCreated is None else self.trialCreated.to_json(omit_unset)
        if not omit_unset or "trialExitedEarly" in vars(self):
            out["trialExitedEarly"] = None if self.trialExitedEarly is None else self.trialExitedEarly.to_json(omit_unset)
        if not omit_unset or "trialProgress" in vars(self):
            out["trialProgress"] = None if self.trialProgress is None else self.trialProgress.to_json(omit_unset)
        if not omit_unset or "validationCompleted" in vars(self):
            out["validationCompleted"] = None if self.validationCompleted is None else self.validationCompleted.to_json(omit_unset)
        return out

class v1SearcherOperation:
    closeTrial: "typing.Optional[v1CloseTrialOperation]" = None
    createTrial: "typing.Optional[v1CreateTrialOperation]" = None
    setSearcherProgress: "typing.Optional[v1SetSearcherProgressOperation]" = None
    shutDown: "typing.Optional[v1ShutDownOperation]" = None
    trialOperation: "typing.Optional[v1TrialOperation]" = None

    def __init__(
        self,
        *,
        closeTrial: "typing.Union[v1CloseTrialOperation, None, Unset]" = _unset,
        createTrial: "typing.Union[v1CreateTrialOperation, None, Unset]" = _unset,
        setSearcherProgress: "typing.Union[v1SetSearcherProgressOperation, None, Unset]" = _unset,
        shutDown: "typing.Union[v1ShutDownOperation, None, Unset]" = _unset,
        trialOperation: "typing.Union[v1TrialOperation, None, Unset]" = _unset,
    ):
        if not isinstance(closeTrial, Unset):
            self.closeTrial = closeTrial
        if not isinstance(createTrial, Unset):
            self.createTrial = createTrial
        if not isinstance(setSearcherProgress, Unset):
            self.setSearcherProgress = setSearcherProgress
        if not isinstance(shutDown, Unset):
            self.shutDown = shutDown
        if not isinstance(trialOperation, Unset):
            self.trialOperation = trialOperation

    @classmethod
    def from_json(cls, obj: Json) -> "v1SearcherOperation":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "closeTrial" in obj:
            kwargs["closeTrial"] = v1CloseTrialOperation.from_json(obj["closeTrial"]) if obj["closeTrial"] is not None else None
        if "createTrial" in obj:
            kwargs["createTrial"] = v1CreateTrialOperation.from_json(obj["createTrial"]) if obj["createTrial"] is not None else None
        if "setSearcherProgress" in obj:
            kwargs["setSearcherProgress"] = v1SetSearcherProgressOperation.from_json(obj["setSearcherProgress"]) if obj["setSearcherProgress"] is not None else None
        if "shutDown" in obj:
            kwargs["shutDown"] = v1ShutDownOperation.from_json(obj["shutDown"]) if obj["shutDown"] is not None else None
        if "trialOperation" in obj:
            kwargs["trialOperation"] = v1TrialOperation.from_json(obj["trialOperation"]) if obj["trialOperation"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "closeTrial" in vars(self):
            out["closeTrial"] = None if self.closeTrial is None else self.closeTrial.to_json(omit_unset)
        if not omit_unset or "createTrial" in vars(self):
            out["createTrial"] = None if self.createTrial is None else self.createTrial.to_json(omit_unset)
        if not omit_unset or "setSearcherProgress" in vars(self):
            out["setSearcherProgress"] = None if self.setSearcherProgress is None else self.setSearcherProgress.to_json(omit_unset)
        if not omit_unset or "shutDown" in vars(self):
            out["shutDown"] = None if self.shutDown is None else self.shutDown.to_json(omit_unset)
        if not omit_unset or "trialOperation" in vars(self):
            out["trialOperation"] = None if self.trialOperation is None else self.trialOperation.to_json(omit_unset)
        return out

class v1SetCommandPriorityRequest:
    commandId: "typing.Optional[str]" = None
    priority: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        commandId: "typing.Union[str, None, Unset]" = _unset,
        priority: "typing.Union[int, None, Unset]" = _unset,
    ):
        if not isinstance(commandId, Unset):
            self.commandId = commandId
        if not isinstance(priority, Unset):
            self.priority = priority

    @classmethod
    def from_json(cls, obj: Json) -> "v1SetCommandPriorityRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "commandId" in obj:
            kwargs["commandId"] = obj["commandId"]
        if "priority" in obj:
            kwargs["priority"] = obj["priority"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "commandId" in vars(self):
            out["commandId"] = self.commandId
        if not omit_unset or "priority" in vars(self):
            out["priority"] = self.priority
        return out

class v1SetCommandPriorityResponse:
    command: "typing.Optional[v1Command]" = None

    def __init__(
        self,
        *,
        command: "typing.Union[v1Command, None, Unset]" = _unset,
    ):
        if not isinstance(command, Unset):
            self.command = command

    @classmethod
    def from_json(cls, obj: Json) -> "v1SetCommandPriorityResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "command" in obj:
            kwargs["command"] = v1Command.from_json(obj["command"]) if obj["command"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "command" in vars(self):
            out["command"] = None if self.command is None else self.command.to_json(omit_unset)
        return out

class v1SetNotebookPriorityRequest:
    notebookId: "typing.Optional[str]" = None
    priority: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        notebookId: "typing.Union[str, None, Unset]" = _unset,
        priority: "typing.Union[int, None, Unset]" = _unset,
    ):
        if not isinstance(notebookId, Unset):
            self.notebookId = notebookId
        if not isinstance(priority, Unset):
            self.priority = priority

    @classmethod
    def from_json(cls, obj: Json) -> "v1SetNotebookPriorityRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "notebookId" in obj:
            kwargs["notebookId"] = obj["notebookId"]
        if "priority" in obj:
            kwargs["priority"] = obj["priority"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "notebookId" in vars(self):
            out["notebookId"] = self.notebookId
        if not omit_unset or "priority" in vars(self):
            out["priority"] = self.priority
        return out

class v1SetNotebookPriorityResponse:
    notebook: "typing.Optional[v1Notebook]" = None

    def __init__(
        self,
        *,
        notebook: "typing.Union[v1Notebook, None, Unset]" = _unset,
    ):
        if not isinstance(notebook, Unset):
            self.notebook = notebook

    @classmethod
    def from_json(cls, obj: Json) -> "v1SetNotebookPriorityResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "notebook" in obj:
            kwargs["notebook"] = v1Notebook.from_json(obj["notebook"]) if obj["notebook"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "notebook" in vars(self):
            out["notebook"] = None if self.notebook is None else self.notebook.to_json(omit_unset)
        return out

class v1SetSearcherProgressOperation:
    progress: "typing.Optional[float]" = None

    def __init__(
        self,
        *,
        progress: "typing.Union[float, None, Unset]" = _unset,
    ):
        if not isinstance(progress, Unset):
            self.progress = progress

    @classmethod
    def from_json(cls, obj: Json) -> "v1SetSearcherProgressOperation":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "progress" in obj:
            kwargs["progress"] = float(obj["progress"]) if obj["progress"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "progress" in vars(self):
            out["progress"] = None if self.progress is None else dump_float(self.progress)
        return out

class v1SetShellPriorityRequest:
    priority: "typing.Optional[int]" = None
    shellId: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        priority: "typing.Union[int, None, Unset]" = _unset,
        shellId: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(priority, Unset):
            self.priority = priority
        if not isinstance(shellId, Unset):
            self.shellId = shellId

    @classmethod
    def from_json(cls, obj: Json) -> "v1SetShellPriorityRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "priority" in obj:
            kwargs["priority"] = obj["priority"]
        if "shellId" in obj:
            kwargs["shellId"] = obj["shellId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "priority" in vars(self):
            out["priority"] = self.priority
        if not omit_unset or "shellId" in vars(self):
            out["shellId"] = self.shellId
        return out

class v1SetShellPriorityResponse:
    shell: "typing.Optional[v1Shell]" = None

    def __init__(
        self,
        *,
        shell: "typing.Union[v1Shell, None, Unset]" = _unset,
    ):
        if not isinstance(shell, Unset):
            self.shell = shell

    @classmethod
    def from_json(cls, obj: Json) -> "v1SetShellPriorityResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "shell" in obj:
            kwargs["shell"] = v1Shell.from_json(obj["shell"]) if obj["shell"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "shell" in vars(self):
            out["shell"] = None if self.shell is None else self.shell.to_json(omit_unset)
        return out

class v1SetTensorboardPriorityRequest:
    priority: "typing.Optional[int]" = None
    tensorboardId: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        priority: "typing.Union[int, None, Unset]" = _unset,
        tensorboardId: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(priority, Unset):
            self.priority = priority
        if not isinstance(tensorboardId, Unset):
            self.tensorboardId = tensorboardId

    @classmethod
    def from_json(cls, obj: Json) -> "v1SetTensorboardPriorityRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "priority" in obj:
            kwargs["priority"] = obj["priority"]
        if "tensorboardId" in obj:
            kwargs["tensorboardId"] = obj["tensorboardId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "priority" in vars(self):
            out["priority"] = self.priority
        if not omit_unset or "tensorboardId" in vars(self):
            out["tensorboardId"] = self.tensorboardId
        return out

class v1SetTensorboardPriorityResponse:
    tensorboard: "typing.Optional[v1Tensorboard]" = None

    def __init__(
        self,
        *,
        tensorboard: "typing.Union[v1Tensorboard, None, Unset]" = _unset,
    ):
        if not isinstance(tensorboard, Unset):
            self.tensorboard = tensorboard

    @classmethod
    def from_json(cls, obj: Json) -> "v1SetTensorboardPriorityResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "tensorboard" in obj:
            kwargs["tensorboard"] = v1Tensorboard.from_json(obj["tensorboard"]) if obj["tensorboard"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "tensorboard" in vars(self):
            out["tensorboard"] = None if self.tensorboard is None else self.tensorboard.to_json(omit_unset)
        return out

class v1SetUserPasswordResponse:
    user: "typing.Optional[v1User]" = None

    def __init__(
        self,
        *,
        user: "typing.Union[v1User, None, Unset]" = _unset,
    ):
        if not isinstance(user, Unset):
            self.user = user

    @classmethod
    def from_json(cls, obj: Json) -> "v1SetUserPasswordResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "user" in obj:
            kwargs["user"] = v1User.from_json(obj["user"]) if obj["user"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "user" in vars(self):
            out["user"] = None if self.user is None else self.user.to_json(omit_unset)
        return out

class v1Shell:
    addresses: "typing.Optional[typing.Sequence[typing.Dict[str, typing.Any]]]" = None
    agentUserGroup: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    container: "typing.Optional[v1Container]" = None
    displayName: "typing.Optional[str]" = None
    exitStatus: "typing.Optional[str]" = None
    privateKey: "typing.Optional[str]" = None
    publicKey: "typing.Optional[str]" = None
    userId: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        description: str,
        id: str,
        jobId: str,
        resourcePool: str,
        startTime: str,
        state: "determinedtaskv1State",
        username: str,
        addresses: "typing.Union[typing.Sequence[typing.Dict[str, typing.Any]], None, Unset]" = _unset,
        agentUserGroup: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        container: "typing.Union[v1Container, None, Unset]" = _unset,
        displayName: "typing.Union[str, None, Unset]" = _unset,
        exitStatus: "typing.Union[str, None, Unset]" = _unset,
        privateKey: "typing.Union[str, None, Unset]" = _unset,
        publicKey: "typing.Union[str, None, Unset]" = _unset,
        userId: "typing.Union[int, None, Unset]" = _unset,
    ):
        self.description = description
        self.id = id
        self.jobId = jobId
        self.resourcePool = resourcePool
        self.startTime = startTime
        self.state = state
        self.username = username
        if not isinstance(addresses, Unset):
            self.addresses = addresses
        if not isinstance(agentUserGroup, Unset):
            self.agentUserGroup = agentUserGroup
        if not isinstance(container, Unset):
            self.container = container
        if not isinstance(displayName, Unset):
            self.displayName = displayName
        if not isinstance(exitStatus, Unset):
            self.exitStatus = exitStatus
        if not isinstance(privateKey, Unset):
            self.privateKey = privateKey
        if not isinstance(publicKey, Unset):
            self.publicKey = publicKey
        if not isinstance(userId, Unset):
            self.userId = userId

    @classmethod
    def from_json(cls, obj: Json) -> "v1Shell":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "description": obj["description"],
            "id": obj["id"],
            "jobId": obj["jobId"],
            "resourcePool": obj["resourcePool"],
            "startTime": obj["startTime"],
            "state": determinedtaskv1State(obj["state"]),
            "username": obj["username"],
        }
        if "addresses" in obj:
            kwargs["addresses"] = obj["addresses"]
        if "agentUserGroup" in obj:
            kwargs["agentUserGroup"] = obj["agentUserGroup"]
        if "container" in obj:
            kwargs["container"] = v1Container.from_json(obj["container"]) if obj["container"] is not None else None
        if "displayName" in obj:
            kwargs["displayName"] = obj["displayName"]
        if "exitStatus" in obj:
            kwargs["exitStatus"] = obj["exitStatus"]
        if "privateKey" in obj:
            kwargs["privateKey"] = obj["privateKey"]
        if "publicKey" in obj:
            kwargs["publicKey"] = obj["publicKey"]
        if "userId" in obj:
            kwargs["userId"] = obj["userId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "description": self.description,
            "id": self.id,
            "jobId": self.jobId,
            "resourcePool": self.resourcePool,
            "startTime": self.startTime,
            "state": self.state.value,
            "username": self.username,
        }
        if not omit_unset or "addresses" in vars(self):
            out["addresses"] = self.addresses
        if not omit_unset or "agentUserGroup" in vars(self):
            out["agentUserGroup"] = self.agentUserGroup
        if not omit_unset or "container" in vars(self):
            out["container"] = None if self.container is None else self.container.to_json(omit_unset)
        if not omit_unset or "displayName" in vars(self):
            out["displayName"] = self.displayName
        if not omit_unset or "exitStatus" in vars(self):
            out["exitStatus"] = self.exitStatus
        if not omit_unset or "privateKey" in vars(self):
            out["privateKey"] = self.privateKey
        if not omit_unset or "publicKey" in vars(self):
            out["publicKey"] = self.publicKey
        if not omit_unset or "userId" in vars(self):
            out["userId"] = self.userId
        return out

class v1ShutDownOperation:
    placeholder: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        placeholder: "typing.Union[int, None, Unset]" = _unset,
    ):
        if not isinstance(placeholder, Unset):
            self.placeholder = placeholder

    @classmethod
    def from_json(cls, obj: Json) -> "v1ShutDownOperation":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "placeholder" in obj:
            kwargs["placeholder"] = obj["placeholder"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "placeholder" in vars(self):
            out["placeholder"] = self.placeholder
        return out

class v1Slot:
    container: "typing.Optional[v1Container]" = None
    device: "typing.Optional[v1Device]" = None
    draining: "typing.Optional[bool]" = None
    enabled: "typing.Optional[bool]" = None
    id: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        container: "typing.Union[v1Container, None, Unset]" = _unset,
        device: "typing.Union[v1Device, None, Unset]" = _unset,
        draining: "typing.Union[bool, None, Unset]" = _unset,
        enabled: "typing.Union[bool, None, Unset]" = _unset,
        id: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(container, Unset):
            self.container = container
        if not isinstance(device, Unset):
            self.device = device
        if not isinstance(draining, Unset):
            self.draining = draining
        if not isinstance(enabled, Unset):
            self.enabled = enabled
        if not isinstance(id, Unset):
            self.id = id

    @classmethod
    def from_json(cls, obj: Json) -> "v1Slot":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "container" in obj:
            kwargs["container"] = v1Container.from_json(obj["container"]) if obj["container"] is not None else None
        if "device" in obj:
            kwargs["device"] = v1Device.from_json(obj["device"]) if obj["device"] is not None else None
        if "draining" in obj:
            kwargs["draining"] = obj["draining"]
        if "enabled" in obj:
            kwargs["enabled"] = obj["enabled"]
        if "id" in obj:
            kwargs["id"] = obj["id"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "container" in vars(self):
            out["container"] = None if self.container is None else self.container.to_json(omit_unset)
        if not omit_unset or "device" in vars(self):
            out["device"] = None if self.device is None else self.device.to_json(omit_unset)
        if not omit_unset or "draining" in vars(self):
            out["draining"] = self.draining
        if not omit_unset or "enabled" in vars(self):
            out["enabled"] = self.enabled
        if not omit_unset or "id" in vars(self):
            out["id"] = self.id
        return out

class v1SummarizeTrialResponse:

    def __init__(
        self,
        *,
        metrics: "typing.Sequence[v1SummarizedMetric]",
        trial: "trialv1Trial",
    ):
        self.metrics = metrics
        self.trial = trial

    @classmethod
    def from_json(cls, obj: Json) -> "v1SummarizeTrialResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "metrics": [v1SummarizedMetric.from_json(x) for x in obj["metrics"]],
            "trial": trialv1Trial.from_json(obj["trial"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "metrics": [x.to_json(omit_unset) for x in self.metrics],
            "trial": self.trial.to_json(omit_unset),
        }
        return out

class v1SummarizedMetric:

    def __init__(
        self,
        *,
        data: "typing.Sequence[v1DataPoint]",
        name: str,
        type: "v1MetricType",
    ):
        self.data = data
        self.name = name
        self.type = type

    @classmethod
    def from_json(cls, obj: Json) -> "v1SummarizedMetric":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "data": [v1DataPoint.from_json(x) for x in obj["data"]],
            "name": obj["name"],
            "type": v1MetricType(obj["type"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "data": [x.to_json(omit_unset) for x in self.data],
            "name": self.name,
            "type": self.type.value,
        }
        return out

class v1Task:
    allocations: "typing.Optional[typing.Sequence[v1Allocation]]" = None
    taskId: "typing.Optional[str]" = None
    taskType: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        allocations: "typing.Union[typing.Sequence[v1Allocation], None, Unset]" = _unset,
        taskId: "typing.Union[str, None, Unset]" = _unset,
        taskType: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(allocations, Unset):
            self.allocations = allocations
        if not isinstance(taskId, Unset):
            self.taskId = taskId
        if not isinstance(taskType, Unset):
            self.taskType = taskType

    @classmethod
    def from_json(cls, obj: Json) -> "v1Task":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "allocations" in obj:
            kwargs["allocations"] = [v1Allocation.from_json(x) for x in obj["allocations"]] if obj["allocations"] is not None else None
        if "taskId" in obj:
            kwargs["taskId"] = obj["taskId"]
        if "taskType" in obj:
            kwargs["taskType"] = obj["taskType"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "allocations" in vars(self):
            out["allocations"] = None if self.allocations is None else [x.to_json(omit_unset) for x in self.allocations]
        if not omit_unset or "taskId" in vars(self):
            out["taskId"] = self.taskId
        if not omit_unset or "taskType" in vars(self):
            out["taskType"] = self.taskType
        return out

class v1TaskLogsFieldsResponse:
    agentIds: "typing.Optional[typing.Sequence[str]]" = None
    allocationIds: "typing.Optional[typing.Sequence[str]]" = None
    containerIds: "typing.Optional[typing.Sequence[str]]" = None
    rankIds: "typing.Optional[typing.Sequence[int]]" = None
    sources: "typing.Optional[typing.Sequence[str]]" = None
    stdtypes: "typing.Optional[typing.Sequence[str]]" = None

    def __init__(
        self,
        *,
        agentIds: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        allocationIds: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        containerIds: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        rankIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
        sources: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        stdtypes: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
    ):
        if not isinstance(agentIds, Unset):
            self.agentIds = agentIds
        if not isinstance(allocationIds, Unset):
            self.allocationIds = allocationIds
        if not isinstance(containerIds, Unset):
            self.containerIds = containerIds
        if not isinstance(rankIds, Unset):
            self.rankIds = rankIds
        if not isinstance(sources, Unset):
            self.sources = sources
        if not isinstance(stdtypes, Unset):
            self.stdtypes = stdtypes

    @classmethod
    def from_json(cls, obj: Json) -> "v1TaskLogsFieldsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "agentIds" in obj:
            kwargs["agentIds"] = obj["agentIds"]
        if "allocationIds" in obj:
            kwargs["allocationIds"] = obj["allocationIds"]
        if "containerIds" in obj:
            kwargs["containerIds"] = obj["containerIds"]
        if "rankIds" in obj:
            kwargs["rankIds"] = obj["rankIds"]
        if "sources" in obj:
            kwargs["sources"] = obj["sources"]
        if "stdtypes" in obj:
            kwargs["stdtypes"] = obj["stdtypes"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "agentIds" in vars(self):
            out["agentIds"] = self.agentIds
        if not omit_unset or "allocationIds" in vars(self):
            out["allocationIds"] = self.allocationIds
        if not omit_unset or "containerIds" in vars(self):
            out["containerIds"] = self.containerIds
        if not omit_unset or "rankIds" in vars(self):
            out["rankIds"] = self.rankIds
        if not omit_unset or "sources" in vars(self):
            out["sources"] = self.sources
        if not omit_unset or "stdtypes" in vars(self):
            out["stdtypes"] = self.stdtypes
        return out

class v1TaskLogsResponse:
    agentId: "typing.Optional[str]" = None
    allocationId: "typing.Optional[str]" = None
    containerId: "typing.Optional[str]" = None
    rankId: "typing.Optional[int]" = None
    source: "typing.Optional[str]" = None
    stdtype: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        id: str,
        level: "v1LogLevel",
        log: str,
        message: str,
        taskId: str,
        timestamp: str,
        agentId: "typing.Union[str, None, Unset]" = _unset,
        allocationId: "typing.Union[str, None, Unset]" = _unset,
        containerId: "typing.Union[str, None, Unset]" = _unset,
        rankId: "typing.Union[int, None, Unset]" = _unset,
        source: "typing.Union[str, None, Unset]" = _unset,
        stdtype: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.id = id
        self.level = level
        self.log = log
        self.message = message
        self.taskId = taskId
        self.timestamp = timestamp
        if not isinstance(agentId, Unset):
            self.agentId = agentId
        if not isinstance(allocationId, Unset):
            self.allocationId = allocationId
        if not isinstance(containerId, Unset):
            self.containerId = containerId
        if not isinstance(rankId, Unset):
            self.rankId = rankId
        if not isinstance(source, Unset):
            self.source = source
        if not isinstance(stdtype, Unset):
            self.stdtype = stdtype

    @classmethod
    def from_json(cls, obj: Json) -> "v1TaskLogsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "id": obj["id"],
            "level": v1LogLevel(obj["level"]),
            "log": obj["log"],
            "message": obj["message"],
            "taskId": obj["taskId"],
            "timestamp": obj["timestamp"],
        }
        if "agentId" in obj:
            kwargs["agentId"] = obj["agentId"]
        if "allocationId" in obj:
            kwargs["allocationId"] = obj["allocationId"]
        if "containerId" in obj:
            kwargs["containerId"] = obj["containerId"]
        if "rankId" in obj:
            kwargs["rankId"] = obj["rankId"]
        if "source" in obj:
            kwargs["source"] = obj["source"]
        if "stdtype" in obj:
            kwargs["stdtype"] = obj["stdtype"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "id": self.id,
            "level": self.level.value,
            "log": self.log,
            "message": self.message,
            "taskId": self.taskId,
            "timestamp": self.timestamp,
        }
        if not omit_unset or "agentId" in vars(self):
            out["agentId"] = self.agentId
        if not omit_unset or "allocationId" in vars(self):
            out["allocationId"] = self.allocationId
        if not omit_unset or "containerId" in vars(self):
            out["containerId"] = self.containerId
        if not omit_unset or "rankId" in vars(self):
            out["rankId"] = self.rankId
        if not omit_unset or "source" in vars(self):
            out["source"] = self.source
        if not omit_unset or "stdtype" in vars(self):
            out["stdtype"] = self.stdtype
        return out

class v1Template:

    def __init__(
        self,
        *,
        config: "typing.Dict[str, typing.Any]",
        name: str,
    ):
        self.config = config
        self.name = name

    @classmethod
    def from_json(cls, obj: Json) -> "v1Template":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "config": obj["config"],
            "name": obj["name"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "config": self.config,
            "name": self.name,
        }
        return out

class v1Tensorboard:
    container: "typing.Optional[v1Container]" = None
    displayName: "typing.Optional[str]" = None
    exitStatus: "typing.Optional[str]" = None
    experimentIds: "typing.Optional[typing.Sequence[int]]" = None
    serviceAddress: "typing.Optional[str]" = None
    trialIds: "typing.Optional[typing.Sequence[int]]" = None
    userId: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        description: str,
        id: str,
        jobId: str,
        resourcePool: str,
        startTime: str,
        state: "determinedtaskv1State",
        username: str,
        container: "typing.Union[v1Container, None, Unset]" = _unset,
        displayName: "typing.Union[str, None, Unset]" = _unset,
        exitStatus: "typing.Union[str, None, Unset]" = _unset,
        experimentIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
        serviceAddress: "typing.Union[str, None, Unset]" = _unset,
        trialIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
        userId: "typing.Union[int, None, Unset]" = _unset,
    ):
        self.description = description
        self.id = id
        self.jobId = jobId
        self.resourcePool = resourcePool
        self.startTime = startTime
        self.state = state
        self.username = username
        if not isinstance(container, Unset):
            self.container = container
        if not isinstance(displayName, Unset):
            self.displayName = displayName
        if not isinstance(exitStatus, Unset):
            self.exitStatus = exitStatus
        if not isinstance(experimentIds, Unset):
            self.experimentIds = experimentIds
        if not isinstance(serviceAddress, Unset):
            self.serviceAddress = serviceAddress
        if not isinstance(trialIds, Unset):
            self.trialIds = trialIds
        if not isinstance(userId, Unset):
            self.userId = userId

    @classmethod
    def from_json(cls, obj: Json) -> "v1Tensorboard":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "description": obj["description"],
            "id": obj["id"],
            "jobId": obj["jobId"],
            "resourcePool": obj["resourcePool"],
            "startTime": obj["startTime"],
            "state": determinedtaskv1State(obj["state"]),
            "username": obj["username"],
        }
        if "container" in obj:
            kwargs["container"] = v1Container.from_json(obj["container"]) if obj["container"] is not None else None
        if "displayName" in obj:
            kwargs["displayName"] = obj["displayName"]
        if "exitStatus" in obj:
            kwargs["exitStatus"] = obj["exitStatus"]
        if "experimentIds" in obj:
            kwargs["experimentIds"] = obj["experimentIds"]
        if "serviceAddress" in obj:
            kwargs["serviceAddress"] = obj["serviceAddress"]
        if "trialIds" in obj:
            kwargs["trialIds"] = obj["trialIds"]
        if "userId" in obj:
            kwargs["userId"] = obj["userId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "description": self.description,
            "id": self.id,
            "jobId": self.jobId,
            "resourcePool": self.resourcePool,
            "startTime": self.startTime,
            "state": self.state.value,
            "username": self.username,
        }
        if not omit_unset or "container" in vars(self):
            out["container"] = None if self.container is None else self.container.to_json(omit_unset)
        if not omit_unset or "displayName" in vars(self):
            out["displayName"] = self.displayName
        if not omit_unset or "exitStatus" in vars(self):
            out["exitStatus"] = self.exitStatus
        if not omit_unset or "experimentIds" in vars(self):
            out["experimentIds"] = self.experimentIds
        if not omit_unset or "serviceAddress" in vars(self):
            out["serviceAddress"] = self.serviceAddress
        if not omit_unset or "trialIds" in vars(self):
            out["trialIds"] = self.trialIds
        if not omit_unset or "userId" in vars(self):
            out["userId"] = self.userId
        return out

class v1TestWebhookResponse:

    def __init__(
        self,
        *,
        completed: bool,
    ):
        self.completed = completed

    @classmethod
    def from_json(cls, obj: Json) -> "v1TestWebhookResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "completed": obj["completed"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "completed": self.completed,
        }
        return out

class v1TimestampFieldFilter:
    gt: "typing.Optional[str]" = None
    gte: "typing.Optional[str]" = None
    lt: "typing.Optional[str]" = None
    lte: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        gt: "typing.Union[str, None, Unset]" = _unset,
        gte: "typing.Union[str, None, Unset]" = _unset,
        lt: "typing.Union[str, None, Unset]" = _unset,
        lte: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(gt, Unset):
            self.gt = gt
        if not isinstance(gte, Unset):
            self.gte = gte
        if not isinstance(lt, Unset):
            self.lt = lt
        if not isinstance(lte, Unset):
            self.lte = lte

    @classmethod
    def from_json(cls, obj: Json) -> "v1TimestampFieldFilter":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "gt" in obj:
            kwargs["gt"] = obj["gt"]
        if "gte" in obj:
            kwargs["gte"] = obj["gte"]
        if "lt" in obj:
            kwargs["lt"] = obj["lt"]
        if "lte" in obj:
            kwargs["lte"] = obj["lte"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "gt" in vars(self):
            out["gt"] = self.gt
        if not omit_unset or "gte" in vars(self):
            out["gte"] = self.gte
        if not omit_unset or "lt" in vars(self):
            out["lt"] = self.lt
        if not omit_unset or "lte" in vars(self):
            out["lte"] = self.lte
        return out

class v1TrialClosed:

    def __init__(
        self,
        *,
        requestId: str,
    ):
        self.requestId = requestId

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialClosed":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "requestId": obj["requestId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "requestId": self.requestId,
        }
        return out

class v1TrialCreated:

    def __init__(
        self,
        *,
        requestId: str,
    ):
        self.requestId = requestId

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialCreated":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "requestId": obj["requestId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "requestId": self.requestId,
        }
        return out

class v1TrialEarlyExit:

    def __init__(
        self,
        *,
        reason: "v1TrialEarlyExitExitedReason",
    ):
        self.reason = reason

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialEarlyExit":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "reason": v1TrialEarlyExitExitedReason(obj["reason"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "reason": self.reason.value,
        }
        return out

class v1TrialEarlyExitExitedReason(enum.Enum):
    EXITED_REASON_UNSPECIFIED = "EXITED_REASON_UNSPECIFIED"
    EXITED_REASON_INVALID_HP = "EXITED_REASON_INVALID_HP"
    EXITED_REASON_INIT_INVALID_HP = "EXITED_REASON_INIT_INVALID_HP"

class v1TrialExitedEarly:

    def __init__(
        self,
        *,
        exitedReason: "v1TrialExitedEarlyExitedReason",
        requestId: str,
    ):
        self.exitedReason = exitedReason
        self.requestId = requestId

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialExitedEarly":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "exitedReason": v1TrialExitedEarlyExitedReason(obj["exitedReason"]),
            "requestId": obj["requestId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "exitedReason": self.exitedReason.value,
            "requestId": self.requestId,
        }
        return out

class v1TrialExitedEarlyExitedReason(enum.Enum):
    EXITED_REASON_UNSPECIFIED = "EXITED_REASON_UNSPECIFIED"
    EXITED_REASON_INVALID_HP = "EXITED_REASON_INVALID_HP"
    EXITED_REASON_USER_REQUESTED_STOP = "EXITED_REASON_USER_REQUESTED_STOP"
    EXITED_REASON_USER_CANCELED = "EXITED_REASON_USER_CANCELED"

class v1TrialFilters:
    endTime: "typing.Optional[v1TimestampFieldFilter]" = None
    experimentIds: "typing.Optional[typing.Sequence[int]]" = None
    hparams: "typing.Optional[typing.Sequence[v1ColumnFilter]]" = None
    projectIds: "typing.Optional[typing.Sequence[int]]" = None
    rankWithinExp: "typing.Optional[TrialFiltersRankWithinExp]" = None
    searcher: "typing.Optional[str]" = None
    searcherMetric: "typing.Optional[str]" = None
    searcherMetricValue: "typing.Optional[v1DoubleFieldFilter]" = None
    startTime: "typing.Optional[v1TimestampFieldFilter]" = None
    states: "typing.Optional[typing.Sequence[determinedtrialv1State]]" = None
    tags: "typing.Optional[typing.Sequence[v1TrialTag]]" = None
    trainingMetrics: "typing.Optional[typing.Sequence[v1ColumnFilter]]" = None
    trialIds: "typing.Optional[typing.Sequence[int]]" = None
    userIds: "typing.Optional[typing.Sequence[int]]" = None
    validationMetrics: "typing.Optional[typing.Sequence[v1ColumnFilter]]" = None
    workspaceIds: "typing.Optional[typing.Sequence[int]]" = None

    def __init__(
        self,
        *,
        endTime: "typing.Union[v1TimestampFieldFilter, None, Unset]" = _unset,
        experimentIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
        hparams: "typing.Union[typing.Sequence[v1ColumnFilter], None, Unset]" = _unset,
        projectIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
        rankWithinExp: "typing.Union[TrialFiltersRankWithinExp, None, Unset]" = _unset,
        searcher: "typing.Union[str, None, Unset]" = _unset,
        searcherMetric: "typing.Union[str, None, Unset]" = _unset,
        searcherMetricValue: "typing.Union[v1DoubleFieldFilter, None, Unset]" = _unset,
        startTime: "typing.Union[v1TimestampFieldFilter, None, Unset]" = _unset,
        states: "typing.Union[typing.Sequence[determinedtrialv1State], None, Unset]" = _unset,
        tags: "typing.Union[typing.Sequence[v1TrialTag], None, Unset]" = _unset,
        trainingMetrics: "typing.Union[typing.Sequence[v1ColumnFilter], None, Unset]" = _unset,
        trialIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
        userIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
        validationMetrics: "typing.Union[typing.Sequence[v1ColumnFilter], None, Unset]" = _unset,
        workspaceIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
    ):
        if not isinstance(endTime, Unset):
            self.endTime = endTime
        if not isinstance(experimentIds, Unset):
            self.experimentIds = experimentIds
        if not isinstance(hparams, Unset):
            self.hparams = hparams
        if not isinstance(projectIds, Unset):
            self.projectIds = projectIds
        if not isinstance(rankWithinExp, Unset):
            self.rankWithinExp = rankWithinExp
        if not isinstance(searcher, Unset):
            self.searcher = searcher
        if not isinstance(searcherMetric, Unset):
            self.searcherMetric = searcherMetric
        if not isinstance(searcherMetricValue, Unset):
            self.searcherMetricValue = searcherMetricValue
        if not isinstance(startTime, Unset):
            self.startTime = startTime
        if not isinstance(states, Unset):
            self.states = states
        if not isinstance(tags, Unset):
            self.tags = tags
        if not isinstance(trainingMetrics, Unset):
            self.trainingMetrics = trainingMetrics
        if not isinstance(trialIds, Unset):
            self.trialIds = trialIds
        if not isinstance(userIds, Unset):
            self.userIds = userIds
        if not isinstance(validationMetrics, Unset):
            self.validationMetrics = validationMetrics
        if not isinstance(workspaceIds, Unset):
            self.workspaceIds = workspaceIds

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialFilters":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "endTime" in obj:
            kwargs["endTime"] = v1TimestampFieldFilter.from_json(obj["endTime"]) if obj["endTime"] is not None else None
        if "experimentIds" in obj:
            kwargs["experimentIds"] = obj["experimentIds"]
        if "hparams" in obj:
            kwargs["hparams"] = [v1ColumnFilter.from_json(x) for x in obj["hparams"]] if obj["hparams"] is not None else None
        if "projectIds" in obj:
            kwargs["projectIds"] = obj["projectIds"]
        if "rankWithinExp" in obj:
            kwargs["rankWithinExp"] = TrialFiltersRankWithinExp.from_json(obj["rankWithinExp"]) if obj["rankWithinExp"] is not None else None
        if "searcher" in obj:
            kwargs["searcher"] = obj["searcher"]
        if "searcherMetric" in obj:
            kwargs["searcherMetric"] = obj["searcherMetric"]
        if "searcherMetricValue" in obj:
            kwargs["searcherMetricValue"] = v1DoubleFieldFilter.from_json(obj["searcherMetricValue"]) if obj["searcherMetricValue"] is not None else None
        if "startTime" in obj:
            kwargs["startTime"] = v1TimestampFieldFilter.from_json(obj["startTime"]) if obj["startTime"] is not None else None
        if "states" in obj:
            kwargs["states"] = [determinedtrialv1State(x) for x in obj["states"]] if obj["states"] is not None else None
        if "tags" in obj:
            kwargs["tags"] = [v1TrialTag.from_json(x) for x in obj["tags"]] if obj["tags"] is not None else None
        if "trainingMetrics" in obj:
            kwargs["trainingMetrics"] = [v1ColumnFilter.from_json(x) for x in obj["trainingMetrics"]] if obj["trainingMetrics"] is not None else None
        if "trialIds" in obj:
            kwargs["trialIds"] = obj["trialIds"]
        if "userIds" in obj:
            kwargs["userIds"] = obj["userIds"]
        if "validationMetrics" in obj:
            kwargs["validationMetrics"] = [v1ColumnFilter.from_json(x) for x in obj["validationMetrics"]] if obj["validationMetrics"] is not None else None
        if "workspaceIds" in obj:
            kwargs["workspaceIds"] = obj["workspaceIds"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "endTime" in vars(self):
            out["endTime"] = None if self.endTime is None else self.endTime.to_json(omit_unset)
        if not omit_unset or "experimentIds" in vars(self):
            out["experimentIds"] = self.experimentIds
        if not omit_unset or "hparams" in vars(self):
            out["hparams"] = None if self.hparams is None else [x.to_json(omit_unset) for x in self.hparams]
        if not omit_unset or "projectIds" in vars(self):
            out["projectIds"] = self.projectIds
        if not omit_unset or "rankWithinExp" in vars(self):
            out["rankWithinExp"] = None if self.rankWithinExp is None else self.rankWithinExp.to_json(omit_unset)
        if not omit_unset or "searcher" in vars(self):
            out["searcher"] = self.searcher
        if not omit_unset or "searcherMetric" in vars(self):
            out["searcherMetric"] = self.searcherMetric
        if not omit_unset or "searcherMetricValue" in vars(self):
            out["searcherMetricValue"] = None if self.searcherMetricValue is None else self.searcherMetricValue.to_json(omit_unset)
        if not omit_unset or "startTime" in vars(self):
            out["startTime"] = None if self.startTime is None else self.startTime.to_json(omit_unset)
        if not omit_unset or "states" in vars(self):
            out["states"] = None if self.states is None else [x.value for x in self.states]
        if not omit_unset or "tags" in vars(self):
            out["tags"] = None if self.tags is None else [x.to_json(omit_unset) for x in self.tags]
        if not omit_unset or "trainingMetrics" in vars(self):
            out["trainingMetrics"] = None if self.trainingMetrics is None else [x.to_json(omit_unset) for x in self.trainingMetrics]
        if not omit_unset or "trialIds" in vars(self):
            out["trialIds"] = self.trialIds
        if not omit_unset or "userIds" in vars(self):
            out["userIds"] = self.userIds
        if not omit_unset or "validationMetrics" in vars(self):
            out["validationMetrics"] = None if self.validationMetrics is None else [x.to_json(omit_unset) for x in self.validationMetrics]
        if not omit_unset or "workspaceIds" in vars(self):
            out["workspaceIds"] = self.workspaceIds
        return out

class v1TrialLogsFieldsResponse:
    agentIds: "typing.Optional[typing.Sequence[str]]" = None
    containerIds: "typing.Optional[typing.Sequence[str]]" = None
    rankIds: "typing.Optional[typing.Sequence[int]]" = None
    sources: "typing.Optional[typing.Sequence[str]]" = None
    stdtypes: "typing.Optional[typing.Sequence[str]]" = None

    def __init__(
        self,
        *,
        agentIds: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        containerIds: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        rankIds: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
        sources: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
        stdtypes: "typing.Union[typing.Sequence[str], None, Unset]" = _unset,
    ):
        if not isinstance(agentIds, Unset):
            self.agentIds = agentIds
        if not isinstance(containerIds, Unset):
            self.containerIds = containerIds
        if not isinstance(rankIds, Unset):
            self.rankIds = rankIds
        if not isinstance(sources, Unset):
            self.sources = sources
        if not isinstance(stdtypes, Unset):
            self.stdtypes = stdtypes

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialLogsFieldsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "agentIds" in obj:
            kwargs["agentIds"] = obj["agentIds"]
        if "containerIds" in obj:
            kwargs["containerIds"] = obj["containerIds"]
        if "rankIds" in obj:
            kwargs["rankIds"] = obj["rankIds"]
        if "sources" in obj:
            kwargs["sources"] = obj["sources"]
        if "stdtypes" in obj:
            kwargs["stdtypes"] = obj["stdtypes"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "agentIds" in vars(self):
            out["agentIds"] = self.agentIds
        if not omit_unset or "containerIds" in vars(self):
            out["containerIds"] = self.containerIds
        if not omit_unset or "rankIds" in vars(self):
            out["rankIds"] = self.rankIds
        if not omit_unset or "sources" in vars(self):
            out["sources"] = self.sources
        if not omit_unset or "stdtypes" in vars(self):
            out["stdtypes"] = self.stdtypes
        return out

class v1TrialLogsResponse:
    agentId: "typing.Optional[str]" = None
    containerId: "typing.Optional[str]" = None
    log: "typing.Optional[str]" = None
    rankId: "typing.Optional[int]" = None
    source: "typing.Optional[str]" = None
    stdtype: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        id: str,
        level: "v1LogLevel",
        message: str,
        timestamp: str,
        trialId: int,
        agentId: "typing.Union[str, None, Unset]" = _unset,
        containerId: "typing.Union[str, None, Unset]" = _unset,
        log: "typing.Union[str, None, Unset]" = _unset,
        rankId: "typing.Union[int, None, Unset]" = _unset,
        source: "typing.Union[str, None, Unset]" = _unset,
        stdtype: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.id = id
        self.level = level
        self.message = message
        self.timestamp = timestamp
        self.trialId = trialId
        if not isinstance(agentId, Unset):
            self.agentId = agentId
        if not isinstance(containerId, Unset):
            self.containerId = containerId
        if not isinstance(log, Unset):
            self.log = log
        if not isinstance(rankId, Unset):
            self.rankId = rankId
        if not isinstance(source, Unset):
            self.source = source
        if not isinstance(stdtype, Unset):
            self.stdtype = stdtype

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialLogsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "id": obj["id"],
            "level": v1LogLevel(obj["level"]),
            "message": obj["message"],
            "timestamp": obj["timestamp"],
            "trialId": obj["trialId"],
        }
        if "agentId" in obj:
            kwargs["agentId"] = obj["agentId"]
        if "containerId" in obj:
            kwargs["containerId"] = obj["containerId"]
        if "log" in obj:
            kwargs["log"] = obj["log"]
        if "rankId" in obj:
            kwargs["rankId"] = obj["rankId"]
        if "source" in obj:
            kwargs["source"] = obj["source"]
        if "stdtype" in obj:
            kwargs["stdtype"] = obj["stdtype"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "id": self.id,
            "level": self.level.value,
            "message": self.message,
            "timestamp": self.timestamp,
            "trialId": self.trialId,
        }
        if not omit_unset or "agentId" in vars(self):
            out["agentId"] = self.agentId
        if not omit_unset or "containerId" in vars(self):
            out["containerId"] = self.containerId
        if not omit_unset or "log" in vars(self):
            out["log"] = self.log
        if not omit_unset or "rankId" in vars(self):
            out["rankId"] = self.rankId
        if not omit_unset or "source" in vars(self):
            out["source"] = self.source
        if not omit_unset or "stdtype" in vars(self):
            out["stdtype"] = self.stdtype
        return out

class v1TrialMetrics:

    def __init__(
        self,
        *,
        metrics: "v1Metrics",
        stepsCompleted: int,
        trialId: int,
        trialRunId: int,
    ):
        self.metrics = metrics
        self.stepsCompleted = stepsCompleted
        self.trialId = trialId
        self.trialRunId = trialRunId

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialMetrics":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "metrics": v1Metrics.from_json(obj["metrics"]),
            "stepsCompleted": obj["stepsCompleted"],
            "trialId": obj["trialId"],
            "trialRunId": obj["trialRunId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "metrics": self.metrics.to_json(omit_unset),
            "stepsCompleted": self.stepsCompleted,
            "trialId": self.trialId,
            "trialRunId": self.trialRunId,
        }
        return out

class v1TrialOperation:
    validateAfter: "typing.Optional[v1ValidateAfterOperation]" = None

    def __init__(
        self,
        *,
        validateAfter: "typing.Union[v1ValidateAfterOperation, None, Unset]" = _unset,
    ):
        if not isinstance(validateAfter, Unset):
            self.validateAfter = validateAfter

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialOperation":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "validateAfter" in obj:
            kwargs["validateAfter"] = v1ValidateAfterOperation.from_json(obj["validateAfter"]) if obj["validateAfter"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "validateAfter" in vars(self):
            out["validateAfter"] = None if self.validateAfter is None else self.validateAfter.to_json(omit_unset)
        return out

class v1TrialPatch:
    addTag: "typing.Optional[typing.Sequence[v1TrialTag]]" = None
    removeTag: "typing.Optional[typing.Sequence[v1TrialTag]]" = None

    def __init__(
        self,
        *,
        addTag: "typing.Union[typing.Sequence[v1TrialTag], None, Unset]" = _unset,
        removeTag: "typing.Union[typing.Sequence[v1TrialTag], None, Unset]" = _unset,
    ):
        if not isinstance(addTag, Unset):
            self.addTag = addTag
        if not isinstance(removeTag, Unset):
            self.removeTag = removeTag

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialPatch":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "addTag" in obj:
            kwargs["addTag"] = [v1TrialTag.from_json(x) for x in obj["addTag"]] if obj["addTag"] is not None else None
        if "removeTag" in obj:
            kwargs["removeTag"] = [v1TrialTag.from_json(x) for x in obj["removeTag"]] if obj["removeTag"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "addTag" in vars(self):
            out["addTag"] = None if self.addTag is None else [x.to_json(omit_unset) for x in self.addTag]
        if not omit_unset or "removeTag" in vars(self):
            out["removeTag"] = None if self.removeTag is None else [x.to_json(omit_unset) for x in self.removeTag]
        return out

class v1TrialProfilerMetricLabels:
    agentId: "typing.Optional[str]" = None
    gpuUuid: "typing.Optional[str]" = None
    metricType: "typing.Optional[TrialProfilerMetricLabelsProfilerMetricType]" = None

    def __init__(
        self,
        *,
        name: str,
        trialId: int,
        agentId: "typing.Union[str, None, Unset]" = _unset,
        gpuUuid: "typing.Union[str, None, Unset]" = _unset,
        metricType: "typing.Union[TrialProfilerMetricLabelsProfilerMetricType, None, Unset]" = _unset,
    ):
        self.name = name
        self.trialId = trialId
        if not isinstance(agentId, Unset):
            self.agentId = agentId
        if not isinstance(gpuUuid, Unset):
            self.gpuUuid = gpuUuid
        if not isinstance(metricType, Unset):
            self.metricType = metricType

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialProfilerMetricLabels":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "name": obj["name"],
            "trialId": obj["trialId"],
        }
        if "agentId" in obj:
            kwargs["agentId"] = obj["agentId"]
        if "gpuUuid" in obj:
            kwargs["gpuUuid"] = obj["gpuUuid"]
        if "metricType" in obj:
            kwargs["metricType"] = TrialProfilerMetricLabelsProfilerMetricType(obj["metricType"]) if obj["metricType"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "name": self.name,
            "trialId": self.trialId,
        }
        if not omit_unset or "agentId" in vars(self):
            out["agentId"] = self.agentId
        if not omit_unset or "gpuUuid" in vars(self):
            out["gpuUuid"] = self.gpuUuid
        if not omit_unset or "metricType" in vars(self):
            out["metricType"] = None if self.metricType is None else self.metricType.value
        return out

class v1TrialProfilerMetricsBatch:

    def __init__(
        self,
        *,
        batches: "typing.Sequence[int]",
        labels: "v1TrialProfilerMetricLabels",
        timestamps: "typing.Sequence[str]",
        values: "typing.Sequence[float]",
    ):
        self.batches = batches
        self.labels = labels
        self.timestamps = timestamps
        self.values = values

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialProfilerMetricsBatch":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "batches": obj["batches"],
            "labels": v1TrialProfilerMetricLabels.from_json(obj["labels"]),
            "timestamps": obj["timestamps"],
            "values": [float(x) for x in obj["values"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "batches": self.batches,
            "labels": self.labels.to_json(omit_unset),
            "timestamps": self.timestamps,
            "values": [dump_float(x) for x in self.values],
        }
        return out

class v1TrialProgress:

    def __init__(
        self,
        *,
        partialUnits: float,
        requestId: str,
    ):
        self.partialUnits = partialUnits
        self.requestId = requestId

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialProgress":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "partialUnits": float(obj["partialUnits"]),
            "requestId": obj["requestId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "partialUnits": dump_float(self.partialUnits),
            "requestId": self.requestId,
        }
        return out

class v1TrialRunnerMetadata:

    def __init__(
        self,
        *,
        state: str,
    ):
        self.state = state

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialRunnerMetadata":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "state": obj["state"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "state": self.state,
        }
        return out

class v1TrialSimulation:
    occurrences: "typing.Optional[int]" = None
    operations: "typing.Optional[typing.Sequence[v1RunnableOperation]]" = None

    def __init__(
        self,
        *,
        occurrences: "typing.Union[int, None, Unset]" = _unset,
        operations: "typing.Union[typing.Sequence[v1RunnableOperation], None, Unset]" = _unset,
    ):
        if not isinstance(occurrences, Unset):
            self.occurrences = occurrences
        if not isinstance(operations, Unset):
            self.operations = operations

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialSimulation":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "occurrences" in obj:
            kwargs["occurrences"] = obj["occurrences"]
        if "operations" in obj:
            kwargs["operations"] = [v1RunnableOperation.from_json(x) for x in obj["operations"]] if obj["operations"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "occurrences" in vars(self):
            out["occurrences"] = self.occurrences
        if not omit_unset or "operations" in vars(self):
            out["operations"] = None if self.operations is None else [x.to_json(omit_unset) for x in self.operations]
        return out

class v1TrialSorter:
    orderBy: "typing.Optional[v1OrderBy]" = None

    def __init__(
        self,
        *,
        field: str,
        namespace: "TrialSorterNamespace",
        orderBy: "typing.Union[v1OrderBy, None, Unset]" = _unset,
    ):
        self.field = field
        self.namespace = namespace
        if not isinstance(orderBy, Unset):
            self.orderBy = orderBy

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialSorter":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "field": obj["field"],
            "namespace": TrialSorterNamespace(obj["namespace"]),
        }
        if "orderBy" in obj:
            kwargs["orderBy"] = v1OrderBy(obj["orderBy"]) if obj["orderBy"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "field": self.field,
            "namespace": self.namespace.value,
        }
        if not omit_unset or "orderBy" in vars(self):
            out["orderBy"] = None if self.orderBy is None else self.orderBy.value
        return out

class v1TrialTag:

    def __init__(
        self,
        *,
        key: str,
    ):
        self.key = key

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialTag":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "key": obj["key"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "key": self.key,
        }
        return out

class v1TrialsCollection:

    def __init__(
        self,
        *,
        filters: "v1TrialFilters",
        id: int,
        name: str,
        projectId: int,
        sorter: "v1TrialSorter",
        userId: int,
    ):
        self.filters = filters
        self.id = id
        self.name = name
        self.projectId = projectId
        self.sorter = sorter
        self.userId = userId

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialsCollection":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "filters": v1TrialFilters.from_json(obj["filters"]),
            "id": obj["id"],
            "name": obj["name"],
            "projectId": obj["projectId"],
            "sorter": v1TrialSorter.from_json(obj["sorter"]),
            "userId": obj["userId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "filters": self.filters.to_json(omit_unset),
            "id": self.id,
            "name": self.name,
            "projectId": self.projectId,
            "sorter": self.sorter.to_json(omit_unset),
            "userId": self.userId,
        }
        return out

class v1TrialsSampleResponse:

    def __init__(
        self,
        *,
        demotedTrials: "typing.Sequence[int]",
        promotedTrials: "typing.Sequence[int]",
        trials: "typing.Sequence[v1TrialsSampleResponseTrial]",
    ):
        self.demotedTrials = demotedTrials
        self.promotedTrials = promotedTrials
        self.trials = trials

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialsSampleResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "demotedTrials": obj["demotedTrials"],
            "promotedTrials": obj["promotedTrials"],
            "trials": [v1TrialsSampleResponseTrial.from_json(x) for x in obj["trials"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "demotedTrials": self.demotedTrials,
            "promotedTrials": self.promotedTrials,
            "trials": [x.to_json(omit_unset) for x in self.trials],
        }
        return out

class v1TrialsSampleResponseTrial:

    def __init__(
        self,
        *,
        data: "typing.Sequence[v1DataPoint]",
        hparams: "typing.Dict[str, typing.Any]",
        trialId: int,
    ):
        self.data = data
        self.hparams = hparams
        self.trialId = trialId

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialsSampleResponseTrial":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "data": [v1DataPoint.from_json(x) for x in obj["data"]],
            "hparams": obj["hparams"],
            "trialId": obj["trialId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "data": [x.to_json(omit_unset) for x in self.data],
            "hparams": self.hparams,
            "trialId": self.trialId,
        }
        return out

class v1TrialsSnapshotResponse:

    def __init__(
        self,
        *,
        trials: "typing.Sequence[v1TrialsSnapshotResponseTrial]",
    ):
        self.trials = trials

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialsSnapshotResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "trials": [v1TrialsSnapshotResponseTrial.from_json(x) for x in obj["trials"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "trials": [x.to_json(omit_unset) for x in self.trials],
        }
        return out

class v1TrialsSnapshotResponseTrial:

    def __init__(
        self,
        *,
        batchesProcessed: int,
        hparams: "typing.Dict[str, typing.Any]",
        metric: float,
        trialId: int,
    ):
        self.batchesProcessed = batchesProcessed
        self.hparams = hparams
        self.metric = metric
        self.trialId = trialId

    @classmethod
    def from_json(cls, obj: Json) -> "v1TrialsSnapshotResponseTrial":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "batchesProcessed": obj["batchesProcessed"],
            "hparams": obj["hparams"],
            "metric": float(obj["metric"]),
            "trialId": obj["trialId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "batchesProcessed": self.batchesProcessed,
            "hparams": self.hparams,
            "metric": dump_float(self.metric),
            "trialId": self.trialId,
        }
        return out

class v1Trigger:
    condition: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    id: "typing.Optional[int]" = None
    triggerType: "typing.Optional[v1TriggerType]" = None
    webhookId: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        condition: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        id: "typing.Union[int, None, Unset]" = _unset,
        triggerType: "typing.Union[v1TriggerType, None, Unset]" = _unset,
        webhookId: "typing.Union[int, None, Unset]" = _unset,
    ):
        if not isinstance(condition, Unset):
            self.condition = condition
        if not isinstance(id, Unset):
            self.id = id
        if not isinstance(triggerType, Unset):
            self.triggerType = triggerType
        if not isinstance(webhookId, Unset):
            self.webhookId = webhookId

    @classmethod
    def from_json(cls, obj: Json) -> "v1Trigger":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "condition" in obj:
            kwargs["condition"] = obj["condition"]
        if "id" in obj:
            kwargs["id"] = obj["id"]
        if "triggerType" in obj:
            kwargs["triggerType"] = v1TriggerType(obj["triggerType"]) if obj["triggerType"] is not None else None
        if "webhookId" in obj:
            kwargs["webhookId"] = obj["webhookId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "condition" in vars(self):
            out["condition"] = self.condition
        if not omit_unset or "id" in vars(self):
            out["id"] = self.id
        if not omit_unset or "triggerType" in vars(self):
            out["triggerType"] = None if self.triggerType is None else self.triggerType.value
        if not omit_unset or "webhookId" in vars(self):
            out["webhookId"] = self.webhookId
        return out

class v1TriggerType(enum.Enum):
    TRIGGER_TYPE_UNSPECIFIED = "TRIGGER_TYPE_UNSPECIFIED"
    TRIGGER_TYPE_EXPERIMENT_STATE_CHANGE = "TRIGGER_TYPE_EXPERIMENT_STATE_CHANGE"
    TRIGGER_TYPE_METRIC_THRESHOLD_EXCEEDED = "TRIGGER_TYPE_METRIC_THRESHOLD_EXCEEDED"

class v1UpdateGroupRequest:
    addUsers: "typing.Optional[typing.Sequence[int]]" = None
    name: "typing.Optional[str]" = None
    removeUsers: "typing.Optional[typing.Sequence[int]]" = None

    def __init__(
        self,
        *,
        groupId: int,
        addUsers: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
        name: "typing.Union[str, None, Unset]" = _unset,
        removeUsers: "typing.Union[typing.Sequence[int], None, Unset]" = _unset,
    ):
        self.groupId = groupId
        if not isinstance(addUsers, Unset):
            self.addUsers = addUsers
        if not isinstance(name, Unset):
            self.name = name
        if not isinstance(removeUsers, Unset):
            self.removeUsers = removeUsers

    @classmethod
    def from_json(cls, obj: Json) -> "v1UpdateGroupRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "groupId": obj["groupId"],
        }
        if "addUsers" in obj:
            kwargs["addUsers"] = obj["addUsers"]
        if "name" in obj:
            kwargs["name"] = obj["name"]
        if "removeUsers" in obj:
            kwargs["removeUsers"] = obj["removeUsers"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "groupId": self.groupId,
        }
        if not omit_unset or "addUsers" in vars(self):
            out["addUsers"] = self.addUsers
        if not omit_unset or "name" in vars(self):
            out["name"] = self.name
        if not omit_unset or "removeUsers" in vars(self):
            out["removeUsers"] = self.removeUsers
        return out

class v1UpdateGroupResponse:

    def __init__(
        self,
        *,
        group: "v1GroupDetails",
    ):
        self.group = group

    @classmethod
    def from_json(cls, obj: Json) -> "v1UpdateGroupResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "group": v1GroupDetails.from_json(obj["group"]),
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "group": self.group.to_json(omit_unset),
        }
        return out

class v1UpdateJobQueueRequest:

    def __init__(
        self,
        *,
        updates: "typing.Sequence[v1QueueControl]",
    ):
        self.updates = updates

    @classmethod
    def from_json(cls, obj: Json) -> "v1UpdateJobQueueRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "updates": [v1QueueControl.from_json(x) for x in obj["updates"]],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "updates": [x.to_json(omit_unset) for x in self.updates],
        }
        return out

class v1UpdateTrialTagsRequest:
    filters: "typing.Optional[v1TrialFilters]" = None
    trial: "typing.Optional[UpdateTrialTagsRequestIds]" = None

    def __init__(
        self,
        *,
        patch: "v1TrialPatch",
        filters: "typing.Union[v1TrialFilters, None, Unset]" = _unset,
        trial: "typing.Union[UpdateTrialTagsRequestIds, None, Unset]" = _unset,
    ):
        self.patch = patch
        if not isinstance(filters, Unset):
            self.filters = filters
        if not isinstance(trial, Unset):
            self.trial = trial

    @classmethod
    def from_json(cls, obj: Json) -> "v1UpdateTrialTagsRequest":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "patch": v1TrialPatch.from_json(obj["patch"]),
        }
        if "filters" in obj:
            kwargs["filters"] = v1TrialFilters.from_json(obj["filters"]) if obj["filters"] is not None else None
        if "trial" in obj:
            kwargs["trial"] = UpdateTrialTagsRequestIds.from_json(obj["trial"]) if obj["trial"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "patch": self.patch.to_json(omit_unset),
        }
        if not omit_unset or "filters" in vars(self):
            out["filters"] = None if self.filters is None else self.filters.to_json(omit_unset)
        if not omit_unset or "trial" in vars(self):
            out["trial"] = None if self.trial is None else self.trial.to_json(omit_unset)
        return out

class v1UpdateTrialTagsResponse:
    rowsAffected: "typing.Optional[int]" = None

    def __init__(
        self,
        *,
        rowsAffected: "typing.Union[int, None, Unset]" = _unset,
    ):
        if not isinstance(rowsAffected, Unset):
            self.rowsAffected = rowsAffected

    @classmethod
    def from_json(cls, obj: Json) -> "v1UpdateTrialTagsResponse":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "rowsAffected" in obj:
            kwargs["rowsAffected"] = obj["rowsAffected"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "rowsAffected" in vars(self):
            out["rowsAffected"] = self.rowsAffected
        return out

class v1User:
    agentUserGroup: "typing.Optional[v1AgentUserGroup]" = None
    displayName: "typing.Optional[str]" = None
    id: "typing.Optional[int]" = None
    modifiedAt: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        active: bool,
        admin: bool,
        username: str,
        agentUserGroup: "typing.Union[v1AgentUserGroup, None, Unset]" = _unset,
        displayName: "typing.Union[str, None, Unset]" = _unset,
        id: "typing.Union[int, None, Unset]" = _unset,
        modifiedAt: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.active = active
        self.admin = admin
        self.username = username
        if not isinstance(agentUserGroup, Unset):
            self.agentUserGroup = agentUserGroup
        if not isinstance(displayName, Unset):
            self.displayName = displayName
        if not isinstance(id, Unset):
            self.id = id
        if not isinstance(modifiedAt, Unset):
            self.modifiedAt = modifiedAt

    @classmethod
    def from_json(cls, obj: Json) -> "v1User":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "active": obj["active"],
            "admin": obj["admin"],
            "username": obj["username"],
        }
        if "agentUserGroup" in obj:
            kwargs["agentUserGroup"] = v1AgentUserGroup.from_json(obj["agentUserGroup"]) if obj["agentUserGroup"] is not None else None
        if "displayName" in obj:
            kwargs["displayName"] = obj["displayName"]
        if "id" in obj:
            kwargs["id"] = obj["id"]
        if "modifiedAt" in obj:
            kwargs["modifiedAt"] = obj["modifiedAt"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "active": self.active,
            "admin": self.admin,
            "username": self.username,
        }
        if not omit_unset or "agentUserGroup" in vars(self):
            out["agentUserGroup"] = None if self.agentUserGroup is None else self.agentUserGroup.to_json(omit_unset)
        if not omit_unset or "displayName" in vars(self):
            out["displayName"] = self.displayName
        if not omit_unset or "id" in vars(self):
            out["id"] = self.id
        if not omit_unset or "modifiedAt" in vars(self):
            out["modifiedAt"] = self.modifiedAt
        return out

class v1UserRoleAssignment:

    def __init__(
        self,
        *,
        roleAssignment: "v1RoleAssignment",
        userId: int,
    ):
        self.roleAssignment = roleAssignment
        self.userId = userId

    @classmethod
    def from_json(cls, obj: Json) -> "v1UserRoleAssignment":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "roleAssignment": v1RoleAssignment.from_json(obj["roleAssignment"]),
            "userId": obj["userId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "roleAssignment": self.roleAssignment.to_json(omit_unset),
            "userId": self.userId,
        }
        return out

class v1UserWebSetting:
    storagePath: "typing.Optional[str]" = None
    value: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        key: str,
        storagePath: "typing.Union[str, None, Unset]" = _unset,
        value: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.key = key
        if not isinstance(storagePath, Unset):
            self.storagePath = storagePath
        if not isinstance(value, Unset):
            self.value = value

    @classmethod
    def from_json(cls, obj: Json) -> "v1UserWebSetting":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "key": obj["key"],
        }
        if "storagePath" in obj:
            kwargs["storagePath"] = obj["storagePath"]
        if "value" in obj:
            kwargs["value"] = obj["value"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "key": self.key,
        }
        if not omit_unset or "storagePath" in vars(self):
            out["storagePath"] = self.storagePath
        if not omit_unset or "value" in vars(self):
            out["value"] = self.value
        return out

class v1ValidateAfterOperation:
    length: "typing.Optional[str]" = None
    requestId: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        length: "typing.Union[str, None, Unset]" = _unset,
        requestId: "typing.Union[str, None, Unset]" = _unset,
    ):
        if not isinstance(length, Unset):
            self.length = length
        if not isinstance(requestId, Unset):
            self.requestId = requestId

    @classmethod
    def from_json(cls, obj: Json) -> "v1ValidateAfterOperation":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "length" in obj:
            kwargs["length"] = obj["length"]
        if "requestId" in obj:
            kwargs["requestId"] = obj["requestId"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "length" in vars(self):
            out["length"] = self.length
        if not omit_unset or "requestId" in vars(self):
            out["requestId"] = self.requestId
        return out

class v1ValidationCompleted:

    def __init__(
        self,
        *,
        metric: float,
        requestId: str,
        validateAfterLength: str,
    ):
        self.metric = metric
        self.requestId = requestId
        self.validateAfterLength = validateAfterLength

    @classmethod
    def from_json(cls, obj: Json) -> "v1ValidationCompleted":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "metric": float(obj["metric"]),
            "requestId": obj["requestId"],
            "validateAfterLength": obj["validateAfterLength"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "metric": dump_float(self.metric),
            "requestId": self.requestId,
            "validateAfterLength": self.validateAfterLength,
        }
        return out

class v1ValidationHistoryEntry:

    def __init__(
        self,
        *,
        endTime: str,
        searcherMetric: float,
        trialId: int,
    ):
        self.endTime = endTime
        self.searcherMetric = searcherMetric
        self.trialId = trialId

    @classmethod
    def from_json(cls, obj: Json) -> "v1ValidationHistoryEntry":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "endTime": obj["endTime"],
            "searcherMetric": float(obj["searcherMetric"]),
            "trialId": obj["trialId"],
        }
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "endTime": self.endTime,
            "searcherMetric": dump_float(self.searcherMetric),
            "trialId": self.trialId,
        }
        return out

class v1Webhook:
    id: "typing.Optional[int]" = None
    triggers: "typing.Optional[typing.Sequence[v1Trigger]]" = None

    def __init__(
        self,
        *,
        url: str,
        webhookType: "v1WebhookType",
        id: "typing.Union[int, None, Unset]" = _unset,
        triggers: "typing.Union[typing.Sequence[v1Trigger], None, Unset]" = _unset,
    ):
        self.url = url
        self.webhookType = webhookType
        if not isinstance(id, Unset):
            self.id = id
        if not isinstance(triggers, Unset):
            self.triggers = triggers

    @classmethod
    def from_json(cls, obj: Json) -> "v1Webhook":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "url": obj["url"],
            "webhookType": v1WebhookType(obj["webhookType"]),
        }
        if "id" in obj:
            kwargs["id"] = obj["id"]
        if "triggers" in obj:
            kwargs["triggers"] = [v1Trigger.from_json(x) for x in obj["triggers"]] if obj["triggers"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "url": self.url,
            "webhookType": self.webhookType.value,
        }
        if not omit_unset or "id" in vars(self):
            out["id"] = self.id
        if not omit_unset or "triggers" in vars(self):
            out["triggers"] = None if self.triggers is None else [x.to_json(omit_unset) for x in self.triggers]
        return out

class v1WebhookType(enum.Enum):
    WEBHOOK_TYPE_UNSPECIFIED = "WEBHOOK_TYPE_UNSPECIFIED"
    WEBHOOK_TYPE_DEFAULT = "WEBHOOK_TYPE_DEFAULT"
    WEBHOOK_TYPE_SLACK = "WEBHOOK_TYPE_SLACK"

class v1WorkloadContainer:
    checkpoint: "typing.Optional[v1CheckpointWorkload]" = None
    training: "typing.Optional[v1MetricsWorkload]" = None
    validation: "typing.Optional[v1MetricsWorkload]" = None

    def __init__(
        self,
        *,
        checkpoint: "typing.Union[v1CheckpointWorkload, None, Unset]" = _unset,
        training: "typing.Union[v1MetricsWorkload, None, Unset]" = _unset,
        validation: "typing.Union[v1MetricsWorkload, None, Unset]" = _unset,
    ):
        if not isinstance(checkpoint, Unset):
            self.checkpoint = checkpoint
        if not isinstance(training, Unset):
            self.training = training
        if not isinstance(validation, Unset):
            self.validation = validation

    @classmethod
    def from_json(cls, obj: Json) -> "v1WorkloadContainer":
        kwargs: "typing.Dict[str, typing.Any]" = {
        }
        if "checkpoint" in obj:
            kwargs["checkpoint"] = v1CheckpointWorkload.from_json(obj["checkpoint"]) if obj["checkpoint"] is not None else None
        if "training" in obj:
            kwargs["training"] = v1MetricsWorkload.from_json(obj["training"]) if obj["training"] is not None else None
        if "validation" in obj:
            kwargs["validation"] = v1MetricsWorkload.from_json(obj["validation"]) if obj["validation"] is not None else None
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
        }
        if not omit_unset or "checkpoint" in vars(self):
            out["checkpoint"] = None if self.checkpoint is None else self.checkpoint.to_json(omit_unset)
        if not omit_unset or "training" in vars(self):
            out["training"] = None if self.training is None else self.training.to_json(omit_unset)
        if not omit_unset or "validation" in vars(self):
            out["validation"] = None if self.validation is None else self.validation.to_json(omit_unset)
        return out

class v1Workspace:
    agentUserGroup: "typing.Optional[v1AgentUserGroup]" = None
    checkpointStorageConfig: "typing.Optional[typing.Dict[str, typing.Any]]" = None
    pinnedAt: "typing.Optional[str]" = None

    def __init__(
        self,
        *,
        archived: bool,
        errorMessage: str,
        id: int,
        immutable: bool,
        name: str,
        numExperiments: int,
        numProjects: int,
        pinned: bool,
        state: "v1WorkspaceState",
        userId: int,
        username: str,
        agentUserGroup: "typing.Union[v1AgentUserGroup, None, Unset]" = _unset,
        checkpointStorageConfig: "typing.Union[typing.Dict[str, typing.Any], None, Unset]" = _unset,
        pinnedAt: "typing.Union[str, None, Unset]" = _unset,
    ):
        self.archived = archived
        self.errorMessage = errorMessage
        self.id = id
        self.immutable = immutable
        self.name = name
        self.numExperiments = numExperiments
        self.numProjects = numProjects
        self.pinned = pinned
        self.state = state
        self.userId = userId
        self.username = username
        if not isinstance(agentUserGroup, Unset):
            self.agentUserGroup = agentUserGroup
        if not isinstance(checkpointStorageConfig, Unset):
            self.checkpointStorageConfig = checkpointStorageConfig
        if not isinstance(pinnedAt, Unset):
            self.pinnedAt = pinnedAt

    @classmethod
    def from_json(cls, obj: Json) -> "v1Workspace":
        kwargs: "typing.Dict[str, typing.Any]" = {
            "archived": obj["archived"],
            "errorMessage": obj["errorMessage"],
            "id": obj["id"],
            "immutable": obj["immutable"],
            "name": obj["name"],
            "numExperiments": obj["numExperiments"],
            "numProjects": obj["numProjects"],
            "pinned": obj["pinned"],
            "state": v1WorkspaceState(obj["state"]),
            "userId": obj["userId"],
            "username": obj["username"],
        }
        if "agentUserGroup" in obj:
            kwargs["agentUserGroup"] = v1AgentUserGroup.from_json(obj["agentUserGroup"]) if obj["agentUserGroup"] is not None else None
        if "checkpointStorageConfig" in obj:
            kwargs["checkpointStorageConfig"] = obj["checkpointStorageConfig"]
        if "pinnedAt" in obj:
            kwargs["pinnedAt"] = obj["pinnedAt"]
        return cls(**kwargs)

    def to_json(self, omit_unset: bool = False) -> typing.Dict[str, typing.Any]:
        out: "typing.Dict[str, typing.Any]" = {
            "archived": self.archived,
            "errorMessage": self.errorMessage,
            "id": self.id,
            "immutable": self.immutable,
            "name": self.name,
            "numExperiments": self.numExperiments,
            "numProjects": self.numProjects,
            "pinned": self.pinned,
            "state": self.state.value,
            "userId": self.userId,
            "username": self.username,
        }
        if not omit_unset or "agentUserGroup" in vars(self):
            out["agentUserGroup"] = None if self.agentUserGroup is None else self.agentUserGroup.to_json(omit_unset)
        if not omit_unset or "checkpointStorageConfig" in vars(self):
            out["checkpointStorageConfig"] = self.checkpointStorageConfig
        if not omit_unset or "pinnedAt" in vars(self):
            out["pinnedAt"] = self.pinnedAt
        return out

class v1WorkspaceState(enum.Enum):
    WORKSPACE_STATE_UNSPECIFIED = "WORKSPACE_STATE_UNSPECIFIED"
    WORKSPACE_STATE_DELETING = "WORKSPACE_STATE_DELETING"
    WORKSPACE_STATE_DELETE_FAILED = "WORKSPACE_STATE_DELETE_FAILED"
    WORKSPACE_STATE_DELETED = "WORKSPACE_STATE_DELETED"

def post_AckAllocationPreemptionSignal(
    session: "api.Session",
    *,
    allocationId: str,
    body: "v1AckAllocationPreemptionSignalRequest",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/allocations/{allocationId}/signals/ack_preemption",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_AckAllocationPreemptionSignal", _resp)

def post_ActivateExperiment(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/experiments/{id}/activate",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_ActivateExperiment", _resp)

def post_AddProjectNote(
    session: "api.Session",
    *,
    body: "v1Note",
    projectId: int,
) -> "v1AddProjectNoteResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/projects/{projectId}/notes",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1AddProjectNoteResponse.from_json(_resp.json())
    raise APIHttpError("post_AddProjectNote", _resp)

def post_AllocationAllGather(
    session: "api.Session",
    *,
    allocationId: str,
    body: "v1AllocationAllGatherRequest",
) -> "v1AllocationAllGatherResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/allocations/{allocationId}/all_gather",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1AllocationAllGatherResponse.from_json(_resp.json())
    raise APIHttpError("post_AllocationAllGather", _resp)

def post_AllocationPendingPreemptionSignal(
    session: "api.Session",
    *,
    allocationId: str,
    body: "v1AllocationPendingPreemptionSignalRequest",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/allocations/{allocationId}/signals/pending_preemption",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_AllocationPendingPreemptionSignal", _resp)

def get_AllocationPreemptionSignal(
    session: "api.Session",
    *,
    allocationId: str,
    timeoutSeconds: "typing.Optional[int]" = None,
) -> "v1AllocationPreemptionSignalResponse":
    _params = {
        "timeoutSeconds": timeoutSeconds,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/allocations/{allocationId}/signals/preemption",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1AllocationPreemptionSignalResponse.from_json(_resp.json())
    raise APIHttpError("get_AllocationPreemptionSignal", _resp)

def post_AllocationReady(
    session: "api.Session",
    *,
    allocationId: str,
    body: "v1AllocationReadyRequest",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/allocations/{allocationId}/ready",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_AllocationReady", _resp)

def get_AllocationRendezvousInfo(
    session: "api.Session",
    *,
    allocationId: str,
    resourcesId: str,
) -> "v1AllocationRendezvousInfoResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/allocations/{allocationId}/resources/{resourcesId}/rendezvous",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1AllocationRendezvousInfoResponse.from_json(_resp.json())
    raise APIHttpError("get_AllocationRendezvousInfo", _resp)

def post_AllocationWaiting(
    session: "api.Session",
    *,
    allocationId: str,
    body: "v1AllocationWaitingRequest",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/allocations/{allocationId}/waiting",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_AllocationWaiting", _resp)

def post_ArchiveExperiment(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/experiments/{id}/archive",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_ArchiveExperiment", _resp)

def post_ArchiveModel(
    session: "api.Session",
    *,
    modelName: str,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/models/{modelName}/archive",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_ArchiveModel", _resp)

def post_ArchiveProject(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/projects/{id}/archive",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_ArchiveProject", _resp)

def post_ArchiveWorkspace(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/workspaces/{id}/archive",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_ArchiveWorkspace", _resp)

def post_AssignRoles(
    session: "api.Session",
    *,
    body: "v1AssignRolesRequest",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/roles/add-assignments",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_AssignRoles", _resp)

def post_CancelExperiment(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/experiments/{id}/cancel",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_CancelExperiment", _resp)

def get_CompareTrials(
    session: "api.Session",
    *,
    endBatches: "typing.Optional[int]" = None,
    maxDatapoints: "typing.Optional[int]" = None,
    metricNames: "typing.Optional[typing.Sequence[str]]" = None,
    metricType: "typing.Optional[v1MetricType]" = None,
    scale: "typing.Optional[v1Scale]" = None,
    startBatches: "typing.Optional[int]" = None,
    trialIds: "typing.Optional[typing.Sequence[int]]" = None,
) -> "v1CompareTrialsResponse":
    _params = {
        "endBatches": endBatches,
        "maxDatapoints": maxDatapoints,
        "metricNames": metricNames,
        "metricType": metricType.value if metricType is not None else None,
        "scale": scale.value if scale is not None else None,
        "startBatches": startBatches,
        "trialIds": trialIds,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/trials/compare",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1CompareTrialsResponse.from_json(_resp.json())
    raise APIHttpError("get_CompareTrials", _resp)

def post_CompleteTrialSearcherValidation(
    session: "api.Session",
    *,
    body: "v1CompleteValidateAfterOperation",
    trialId: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/trials/{trialId}/searcher/completed_operation",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_CompleteTrialSearcherValidation", _resp)

def post_ComputeHPImportance(
    session: "api.Session",
    *,
    experimentId: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/experiments/{experimentId}/hyperparameter-importance",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_ComputeHPImportance", _resp)

def post_CreateExperiment(
    session: "api.Session",
    *,
    body: "v1CreateExperimentRequest",
) -> "v1CreateExperimentResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/experiments",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1CreateExperimentResponse.from_json(_resp.json())
    raise APIHttpError("post_CreateExperiment", _resp)

def post_CreateGroup(
    session: "api.Session",
    *,
    body: "v1CreateGroupRequest",
) -> "v1CreateGroupResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/groups",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1CreateGroupResponse.from_json(_resp.json())
    raise APIHttpError("post_CreateGroup", _resp)

def post_CreateTrialsCollection(
    session: "api.Session",
    *,
    body: "v1CreateTrialsCollectionRequest",
) -> "v1CreateTrialsCollectionResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/trial-comparison/collections",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1CreateTrialsCollectionResponse.from_json(_resp.json())
    raise APIHttpError("post_CreateTrialsCollection", _resp)

def get_CurrentUser(
    session: "api.Session",
) -> "v1CurrentUserResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path="/api/v1/auth/user",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1CurrentUserResponse.from_json(_resp.json())
    raise APIHttpError("get_CurrentUser", _resp)

def delete_DeleteCheckpoints(
    session: "api.Session",
    *,
    body: "v1DeleteCheckpointsRequest",
) -> None:
    _params = None
    _resp = session._do_request(
        method="DELETE",
        path="/api/v1/checkpoints",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("delete_DeleteCheckpoints", _resp)

def delete_DeleteExperiment(
    session: "api.Session",
    *,
    experimentId: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="DELETE",
        path=f"/api/v1/experiments/{experimentId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("delete_DeleteExperiment", _resp)

def delete_DeleteGroup(
    session: "api.Session",
    *,
    groupId: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="DELETE",
        path=f"/api/v1/groups/{groupId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("delete_DeleteGroup", _resp)

def delete_DeleteModel(
    session: "api.Session",
    *,
    modelName: str,
) -> None:
    _params = None
    _resp = session._do_request(
        method="DELETE",
        path=f"/api/v1/models/{modelName}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("delete_DeleteModel", _resp)

def delete_DeleteModelVersion(
    session: "api.Session",
    *,
    modelName: str,
    modelVersionNum: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="DELETE",
        path=f"/api/v1/models/{modelName}/versions/{modelVersionNum}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("delete_DeleteModelVersion", _resp)

def delete_DeleteProject(
    session: "api.Session",
    *,
    id: int,
) -> "v1DeleteProjectResponse":
    _params = None
    _resp = session._do_request(
        method="DELETE",
        path=f"/api/v1/projects/{id}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1DeleteProjectResponse.from_json(_resp.json())
    raise APIHttpError("delete_DeleteProject", _resp)

def delete_DeleteTemplate(
    session: "api.Session",
    *,
    templateName: str,
) -> None:
    _params = None
    _resp = session._do_request(
        method="DELETE",
        path=f"/api/v1/templates/{templateName}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("delete_DeleteTemplate", _resp)

def delete_DeleteTrialsCollection(
    session: "api.Session",
    *,
    id: "typing.Optional[int]" = None,
) -> None:
    _params = {
        "id": id,
    }
    _resp = session._do_request(
        method="DELETE",
        path="/api/v1/trial-comparison/collections",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("delete_DeleteTrialsCollection", _resp)

def delete_DeleteWebhook(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="DELETE",
        path=f"/api/v1/webhooks/{id}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("delete_DeleteWebhook", _resp)

def delete_DeleteWorkspace(
    session: "api.Session",
    *,
    id: int,
) -> "v1DeleteWorkspaceResponse":
    _params = None
    _resp = session._do_request(
        method="DELETE",
        path=f"/api/v1/workspaces/{id}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1DeleteWorkspaceResponse.from_json(_resp.json())
    raise APIHttpError("delete_DeleteWorkspace", _resp)

def post_DisableAgent(
    session: "api.Session",
    *,
    agentId: str,
    body: "v1DisableAgentRequest",
) -> "v1DisableAgentResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/agents/{agentId}/disable",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1DisableAgentResponse.from_json(_resp.json())
    raise APIHttpError("post_DisableAgent", _resp)

def post_DisableSlot(
    session: "api.Session",
    *,
    agentId: str,
    slotId: str,
) -> "v1DisableSlotResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/agents/{agentId}/slots/{slotId}/disable",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1DisableSlotResponse.from_json(_resp.json())
    raise APIHttpError("post_DisableSlot", _resp)

def post_EnableAgent(
    session: "api.Session",
    *,
    agentId: str,
) -> "v1EnableAgentResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/agents/{agentId}/enable",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1EnableAgentResponse.from_json(_resp.json())
    raise APIHttpError("post_EnableAgent", _resp)

def post_EnableSlot(
    session: "api.Session",
    *,
    agentId: str,
    slotId: str,
) -> "v1EnableSlotResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/agents/{agentId}/slots/{slotId}/enable",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1EnableSlotResponse.from_json(_resp.json())
    raise APIHttpError("post_EnableSlot", _resp)

def get_ExpCompareMetricNames(
    session: "api.Session",
    *,
    trialId: "typing.Sequence[int]",
    periodSeconds: "typing.Optional[int]" = None,
) -> "typing.Iterable[v1ExpCompareMetricNamesResponse]":
    _params = {
        "periodSeconds": periodSeconds,
        "trialId": trialId,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/trials/metrics-stream/metric-names",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_ExpCompareMetricNames",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1ExpCompareMetricNamesResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_ExpCompareMetricNames", _resp)

def get_ExpCompareTrialsSample(
    session: "api.Session",
    *,
    experimentIds: "typing.Sequence[int]",
    metricName: str,
    metricType: "v1MetricType",
    endBatches: "typing.Optional[int]" = None,
    maxDatapoints: "typing.Optional[int]" = None,
    maxTrials: "typing.Optional[int]" = None,
    periodSeconds: "typing.Optional[int]" = None,
    startBatches: "typing.Optional[int]" = None,
) -> "typing.Iterable[v1ExpCompareTrialsSampleResponse]":
    _params = {
        "endBatches": endBatches,
        "experimentIds": experimentIds,
        "maxDatapoints": maxDatapoints,
        "maxTrials": maxTrials,
        "metricName": metricName,
        "metricType": metricType.value,
        "periodSeconds": periodSeconds,
        "startBatches": startBatches,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/experiments-compare",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_ExpCompareTrialsSample",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1ExpCompareTrialsSampleResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_ExpCompareTrialsSample", _resp)

def get_GetActiveTasksCount(
    session: "api.Session",
) -> "v1GetActiveTasksCountResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path="/api/v1/tasks/count",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetActiveTasksCountResponse.from_json(_resp.json())
    raise APIHttpError("get_GetActiveTasksCount", _resp)

def get_GetAgent(
    session: "api.Session",
    *,
    agentId: str,
) -> "v1GetAgentResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/agents/{agentId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetAgentResponse.from_json(_resp.json())
    raise APIHttpError("get_GetAgent", _resp)

def get_GetAgents(
    session: "api.Session",
    *,
    label: "typing.Optional[str]" = None,
    limit: "typing.Optional[int]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortBy: "typing.Optional[v1GetAgentsRequestSortBy]" = None,
) -> "v1GetAgentsResponse":
    _params = {
        "label": label,
        "limit": limit,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/agents",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetAgentsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetAgents", _resp)

def get_GetBestSearcherValidationMetric(
    session: "api.Session",
    *,
    experimentId: int,
) -> "v1GetBestSearcherValidationMetricResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/experiments/{experimentId}/searcher/best_searcher_validation_metric",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetBestSearcherValidationMetricResponse.from_json(_resp.json())
    raise APIHttpError("get_GetBestSearcherValidationMetric", _resp)

def get_GetCheckpoint(
    session: "api.Session",
    *,
    checkpointUuid: str,
) -> "v1GetCheckpointResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/checkpoints/{checkpointUuid}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetCheckpointResponse.from_json(_resp.json())
    raise APIHttpError("get_GetCheckpoint", _resp)

def get_GetCommand(
    session: "api.Session",
    *,
    commandId: str,
) -> "v1GetCommandResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/commands/{commandId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetCommandResponse.from_json(_resp.json())
    raise APIHttpError("get_GetCommand", _resp)

def get_GetCommands(
    session: "api.Session",
    *,
    limit: "typing.Optional[int]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortBy: "typing.Optional[v1GetTensorboardsRequestSortBy]" = None,
    userIds: "typing.Optional[typing.Sequence[int]]" = None,
    users: "typing.Optional[typing.Sequence[str]]" = None,
) -> "v1GetCommandsResponse":
    _params = {
        "limit": limit,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
        "userIds": userIds,
        "users": users,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/commands",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetCommandsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetCommands", _resp)

def get_GetCurrentTrialSearcherOperation(
    session: "api.Session",
    *,
    trialId: int,
) -> "v1GetCurrentTrialSearcherOperationResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/trials/{trialId}/searcher/operation",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetCurrentTrialSearcherOperationResponse.from_json(_resp.json())
    raise APIHttpError("get_GetCurrentTrialSearcherOperation", _resp)

def get_GetExperiment(
    session: "api.Session",
    *,
    experimentId: int,
) -> "v1GetExperimentResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/experiments/{experimentId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetExperimentResponse.from_json(_resp.json())
    raise APIHttpError("get_GetExperiment", _resp)

def get_GetExperimentCheckpoints(
    session: "api.Session",
    *,
    id: int,
    limit: "typing.Optional[int]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortBy: "typing.Optional[v1GetExperimentCheckpointsRequestSortBy]" = None,
    states: "typing.Optional[typing.Sequence[determinedcheckpointv1State]]" = None,
) -> "v1GetExperimentCheckpointsResponse":
    _params = {
        "limit": limit,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
        "states": [x.value for x in states] if states is not None else None,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/experiments/{id}/checkpoints",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetExperimentCheckpointsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetExperimentCheckpoints", _resp)

def get_GetExperimentLabels(
    session: "api.Session",
    *,
    projectId: "typing.Optional[int]" = None,
) -> "v1GetExperimentLabelsResponse":
    _params = {
        "projectId": projectId,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/experiment/labels",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetExperimentLabelsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetExperimentLabels", _resp)

def get_GetExperimentTrials(
    session: "api.Session",
    *,
    experimentId: int,
    limit: "typing.Optional[int]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortBy: "typing.Optional[v1GetExperimentTrialsRequestSortBy]" = None,
    states: "typing.Optional[typing.Sequence[determinedexperimentv1State]]" = None,
) -> "v1GetExperimentTrialsResponse":
    _params = {
        "limit": limit,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
        "states": [x.value for x in states] if states is not None else None,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/experiments/{experimentId}/trials",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetExperimentTrialsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetExperimentTrials", _resp)

def get_GetExperimentValidationHistory(
    session: "api.Session",
    *,
    experimentId: int,
) -> "v1GetExperimentValidationHistoryResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/experiments/{experimentId}/validation-history",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetExperimentValidationHistoryResponse.from_json(_resp.json())
    raise APIHttpError("get_GetExperimentValidationHistory", _resp)

def get_GetExperiments(
    session: "api.Session",
    *,
    archived: "typing.Optional[bool]" = None,
    description: "typing.Optional[str]" = None,
    experimentIdFilter_gt: "typing.Optional[int]" = None,
    experimentIdFilter_gte: "typing.Optional[int]" = None,
    experimentIdFilter_incl: "typing.Optional[typing.Sequence[int]]" = None,
    experimentIdFilter_lt: "typing.Optional[int]" = None,
    experimentIdFilter_lte: "typing.Optional[int]" = None,
    experimentIdFilter_notIn: "typing.Optional[typing.Sequence[int]]" = None,
    labels: "typing.Optional[typing.Sequence[str]]" = None,
    limit: "typing.Optional[int]" = None,
    name: "typing.Optional[str]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    projectId: "typing.Optional[int]" = None,
    sortBy: "typing.Optional[v1GetExperimentsRequestSortBy]" = None,
    states: "typing.Optional[typing.Sequence[determinedexperimentv1State]]" = None,
    userIds: "typing.Optional[typing.Sequence[int]]" = None,
    users: "typing.Optional[typing.Sequence[str]]" = None,
) -> "v1GetExperimentsResponse":
    _params = {
        "archived": str(archived).lower() if archived is not None else None,
        "description": description,
        "experimentIdFilter.gt": experimentIdFilter_gt,
        "experimentIdFilter.gte": experimentIdFilter_gte,
        "experimentIdFilter.incl": experimentIdFilter_incl,
        "experimentIdFilter.lt": experimentIdFilter_lt,
        "experimentIdFilter.lte": experimentIdFilter_lte,
        "experimentIdFilter.notIn": experimentIdFilter_notIn,
        "labels": labels,
        "limit": limit,
        "name": name,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "projectId": projectId,
        "sortBy": sortBy.value if sortBy is not None else None,
        "states": [x.value for x in states] if states is not None else None,
        "userIds": userIds,
        "users": users,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/experiments",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetExperimentsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetExperiments", _resp)

def get_GetGroup(
    session: "api.Session",
    *,
    groupId: int,
) -> "v1GetGroupResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/groups/{groupId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetGroupResponse.from_json(_resp.json())
    raise APIHttpError("get_GetGroup", _resp)

def post_GetGroups(
    session: "api.Session",
    *,
    body: "v1GetGroupsRequest",
) -> "v1GetGroupsResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/groups/search",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetGroupsResponse.from_json(_resp.json())
    raise APIHttpError("post_GetGroups", _resp)

def get_GetGroupsAndUsersAssignedToWorkspace(
    session: "api.Session",
    *,
    workspaceId: int,
    name: "typing.Optional[str]" = None,
) -> "v1GetGroupsAndUsersAssignedToWorkspaceResponse":
    _params = {
        "name": name,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/roles/workspace/{workspaceId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetGroupsAndUsersAssignedToWorkspaceResponse.from_json(_resp.json())
    raise APIHttpError("get_GetGroupsAndUsersAssignedToWorkspace", _resp)

def get_GetHPImportance(
    session: "api.Session",
    *,
    experimentId: int,
    periodSeconds: "typing.Optional[int]" = None,
) -> "typing.Iterable[v1GetHPImportanceResponse]":
    _params = {
        "periodSeconds": periodSeconds,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/experiments/{experimentId}/hyperparameter-importance",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_GetHPImportance",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1GetHPImportanceResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_GetHPImportance", _resp)

def get_GetJobQueueStats(
    session: "api.Session",
    *,
    resourcePools: "typing.Optional[typing.Sequence[str]]" = None,
) -> "v1GetJobQueueStatsResponse":
    _params = {
        "resourcePools": resourcePools,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/job-queues/stats",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetJobQueueStatsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetJobQueueStats", _resp)

def get_GetJobs(
    session: "api.Session",
    *,
    limit: "typing.Optional[int]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    resourcePool: "typing.Optional[str]" = None,
    states: "typing.Optional[typing.Sequence[determinedjobv1State]]" = None,
) -> "v1GetJobsResponse":
    _params = {
        "limit": limit,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "resourcePool": resourcePool,
        "states": [x.value for x in states] if states is not None else None,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/job-queues",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetJobsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetJobs", _resp)

def get_GetMaster(
    session: "api.Session",
) -> "v1GetMasterResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path="/api/v1/master",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetMasterResponse.from_json(_resp.json())
    raise APIHttpError("get_GetMaster", _resp)

def get_GetMasterConfig(
    session: "api.Session",
) -> "v1GetMasterConfigResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path="/api/v1/master/config",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetMasterConfigResponse.from_json(_resp.json())
    raise APIHttpError("get_GetMasterConfig", _resp)

def get_GetMe(
    session: "api.Session",
) -> "v1GetMeResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path="/api/v1/me",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetMeResponse.from_json(_resp.json())
    raise APIHttpError("get_GetMe", _resp)

def get_GetModel(
    session: "api.Session",
    *,
    modelName: str,
) -> "v1GetModelResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/models/{modelName}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetModelResponse.from_json(_resp.json())
    raise APIHttpError("get_GetModel", _resp)

def get_GetModelDef(
    session: "api.Session",
    *,
    experimentId: int,
) -> "v1GetModelDefResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/experiments/{experimentId}/model_def",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetModelDefResponse.from_json(_resp.json())
    raise APIHttpError("get_GetModelDef", _resp)

def post_GetModelDefFile(
    session: "api.Session",
    *,
    body: "v1GetModelDefFileRequest",
    experimentId: int,
) -> "v1GetModelDefFileResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/experiments/{experimentId}/file",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetModelDefFileResponse.from_json(_resp.json())
    raise APIHttpError("post_GetModelDefFile", _resp)

def get_GetModelDefTree(
    session: "api.Session",
    *,
    experimentId: int,
) -> "v1GetModelDefTreeResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/experiments/{experimentId}/file_tree",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetModelDefTreeResponse.from_json(_resp.json())
    raise APIHttpError("get_GetModelDefTree", _resp)

def get_GetModelLabels(
    session: "api.Session",
) -> "v1GetModelLabelsResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path="/api/v1/model/labels",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetModelLabelsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetModelLabels", _resp)

def get_GetModelVersion(
    session: "api.Session",
    *,
    modelName: str,
    modelVersionNum: int,
) -> "v1GetModelVersionResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/models/{modelName}/versions/{modelVersionNum}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetModelVersionResponse.from_json(_resp.json())
    raise APIHttpError("get_GetModelVersion", _resp)

def get_GetModelVersions(
    session: "api.Session",
    *,
    modelName: str,
    limit: "typing.Optional[int]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortBy: "typing.Optional[v1GetModelVersionsRequestSortBy]" = None,
) -> "v1GetModelVersionsResponse":
    _params = {
        "limit": limit,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/models/{modelName}/versions",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetModelVersionsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetModelVersions", _resp)

def get_GetModels(
    session: "api.Session",
    *,
    archived: "typing.Optional[bool]" = None,
    description: "typing.Optional[str]" = None,
    id: "typing.Optional[int]" = None,
    labels: "typing.Optional[typing.Sequence[str]]" = None,
    limit: "typing.Optional[int]" = None,
    name: "typing.Optional[str]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortBy: "typing.Optional[v1GetModelsRequestSortBy]" = None,
    userIds: "typing.Optional[typing.Sequence[int]]" = None,
    users: "typing.Optional[typing.Sequence[str]]" = None,
) -> "v1GetModelsResponse":
    _params = {
        "archived": str(archived).lower() if archived is not None else None,
        "description": description,
        "id": id,
        "labels": labels,
        "limit": limit,
        "name": name,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
        "userIds": userIds,
        "users": users,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/models",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetModelsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetModels", _resp)

def get_GetNotebook(
    session: "api.Session",
    *,
    notebookId: str,
) -> "v1GetNotebookResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/notebooks/{notebookId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetNotebookResponse.from_json(_resp.json())
    raise APIHttpError("get_GetNotebook", _resp)

def get_GetNotebooks(
    session: "api.Session",
    *,
    limit: "typing.Optional[int]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortBy: "typing.Optional[v1GetTensorboardsRequestSortBy]" = None,
    userIds: "typing.Optional[typing.Sequence[int]]" = None,
    users: "typing.Optional[typing.Sequence[str]]" = None,
) -> "v1GetNotebooksResponse":
    _params = {
        "limit": limit,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
        "userIds": userIds,
        "users": users,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/notebooks",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetNotebooksResponse.from_json(_resp.json())
    raise APIHttpError("get_GetNotebooks", _resp)

def get_GetPermissionsSummary(
    session: "api.Session",
) -> "v1GetPermissionsSummaryResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path="/api/v1/permissions/summary",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetPermissionsSummaryResponse.from_json(_resp.json())
    raise APIHttpError("get_GetPermissionsSummary", _resp)

def get_GetProject(
    session: "api.Session",
    *,
    id: int,
) -> "v1GetProjectResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/projects/{id}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetProjectResponse.from_json(_resp.json())
    raise APIHttpError("get_GetProject", _resp)

def get_GetProjectsByUserActivity(
    session: "api.Session",
    *,
    limit: "typing.Optional[int]" = None,
) -> "v1GetProjectsByUserActivityResponse":
    _params = {
        "limit": limit,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/user/projects/activity",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetProjectsByUserActivityResponse.from_json(_resp.json())
    raise APIHttpError("get_GetProjectsByUserActivity", _resp)

def get_GetResourcePools(
    session: "api.Session",
    *,
    limit: "typing.Optional[int]" = None,
    offset: "typing.Optional[int]" = None,
) -> "v1GetResourcePoolsResponse":
    _params = {
        "limit": limit,
        "offset": offset,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/resource-pools",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetResourcePoolsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetResourcePools", _resp)

def get_GetRolesAssignedToGroup(
    session: "api.Session",
    *,
    groupId: int,
) -> "v1GetRolesAssignedToGroupResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/roles/search/by-group/{groupId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetRolesAssignedToGroupResponse.from_json(_resp.json())
    raise APIHttpError("get_GetRolesAssignedToGroup", _resp)

def get_GetRolesAssignedToUser(
    session: "api.Session",
    *,
    userId: int,
) -> "v1GetRolesAssignedToUserResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/roles/search/by-user/{userId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetRolesAssignedToUserResponse.from_json(_resp.json())
    raise APIHttpError("get_GetRolesAssignedToUser", _resp)

def post_GetRolesByID(
    session: "api.Session",
    *,
    body: "v1GetRolesByIDRequest",
) -> "v1GetRolesByIDResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/roles/search/by-ids",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetRolesByIDResponse.from_json(_resp.json())
    raise APIHttpError("post_GetRolesByID", _resp)

def get_GetSearcherEvents(
    session: "api.Session",
    *,
    experimentId: int,
) -> "v1GetSearcherEventsResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/experiments/{experimentId}/searcher_events",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetSearcherEventsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetSearcherEvents", _resp)

def get_GetShell(
    session: "api.Session",
    *,
    shellId: str,
) -> "v1GetShellResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/shells/{shellId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetShellResponse.from_json(_resp.json())
    raise APIHttpError("get_GetShell", _resp)

def get_GetShells(
    session: "api.Session",
    *,
    limit: "typing.Optional[int]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortBy: "typing.Optional[v1GetTensorboardsRequestSortBy]" = None,
    userIds: "typing.Optional[typing.Sequence[int]]" = None,
    users: "typing.Optional[typing.Sequence[str]]" = None,
) -> "v1GetShellsResponse":
    _params = {
        "limit": limit,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
        "userIds": userIds,
        "users": users,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/shells",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetShellsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetShells", _resp)

def get_GetSlot(
    session: "api.Session",
    *,
    agentId: str,
    slotId: str,
) -> "v1GetSlotResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/agents/{agentId}/slots/{slotId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetSlotResponse.from_json(_resp.json())
    raise APIHttpError("get_GetSlot", _resp)

def get_GetSlots(
    session: "api.Session",
    *,
    agentId: str,
) -> "v1GetSlotsResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/agents/{agentId}/slots",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetSlotsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetSlots", _resp)

def get_GetTask(
    session: "api.Session",
    *,
    taskId: str,
) -> "v1GetTaskResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/tasks/{taskId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetTaskResponse.from_json(_resp.json())
    raise APIHttpError("get_GetTask", _resp)

def get_GetTelemetry(
    session: "api.Session",
) -> "v1GetTelemetryResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path="/api/v1/master/telemetry",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetTelemetryResponse.from_json(_resp.json())
    raise APIHttpError("get_GetTelemetry", _resp)

def get_GetTemplate(
    session: "api.Session",
    *,
    templateName: str,
) -> "v1GetTemplateResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/templates/{templateName}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetTemplateResponse.from_json(_resp.json())
    raise APIHttpError("get_GetTemplate", _resp)

def get_GetTemplates(
    session: "api.Session",
    *,
    limit: "typing.Optional[int]" = None,
    name: "typing.Optional[str]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortBy: "typing.Optional[v1GetTemplatesRequestSortBy]" = None,
) -> "v1GetTemplatesResponse":
    _params = {
        "limit": limit,
        "name": name,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/templates",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetTemplatesResponse.from_json(_resp.json())
    raise APIHttpError("get_GetTemplates", _resp)

def get_GetTensorboard(
    session: "api.Session",
    *,
    tensorboardId: str,
) -> "v1GetTensorboardResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/tensorboards/{tensorboardId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetTensorboardResponse.from_json(_resp.json())
    raise APIHttpError("get_GetTensorboard", _resp)

def get_GetTensorboards(
    session: "api.Session",
    *,
    limit: "typing.Optional[int]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortBy: "typing.Optional[v1GetTensorboardsRequestSortBy]" = None,
    userIds: "typing.Optional[typing.Sequence[int]]" = None,
    users: "typing.Optional[typing.Sequence[str]]" = None,
) -> "v1GetTensorboardsResponse":
    _params = {
        "limit": limit,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
        "userIds": userIds,
        "users": users,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/tensorboards",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetTensorboardsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetTensorboards", _resp)

def get_GetTrial(
    session: "api.Session",
    *,
    trialId: int,
) -> "v1GetTrialResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/trials/{trialId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetTrialResponse.from_json(_resp.json())
    raise APIHttpError("get_GetTrial", _resp)

def get_GetTrialCheckpoints(
    session: "api.Session",
    *,
    id: int,
    limit: "typing.Optional[int]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortBy: "typing.Optional[v1GetTrialCheckpointsRequestSortBy]" = None,
    states: "typing.Optional[typing.Sequence[determinedcheckpointv1State]]" = None,
) -> "v1GetTrialCheckpointsResponse":
    _params = {
        "limit": limit,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
        "states": [x.value for x in states] if states is not None else None,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/trials/{id}/checkpoints",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetTrialCheckpointsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetTrialCheckpoints", _resp)

def get_GetTrialProfilerAvailableSeries(
    session: "api.Session",
    *,
    trialId: int,
    follow: "typing.Optional[bool]" = None,
) -> "typing.Iterable[v1GetTrialProfilerAvailableSeriesResponse]":
    _params = {
        "follow": str(follow).lower() if follow is not None else None,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/trials/{trialId}/profiler/available_series",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_GetTrialProfilerAvailableSeries",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1GetTrialProfilerAvailableSeriesResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_GetTrialProfilerAvailableSeries", _resp)

def get_GetTrialProfilerMetrics(
    session: "api.Session",
    *,
    labels_trialId: int,
    follow: "typing.Optional[bool]" = None,
    labels_agentId: "typing.Optional[str]" = None,
    labels_gpuUuid: "typing.Optional[str]" = None,
    labels_metricType: "typing.Optional[TrialProfilerMetricLabelsProfilerMetricType]" = None,
    labels_name: "typing.Optional[str]" = None,
) -> "typing.Iterable[v1GetTrialProfilerMetricsResponse]":
    _params = {
        "follow": str(follow).lower() if follow is not None else None,
        "labels.agentId": labels_agentId,
        "labels.gpuUuid": labels_gpuUuid,
        "labels.metricType": labels_metricType.value if labels_metricType is not None else None,
        "labels.name": labels_name,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/trials/{labels_trialId}/profiler/metrics",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_GetTrialProfilerMetrics",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1GetTrialProfilerMetricsResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_GetTrialProfilerMetrics", _resp)

def get_GetTrialWorkloads(
    session: "api.Session",
    *,
    trialId: int,
    filter: "typing.Optional[GetTrialWorkloadsRequestFilterOption]" = None,
    includeBatchMetrics: "typing.Optional[bool]" = None,
    limit: "typing.Optional[int]" = None,
    metricType: "typing.Optional[v1MetricType]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortKey: "typing.Optional[str]" = None,
) -> "v1GetTrialWorkloadsResponse":
    _params = {
        "filter": filter.value if filter is not None else None,
        "includeBatchMetrics": str(includeBatchMetrics).lower() if includeBatchMetrics is not None else None,
        "limit": limit,
        "metricType": metricType.value if metricType is not None else None,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortKey": sortKey,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/trials/{trialId}/workloads",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetTrialWorkloadsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetTrialWorkloads", _resp)

def get_GetTrialsCollections(
    session: "api.Session",
    *,
    projectId: "typing.Optional[int]" = None,
) -> "v1GetTrialsCollectionsResponse":
    _params = {
        "projectId": projectId,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/trial-comparison/collections",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetTrialsCollectionsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetTrialsCollections", _resp)

def get_GetUser(
    session: "api.Session",
    *,
    userId: int,
) -> "v1GetUserResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/users/{userId}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetUserResponse.from_json(_resp.json())
    raise APIHttpError("get_GetUser", _resp)

def get_GetUserByUsername(
    session: "api.Session",
    *,
    username: str,
) -> "v1GetUserByUsernameResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/users/{username}/by-username",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetUserByUsernameResponse.from_json(_resp.json())
    raise APIHttpError("get_GetUserByUsername", _resp)

def get_GetUserSetting(
    session: "api.Session",
) -> "v1GetUserSettingResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path="/api/v1/users/setting",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetUserSettingResponse.from_json(_resp.json())
    raise APIHttpError("get_GetUserSetting", _resp)

def get_GetUsers(
    session: "api.Session",
    *,
    limit: "typing.Optional[int]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortBy: "typing.Optional[v1GetUsersRequestSortBy]" = None,
) -> "v1GetUsersResponse":
    _params = {
        "limit": limit,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/users",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetUsersResponse.from_json(_resp.json())
    raise APIHttpError("get_GetUsers", _resp)

def get_GetWebhooks(
    session: "api.Session",
) -> "v1GetWebhooksResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path="/api/v1/webhooks",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetWebhooksResponse.from_json(_resp.json())
    raise APIHttpError("get_GetWebhooks", _resp)

def get_GetWorkspace(
    session: "api.Session",
    *,
    id: int,
) -> "v1GetWorkspaceResponse":
    _params = None
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/workspaces/{id}",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetWorkspaceResponse.from_json(_resp.json())
    raise APIHttpError("get_GetWorkspace", _resp)

def get_GetWorkspaceProjects(
    session: "api.Session",
    *,
    id: int,
    archived: "typing.Optional[bool]" = None,
    limit: "typing.Optional[int]" = None,
    name: "typing.Optional[str]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    sortBy: "typing.Optional[v1GetWorkspaceProjectsRequestSortBy]" = None,
    userIds: "typing.Optional[typing.Sequence[int]]" = None,
    users: "typing.Optional[typing.Sequence[str]]" = None,
) -> "v1GetWorkspaceProjectsResponse":
    _params = {
        "archived": str(archived).lower() if archived is not None else None,
        "limit": limit,
        "name": name,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
        "userIds": userIds,
        "users": users,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/workspaces/{id}/projects",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetWorkspaceProjectsResponse.from_json(_resp.json())
    raise APIHttpError("get_GetWorkspaceProjects", _resp)

def get_GetWorkspaces(
    session: "api.Session",
    *,
    archived: "typing.Optional[bool]" = None,
    limit: "typing.Optional[int]" = None,
    name: "typing.Optional[str]" = None,
    offset: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    pinned: "typing.Optional[bool]" = None,
    sortBy: "typing.Optional[v1GetWorkspacesRequestSortBy]" = None,
    userIds: "typing.Optional[typing.Sequence[int]]" = None,
    users: "typing.Optional[typing.Sequence[str]]" = None,
) -> "v1GetWorkspacesResponse":
    _params = {
        "archived": str(archived).lower() if archived is not None else None,
        "limit": limit,
        "name": name,
        "offset": offset,
        "orderBy": orderBy.value if orderBy is not None else None,
        "pinned": str(pinned).lower() if pinned is not None else None,
        "sortBy": sortBy.value if sortBy is not None else None,
        "userIds": userIds,
        "users": users,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/workspaces",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1GetWorkspacesResponse.from_json(_resp.json())
    raise APIHttpError("get_GetWorkspaces", _resp)

def put_IdleNotebook(
    session: "api.Session",
    *,
    body: "v1IdleNotebookRequest",
    notebookId: str,
) -> None:
    _params = None
    _resp = session._do_request(
        method="PUT",
        path=f"/api/v1/notebooks/{notebookId}/report_idle",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("put_IdleNotebook", _resp)

def post_KillCommand(
    session: "api.Session",
    *,
    commandId: str,
) -> "v1KillCommandResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/commands/{commandId}/kill",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1KillCommandResponse.from_json(_resp.json())
    raise APIHttpError("post_KillCommand", _resp)

def post_KillExperiment(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/experiments/{id}/kill",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_KillExperiment", _resp)

def post_KillNotebook(
    session: "api.Session",
    *,
    notebookId: str,
) -> "v1KillNotebookResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/notebooks/{notebookId}/kill",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1KillNotebookResponse.from_json(_resp.json())
    raise APIHttpError("post_KillNotebook", _resp)

def post_KillShell(
    session: "api.Session",
    *,
    shellId: str,
) -> "v1KillShellResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/shells/{shellId}/kill",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1KillShellResponse.from_json(_resp.json())
    raise APIHttpError("post_KillShell", _resp)

def post_KillTensorboard(
    session: "api.Session",
    *,
    tensorboardId: str,
) -> "v1KillTensorboardResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/tensorboards/{tensorboardId}/kill",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1KillTensorboardResponse.from_json(_resp.json())
    raise APIHttpError("post_KillTensorboard", _resp)

def post_KillTrial(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/trials/{id}/kill",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_KillTrial", _resp)

def post_LaunchCommand(
    session: "api.Session",
    *,
    body: "v1LaunchCommandRequest",
) -> "v1LaunchCommandResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/commands",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1LaunchCommandResponse.from_json(_resp.json())
    raise APIHttpError("post_LaunchCommand", _resp)

def post_LaunchNotebook(
    session: "api.Session",
    *,
    body: "v1LaunchNotebookRequest",
) -> "v1LaunchNotebookResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/notebooks",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1LaunchNotebookResponse.from_json(_resp.json())
    raise APIHttpError("post_LaunchNotebook", _resp)

def post_LaunchShell(
    session: "api.Session",
    *,
    body: "v1LaunchShellRequest",
) -> "v1LaunchShellResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/shells",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1LaunchShellResponse.from_json(_resp.json())
    raise APIHttpError("post_LaunchShell", _resp)

def post_LaunchTensorboard(
    session: "api.Session",
    *,
    body: "v1LaunchTensorboardRequest",
) -> "v1LaunchTensorboardResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/tensorboards",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1LaunchTensorboardResponse.from_json(_resp.json())
    raise APIHttpError("post_LaunchTensorboard", _resp)

def post_ListRoles(
    session: "api.Session",
    *,
    body: "v1ListRolesRequest",
) -> "v1ListRolesResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/roles/search",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1ListRolesResponse.from_json(_resp.json())
    raise APIHttpError("post_ListRoles", _resp)

def post_Login(
    session: "api.Session",
    *,
    body: "v1LoginRequest",
) -> "v1LoginResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/auth/login",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1LoginResponse.from_json(_resp.json())
    raise APIHttpError("post_Login", _resp)

def post_Logout(
    session: "api.Session",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/auth/logout",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_Logout", _resp)

def post_MarkAllocationResourcesDaemon(
    session: "api.Session",
    *,
    allocationId: str,
    body: "v1MarkAllocationResourcesDaemonRequest",
    resourcesId: str,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/allocations/{allocationId}/resources/{resourcesId}/daemon",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_MarkAllocationResourcesDaemon", _resp)

def get_MasterLogs(
    session: "api.Session",
    *,
    follow: "typing.Optional[bool]" = None,
    limit: "typing.Optional[int]" = None,
    offset: "typing.Optional[int]" = None,
) -> "typing.Iterable[v1MasterLogsResponse]":
    _params = {
        "follow": str(follow).lower() if follow is not None else None,
        "limit": limit,
        "offset": offset,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/master/logs",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_MasterLogs",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1MasterLogsResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_MasterLogs", _resp)

def get_MetricBatches(
    session: "api.Session",
    *,
    experimentId: int,
    metricName: str,
    metricType: "v1MetricType",
    periodSeconds: "typing.Optional[int]" = None,
) -> "typing.Iterable[v1MetricBatchesResponse]":
    _params = {
        "metricName": metricName,
        "metricType": metricType.value,
        "periodSeconds": periodSeconds,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/experiments/{experimentId}/metrics-stream/batches",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_MetricBatches",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1MetricBatchesResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_MetricBatches", _resp)

def get_MetricNames(
    session: "api.Session",
    *,
    experimentId: int,
    periodSeconds: "typing.Optional[int]" = None,
) -> "typing.Iterable[v1MetricNamesResponse]":
    _params = {
        "periodSeconds": periodSeconds,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/experiments/{experimentId}/metrics-stream/metric-names",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_MetricNames",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1MetricNamesResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_MetricNames", _resp)

def post_MoveExperiment(
    session: "api.Session",
    *,
    body: "v1MoveExperimentRequest",
    experimentId: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/experiments/{experimentId}/move",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_MoveExperiment", _resp)

def post_MoveProject(
    session: "api.Session",
    *,
    body: "v1MoveProjectRequest",
    projectId: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/projects/{projectId}/move",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_MoveProject", _resp)

def post_NotifyContainerRunning(
    session: "api.Session",
    *,
    allocationId: str,
    body: "v1NotifyContainerRunningRequest",
) -> "v1NotifyContainerRunningResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/allocations/{allocationId}/notify_container_running",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1NotifyContainerRunningResponse.from_json(_resp.json())
    raise APIHttpError("post_NotifyContainerRunning", _resp)

def patch_PatchExperiment(
    session: "api.Session",
    *,
    body: "v1PatchExperiment",
    experiment_id: int,
) -> "v1PatchExperimentResponse":
    _params = None
    _resp = session._do_request(
        method="PATCH",
        path=f"/api/v1/experiments/{experiment_id}",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PatchExperimentResponse.from_json(_resp.json())
    raise APIHttpError("patch_PatchExperiment", _resp)

def patch_PatchModel(
    session: "api.Session",
    *,
    body: "v1PatchModel",
    modelName: str,
) -> "v1PatchModelResponse":
    _params = None
    _resp = session._do_request(
        method="PATCH",
        path=f"/api/v1/models/{modelName}",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PatchModelResponse.from_json(_resp.json())
    raise APIHttpError("patch_PatchModel", _resp)

def patch_PatchModelVersion(
    session: "api.Session",
    *,
    body: "v1PatchModelVersion",
    modelName: str,
    modelVersionNum: int,
) -> "v1PatchModelVersionResponse":
    _params = None
    _resp = session._do_request(
        method="PATCH",
        path=f"/api/v1/models/{modelName}/versions/{modelVersionNum}",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PatchModelVersionResponse.from_json(_resp.json())
    raise APIHttpError("patch_PatchModelVersion", _resp)

def patch_PatchProject(
    session: "api.Session",
    *,
    body: "v1PatchProject",
    id: int,
) -> "v1PatchProjectResponse":
    _params = None
    _resp = session._do_request(
        method="PATCH",
        path=f"/api/v1/projects/{id}",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PatchProjectResponse.from_json(_resp.json())
    raise APIHttpError("patch_PatchProject", _resp)

def patch_PatchTrialsCollection(
    session: "api.Session",
    *,
    body: "v1PatchTrialsCollectionRequest",
) -> "v1PatchTrialsCollectionResponse":
    _params = None
    _resp = session._do_request(
        method="PATCH",
        path="/api/v1/trial-comparison/collections",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PatchTrialsCollectionResponse.from_json(_resp.json())
    raise APIHttpError("patch_PatchTrialsCollection", _resp)

def patch_PatchUser(
    session: "api.Session",
    *,
    body: "v1PatchUser",
    userId: int,
) -> "v1PatchUserResponse":
    _params = None
    _resp = session._do_request(
        method="PATCH",
        path=f"/api/v1/users/{userId}",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PatchUserResponse.from_json(_resp.json())
    raise APIHttpError("patch_PatchUser", _resp)

def patch_PatchWorkspace(
    session: "api.Session",
    *,
    body: "v1PatchWorkspace",
    id: int,
) -> "v1PatchWorkspaceResponse":
    _params = None
    _resp = session._do_request(
        method="PATCH",
        path=f"/api/v1/workspaces/{id}",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PatchWorkspaceResponse.from_json(_resp.json())
    raise APIHttpError("patch_PatchWorkspace", _resp)

def post_PauseExperiment(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/experiments/{id}/pause",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_PauseExperiment", _resp)

def post_PinWorkspace(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/workspaces/{id}/pin",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_PinWorkspace", _resp)

def post_PostAllocationProxyAddress(
    session: "api.Session",
    *,
    allocationId: str,
    body: "v1PostAllocationProxyAddressRequest",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/allocations/{allocationId}/proxy_address",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_PostAllocationProxyAddress", _resp)

def post_PostCheckpointMetadata(
    session: "api.Session",
    *,
    body: "v1PostCheckpointMetadataRequest",
    checkpoint_uuid: str,
) -> "v1PostCheckpointMetadataResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/checkpoints/{checkpoint_uuid}/metadata",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PostCheckpointMetadataResponse.from_json(_resp.json())
    raise APIHttpError("post_PostCheckpointMetadata", _resp)

def post_PostModel(
    session: "api.Session",
    *,
    body: "v1PostModelRequest",
) -> "v1PostModelResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/models",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PostModelResponse.from_json(_resp.json())
    raise APIHttpError("post_PostModel", _resp)

def post_PostModelVersion(
    session: "api.Session",
    *,
    body: "v1PostModelVersionRequest",
    modelName: str,
) -> "v1PostModelVersionResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/models/{modelName}/versions",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PostModelVersionResponse.from_json(_resp.json())
    raise APIHttpError("post_PostModelVersion", _resp)

def post_PostProject(
    session: "api.Session",
    *,
    body: "v1PostProjectRequest",
    workspaceId: int,
) -> "v1PostProjectResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/workspaces/{workspaceId}/projects",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PostProjectResponse.from_json(_resp.json())
    raise APIHttpError("post_PostProject", _resp)

def post_PostSearcherOperations(
    session: "api.Session",
    *,
    body: "v1PostSearcherOperationsRequest",
    experimentId: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/experiments/{experimentId}/searcher_operations",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_PostSearcherOperations", _resp)

def post_PostTrialProfilerMetricsBatch(
    session: "api.Session",
    *,
    body: "v1PostTrialProfilerMetricsBatchRequest",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/trials/profiler/metrics",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_PostTrialProfilerMetricsBatch", _resp)

def post_PostTrialRunnerMetadata(
    session: "api.Session",
    *,
    body: "v1TrialRunnerMetadata",
    trialId: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/trials/{trialId}/runner/metadata",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_PostTrialRunnerMetadata", _resp)

def post_PostUser(
    session: "api.Session",
    *,
    body: "v1PostUserRequest",
) -> "v1PostUserResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/users",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PostUserResponse.from_json(_resp.json())
    raise APIHttpError("post_PostUser", _resp)

def post_PostUserActivity(
    session: "api.Session",
    *,
    body: "v1PostUserActivityRequest",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/users/activity",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_PostUserActivity", _resp)

def post_PostUserSetting(
    session: "api.Session",
    *,
    body: "v1PostUserSettingRequest",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/users/setting",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_PostUserSetting", _resp)

def post_PostWebhook(
    session: "api.Session",
    *,
    body: "v1Webhook",
) -> "v1PostWebhookResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/webhooks",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PostWebhookResponse.from_json(_resp.json())
    raise APIHttpError("post_PostWebhook", _resp)

def post_PostWorkspace(
    session: "api.Session",
    *,
    body: "v1PostWorkspaceRequest",
) -> "v1PostWorkspaceResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/workspaces",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PostWorkspaceResponse.from_json(_resp.json())
    raise APIHttpError("post_PostWorkspace", _resp)

def post_PreviewHPSearch(
    session: "api.Session",
    *,
    body: "v1PreviewHPSearchRequest",
) -> "v1PreviewHPSearchResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/preview-hp-search",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PreviewHPSearchResponse.from_json(_resp.json())
    raise APIHttpError("post_PreviewHPSearch", _resp)

def put_PutProjectNotes(
    session: "api.Session",
    *,
    body: "v1PutProjectNotesRequest",
    projectId: int,
) -> "v1PutProjectNotesResponse":
    _params = None
    _resp = session._do_request(
        method="PUT",
        path=f"/api/v1/projects/{projectId}/notes",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PutProjectNotesResponse.from_json(_resp.json())
    raise APIHttpError("put_PutProjectNotes", _resp)

def put_PutTemplate(
    session: "api.Session",
    *,
    body: "v1Template",
    template_name: str,
) -> "v1PutTemplateResponse":
    _params = None
    _resp = session._do_request(
        method="PUT",
        path=f"/api/v1/templates/{template_name}",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1PutTemplateResponse.from_json(_resp.json())
    raise APIHttpError("put_PutTemplate", _resp)

def post_QueryTrials(
    session: "api.Session",
    *,
    body: "v1QueryTrialsRequest",
) -> "v1QueryTrialsResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/trial-comparison/query",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1QueryTrialsResponse.from_json(_resp.json())
    raise APIHttpError("post_QueryTrials", _resp)

def post_RemoveAssignments(
    session: "api.Session",
    *,
    body: "v1RemoveAssignmentsRequest",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/roles/remove-assignments",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_RemoveAssignments", _resp)

def post_ReportCheckpoint(
    session: "api.Session",
    *,
    body: "v1Checkpoint",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/checkpoints",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_ReportCheckpoint", _resp)

def post_ReportTrialProgress(
    session: "api.Session",
    *,
    body: float,
    trialId: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/trials/{trialId}/progress",
        params=_params,
        json=dump_float(body),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_ReportTrialProgress", _resp)

def post_ReportTrialSearcherEarlyExit(
    session: "api.Session",
    *,
    body: "v1TrialEarlyExit",
    trialId: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/trials/{trialId}/early_exit",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_ReportTrialSearcherEarlyExit", _resp)

def post_ReportTrialTrainingMetrics(
    session: "api.Session",
    *,
    body: "v1TrialMetrics",
    trainingMetrics_trialId: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/trials/{trainingMetrics_trialId}/training_metrics",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_ReportTrialTrainingMetrics", _resp)

def post_ReportTrialValidationMetrics(
    session: "api.Session",
    *,
    body: "v1TrialMetrics",
    validationMetrics_trialId: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/trials/{validationMetrics_trialId}/validation_metrics",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_ReportTrialValidationMetrics", _resp)

def post_ResetUserSetting(
    session: "api.Session",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/users/setting/reset",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_ResetUserSetting", _resp)

def get_ResourceAllocationAggregated(
    session: "api.Session",
    *,
    endDate: "typing.Optional[str]" = None,
    period: "typing.Optional[v1ResourceAllocationAggregationPeriod]" = None,
    startDate: "typing.Optional[str]" = None,
) -> "v1ResourceAllocationAggregatedResponse":
    _params = {
        "endDate": endDate,
        "period": period.value if period is not None else None,
        "startDate": startDate,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/resources/allocation/aggregated",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1ResourceAllocationAggregatedResponse.from_json(_resp.json())
    raise APIHttpError("get_ResourceAllocationAggregated", _resp)

def get_ResourceAllocationRaw(
    session: "api.Session",
    *,
    timestampAfter: "typing.Optional[str]" = None,
    timestampBefore: "typing.Optional[str]" = None,
) -> "v1ResourceAllocationRawResponse":
    _params = {
        "timestampAfter": timestampAfter,
        "timestampBefore": timestampBefore,
    }
    _resp = session._do_request(
        method="GET",
        path="/api/v1/resources/allocation/raw",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1ResourceAllocationRawResponse.from_json(_resp.json())
    raise APIHttpError("get_ResourceAllocationRaw", _resp)

def post_SearchRolesAssignableToScope(
    session: "api.Session",
    *,
    body: "v1SearchRolesAssignableToScopeRequest",
) -> "v1SearchRolesAssignableToScopeResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/roles/search/by-assignability",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1SearchRolesAssignableToScopeResponse.from_json(_resp.json())
    raise APIHttpError("post_SearchRolesAssignableToScope", _resp)

def post_SetCommandPriority(
    session: "api.Session",
    *,
    body: "v1SetCommandPriorityRequest",
    commandId: str,
) -> "v1SetCommandPriorityResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/commands/{commandId}/set_priority",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1SetCommandPriorityResponse.from_json(_resp.json())
    raise APIHttpError("post_SetCommandPriority", _resp)

def post_SetNotebookPriority(
    session: "api.Session",
    *,
    body: "v1SetNotebookPriorityRequest",
    notebookId: str,
) -> "v1SetNotebookPriorityResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/notebooks/{notebookId}/set_priority",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1SetNotebookPriorityResponse.from_json(_resp.json())
    raise APIHttpError("post_SetNotebookPriority", _resp)

def post_SetShellPriority(
    session: "api.Session",
    *,
    body: "v1SetShellPriorityRequest",
    shellId: str,
) -> "v1SetShellPriorityResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/shells/{shellId}/set_priority",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1SetShellPriorityResponse.from_json(_resp.json())
    raise APIHttpError("post_SetShellPriority", _resp)

def post_SetTensorboardPriority(
    session: "api.Session",
    *,
    body: "v1SetTensorboardPriorityRequest",
    tensorboardId: str,
) -> "v1SetTensorboardPriorityResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/tensorboards/{tensorboardId}/set_priority",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1SetTensorboardPriorityResponse.from_json(_resp.json())
    raise APIHttpError("post_SetTensorboardPriority", _resp)

def post_SetUserPassword(
    session: "api.Session",
    *,
    body: str,
    userId: int,
) -> "v1SetUserPasswordResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/users/{userId}/password",
        params=_params,
        json=body,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1SetUserPasswordResponse.from_json(_resp.json())
    raise APIHttpError("post_SetUserPassword", _resp)

def get_SummarizeTrial(
    session: "api.Session",
    *,
    trialId: int,
    endBatches: "typing.Optional[int]" = None,
    maxDatapoints: "typing.Optional[int]" = None,
    metricNames: "typing.Optional[typing.Sequence[str]]" = None,
    metricType: "typing.Optional[v1MetricType]" = None,
    scale: "typing.Optional[v1Scale]" = None,
    startBatches: "typing.Optional[int]" = None,
) -> "v1SummarizeTrialResponse":
    _params = {
        "endBatches": endBatches,
        "maxDatapoints": maxDatapoints,
        "metricNames": metricNames,
        "metricType": metricType.value if metricType is not None else None,
        "scale": scale.value if scale is not None else None,
        "startBatches": startBatches,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/trials/{trialId}/summarize",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1SummarizeTrialResponse.from_json(_resp.json())
    raise APIHttpError("get_SummarizeTrial", _resp)

def get_TaskLogs(
    session: "api.Session",
    *,
    taskId: str,
    agentIds: "typing.Optional[typing.Sequence[str]]" = None,
    allocationIds: "typing.Optional[typing.Sequence[str]]" = None,
    containerIds: "typing.Optional[typing.Sequence[str]]" = None,
    follow: "typing.Optional[bool]" = None,
    levels: "typing.Optional[typing.Sequence[v1LogLevel]]" = None,
    limit: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    rankIds: "typing.Optional[typing.Sequence[int]]" = None,
    searchText: "typing.Optional[str]" = None,
    sources: "typing.Optional[typing.Sequence[str]]" = None,
    stdtypes: "typing.Optional[typing.Sequence[str]]" = None,
    timestampAfter: "typing.Optional[str]" = None,
    timestampBefore: "typing.Optional[str]" = None,
) -> "typing.Iterable[v1TaskLogsResponse]":
    _params = {
        "agentIds": agentIds,
        "allocationIds": allocationIds,
        "containerIds": containerIds,
        "follow": str(follow).lower() if follow is not None else None,
        "levels": [x.value for x in levels] if levels is not None else None,
        "limit": limit,
        "orderBy": orderBy.value if orderBy is not None else None,
        "rankIds": rankIds,
        "searchText": searchText,
        "sources": sources,
        "stdtypes": stdtypes,
        "timestampAfter": timestampAfter,
        "timestampBefore": timestampBefore,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/tasks/{taskId}/logs",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_TaskLogs",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1TaskLogsResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_TaskLogs", _resp)

def get_TaskLogsFields(
    session: "api.Session",
    *,
    taskId: str,
    follow: "typing.Optional[bool]" = None,
) -> "typing.Iterable[v1TaskLogsFieldsResponse]":
    _params = {
        "follow": str(follow).lower() if follow is not None else None,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/tasks/{taskId}/logs/fields",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_TaskLogsFields",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1TaskLogsFieldsResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_TaskLogsFields", _resp)

def post_TestWebhook(
    session: "api.Session",
    *,
    id: int,
) -> "v1TestWebhookResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/webhooks/{id}/test",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1TestWebhookResponse.from_json(_resp.json())
    raise APIHttpError("post_TestWebhook", _resp)

def get_TrialLogs(
    session: "api.Session",
    *,
    trialId: int,
    agentIds: "typing.Optional[typing.Sequence[str]]" = None,
    containerIds: "typing.Optional[typing.Sequence[str]]" = None,
    follow: "typing.Optional[bool]" = None,
    levels: "typing.Optional[typing.Sequence[v1LogLevel]]" = None,
    limit: "typing.Optional[int]" = None,
    orderBy: "typing.Optional[v1OrderBy]" = None,
    rankIds: "typing.Optional[typing.Sequence[int]]" = None,
    searchText: "typing.Optional[str]" = None,
    sources: "typing.Optional[typing.Sequence[str]]" = None,
    stdtypes: "typing.Optional[typing.Sequence[str]]" = None,
    timestampAfter: "typing.Optional[str]" = None,
    timestampBefore: "typing.Optional[str]" = None,
) -> "typing.Iterable[v1TrialLogsResponse]":
    _params = {
        "agentIds": agentIds,
        "containerIds": containerIds,
        "follow": str(follow).lower() if follow is not None else None,
        "levels": [x.value for x in levels] if levels is not None else None,
        "limit": limit,
        "orderBy": orderBy.value if orderBy is not None else None,
        "rankIds": rankIds,
        "searchText": searchText,
        "sources": sources,
        "stdtypes": stdtypes,
        "timestampAfter": timestampAfter,
        "timestampBefore": timestampBefore,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/trials/{trialId}/logs",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_TrialLogs",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1TrialLogsResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_TrialLogs", _resp)

def get_TrialLogsFields(
    session: "api.Session",
    *,
    trialId: int,
    follow: "typing.Optional[bool]" = None,
) -> "typing.Iterable[v1TrialLogsFieldsResponse]":
    _params = {
        "follow": str(follow).lower() if follow is not None else None,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/trials/{trialId}/logs/fields",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_TrialLogsFields",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1TrialLogsFieldsResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_TrialLogsFields", _resp)

def get_TrialsSample(
    session: "api.Session",
    *,
    experimentId: int,
    metricName: str,
    metricType: "v1MetricType",
    endBatches: "typing.Optional[int]" = None,
    maxDatapoints: "typing.Optional[int]" = None,
    maxTrials: "typing.Optional[int]" = None,
    periodSeconds: "typing.Optional[int]" = None,
    startBatches: "typing.Optional[int]" = None,
) -> "typing.Iterable[v1TrialsSampleResponse]":
    _params = {
        "endBatches": endBatches,
        "maxDatapoints": maxDatapoints,
        "maxTrials": maxTrials,
        "metricName": metricName,
        "metricType": metricType.value,
        "periodSeconds": periodSeconds,
        "startBatches": startBatches,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/experiments/{experimentId}/metrics-stream/trials-sample",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_TrialsSample",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1TrialsSampleResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_TrialsSample", _resp)

def get_TrialsSnapshot(
    session: "api.Session",
    *,
    batchesProcessed: int,
    experimentId: int,
    metricName: str,
    metricType: "v1MetricType",
    batchesMargin: "typing.Optional[int]" = None,
    periodSeconds: "typing.Optional[int]" = None,
) -> "typing.Iterable[v1TrialsSnapshotResponse]":
    _params = {
        "batchesMargin": batchesMargin,
        "batchesProcessed": batchesProcessed,
        "metricName": metricName,
        "metricType": metricType.value,
        "periodSeconds": periodSeconds,
    }
    _resp = session._do_request(
        method="GET",
        path=f"/api/v1/experiments/{experimentId}/metrics-stream/trials-snapshot",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=True,
    )
    if _resp.status_code == 200:
        for _line in _resp.iter_lines():
            _j = json.loads(_line)
            if "error" in _j:
                raise APIHttpStreamError(
                    "get_TrialsSnapshot",
                    runtimeStreamError.from_json(_j["error"])
            )
            yield v1TrialsSnapshotResponse.from_json(_j["result"])
        return
    raise APIHttpError("get_TrialsSnapshot", _resp)

def post_UnarchiveExperiment(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/experiments/{id}/unarchive",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_UnarchiveExperiment", _resp)

def post_UnarchiveModel(
    session: "api.Session",
    *,
    modelName: str,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/models/{modelName}/unarchive",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_UnarchiveModel", _resp)

def post_UnarchiveProject(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/projects/{id}/unarchive",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_UnarchiveProject", _resp)

def post_UnarchiveWorkspace(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/workspaces/{id}/unarchive",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_UnarchiveWorkspace", _resp)

def post_UnpinWorkspace(
    session: "api.Session",
    *,
    id: int,
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path=f"/api/v1/workspaces/{id}/unpin",
        params=_params,
        json=None,
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_UnpinWorkspace", _resp)

def put_UpdateGroup(
    session: "api.Session",
    *,
    body: "v1UpdateGroupRequest",
    groupId: int,
) -> "v1UpdateGroupResponse":
    _params = None
    _resp = session._do_request(
        method="PUT",
        path=f"/api/v1/groups/{groupId}",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1UpdateGroupResponse.from_json(_resp.json())
    raise APIHttpError("put_UpdateGroup", _resp)

def post_UpdateJobQueue(
    session: "api.Session",
    *,
    body: "v1UpdateJobQueueRequest",
) -> None:
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/job-queues",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return
    raise APIHttpError("post_UpdateJobQueue", _resp)

def post_UpdateTrialTags(
    session: "api.Session",
    *,
    body: "v1UpdateTrialTagsRequest",
) -> "v1UpdateTrialTagsResponse":
    _params = None
    _resp = session._do_request(
        method="POST",
        path="/api/v1/trial-comparison/update-trial-tags",
        params=_params,
        json=body.to_json(True),
        data=None,
        headers=None,
        timeout=None,
        stream=False,
    )
    if _resp.status_code == 200:
        return v1UpdateTrialTagsResponse.from_json(_resp.json())
    raise APIHttpError("post_UpdateTrialTags", _resp)

# Paginated is a union type of objects whose .pagination
# attribute is a v1Pagination-type object.
Paginated = typing.Union[
    v1GetAgentsResponse,
    v1GetCommandsResponse,
    v1GetExperimentCheckpointsResponse,
    v1GetExperimentTrialsResponse,
    v1GetExperimentsResponse,
    v1GetGroupsResponse,
    v1GetJobsResponse,
    v1GetModelVersionsResponse,
    v1GetModelsResponse,
    v1GetNotebooksResponse,
    v1GetResourcePoolsResponse,
    v1GetShellsResponse,
    v1GetTemplatesResponse,
    v1GetTensorboardsResponse,
    v1GetTrialCheckpointsResponse,
    v1GetTrialWorkloadsResponse,
    v1GetUsersResponse,
    v1GetWorkspaceProjectsResponse,
    v1GetWorkspacesResponse,
    v1ListRolesResponse,
    v1SearchRolesAssignableToScopeResponse,
]
