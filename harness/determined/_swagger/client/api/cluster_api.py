# coding: utf-8

"""
    Determined API (Beta)

    Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.  You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.  # noqa: E501

    OpenAPI spec version: 0.1
    Contact: community@determined.ai
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from determined._swagger.client.api_client import ApiClient


class ClusterApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def determined_disable_agent(self, agent_id, **kwargs):  # noqa: E501
        """Disable the agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_disable_agent(agent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :return: V1DisableAgentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_disable_agent_with_http_info(agent_id, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_disable_agent_with_http_info(agent_id, **kwargs)  # noqa: E501
            return data

    def determined_disable_agent_with_http_info(self, agent_id, **kwargs):  # noqa: E501
        """Disable the agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_disable_agent_with_http_info(agent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :return: V1DisableAgentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['agent_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_disable_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'agent_id' is set
        if ('agent_id' not in params or
                params['agent_id'] is None):
            raise ValueError("Missing the required parameter `agent_id` when calling `determined_disable_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'agent_id' in params:
            path_params['agentId'] = params['agent_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/agents/{agentId}/disable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1DisableAgentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_disable_slot(self, agent_id, slot_id, **kwargs):  # noqa: E501
        """Disable the slot.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_disable_slot(agent_id, slot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :param str slot_id: The id of the slot. (required)
        :return: V1DisableSlotResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_disable_slot_with_http_info(agent_id, slot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_disable_slot_with_http_info(agent_id, slot_id, **kwargs)  # noqa: E501
            return data

    def determined_disable_slot_with_http_info(self, agent_id, slot_id, **kwargs):  # noqa: E501
        """Disable the slot.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_disable_slot_with_http_info(agent_id, slot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :param str slot_id: The id of the slot. (required)
        :return: V1DisableSlotResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['agent_id', 'slot_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_disable_slot" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'agent_id' is set
        if ('agent_id' not in params or
                params['agent_id'] is None):
            raise ValueError("Missing the required parameter `agent_id` when calling `determined_disable_slot`")  # noqa: E501
        # verify the required parameter 'slot_id' is set
        if ('slot_id' not in params or
                params['slot_id'] is None):
            raise ValueError("Missing the required parameter `slot_id` when calling `determined_disable_slot`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'agent_id' in params:
            path_params['agentId'] = params['agent_id']  # noqa: E501
        if 'slot_id' in params:
            path_params['slotId'] = params['slot_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/agents/{agentId}/slots/{slotId}/disable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1DisableSlotResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_enable_agent(self, agent_id, **kwargs):  # noqa: E501
        """Enable the agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_enable_agent(agent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :return: V1EnableAgentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_enable_agent_with_http_info(agent_id, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_enable_agent_with_http_info(agent_id, **kwargs)  # noqa: E501
            return data

    def determined_enable_agent_with_http_info(self, agent_id, **kwargs):  # noqa: E501
        """Enable the agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_enable_agent_with_http_info(agent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :return: V1EnableAgentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['agent_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_enable_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'agent_id' is set
        if ('agent_id' not in params or
                params['agent_id'] is None):
            raise ValueError("Missing the required parameter `agent_id` when calling `determined_enable_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'agent_id' in params:
            path_params['agentId'] = params['agent_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/agents/{agentId}/enable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1EnableAgentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_enable_slot(self, agent_id, slot_id, **kwargs):  # noqa: E501
        """Enable the slot.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_enable_slot(agent_id, slot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :param str slot_id: The id of the slot. (required)
        :return: V1EnableSlotResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_enable_slot_with_http_info(agent_id, slot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_enable_slot_with_http_info(agent_id, slot_id, **kwargs)  # noqa: E501
            return data

    def determined_enable_slot_with_http_info(self, agent_id, slot_id, **kwargs):  # noqa: E501
        """Enable the slot.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_enable_slot_with_http_info(agent_id, slot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :param str slot_id: The id of the slot. (required)
        :return: V1EnableSlotResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['agent_id', 'slot_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_enable_slot" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'agent_id' is set
        if ('agent_id' not in params or
                params['agent_id'] is None):
            raise ValueError("Missing the required parameter `agent_id` when calling `determined_enable_slot`")  # noqa: E501
        # verify the required parameter 'slot_id' is set
        if ('slot_id' not in params or
                params['slot_id'] is None):
            raise ValueError("Missing the required parameter `slot_id` when calling `determined_enable_slot`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'agent_id' in params:
            path_params['agentId'] = params['agent_id']  # noqa: E501
        if 'slot_id' in params:
            path_params['slotId'] = params['slot_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/agents/{agentId}/slots/{slotId}/enable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1EnableSlotResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_get_agent(self, agent_id, **kwargs):  # noqa: E501
        """Get the requested agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_agent(agent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :return: V1GetAgentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_get_agent_with_http_info(agent_id, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_get_agent_with_http_info(agent_id, **kwargs)  # noqa: E501
            return data

    def determined_get_agent_with_http_info(self, agent_id, **kwargs):  # noqa: E501
        """Get the requested agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_agent_with_http_info(agent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :return: V1GetAgentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['agent_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_get_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'agent_id' is set
        if ('agent_id' not in params or
                params['agent_id'] is None):
            raise ValueError("Missing the required parameter `agent_id` when calling `determined_get_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'agent_id' in params:
            path_params['agentId'] = params['agent_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/agents/{agentId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetAgentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_get_agents(self, **kwargs):  # noqa: E501
        """Get a set of agents from the cluster.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_agents(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sort_by: Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
        :param str order_by: Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
        :param int offset: Skip the number of agents before returning results. Negative values denote number of agents to skip from the end before returning results.
        :param int limit: Limit the number of agents. A value of 0 denotes no limit.
        :param str label: Filter agents by their label. If no label is specified or is empty, all agents are returned.
        :return: V1GetAgentsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_get_agents_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.determined_get_agents_with_http_info(**kwargs)  # noqa: E501
            return data

    def determined_get_agents_with_http_info(self, **kwargs):  # noqa: E501
        """Get a set of agents from the cluster.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_agents_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sort_by: Sort agents by the given field.   - SORT_BY_UNSPECIFIED: Returns agents in an unsorted list.  - SORT_BY_ID: Returns agents sorted by id.  - SORT_BY_TIME: Returns agents sorted by time.
        :param str order_by: Order agents in either ascending or descending order.   - ORDER_BY_UNSPECIFIED: Returns records in no specific order.  - ORDER_BY_ASC: Returns records in ascending order.  - ORDER_BY_DESC: Returns records in descending order.
        :param int offset: Skip the number of agents before returning results. Negative values denote number of agents to skip from the end before returning results.
        :param int limit: Limit the number of agents. A value of 0 denotes no limit.
        :param str label: Filter agents by their label. If no label is specified or is empty, all agents are returned.
        :return: V1GetAgentsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sort_by', 'order_by', 'offset', 'limit', 'label']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_get_agents" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sort_by' in params:
            query_params.append(('sortBy', params['sort_by']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'label' in params:
            query_params.append(('label', params['label']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/agents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetAgentsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_get_master(self, **kwargs):  # noqa: E501
        """Get master information.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_master(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: V1GetMasterResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_get_master_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.determined_get_master_with_http_info(**kwargs)  # noqa: E501
            return data

    def determined_get_master_with_http_info(self, **kwargs):  # noqa: E501
        """Get master information.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_master_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: V1GetMasterResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_get_master" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/master', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetMasterResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_get_master_config(self, **kwargs):  # noqa: E501
        """Get master config.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_master_config(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: V1GetMasterConfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_get_master_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.determined_get_master_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def determined_get_master_config_with_http_info(self, **kwargs):  # noqa: E501
        """Get master config.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_master_config_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: V1GetMasterConfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_get_master_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/master/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetMasterConfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_get_slot(self, agent_id, slot_id, **kwargs):  # noqa: E501
        """Get the requested slot for an agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_slot(agent_id, slot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :param str slot_id: The id of the slot. (required)
        :return: V1GetSlotResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_get_slot_with_http_info(agent_id, slot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_get_slot_with_http_info(agent_id, slot_id, **kwargs)  # noqa: E501
            return data

    def determined_get_slot_with_http_info(self, agent_id, slot_id, **kwargs):  # noqa: E501
        """Get the requested slot for an agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_slot_with_http_info(agent_id, slot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :param str slot_id: The id of the slot. (required)
        :return: V1GetSlotResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['agent_id', 'slot_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_get_slot" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'agent_id' is set
        if ('agent_id' not in params or
                params['agent_id'] is None):
            raise ValueError("Missing the required parameter `agent_id` when calling `determined_get_slot`")  # noqa: E501
        # verify the required parameter 'slot_id' is set
        if ('slot_id' not in params or
                params['slot_id'] is None):
            raise ValueError("Missing the required parameter `slot_id` when calling `determined_get_slot`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'agent_id' in params:
            path_params['agentId'] = params['agent_id']  # noqa: E501
        if 'slot_id' in params:
            path_params['slotId'] = params['slot_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/agents/{agentId}/slots/{slotId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetSlotResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_get_slots(self, agent_id, **kwargs):  # noqa: E501
        """Get all the slots for an agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_slots(agent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :return: V1GetSlotsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_get_slots_with_http_info(agent_id, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_get_slots_with_http_info(agent_id, **kwargs)  # noqa: E501
            return data

    def determined_get_slots_with_http_info(self, agent_id, **kwargs):  # noqa: E501
        """Get all the slots for an agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_slots_with_http_info(agent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agent_id: The id of the agent. (required)
        :return: V1GetSlotsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['agent_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_get_slots" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'agent_id' is set
        if ('agent_id' not in params or
                params['agent_id'] is None):
            raise ValueError("Missing the required parameter `agent_id` when calling `determined_get_slots`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'agent_id' in params:
            path_params['agentId'] = params['agent_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/agents/{agentId}/slots', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetSlotsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_master_logs(self, **kwargs):  # noqa: E501
        """Stream master logs.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_master_logs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int offset: Skip the number of master logs before returning results. Negative values denote number of master logs to skip from the end before returning results.
        :param int limit: Limit the number of master logs. A value of 0 denotes no limit.
        :param bool follow: Continue following logs until the master stops or the limit is reached.
        :return: StreamResultOfV1MasterLogsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_master_logs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.determined_master_logs_with_http_info(**kwargs)  # noqa: E501
            return data

    def determined_master_logs_with_http_info(self, **kwargs):  # noqa: E501
        """Stream master logs.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_master_logs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int offset: Skip the number of master logs before returning results. Negative values denote number of master logs to skip from the end before returning results.
        :param int limit: Limit the number of master logs. A value of 0 denotes no limit.
        :param bool follow: Continue following logs until the master stops or the limit is reached.
        :return: StreamResultOfV1MasterLogsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['offset', 'limit', 'follow']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_master_logs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'follow' in params:
            query_params.append(('follow', params['follow']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/master/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StreamResultOfV1MasterLogsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_resource_allocation_aggregated(self, **kwargs):  # noqa: E501
        """Get an aggregated view of resource allocation during the given time period.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_resource_allocation_aggregated(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str start_date: The first day to consider (the exact time is midnight UTC at the beginning of the day).
        :param str end_date: The last day to consider (the exact time is midnight UTC at the end of the day).
        :param str period: The period over which to perform aggregation.   - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
        :return: V1ResourceAllocationAggregatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_resource_allocation_aggregated_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.determined_resource_allocation_aggregated_with_http_info(**kwargs)  # noqa: E501
            return data

    def determined_resource_allocation_aggregated_with_http_info(self, **kwargs):  # noqa: E501
        """Get an aggregated view of resource allocation during the given time period.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_resource_allocation_aggregated_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str start_date: The first day to consider (the exact time is midnight UTC at the beginning of the day).
        :param str end_date: The last day to consider (the exact time is midnight UTC at the end of the day).
        :param str period: The period over which to perform aggregation.   - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_UNSPECIFIED: Unspecified. This value will never actually be returned by the API, it is just an artifact of using protobuf.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_DAILY: Aggregation by day.  - RESOURCE_ALLOCATION_AGGREGATION_PERIOD_MONTHLY: Aggregation by month.
        :return: V1ResourceAllocationAggregatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start_date', 'end_date', 'period']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_resource_allocation_aggregated" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start_date' in params:
            query_params.append(('startDate', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('endDate', params['end_date']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/resources/allocation/aggregated', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1ResourceAllocationAggregatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_resource_allocation_raw(self, **kwargs):  # noqa: E501
        """Get a detailed view of resource allocation during the given time period.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_resource_allocation_raw(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime timestamp_after: The start of the period to consider.
        :param datetime timestamp_before: The end of the period to consider.
        :return: V1ResourceAllocationRawResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_resource_allocation_raw_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.determined_resource_allocation_raw_with_http_info(**kwargs)  # noqa: E501
            return data

    def determined_resource_allocation_raw_with_http_info(self, **kwargs):  # noqa: E501
        """Get a detailed view of resource allocation during the given time period.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_resource_allocation_raw_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime timestamp_after: The start of the period to consider.
        :param datetime timestamp_before: The end of the period to consider.
        :return: V1ResourceAllocationRawResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['timestamp_after', 'timestamp_before']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_resource_allocation_raw" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'timestamp_after' in params:
            query_params.append(('timestampAfter', params['timestamp_after']))  # noqa: E501
        if 'timestamp_before' in params:
            query_params.append(('timestampBefore', params['timestamp_before']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/resources/allocation/raw', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1ResourceAllocationRawResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
