# coding: utf-8

"""
    Determined API (Beta)

    Determined helps deep learning teams train models more quickly, easily share GPU resources, and effectively collaborate. Determined allows deep learning engineers to focus on building and training models at scale, without needing to worry about DevOps or writing custom code for common tasks like fault tolerance or experiment tracking.  You can think of Determined as a platform that bridges the gap between tools like TensorFlow and PyTorch --- which work great for a single researcher with a single GPU --- to the challenges that arise when doing deep learning at scale, as teams, clusters, and data sets all increase in size.  # noqa: E501

    OpenAPI spec version: 0.1
    Contact: community@determined.ai
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from determined._swagger.client.api_client import ApiClient


class InternalApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def determined_complete_trial_searcher_validation(self, trial_id, body, **kwargs):  # noqa: E501
        """Reports to the searcher that the trial has completed the given searcher operation.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_complete_trial_searcher_validation(trial_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trial_id: The id of the trial. (required)
        :param V1CompleteValidateAfterOperation body: The completed operation. (required)
        :return: V1CompleteTrialSearcherValidationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_complete_trial_searcher_validation_with_http_info(trial_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_complete_trial_searcher_validation_with_http_info(trial_id, body, **kwargs)  # noqa: E501
            return data

    def determined_complete_trial_searcher_validation_with_http_info(self, trial_id, body, **kwargs):  # noqa: E501
        """Reports to the searcher that the trial has completed the given searcher operation.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_complete_trial_searcher_validation_with_http_info(trial_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trial_id: The id of the trial. (required)
        :param V1CompleteValidateAfterOperation body: The completed operation. (required)
        :return: V1CompleteTrialSearcherValidationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['trial_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_complete_trial_searcher_validation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'trial_id' is set
        if ('trial_id' not in params or
                params['trial_id'] is None):
            raise ValueError("Missing the required parameter `trial_id` when calling `determined_complete_trial_searcher_validation`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `determined_complete_trial_searcher_validation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'trial_id' in params:
            path_params['trialId'] = params['trial_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/trials/{trialId}/searcher/completed_operation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1CompleteTrialSearcherValidationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_compute_hp_importance(self, experiment_id, **kwargs):  # noqa: E501
        """Trigger the computation of hyperparameter importance on-demand for a specific metric on a specific experiment. The status and results can be retrieved with GetHPImportance.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_compute_hp_importance(experiment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int experiment_id: The id of the experiment. (required)
        :return: V1ComputeHPImportanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_compute_hp_importance_with_http_info(experiment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_compute_hp_importance_with_http_info(experiment_id, **kwargs)  # noqa: E501
            return data

    def determined_compute_hp_importance_with_http_info(self, experiment_id, **kwargs):  # noqa: E501
        """Trigger the computation of hyperparameter importance on-demand for a specific metric on a specific experiment. The status and results can be retrieved with GetHPImportance.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_compute_hp_importance_with_http_info(experiment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int experiment_id: The id of the experiment. (required)
        :return: V1ComputeHPImportanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_compute_hp_importance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params or
                params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `determined_compute_hp_importance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/experiments/{experimentId}/hyperparameter-importance', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1ComputeHPImportanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_create_experiment(self, body, **kwargs):  # noqa: E501
        """Create an experiment.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_create_experiment(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1CreateExperimentRequest body: (required)
        :return: V1CreateExperimentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_create_experiment_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_create_experiment_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def determined_create_experiment_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create an experiment.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_create_experiment_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1CreateExperimentRequest body: (required)
        :return: V1CreateExperimentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_create_experiment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `determined_create_experiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/experiments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1CreateExperimentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_get_current_trial_searcher_operation(self, trial_id, **kwargs):  # noqa: E501
        """Get the current searcher operation.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_current_trial_searcher_operation(trial_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trial_id: The id of the trial. (required)
        :return: V1GetCurrentTrialSearcherOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_get_current_trial_searcher_operation_with_http_info(trial_id, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_get_current_trial_searcher_operation_with_http_info(trial_id, **kwargs)  # noqa: E501
            return data

    def determined_get_current_trial_searcher_operation_with_http_info(self, trial_id, **kwargs):  # noqa: E501
        """Get the current searcher operation.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_current_trial_searcher_operation_with_http_info(trial_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trial_id: The id of the trial. (required)
        :return: V1GetCurrentTrialSearcherOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['trial_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_get_current_trial_searcher_operation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'trial_id' is set
        if ('trial_id' not in params or
                params['trial_id'] is None):
            raise ValueError("Missing the required parameter `trial_id` when calling `determined_get_current_trial_searcher_operation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'trial_id' in params:
            path_params['trialId'] = params['trial_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/trials/{trialId}/searcher/operation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetCurrentTrialSearcherOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_get_hp_importance(self, experiment_id, **kwargs):  # noqa: E501
        """Retrieve the latest computation of hyperparameter importance. Currently this is triggered for training loss (if emitted) and the searcher metric after 10% increments in an experiment's progress, but no more than every 10 minutes.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_hp_importance(experiment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int experiment_id: The id of the experiment. (required)
        :param int period_seconds: Seconds to wait when polling for updates.
        :return: StreamResultOfV1GetHPImportanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_get_hp_importance_with_http_info(experiment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_get_hp_importance_with_http_info(experiment_id, **kwargs)  # noqa: E501
            return data

    def determined_get_hp_importance_with_http_info(self, experiment_id, **kwargs):  # noqa: E501
        """Retrieve the latest computation of hyperparameter importance. Currently this is triggered for training loss (if emitted) and the searcher metric after 10% increments in an experiment's progress, but no more than every 10 minutes.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_hp_importance_with_http_info(experiment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int experiment_id: The id of the experiment. (required)
        :param int period_seconds: Seconds to wait when polling for updates.
        :return: StreamResultOfV1GetHPImportanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'period_seconds']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_get_hp_importance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params or
                params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `determined_get_hp_importance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']  # noqa: E501

        query_params = []
        if 'period_seconds' in params:
            query_params.append(('periodSeconds', params['period_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/experiments/{experimentId}/hyperparameter-importance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StreamResultOfV1GetHPImportanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_get_resource_pools(self, **kwargs):  # noqa: E501
        """Get a list of all resource pools from the cluster.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_resource_pools(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int offset: Skip the number of resource pools before returning results. Negative values denote number of resource pools to skip from the end before returning results.
        :param int limit: Limit the number of resource pools. A value of 0 denotes no limit.
        :return: V1GetResourcePoolsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_get_resource_pools_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.determined_get_resource_pools_with_http_info(**kwargs)  # noqa: E501
            return data

    def determined_get_resource_pools_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all resource pools from the cluster.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_resource_pools_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int offset: Skip the number of resource pools before returning results. Negative values denote number of resource pools to skip from the end before returning results.
        :param int limit: Limit the number of resource pools. A value of 0 denotes no limit.
        :return: V1GetResourcePoolsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['offset', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_get_resource_pools" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/resource-pools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetResourcePoolsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_get_telemetry(self, **kwargs):  # noqa: E501
        """Get telemetry information.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_telemetry(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: V1GetTelemetryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_get_telemetry_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.determined_get_telemetry_with_http_info(**kwargs)  # noqa: E501
            return data

    def determined_get_telemetry_with_http_info(self, **kwargs):  # noqa: E501
        """Get telemetry information.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_get_telemetry_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: V1GetTelemetryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_get_telemetry" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/master/telemetry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1GetTelemetryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_metric_batches(self, experiment_id, metric_name, metric_type, **kwargs):  # noqa: E501
        """Get the milestones (in batches processed) at which a metric is recorded by an experiment.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_metric_batches(experiment_id, metric_name, metric_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int experiment_id: The id of the experiment. (required)
        :param str metric_name: A metric name. (required)
        :param str metric_type: The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation. (required)
        :param int period_seconds: Seconds to wait when polling for updates.
        :return: StreamResultOfV1MetricBatchesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_metric_batches_with_http_info(experiment_id, metric_name, metric_type, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_metric_batches_with_http_info(experiment_id, metric_name, metric_type, **kwargs)  # noqa: E501
            return data

    def determined_metric_batches_with_http_info(self, experiment_id, metric_name, metric_type, **kwargs):  # noqa: E501
        """Get the milestones (in batches processed) at which a metric is recorded by an experiment.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_metric_batches_with_http_info(experiment_id, metric_name, metric_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int experiment_id: The id of the experiment. (required)
        :param str metric_name: A metric name. (required)
        :param str metric_type: The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation. (required)
        :param int period_seconds: Seconds to wait when polling for updates.
        :return: StreamResultOfV1MetricBatchesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'metric_name', 'metric_type', 'period_seconds']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_metric_batches" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params or
                params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `determined_metric_batches`")  # noqa: E501
        # verify the required parameter 'metric_name' is set
        if ('metric_name' not in params or
                params['metric_name'] is None):
            raise ValueError("Missing the required parameter `metric_name` when calling `determined_metric_batches`")  # noqa: E501
        # verify the required parameter 'metric_type' is set
        if ('metric_type' not in params or
                params['metric_type'] is None):
            raise ValueError("Missing the required parameter `metric_type` when calling `determined_metric_batches`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']  # noqa: E501

        query_params = []
        if 'metric_name' in params:
            query_params.append(('metricName', params['metric_name']))  # noqa: E501
        if 'metric_type' in params:
            query_params.append(('metricType', params['metric_type']))  # noqa: E501
        if 'period_seconds' in params:
            query_params.append(('periodSeconds', params['period_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/experiments/{experimentId}/metrics-stream/batches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StreamResultOfV1MetricBatchesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_metric_names(self, experiment_id, **kwargs):  # noqa: E501
        """Get the set of metric names recorded for an experiment.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_metric_names(experiment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int experiment_id: The id of the experiment. (required)
        :param int period_seconds: Seconds to wait when polling for updates.
        :return: StreamResultOfV1MetricNamesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_metric_names_with_http_info(experiment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_metric_names_with_http_info(experiment_id, **kwargs)  # noqa: E501
            return data

    def determined_metric_names_with_http_info(self, experiment_id, **kwargs):  # noqa: E501
        """Get the set of metric names recorded for an experiment.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_metric_names_with_http_info(experiment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int experiment_id: The id of the experiment. (required)
        :param int period_seconds: Seconds to wait when polling for updates.
        :return: StreamResultOfV1MetricNamesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'period_seconds']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_metric_names" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params or
                params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `determined_metric_names`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']  # noqa: E501

        query_params = []
        if 'period_seconds' in params:
            query_params.append(('periodSeconds', params['period_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/experiments/{experimentId}/metrics-stream/metric-names', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StreamResultOfV1MetricNamesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_report_trial_checkpoint_metadata(self, checkpoint_metadata_trial_id, body, **kwargs):  # noqa: E501
        """Record a checkpoint.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_report_trial_checkpoint_metadata(checkpoint_metadata_trial_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int checkpoint_metadata_trial_id: The ID of the trial associated with the checkpoint. (required)
        :param V1CheckpointMetadata body: The training metrics to persist. (required)
        :return: V1ReportTrialCheckpointMetadataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_report_trial_checkpoint_metadata_with_http_info(checkpoint_metadata_trial_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_report_trial_checkpoint_metadata_with_http_info(checkpoint_metadata_trial_id, body, **kwargs)  # noqa: E501
            return data

    def determined_report_trial_checkpoint_metadata_with_http_info(self, checkpoint_metadata_trial_id, body, **kwargs):  # noqa: E501
        """Record a checkpoint.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_report_trial_checkpoint_metadata_with_http_info(checkpoint_metadata_trial_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int checkpoint_metadata_trial_id: The ID of the trial associated with the checkpoint. (required)
        :param V1CheckpointMetadata body: The training metrics to persist. (required)
        :return: V1ReportTrialCheckpointMetadataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['checkpoint_metadata_trial_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_report_trial_checkpoint_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'checkpoint_metadata_trial_id' is set
        if ('checkpoint_metadata_trial_id' not in params or
                params['checkpoint_metadata_trial_id'] is None):
            raise ValueError("Missing the required parameter `checkpoint_metadata_trial_id` when calling `determined_report_trial_checkpoint_metadata`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `determined_report_trial_checkpoint_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'checkpoint_metadata_trial_id' in params:
            path_params['checkpointMetadata.trialId'] = params['checkpoint_metadata_trial_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/trials/{checkpointMetadata.trialId}/checkpoint_metadata', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1ReportTrialCheckpointMetadataResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_report_trial_progress(self, trial_id, body, **kwargs):  # noqa: E501
        """For bookkeeping, updates the progress towards to current requested searcher training length.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_report_trial_progress(trial_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trial_id: The id of the trial. (required)
        :param float body: Total units completed by the trial, in terms of the unit used to configure the searcher. (required)
        :return: V1ReportTrialProgressResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_report_trial_progress_with_http_info(trial_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_report_trial_progress_with_http_info(trial_id, body, **kwargs)  # noqa: E501
            return data

    def determined_report_trial_progress_with_http_info(self, trial_id, body, **kwargs):  # noqa: E501
        """For bookkeeping, updates the progress towards to current requested searcher training length.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_report_trial_progress_with_http_info(trial_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trial_id: The id of the trial. (required)
        :param float body: Total units completed by the trial, in terms of the unit used to configure the searcher. (required)
        :return: V1ReportTrialProgressResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['trial_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_report_trial_progress" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'trial_id' is set
        if ('trial_id' not in params or
                params['trial_id'] is None):
            raise ValueError("Missing the required parameter `trial_id` when calling `determined_report_trial_progress`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `determined_report_trial_progress`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'trial_id' in params:
            path_params['trialId'] = params['trial_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/trials/{trialId}/progress', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1ReportTrialProgressResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_report_trial_searcher_early_exit(self, trial_id, body, **kwargs):  # noqa: E501
        """Reports to the searcher that the trial has completed the current requested amount of training with the given searcher validation metric.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_report_trial_searcher_early_exit(trial_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trial_id: The id of the trial. (required)
        :param V1TrialEarlyExit body: The exit reason. (required)
        :return: V1ReportTrialSearcherEarlyExitResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_report_trial_searcher_early_exit_with_http_info(trial_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_report_trial_searcher_early_exit_with_http_info(trial_id, body, **kwargs)  # noqa: E501
            return data

    def determined_report_trial_searcher_early_exit_with_http_info(self, trial_id, body, **kwargs):  # noqa: E501
        """Reports to the searcher that the trial has completed the current requested amount of training with the given searcher validation metric.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_report_trial_searcher_early_exit_with_http_info(trial_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trial_id: The id of the trial. (required)
        :param V1TrialEarlyExit body: The exit reason. (required)
        :return: V1ReportTrialSearcherEarlyExitResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['trial_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_report_trial_searcher_early_exit" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'trial_id' is set
        if ('trial_id' not in params or
                params['trial_id'] is None):
            raise ValueError("Missing the required parameter `trial_id` when calling `determined_report_trial_searcher_early_exit`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `determined_report_trial_searcher_early_exit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'trial_id' in params:
            path_params['trialId'] = params['trial_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/trials/{trialId}/early_exit', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1ReportTrialSearcherEarlyExitResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_report_trial_training_metrics(self, training_metrics_trial_id, body, **kwargs):  # noqa: E501
        """Record training metrics for specified training.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_report_trial_training_metrics(training_metrics_trial_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int training_metrics_trial_id: The trial associated with these metrics. (required)
        :param V1TrainingMetrics body: The training metrics to persist. (required)
        :return: V1ReportTrialTrainingMetricsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_report_trial_training_metrics_with_http_info(training_metrics_trial_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_report_trial_training_metrics_with_http_info(training_metrics_trial_id, body, **kwargs)  # noqa: E501
            return data

    def determined_report_trial_training_metrics_with_http_info(self, training_metrics_trial_id, body, **kwargs):  # noqa: E501
        """Record training metrics for specified training.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_report_trial_training_metrics_with_http_info(training_metrics_trial_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int training_metrics_trial_id: The trial associated with these metrics. (required)
        :param V1TrainingMetrics body: The training metrics to persist. (required)
        :return: V1ReportTrialTrainingMetricsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['training_metrics_trial_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_report_trial_training_metrics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'training_metrics_trial_id' is set
        if ('training_metrics_trial_id' not in params or
                params['training_metrics_trial_id'] is None):
            raise ValueError("Missing the required parameter `training_metrics_trial_id` when calling `determined_report_trial_training_metrics`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `determined_report_trial_training_metrics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'training_metrics_trial_id' in params:
            path_params['trainingMetrics.trialId'] = params['training_metrics_trial_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/trials/{trainingMetrics.trialId}/training_metrics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1ReportTrialTrainingMetricsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_report_trial_validation_metrics(self, validation_metrics_trial_id, body, **kwargs):  # noqa: E501
        """Record validation metrics.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_report_trial_validation_metrics(validation_metrics_trial_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int validation_metrics_trial_id: The trial associated with these metrics. (required)
        :param V1ValidationMetrics body: The training metrics to persist. (required)
        :return: V1ReportTrialValidationMetricsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_report_trial_validation_metrics_with_http_info(validation_metrics_trial_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_report_trial_validation_metrics_with_http_info(validation_metrics_trial_id, body, **kwargs)  # noqa: E501
            return data

    def determined_report_trial_validation_metrics_with_http_info(self, validation_metrics_trial_id, body, **kwargs):  # noqa: E501
        """Record validation metrics.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_report_trial_validation_metrics_with_http_info(validation_metrics_trial_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int validation_metrics_trial_id: The trial associated with these metrics. (required)
        :param V1ValidationMetrics body: The training metrics to persist. (required)
        :return: V1ReportTrialValidationMetricsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['validation_metrics_trial_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_report_trial_validation_metrics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'validation_metrics_trial_id' is set
        if ('validation_metrics_trial_id' not in params or
                params['validation_metrics_trial_id'] is None):
            raise ValueError("Missing the required parameter `validation_metrics_trial_id` when calling `determined_report_trial_validation_metrics`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `determined_report_trial_validation_metrics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'validation_metrics_trial_id' in params:
            path_params['validationMetrics.trialId'] = params['validation_metrics_trial_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/trials/{validationMetrics.trialId}/validation_metrics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1ReportTrialValidationMetricsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_trial_preemption_signal(self, trial_id, **kwargs):  # noqa: E501
        """Stream preemption signals for the given trial. Upon connection a signal is sent immediately, for synchronization purposes. If it is to preempt, that will be the only signal and the trial should preempt. Otherwise, the trial should continue to listen. The only signal ever sent after this will be to preempt.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_trial_preemption_signal(trial_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trial_id: The requested trial's id. (required)
        :return: StreamResultOfV1TrialPreemptionSignalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_trial_preemption_signal_with_http_info(trial_id, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_trial_preemption_signal_with_http_info(trial_id, **kwargs)  # noqa: E501
            return data

    def determined_trial_preemption_signal_with_http_info(self, trial_id, **kwargs):  # noqa: E501
        """Stream preemption signals for the given trial. Upon connection a signal is sent immediately, for synchronization purposes. If it is to preempt, that will be the only signal and the trial should preempt. Otherwise, the trial should continue to listen. The only signal ever sent after this will be to preempt.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_trial_preemption_signal_with_http_info(trial_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trial_id: The requested trial's id. (required)
        :return: StreamResultOfV1TrialPreemptionSignalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['trial_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_trial_preemption_signal" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'trial_id' is set
        if ('trial_id' not in params or
                params['trial_id'] is None):
            raise ValueError("Missing the required parameter `trial_id` when calling `determined_trial_preemption_signal`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'trial_id' in params:
            path_params['trialId'] = params['trial_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/trials/{trialId}/signals/preemption', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StreamResultOfV1TrialPreemptionSignalResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_trials_sample(self, experiment_id, metric_name, metric_type, **kwargs):  # noqa: E501
        """Get a sample of the metrics over time for a sample of the trials.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_trials_sample(experiment_id, metric_name, metric_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int experiment_id: The id of the experiment. (required)
        :param str metric_name: A metric name. (required)
        :param str metric_type: The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation. (required)
        :param int max_trials: Maximum number of trials to fetch data for.
        :param int max_datapoints: Maximum number of initial / historical data points.
        :param int start_batches: Beginning of window (inclusive) to fetch data for.
        :param int end_batches: Ending of window (inclusive) to fetch data for.
        :param int period_seconds: Seconds to wait when polling for updates.
        :return: StreamResultOfV1TrialsSampleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_trials_sample_with_http_info(experiment_id, metric_name, metric_type, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_trials_sample_with_http_info(experiment_id, metric_name, metric_type, **kwargs)  # noqa: E501
            return data

    def determined_trials_sample_with_http_info(self, experiment_id, metric_name, metric_type, **kwargs):  # noqa: E501
        """Get a sample of the metrics over time for a sample of the trials.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_trials_sample_with_http_info(experiment_id, metric_name, metric_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int experiment_id: The id of the experiment. (required)
        :param str metric_name: A metric name. (required)
        :param str metric_type: The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation. (required)
        :param int max_trials: Maximum number of trials to fetch data for.
        :param int max_datapoints: Maximum number of initial / historical data points.
        :param int start_batches: Beginning of window (inclusive) to fetch data for.
        :param int end_batches: Ending of window (inclusive) to fetch data for.
        :param int period_seconds: Seconds to wait when polling for updates.
        :return: StreamResultOfV1TrialsSampleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'metric_name', 'metric_type', 'max_trials', 'max_datapoints', 'start_batches', 'end_batches', 'period_seconds']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_trials_sample" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params or
                params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `determined_trials_sample`")  # noqa: E501
        # verify the required parameter 'metric_name' is set
        if ('metric_name' not in params or
                params['metric_name'] is None):
            raise ValueError("Missing the required parameter `metric_name` when calling `determined_trials_sample`")  # noqa: E501
        # verify the required parameter 'metric_type' is set
        if ('metric_type' not in params or
                params['metric_type'] is None):
            raise ValueError("Missing the required parameter `metric_type` when calling `determined_trials_sample`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']  # noqa: E501

        query_params = []
        if 'metric_name' in params:
            query_params.append(('metricName', params['metric_name']))  # noqa: E501
        if 'metric_type' in params:
            query_params.append(('metricType', params['metric_type']))  # noqa: E501
        if 'max_trials' in params:
            query_params.append(('maxTrials', params['max_trials']))  # noqa: E501
        if 'max_datapoints' in params:
            query_params.append(('maxDatapoints', params['max_datapoints']))  # noqa: E501
        if 'start_batches' in params:
            query_params.append(('startBatches', params['start_batches']))  # noqa: E501
        if 'end_batches' in params:
            query_params.append(('endBatches', params['end_batches']))  # noqa: E501
        if 'period_seconds' in params:
            query_params.append(('periodSeconds', params['period_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/experiments/{experimentId}/metrics-stream/trials-sample', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StreamResultOfV1TrialsSampleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def determined_trials_snapshot(self, experiment_id, metric_name, metric_type, batches_processed, **kwargs):  # noqa: E501
        """Get a snapshot of a metric across all trials at a certain point of progress.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_trials_snapshot(experiment_id, metric_name, metric_type, batches_processed, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int experiment_id: The id of the experiment. (required)
        :param str metric_name: A metric name. (required)
        :param str metric_type: The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation. (required)
        :param int batches_processed: The point of progress at which to query metrics. (required)
        :param int batches_margin: A range either side of batches_processed to include near-misses.
        :param int period_seconds: Seconds to wait when polling for updates.
        :return: StreamResultOfV1TrialsSnapshotResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.determined_trials_snapshot_with_http_info(experiment_id, metric_name, metric_type, batches_processed, **kwargs)  # noqa: E501
        else:
            (data) = self.determined_trials_snapshot_with_http_info(experiment_id, metric_name, metric_type, batches_processed, **kwargs)  # noqa: E501
            return data

    def determined_trials_snapshot_with_http_info(self, experiment_id, metric_name, metric_type, batches_processed, **kwargs):  # noqa: E501
        """Get a snapshot of a metric across all trials at a certain point of progress.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.determined_trials_snapshot_with_http_info(experiment_id, metric_name, metric_type, batches_processed, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int experiment_id: The id of the experiment. (required)
        :param str metric_name: A metric name. (required)
        :param str metric_type: The type of metric.   - METRIC_TYPE_UNSPECIFIED: Zero-value (not allowed).  - METRIC_TYPE_TRAINING: For metrics emitted during training.  - METRIC_TYPE_VALIDATION: For metrics emitted during validation. (required)
        :param int batches_processed: The point of progress at which to query metrics. (required)
        :param int batches_margin: A range either side of batches_processed to include near-misses.
        :param int period_seconds: Seconds to wait when polling for updates.
        :return: StreamResultOfV1TrialsSnapshotResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'metric_name', 'metric_type', 'batches_processed', 'batches_margin', 'period_seconds']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method determined_trials_snapshot" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params or
                params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `determined_trials_snapshot`")  # noqa: E501
        # verify the required parameter 'metric_name' is set
        if ('metric_name' not in params or
                params['metric_name'] is None):
            raise ValueError("Missing the required parameter `metric_name` when calling `determined_trials_snapshot`")  # noqa: E501
        # verify the required parameter 'metric_type' is set
        if ('metric_type' not in params or
                params['metric_type'] is None):
            raise ValueError("Missing the required parameter `metric_type` when calling `determined_trials_snapshot`")  # noqa: E501
        # verify the required parameter 'batches_processed' is set
        if ('batches_processed' not in params or
                params['batches_processed'] is None):
            raise ValueError("Missing the required parameter `batches_processed` when calling `determined_trials_snapshot`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']  # noqa: E501

        query_params = []
        if 'metric_name' in params:
            query_params.append(('metricName', params['metric_name']))  # noqa: E501
        if 'metric_type' in params:
            query_params.append(('metricType', params['metric_type']))  # noqa: E501
        if 'batches_processed' in params:
            query_params.append(('batchesProcessed', params['batches_processed']))  # noqa: E501
        if 'batches_margin' in params:
            query_params.append(('batchesMargin', params['batches_margin']))  # noqa: E501
        if 'period_seconds' in params:
            query_params.append(('periodSeconds', params['period_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BearerToken']  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/experiments/{experimentId}/metrics-stream/trials-snapshot', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StreamResultOfV1TrialsSnapshotResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
