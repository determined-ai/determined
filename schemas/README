JSON-SCHEMA AS THE EXPERIMENT CONFIG DEFINITION

Linting:
  - There is a linter which enforces various custom checks to ensure that the
    assumptions we make in our system will be enforced by the schemas
  - The linter also enforces basic formatting requirements

Validation:
  - Validation happens in two steps:
    - Sanity check: make sure everything is parsable
    - Validation: make sure everything is present
  - Sanity check is applied to raw user inputs
  - Validation is applied after cluster defaults have been applied
  - The implementation difference between sanity check and validation is the
    inclusion of a single eventuallyRequired schema in the latter.

Null handling:
  - There is no pythonic or golangic way to represent values which were
    provided in the configuration as literal nulls, rather than values which
    were not provided at all.  In theory, you could have singleton
    "NotProvided" pointers, which you would check for every time that you
    checked a value in the schema, but in practice that would be a pain in the
    ass.  Additionally, the golang json-schema library we use treats
    not-present values a nil values anyway.

    Conclusion: null values shall be treated as if they were not present.

Default values:
  - "default" refers to "encoded in json-schema" and not "cluster default"
  - otherwise, there's no way to do client-side defaults, as the master would
    need to be involved in deciding all default values.

  const.yaml:

    hyperparameters:
      global_batch_size: 100

  Python API (for us and for users):

    exp_conf.min_validation_period.batches        # returns 0
    exp_conf.min_validation_period                # returns Length(batches=0)

    exp_conf.json() -> return a dictionary

  Golang API (for us):

    1. save what the user provides as raw_exp_conf and Raw=self
    2. create an exp_conf with defaults and Raw=raw_exp_conf

    exp_conf.MinValidationPeriod.Batches
    exp_conf.Raw.MinValidationPeriod        # would be nil
    exp_conf.Raw.Raw -> exp_conf.Raw

Customization strategy:
  - Json-schema alone does not provide the behavior we want out of the box
  - Most json-schema libraries have great support for custom validation logic
  - We have json-schema extensions for the following keywords:
    - checks: Custom messages for arbitrary validation logic
    - compareProperties: Support customizable value comparisons
    - conditional: Enforce a schema whenever some condition is met.
    - disallowProperties: Custom messages when disallowing properties
    - eventuallyRequired: Support two-step validation
    - union: Excellent error messages when validating union types
  - The canonical implementations (with thorough comments) may be found in
    determined_common/schemas/extensions.py

V1 changes:
 - environments must define both GPU and CPU variants if they go that route
 - strict additionalProperties on at least resources config
 - nested hyperparameters

